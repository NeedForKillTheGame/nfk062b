{default A+,B-,C+,D+,E-,F-,G+,H+,I+,J+,K-,L+,M-,N+,O+,P+,Q-,R-,S-,T-,U-,V+,W-,X+,Y-,Z1}
{$A+,B-,C+,D+,E-,F-,G+,H+,I+,J+,K-,L+,M-,N+,O-,P+,Q+,R+,S-,T-,U+,V+,W+,X+,Y+,Z1}
{MINSTACKSIZE $00004000}
{MAXSTACKSIZE $00800000}
{$IMAGEBASE $00400000}
{$APPTYPE GUI}
{
        game NEED FOR KILL
        Main Module
        Created by 3d[Power]

        http://www.3dpower.org
        http://powersite.narod.ru

        haz-3dpower@mail.ru
        3dpower@3dpower.org
}


unit Unit1;

{$R data.res}

interface
uses
  Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs, DirectX,
  DirectXGraphics, DXInput, math, ExtCtrls, Psock, NMHttp, ScktComp, PowerTiming, VTDUnit,
  PowerD3D, PowerFont, MPlayer,  wave, MMSYSTEM, inifiles,jpeg, PDrawEx,AGFUnit,
  PInput,PowerTypes, registry, crc32, bzlib,winsock,PEngine,powerarc, FMOD,
  FMODErrors, bnet, nethandle,simpleTCP, clipbrd;



type TPlayerStats = record
        stat_suicide : word;
        stat_kills : word;
        stat_deaths : word;
        stat_dmggiven : integer;
        stat_dmgrecvd : integer;
        stat_impressives : word;
        stat_excellents : word;
        stat_humiliations : word;
        gaun_hits : word;
        mach_kills : word;
        mach_hits : word;
        mach_fire : word;
        shot_kills  : word;
        shot_hits : word;
        shot_fire : word;
        gren_fire : word;
        gren_hits : word;
        gren_kills : word;
        rocket_fire : word;
        rocket_kills : word;
        rocket_hits : word;
        shaft_fire : word;
        shaft_hits : word;
        shaft_kills : word;
        plasma_fire : word;
        plasma_hits : word;
        plasma_kills : word;
        rail_kills : word;
        rail_hits : word;
        rail_fire : word;
        bfg_fire : word;
        bfg_kills : word;
        bfg_hits : word;
end;

type TNFKModel = record
        cached : boolean;
        classname : string[30];
        skinname : string[30];
        walk_index, die_index, crouch_index, power_index,cpower_index : word;
        SND_death1,SND_death2,SND_death3,SND_Jump,SND_Pain100,SND_Pain75,SND_Pain50,SND_Pain25:word;//fmod index.
        walkframes,crouchframes : byte;
        dieframes : byte;
        modelsizex : byte;
        diesizey, crouchsizex,crouchsizey : byte;
        walkstartframe, framerefreshtime, dieframerefreshtime, crouchrefreshtime, crouchstartframe : byte;
        end;

type TNFKMegamodel = record
        classname : string[30];
        skinname : string[30];
        end;

type Tplayer = class
        private
        dead : byte;
        frame,nextframe : byte;
        refire,doublejump,weapchg,weapon,threadweapon : byte;
        dir,idd,control,shaftframe,shaftsttime,inlava,paintime,hitsnd, justrespawned, justrespawned2 : byte;
        gantl_s,gauntl_s_order, gantl_refire, gantl_state : byte;
        shaft_state : byte;
        ammo_snd,ammo_mg,ammo_sg,ammo_gl,ammo_rl,ammo_sh,ammo_rg,ammo_pl,ammo_bfg : byte;

        loadframe : byte;
        air, team : byte;

        walk_index, die_index, crouch_index, power_index,cpower_index : word;
        SND_death1,SND_death2,SND_death3,SND_Jump,SND_Pain100,SND_Pain75,SND_Pain50,SND_Pain25:word;//fmod index.

        clippixel : integer;
        health, armor, frags : integer;
        objname,netname,soundmodel,nfkmodel, realmodel : string[30];


        keys : word;

        crouch,balloon,flagcarrier : boolean;

        NETUpdateD : boolean;
        NETNoSignal : word;
        Location : string[64];

        IPAddress : ShortString;
        Port : word;
        PLAYERISHOST : boolean;

        Vote:byte;

        botangle : real;
        botrailcolor : byte;

        TESTPREDICT_X, TESTPREDICT_Y : Real; // interpolate players coordinates for multiplayer (if lag). outdated.

//        TST_X, TST_Y : Real; // interpolate players coordinates for multiplayer (if lag).
//        TEN_X, TEN_Y : Real; // interpolate players coordinates for multiplayer (if lag).
//        TMT, CTI : byte;

        {
                TST_X, TST_Y - start position
                TEN_X, TEN_Y - end position
                TMT - max ticks available
                CTI - current tick process.
        }

        walkframes,dieframes,modelsizex,walkstartframe,framerefreshtime,dieframerefreshtime,diesizey,crouchsizex,crouchsizey,crouchframes,crouchrefreshtime,crouchstartframe : byte;
        netobject : boolean;
        item_quad,item_regen,item_battle,item_flight,item_haste,item_invis : byte;
        item_quad_time, item_haste_time,item_regen_time,item_battle_time, item_flight_time: byte;
        impressive, excellent, rewardtype, rewardtime : byte;
        have_rl,have_gl,have_rg,have_bfg,have_sg,have_mg,have_sh,have_pl : boolean;
        DXID,respawn : word;
        x,y,cx,cy,fangle : real;
        InertiaX,InertiaY : real;
        stats : TPlayerstats;

        // for demo!
        Lx,Ly : word;
        LInertiaX,LInertiaY : Single;
        Lcrouch, Lballoon:boolean;
        Ldir,Ldead,Lwpn,Lwpnang,LArmor : byte;
        LHealth,Lfrags : smallint;
        NETHealth, NETFrags,NETArmor,NETLastammo,NETAmmo:smallint;
        NET_LastInertiaY, NET_LastPosY : real;
        clientrespawntimeout : cardinal; // for avoiding cant respawn bug..

        olspx, olspy : byte;
        // net;
        ping : word;
end;

type TPlayerEx = record //class copy. DO NOT MODIFY. This record used by NFK CODE.
        dead,bot,crouch,balloon,flagcarrier,have_rl, have_gl, have_rg, have_bfg, have_sg, have_mg, have_sh, have_pl : boolean;
        refire,weapchg,weapon,threadweapon,dir,gantl_state,air,team,item_quad, item_regen, item_battle, item_flight, item_haste, item_invis,ammo_mg, ammo_sg, ammo_gl, ammo_rl, ammo_sh, ammo_rg, ammo_pl, ammo_bfg : byte;
        x, y, cx, cy, fangle,InertiaX, InertiaY : real;
        health, armor, frags : integer;
        netname,nfkmodel : string[30];
        Location : string[64];
        DXID : word;
        end;

type TComboBoxNFK = record
        Index: byte;
        TS : TStringList;
        Opened:Boolean;
        Text : string;
        end;

type TListBoxNFK = record
        Index: byte;
        Items : TStringList;
        Text : string;
        end;

type Tmapweapondata = record
        machine, shotgun,grenade,rocket,shaft,rail,plasma,bfg :boolean;
        end;

Type TLocationText = Packed Record
        Enabled : boolean;
        X, Y : byte;
        Text : String [64];
end;
// =========== demos ===============
type    DDEMODATA = record
        x,y : word;
        InertiaX,InertiaY : Single;
        dir,frame,dead,wpn,wpnang,type1,type2 : byte;
        gametic : byte;
        gametime,DXID,type3 : word;
end;

type THeader = record
          ID : Array[1..4] of Char;
          Version : byte;
          MapName      : string[70];
          Author : string[70];
          MapSizeX,MapSizeY,BG,GAMETYPE,numobj : byte;
          numlights : word;
        end;

type TMAPOBJ = record
        active : boolean;
        x,y,lenght,dir,wait : word;
        targetname,target,objtype,orient,nowanim,special : byte;
        end;

type TMAPOBJV2 = record
        active : boolean;
        x,y,lenght,dir,wait : word;
        targetname,target,orient,nowanim,special:word;
        objtype : byte;
        end;

type
        PSpectator = ^TSpectator;
        TSpectator = record
        Netname : string[30];
        IP : string[15];
        Port : word;
        TimedOut : cardinal;
        end;

// =================================

type
  TMonoSprite = class
  protected
        dead : byte;
        clippixel : smallint;
        speed,fallt,weapon,doublejump,refire : byte;
        imageindex,dir,idd : byte;
        spawner : TPlayer;
        frame : byte;
        health : smallint;
        railgunhit : array[0..7] of boolean;
        x,y,cx,cy,fangle,fspeed : real;
        objname : string[30];
        netobject : boolean;
        DXID : word;
        dude : boolean;
        topdraw : byte;
        mass, InertiaX,InertiaY : real;
        procedure Hit;
        procedure DoMove(MoveCount: Integer);
end;

type
  TMonoSpriteBD = record
        dead : byte;
        speed,fallt,weapon,doublejump,refire : byte;
        imageindex,dir,idd : byte;
        clippixel : smallint;
        spawnerDXID : word;
        frame : byte;
        health : smallint;
        x,y,cx,cy,fangle,fspeed : real;
        objname : string[30];
        DXID : word;
        mass, InertiaX,InertiaY : real;
end;

// ==========================================
TYPE
        TBrick = record
        image : byte;          // graphix index
        block : boolean;       // do this brick block player;
        respawntime : integer; // respawn time
        y           : shortint;
        dir         : byte;
        oy          : real;
        respawnable : boolean; // do this shit can respawn?
        scale       : byte;
end;

// ==========================================
type TMapEntry = packed record
        EntryType : string[3];
        DataSize : longint;
        Reserved1 : byte;
        Reserved2 : word;
        Reserved3 : integer;
        Reserved4 : longint;
        Reserved5 : cardinal;
        Reserved6 : boolean;
        end;

type
     TDXSimpleMessage = RECORD
             DATA: DWORD;
             Len: Integer;
             X, Y : double;
             DXID : Word;
             frame,dir,ang,weapon: byte;
//           netname : string[15];
end;
type
     TDXPlayerSyncMessage = RECORD
             DATA: DWORD;
             X, Y : double;
             ix,iy : shortint; // inertia;
             DXID : Word;
             frame,dir,ang,weapon,dead : byte;
end;

// ==========================================
type
     TDXChatMessage = RECORD
             DATA: DWORD;
             Len: Integer;
             str : string[50];
end;
// ==========================================
type
     TDXDamageMessage = RECORD
             DATA: DWORD;
             Len: Integer;
             X,Y : double;
             health,armor : smallint;
             ix,iy : shortint; // inertia;
             DMGTYPE : byte;    // tama RL or shotgun ...
             DXID : Word;
//           frame,dir,ang,weapon: byte;

//           netname : string[15];
end;

// ==========================================
type
     TDXMapaMessage = RECORD
             DATA: DWORD;
             Len: Integer;
             X, Y : double;
             BUFFER : array [0..2048] of byte;
//           netname : string[15];
end;
// ==========================================
TYPE TScreenMessage = record
        str : string[255];
        live : integer;
        end;
// ==========================================
  type ttttdata = array[0..1023] of byte;

type
  Tmainform = class(TForm)
    MediaPlayer1: TMediaPlayer;
    PowerGraph: TPowerGraph;
    Font1: TPowerFont;
    Font2: TPowerFont;
    Font3: TPowerFont;
    VTDb: TVTDb;
    DXInput: TDXInput;
    Font4: TPowerFont;
    Font2ss: TPowerFont;
    Font6: TPowerFont;
    font2s: TPowerFont;
    Font2b: TPowerFont;
    DXTimer: TPowerTimer;
    lobby: TClientSocket;
    NMHTTP1: TNMHTTP;
    nfkplanet_idle: TTimer;
    VTDb2: TVTDb;
    procedure DXTimerTimer(Sender: TObject);
    procedure DXDrawInitialize(Sender: TObject);
    procedure FormCreate(Sender: TObject);
    procedure FormClose(Sender: TObject; var Action: TCloseAction);
    procedure FormKeyUp(Sender: TObject; var Key: Word;
      Shift: TShiftState);
    procedure DXPlayOpen(Sender: TObject);
    procedure FormKeyPress(Sender: TObject; var Key: Char);
    procedure DXDrawInitializeSurface(Sender: TObject);
    procedure MediaPlayer1Notify(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
    procedure LoadGrafix();
    procedure FinalizeAll();
    procedure PowerGraphDeviceLost(Sender: TObject);
    procedure DXPlaySessionLost(Sender: TObject);
    procedure FormKeyDown(Sender: TObject; var Key: Word; Shift: TShiftState);

    // NFK050 NETWORK.
    procedure BNET_NFK_ReceiveData(Data: Pointer; FromIP:shortstring; FromPort : integer; DataSize : integer);

    procedure BNET_TCPSERV_DataAvailable (Sender: TObject; Client: TSimpleTCPClient; DataSize: Integer);
    procedure BNET_TCPCLIENT_DataAvailable (Sender: TObject; DataSize: Integer);
    procedure BNET_TCPCLIENT_Connected(Sender: TObject);
    procedure BNET_TCPSERV_ClientConnected(Sender: TObject; Client: TSimpleTCPClient);

    procedure BNETReceiveData(Sender:TObject);
    procedure BNETSend_SV_Data2All_Except(ExceptIP: ShortString; Var Data; Size, Flags:Word);
    procedure BNETSendData2All(Var Data; Size, Flags:Word);
//    procedure BNETSendData2IP(Host: ShortString; Var Data; Size, Flags:Word);
    procedure BNETSendData2IP_(Host: ShortString; Port: Word;  Var Data; Size, Flags:Word);
    procedure BNETSendData2HOST(Var Data; Size, Flags:Word);
    procedure BNETSendData2Player(PlayerID: Byte; Var Data; Size, Flags:Word);
    procedure BNETSendData2PlayerEx(Player: TPlayer ; Var Data; Size, Flags:Word);

    procedure LOBBYConnecting(Sender: TObject; Socket: TCustomWinSocket);
    procedure LOBBYDisconnect(Sender: TObject; Socket: TCustomWinSocket);
    procedure LOBBYConnect(Sender: TObject; Socket: TCustomWinSocket);
    procedure LOBBYError(Sender: TObject; Socket: TCustomWinSocket;
      ErrorEvent: TErrorEvent; var ErrorCode: Integer);
    procedure LOBBYRead(Sender: TObject; Socket: TCustomWinSocket);
    procedure nfkplanet_idleTimer(Sender: TObject);
    procedure FormMouseUp(Sender: TObject; Button: TMouseButton;
      Shift: TShiftState; X, Y: Integer);

  private




    procedure AppError(sender:TObject; E: Exception);
    procedure AppActivate(sender:TObject);
    procedure AppDeactivate(sender:TObject);


    { Private declarations }
  public
    LocalIP, GlobalIP : string;
    Format1, Format2: TD3DFormat;
    Images: array[0..5000] of TAGFImage;

    // NEW NFK 050 NETWORK
//    ReadBuf : array[0..1023] of Byte;

//    Graph:TPowerFuck;
  end;

  type
  TParticle=packed record
    ex,ey,ez, {end}
    x,y,z, {Current}
    r,g,b:single;
    frame : byte;
    dead : boolean;
    step,
    steps: integer;
  end;

  type tmapinfo=packed record
        supportTRIX : boolean;
        supportCTF  : boolean;
        supportDOM  : boolean;
        end;

  type  PSV_Remember_Score = ^TSV_Remember_Score;
        TSV_Remember_Score = packed record
        netname : string[30];
        nfkmodel : string[30];
        frags : integer;
        end;

  type TSVCallVote=packed record
        voteActive:boolean;
        voteString:shortstring;
        voteTimedOut:cardinal;
        voted : boolean;
        votesPERCENT : byte;
        end;


CONST
  VERSION = '062B';

  BNET_LOBBYPORT : word = 29990;
  BNET_GAMEPORT  : word = 29991;
  BNET_SERVERPORT : word = 29991;
  BNET_TCPPORT   : word = 29992;
  BNET_GAMEIP : shortstring = '127.0.0.1';
  BNET_OLDGAMEIP : shortstring = '';
  BNET_LOBBY_STATUS : byte = 0; // not connected;
  BNET_LOBBY_PLAYERSPLAYING : word = 0;

  // NFK050 AUTOUPDATE. well, its simply checks version :)
  BNET_AUTOUPDATE : boolean = true;
  BNET_UPDATEURL : string = 'http://www.3dpower.org/data/nfk/update/version.txt';
  BNET_LASTUPDATESRC : cardinal = 0;
  BNET_AU_PosX   : word = 0;
  BNET_AU_PosY   : word = 0;
  BNET_AU_WidthX : word = 100;
  BNET_AU_WidthY : word = 100;
  BNET_AU_Caption: string = 'NFK News & Updates delivery system';
  BNET_AU_ShowUpdateInfo : boolean = false;
  BNET_AU_CanPlayWithThisVersion : boolean = False;

  BNET_CONNECTING : boolean = false;  // dialog...
  BNET_TIMEDOUT : Longword = 0;
  ENABLE_PROTECT : boolean = true;
  ENABLE_PACKETSHOW : boolean = false;

  // 1 - connecting
  // 2 - connected;

  BNET_ISMULTIP : word = 0;
  BNET_STR_LOBBY = 'Connect to NFK PLANET';
  BNET_STR_DIRECT = 'Create game (TCP\IP or LAN)';
  BNET_STR_DIRECTJOIN = 'Join to specified IP Address';
  BNET_STR_JOINLAN = 'Search for LAN games';

  CLIENTID      : word = 0;
  DIE_LAVA      = 3;
  DIE_WRONGPLACE = 4;
  DIE_INPAIN    = 5;
  DIE_WATER     = 6;

  DAMAGE_MACHINE : byte = 5;
  DAMAGE_SHAFT   : byte = 2;
  DAMAGE_SHAFT2  : byte = 3;
  DAMAGE_PLASMA  : byte = 14;
  DAMAGE_SHOTGUN : byte = 8;
  DAMAGE_GRENADE : byte = 65;
  DAMAGE_RAIL    : integer = 75;
  DAMAGE_GAUNTLET: byte = 35;

  GAME_FULLLOAD  : boolean = false;

  LMS_OK : byte=0;
  LMS_NOTFOUND : byte=1;
  LMS_CRC32FAILED : byte=2;

  SPECTATOR_TIMEDOUT : word = 7000;

  SHAFT_DIST : integer = 150;
  GAMMA : byte = 0;
  DRAW_FPS : boolean = false;
  DRAW_OBJECTS : boolean = false;
  DRAW_BACKGROUND : boolean = true;
  DRAW_BARFLASH : boolean = true;
  DRAW_EXTBACKGROUND : boolean = false;
  ISMULTI : boolean = false;
  CON_SIMPLEPHYSICS : boolean = true;
  MAX_MAPOBJ : word = 60;

  P1BARORIENT : integer = 427;
  MSG_DISABLE : boolean = False;
  HIST_DISABLE : boolean = False;
  ALIASCOMMAND : boolean = False;
  P1NAME : shortstring = 'player';
  P2NAME : shortstring = 'player2';
  FONTLOAD : shortstring = '';
  FONTLOADNAME : shortstring = 'arial';
  GAME_LOG : boolean = true;
  MP_WAITSNAPSHOT : boolean = false;
  SYS_TEAMSELECT : byte =0;
  SYS_TEST10:byte=0;
  SYS_BOT : boolean = true;
  SYS_BOT_FIRSTBOOT : boolean = false;

  SYS_CUSTOM_GRAPH_CONSOLE : boolean = false;
  SYS_BANNER : boolean = false;
  SYS_CONSOLE_Y : word = 0;
  SYS_CONSOLE_MAXY : word = 240;
  SYS_CONSOLE_DELIMETER : word = 32;
  SYS_CONSOLE_ALPHA : cardinal = $EE;
  SYS_CONSOLE_STRETCH : boolean = true;
  SYS_CONSOLE_POS : byte = 0;

  IMAGE_BR1 = 20;
  IMAGE_BR2 = 21;
  IMAGE_ITEM = 22;
  IMAGE_LAST : word=0;
  CONTENT_EMPTY = 37;
  CONTENT_LAVA = 31;
  CONTENT_WATER = 32;
  CONTENT_DEATH = 33;
  CONTENT_RESPAWNRED = 35;
  CONTENT_RESPAWNBLUE = 36;
  CONTENT_DOMPOINT = 42;

  OPT_FILL_RGB : cardinal = $000000;
  OPT_BGMOTION : boolean = false;
  OPT_PSYHODELIA : boolean = false;
  OPT_CL_AVIMODE : boolean=false;
  OPT_CONTENTEMPTYDEATHHIGHLIGHT : boolean = false;
  OPT_DONOTSHOW_RECLABEL : boolean = true;
  OPT_SHOWBANDWIDTH:boolean=false;
  OPT_NOCONSOLESCROLL : boolean = false;
  OPT_QWSCOREBOARD : boolean = false;

  OPT_HUD_WIDTH : byte = 16;
  OPT_HUD_DIVISOR : byte = 6;
  OPT_HUD_HEIGTH : byte = 32;
  OPT_HUD_SHADOWED : boolean = true;
  OPT_HUD_ICONS : boolean = true;
  OPT_HUD_X : word = 320;
  OPT_HUD_Y : word = 432;
  OPT_HUD_ALPHA : cardinal = 200;
  OPT_HUD_VISIBLE : byte = 1; // 0-none; 1-large; 2-always



  OPT_RCON_PASSWORD : string = '';
  SYS_GIBIMAGES : byte = 7;

//  OPT_LIGHTFX : boolean = true;

  //040 FX
  OPT_FXSMOKE : boolean = true;
  OPT_FXLIGHTRLBFG : boolean = true;
  OPT_FXPLASMA : boolean = true;
  OPT_FXQUAD : boolean = true;
  OPT_FXEXPLO : boolean = true;
  OPT_FXSHAFT : boolean = true;
  OPT_ALTGRENADES : boolean = false;
  OPT_EASTERGRENADES : boolean = false;
  OPT_BIRTHDAY : boolean = false;

  OPT_TB_SHOWMYSELF:boolean=true;
  OPT_TB_COLOR: byte=6; // 14-team bazed
  OPT_TB_STYLE : byte=1; //0-disabled.
  OPT_AUTOCONNECT_ONINVITE : boolean = true;

  pingsend_tick : longword = 0;
  pingrecv_tick : longword = 0;

  OPT_DOMBARPOS: word=0;
  OPT_DOMBARSTYLE : byte=1;

  TESTPREDICT_X : real=100;
  TESTPREDICT_Y : real=100;

  MATCH_STARTSIN : integer = 500;

  MATCH_FAKESTARTSIN : integer = 999;
  MATCH_FAKESEC : byte = 0;
  MATCH_FAKEMIN : word = 0;

  MATCH_WARMUP : integer = 300; // default;
  MATCH_TIMELIMIT : integer = 10;
  MATCH_FRAGLIMIT : integer = 0;
  MATCH_CAPTURELIMIT: word = 5;
  MATCH_DOMLIMIT: word = 300;
  MATCH_OVERTIME : word = 0;
  MATCH_GAMEEND : boolean = false;
  MATCH_SUDDEN : boolean = false;
  MATCH_OVERTIMESHOW : byte = 0;
  MATCH_RECORD : boolean = false;
//  MATCH_DEMOPLAY : boolean = false;
  MATCH_DRECORD : boolean = false;
  MATCH_DDEMOPLAY : boolean = false;
  MATCH_DEMOPLAYING : boolean = false; // font Restart Demo only

  MATCH_DDEMOMPPLAY : byte = 0;
  MATCH_REDTEAMSCORE : word = 0;
  MATCH_BLUETEAMSCORE : word = 0;

  CTF_CAPTURE_BONUS : byte=5;	 // what you get for capture
  CTF_RECOVERY_BONUS :byte=1;	 // what you get for recovery
  CTF_FRAG_CARRIER_BONUS:byte=1; // what you get for fragging enemy flag carrier
  CTF_REDFLAGSTATUS:byte=0; // for ctf bar;
  CTF_BLUEFLAGSTATUS:byte=0; // for ctf bar;

  NUM_PARTICLES : word = 0;

  flag_frame:byte = 0;
  flag_frametime:byte = 0;

  planet_frame:byte = 0;
  planet_frametime:byte = 0;

  END_SUDDEN = 1;
  END_TIMELIMIT = 2;
  END_FRAGLIMIT = 3;
  END_JUSTEND = 4;
  END_CAPTURELIMIT = 5;
  END_DOMLIMIT = 6;

  MENU_PAGE_MAIN = 0;
  MENU_PAGE_HOTSEAT = 1;
  MENU_PAGE_P1PROP = 2;
  MENU_PAGE_P2PROP = 3;
  MENU_PAGE_SETUP = 4;
  MENU_PAGE_CREDITS = 5;
  MENU_PAGE_DEMOS = 6;
  MENU_PAGE_GOGAME = 33;
  MENU_PAGE_MULTIPLAYER = 8;
  MENU_REDEFINEP1 = 9;
  MENU_REDEFINEP2 = 10;

  // DDEMO
  DDEMO_VERSION : byte = 0;     // here is a version of the demo engine... reading from demofile
  DDEMO_FIREROCKET      = 1;
  DDEMO_PLAYERPOS       = 2;
  DDEMO_TIMESET         = 3;
  DDEMO_CREATEPLAYER    = 4;
  DDEMO_KILLOBJECT      = 5;
  DDEMO_FIREBFG         = 6;
  DDEMO_FIREPLASMA      = 7;
  DDEMO_FIREGREN        = 8;
  DDEMO_FIRERAIL        = 9;
  DDEMO_FIRESHAFT       =10;
  DDEMO_FIRESHOTGUN     =11;
  DDEMO_FIREMACH        =12;
  DDEMO_ITEMDISSAPEAR   =13;
  DDEMO_ITEMAPEAR       =14;
  DDEMO_DAMAGEPLAYER    =15;
  DDEMO_HAUPDATE        =16;
  DDEMO_FLASH           =17;
  DDEMO_JUMPSOUND       =18;
  DDEMO_GAMEEND         =19;
  DDEMO_RESPAWNSOUND    =20;
  DDEMO_JUMPPADSOUND    =21;
  DDEMO_LAVASOUND       =22;
  DDEMO_POWERUPSOUND    =23;
  DDEMO_EARNPOWERUP     =24;
  DDEMO_READYPRESS      =25;
  DDEMO_FLIGHTSOUND     =26;
  DDEMO_EARNREWARD      =27;
  DDEMO_STATS           =28;
  DDEMO_GAMESTATE       =29;
  DDEMO_TRIXARENAEND    =30;
  DDEMO_OBJCHANGESTATE  =31;
  DDEMO_CORPSESPAWN     =32;
  DDEMO_GRENADESYNC     =33;
  DDEMO_STATS2          =34;
  DDEMO_PLAYERPOSV2     =35;
  DDEMO_FIREGRENV2      =36;
  DDEMO_NOAMMOSOUND     =37;
  DDEMO_GAUNTLETSTATE   =38;
  DDEMO_STATS3          =39;
  DDEMO_FIREPLASMAV2    =40;
  DDEMO_PLAYERPOSV3     =41;
  DDEMO_BUBBLE          =42;
  //mp
  DDEMO_MPSTATE         =43;
  DDEMO_NETRAIL         =44;//clients.
  DDEMO_NETPARTICLE     =45;//clients
  DDEMO_NETTIMEUPDATE   =46;//only clients.
  DDEMO_NETSVMATCHSTART =47;//only clients.
  DDEMO_DROPPLAYER      =48;
  DDEMO_CREATEPLAYERV2    = 49;
  DDEMO_SPECTATORCONNECT        =50;
  DDEMO_SPECTATORDISCONNECT     =51;
  DDEMO_CHATMESSAGE             =52;
  DDEMO_PLAYERRENAME            =53;
  DDEMO_PLAYERMODELCHANGE       =54;
  DDEMO_GENERICSOUNDDATA        =55;
  DDEMO_GENERICSOUNDSTATDATA    =56;
  DDEMO_TEAMSELECT              =57;
  DDEMO_CTF_EVENT_FLAGTAKEN     =58;
  DDEMO_CTF_EVENT_FLAGCAPTURE   =59;
  DDEMO_CTF_EVENT_FLAGDROP      =60;
  DDEMO_CTF_EVENT_FLAGPICKUP    =61;
  DDEMO_CTF_EVENT_FLAGDROP_APPLY=62;
  DDEMO_CTF_EVENT_FLAGRETURN    =63;
  DDEMO_CTF_GAMESTATE           =64;
  DDEMO_CTF_EVENT_FLAGDROPGAMESTATE=65;
  DDEMO_CTF_GAMESTATESCORE      =66;
  DDEMO_CTF_FLAGCARRIER         =67;
  DDEMO_DOM_CAPTURE             =68;
  DDEMO_DOM_SCORECHANGED        =69;
  DDEMO_WPN_EVENT_WEAPONDROP    =70;
  DDEMO_WPN_EVENT_PICKUP        =71;
  DDEMO_WPN_EVENT_WEAPONDROP_APPLY=72;
  DDEMO_WPN_EVENT_WEAPONDROPGAMESTATE=73;
  DDEMO_DOM_CAPTUREGAMESTATE    =74;
  DDEMO_NEW_SHAFTBEGIN          =75;
  DDEMO_NEW_SHAFTEND            =76;
  DDEMO_POWERUP_EVENT_POWERUPDROP               =77;
  DDEMO_POWERUP_EVENT_PICKUP                    =78;
  DDEMO_POWERUP_EVENT_POWERUPDROPGAMESTATE      =79;

  CROSHDIST : integer = 80;    // crosshair distanze;
  CROSHADD : integer = 20;
  OPT_WEAPONFLOAT : boolean = true;
  OPT_BG : byte = 1;
  OPT_SENS : byte = 4;
  OPT_KSENS : byte = 3;
  OPT_MINVERT:boolean=false;
  OPT_MROTATED:boolean=false;
  OPT_KEYBACCELDELIM : byte = 0;
  OPT_MOUSEACCELDELIM : byte = 0;
  OPT_P1KEYBACCELDELIM : byte = 0;
  OPT_SMOKE : boolean = true;
  OPT_P1CROSH : byte = 7;
  OPT_P2CROSH : byte = 7;
  OPT_P1CROSHT : byte = 1;
  OPT_P2CROSHT : byte = 1;
  OPT_SOUNDMODEL1 : shortstring = 'sarge';
  OPT_SOUNDMODEL2 : shortstring = 'sarge';
  OPT_NFKMODEL1 : shortstring = 'sarge+default';
  OPT_NFKMODEL2 : shortstring = 'sarge+blue';
  OPT_RAILCOLOR1 : byte = 1;
  OPT_RAILCOLOR2 : byte = 1;

  OPT_P1MAXARMOR : byte = 200;
  OPT_P2MAXARMOR : byte = 200;
  OPT_SYNC : byte = 3;
  OPT_MENUANIM : boolean = true;
  OPT_STEREO : boolean = true;
  OPT_REVERSESTEREO : boolean = false;
  OPT_VOLUME : byte = 100;
  OPT_MP3VOLUME : byte =100;
  OPT_MEATLEVEL : byte = 1;
  OPT_CHANNELAPPROACH : byte = 8;     // the stereo value
  OPT_RAILTRAILTIME : byte = 8;
  OPT_RAILSMOOTH : boolean= true;
  OPT_RAILPROGRESSIVEALPHA : boolean=true;
  OPT_TEAMDAMAGE : boolean = true;
  OPT_AVIDEMO : boolean=false;
  OPT_AVIDEMOC:longint=0;

  OPT_HITSND : boolean = true;
  OPT_GIBVELOCITY : boolean = false;
  OPT_GIBBLOOD : boolean = true;
  OPT_SOUND : boolean = true;
  OPT_MOUSEANGRY : boolean = FALSE;
  OPT_GAMMAANIMSPEED : real48 = 0.1;
  OPT_SHOWSTATS : boolean = false;
  OPT_DOORSOUNDS : boolean = true;
  OPT_CAMERATYPE : byte = 1;
  NUM_OBJECTS : byte = 0;
  NUM_OBJECTS_0 : boolean = true;
  OPT_MOUSESMOOTH : byte = 0;
  OPT_WEAPONSWITCH_END : byte = 1;
  OPT_P2WEAPONSWITCH_END : byte = 1;
  OPT_ALLOWMAPCHANGEBG : boolean = true;
  OPT_WARMUPARMOR : byte = 100;
  OPT_GRAPHICS : boolean = true;
  OPT_1BARTRAX : byte = 0;
  OPT_2BARTRAX : byte = 1;
  OPT_SHOWNAMES : boolean = false;
  OPT_AUTOSHOWNAMES : boolean = true;
  OPT_AUTOSHOWNAMESTIME : byte = 0;
  OPT_AUTOSHOWNAMESDEFTIME : byte = 5;
  OPT_P1MOUSELOOK : boolean = true;
  OPT_RESTRICTEDRAIL : boolean = false;
  OPT_NFKITEMS : boolean = true;
  OPT_FORCERESPAWN : word = 10;
  OPT_CORPSETIME : word = 10;
  OPT_MINRESPAWNTIME : byte = 50;
  OPT_TREADWEAPON : boolean = true;
  OPT_P1BARTIME : byte = 100;
  OPT_P2BARTIME : byte = 100;
  OPT_MESSAGETIME : word = 125;
  OPT_NOPLAYER : byte = 0;
  OPT_TRANSPASTATS : boolean = false;
  OPT_BG_R : byte = 0;
  OPT_BG_G : byte = 0;
  OPT_BG_B : byte = 0;
  OPT_SV_MAXPLAYERS : byte = 8;
  OPT_SV_ALLOWJOINMATCH : boolean = true;
  OPT_SV_DEDICATED : boolean = false;
  OPT_SV_HOSTNAME : string[50] = 'Welcome';
  OPT_SV_LOCK : boolean = false;
  OPT_SV_OVERTIME : byte = 5;
  OPT_SV_TESTPLAYER2 : boolean = false;
  OPT_SV_ALLOWSPECTATORS : boolean = false;
  OPT_SV_MAXSPECTATORS   : byte = 4;
  OPT_SV_POWERUP         : boolean = true;

  // Voting.
  OPT_SV_ALLOWVOTE : boolean = true;
  OPT_SV_VOTE_PERCENT : byte = 60;
  OPT_SV_ALLOWVOTE_RESTART : boolean = true;
  OPT_SV_ALLOWVOTE_FRAGLIMIT : boolean = true;
  OPT_SV_ALLOWVOTE_TIMELIMIT : boolean = true;
  OPT_SV_ALLOWVOTE_CAPTURELIMIT : boolean = true;
  OPT_SV_ALLOWVOTE_DOMLIMIT : boolean = true;
  OPT_SV_ALLOWVOTE_READY : boolean = true;
  OPT_SV_ALLOWVOTE_MAP : boolean = true;
  OPT_SV_ALLOWVOTE_WARMUP : boolean = true;
  OPT_SV_ALLOWVOTE_WARMUPARMOR : boolean = true;
  OPT_SV_ALLOWVOTE_FORCERESPAWN : boolean = true;
  OPT_SV_ALLOWVOTE_SYNC : boolean = true;
  OPT_SV_ALLOWVOTE_SV_TEAMDAMAGE : boolean = true;
  OPT_SV_ALLOWVOTE_NET_PREDICT : boolean = true;
  OPT_SV_ALLOWVOTE_SV_MAXPLAYERS : boolean = true;
  OPT_SV_ALLOWVOTE_SV_POWERUP : boolean = true;

  OPT_CACHELEVEL : byte = 3;
  OPT_SHOWLOADING : boolean = true;
  OPT_GAMEMENUCOLOR : byte = 6;
  SYS_CACHEDBG : byte=0;
  SYS_DXINPUT : boolean= true;
  SYS_NFKAMPSTATE : byte = 0;
  SYS_NFKAMPREFRESH : byte = 0;
  SYS_NFKDOBASS : boolean = true;
  SYS_NFKAMP_SHOULDSTARTMP3 : boolean = false;
  SYS_NFKAMP_PLAYINGCOMMENT : boolean = false;
  SYS_MAXAIR : byte = 250;
  SYS_DEMOUPDATESPEED : byte = 2;
  SYS_ANNOUNCER:byte=0;//default tied..
  SYS_USECUSTOMPALETTE:boolean=false;
  SYS_USECUSTOMPALETTE_TRANSPARENT:boolean=false;
  SYS_USECUSTOMPALETTE_TRANS_COLOR:Cardinal=$FFFFFF;

  DMG_WATER : byte=16;
  OPT_SPEEDDEMO : byte = 20;
  OPT_P1GAUNTLETNEXTWPN : boolean=true;
  OPT_P2GAUNTLETNEXTWPN : boolean=true;
  OPT_P1NEXTWPNSKIPEMPTY : boolean = false;
  OPT_P2NEXTWPNSKIPEMPTY : boolean = false;

  OPT_TRIXMASTA : boolean=false;
  OPT_SHOWMAPINFO : boolean =true;
  OPT_RAILARENA_INSTAGIB : boolean =true;
  OPT_BGMADNESS : byte=0;
//  OPT_C_NICKCOLOR : byte=0;
  OPT_SHOWNICKATSB : boolean = false;
  OPT_TESTBLOOD: boolean= true;
  OPT_DRAWFRAGBAR: boolean= true;
  OPT_DRAWFRAGBARX: word=0;
  OPT_DRAWFRAGBARY: word=464;
  OPT_DRAWFRAGBARMYFRAG : smallint = 0;
  OPT_DRAWFRAGBAROTHERFRAG : smallint = 0;
  OPT_ANNOUNCER : boolean = true;


  SYS_CURSORFRAME : byte=0;
  SYS_CURSORFRAMEWAIT : byte=0;
  SYS_FLAGFRAME : byte=0;
  SYS_FLAGFRAMERATE:byte=0;
  SYS_DOMFRAME : byte=0;
  SYS_DOMFRAMERATE:byte=0;

  SYS_SHOWCRITICAL : boolean=FALSE;
  SYS_SHOWCRITICAL_TEXT1 : shortstring='msg1';
  SYS_SHOWCRITICAL_TEXT2 : shortstring='msg2';
  SYS_SHOWCRITICAL_CAPTION : shortstring='Error';
  SYS_BAR2AVAILABLE : boolean = true;

  // powerdraw graph optionz
  OPT_R_TRANSPARENTBULLETMARKS : boolean = true;
  OPT_R_TRANSPARENTEXPLOSIONS : boolean = true;
  OPT_R_FLASHINGITEMS : boolean = true;
  OPT_R_ALPHAITEMSRESPAWN : boolean = true;
  OPT_R_WATERALPHA : Cardinal = $bb;
  OPT_R_BUBBLES : boolean = true;
  OPT_R_STATUSBARALPHA : cardinal = $DD;
  OPT_R_RAILSTYLE : byte = 0;
  OPT_NETPREDICTION : single = 0.85;
  OPT_NETCORRECTINTERPOLATEERROR : boolean = true;
  OPT_NETSPECTATOR : boolean=false;

  OPT_NETPREDICT : boolean = false;
  OPT_NETGUARANTEED : boolean = true;

  OPT_ENEMYMODEL:string[30]='';
  OPT_TEAMMODEL:string[30]='';


  SYS_P1STATSX:word=640;
  SYS_P2STATSX:word=0;
  SYS_BGANGLE : byte = 0;
  SYS_TRYTOSPANKME : boolean = false;
  SYS_COMETOPAPA   : boolean = false;
  SYS_FIREWORKSSTUDIOS : boolean = false;
  SYS_BLOODRAIN : boolean = false;
  SYS_BLOODPUNK : boolean = false;
  SYS_BLOODMONITOR : boolean = false;
  SYS_MAGICLEVEL : boolean = false;
  SYS_DRUNKRL : boolean = false;
  SYS_IAMMOON : boolean = false;
  SYS_STARWARS : boolean = false;

  C_TEAMRED = 1;
  C_TEAMBLU = 0;
  C_TEAMNON = 2;
  C_WPN_GAUNTLET=0;
  C_WPN_MACHINE=1;
  C_WPN_SHOTGUN=2;
  C_WPN_GRENADE=3;
  C_WPN_ROCKET=4;
  C_WPN_SHAFT=5;
  C_WPN_RAIL=6;
  C_WPN_PLASMA=7;
  C_WPN_BFG=8;

  // key bindings
  mButton1  : byte = 250;
  mButton2  : byte = 251;
  mButton3  : byte = 252;
  mScrollUp : byte = 253;
  mScrollDn : byte = 254;

  CTRL_MOVERIGHT : integer = 0;
  CTRL_MOVELEFT : integer = 0;
  CTRL_MOVEUP : integer = 0;
  CTRL_MOVEDOWN : integer = 0;
  CTRL_NEXTWEAPON : integer = 0;
  CTRL_PREVWEAPON : integer = 0;
  CTRL_LOOKUP : integer = 0;
  CTRL_LOOKDOWN : integer = 0;
  CTRL_FIRE : integer = 0;
  CTRL_CENTER : integer = 0;
  CTRL_WEAPON0 : integer = 0;
  CTRL_WEAPON1 : integer = 0;
  CTRL_WEAPON2 : integer = 0;
  CTRL_WEAPON3 : integer = 0;
  CTRL_WEAPON4 : integer = 0;
  CTRL_WEAPON5 : integer = 0;
  CTRL_WEAPON6 : integer = 0;
  CTRL_WEAPON7 : integer = 0;
  CTRL_WEAPON8 : integer = 0;
  CTRL_SCOREBOARD : integer = 0;
  CTRL_P2MOVERIGHT : integer = 0;
  CTRL_P2MOVELEFT : integer = 0;
  CTRL_P2MOVEUP : integer = 0;
  CTRL_P2MOVEDOWN : integer = 0;
  CTRL_P2NEXTWEAPON : integer = 0;
  CTRL_P2PREVWEAPON : integer = 0;
  CTRL_P2LOOKUP : integer = 0;
  CTRL_P2LOOKDOWN : integer = 0;
  CTRL_P2FIRE : integer = 0;
  CTRL_P2CENTER : integer = 0;
  CTRL_P2WEAPON0 : integer = 0;
  CTRL_P2WEAPON1 : integer = 0;
  CTRL_P2WEAPON2 : integer = 0;
  CTRL_P2WEAPON3 : integer = 0;
  CTRL_P2WEAPON4 : integer = 0;
  CTRL_P2WEAPON5 : integer = 0;
  CTRL_P2WEAPON6 : integer = 0;
  CTRL_P2WEAPON7 : integer = 0;
  CTRL_P2WEAPON8 : integer = 0;

  MATCH_GAMETYPE : byte = 0;

  GAMETYPE_FFA = 0;
//GAMETYPE_1V1 = 1;
  GAMETYPE_TEAM = 2;
  GAMETYPE_CTF = 3;
  GAMETYPE_RAILARENA = 4;
  GAMETYPE_TRIXARENA = 5;
  GAMETYPE_PRACTICE = 6;
  GAMETYPE_DOMINATION = 7;
  COLORARRAY : array [0..16] of Cardinal =
          ($FFFFFFF, $FF000080, $FF008000,$FF800000, $FF800080, $FF808000, $FF808080, $FFC0C0C0, $FF0000FF, $FF00FF00,
          $FF00FFFF, $FFFF0000, $FFFF00FF, $FFFFFF00, $FFC0C0C0, $FF808080, $FF000000);


  ACOLOR:array[1..8] of cardinal = ($0000FF,$00FF00,$00FFFF,$FF2525,$FFFF00,$FF00FF,$FFFFFF,$000000);

  GAMETYPE_STR : array [0..9] of string = ('DeathMatch','nul','Teamplay', 'Capture The Flag','Rail Arena', 'Trix Arena', 'Practice','Domination', 'nul', 'nul');
  GAMETYPE_STR_NP : array [0..9] of string = ('DM','-','TDM', 'CTF','RAIL', 'TRIX', 'PRAC','DOM', '-', '-');

  STIME : Cardinal = 0;

  KEYSTR : array[0..255] of string =
 ('unbinded',
  '','','','','','','','backspace','tab','',//10
  '','','enter','','','shift','ctrl','alt','','capslock',//20
  '','','','','','','','','','',//30
  '','space','pgup','pgdown','end','home','leftarrow','uparrow','rightarrow','downarrow',//40
  '','num*','','','insert','delete','','0','1','2',//50
  '3','4','5','6','7','8','9','','','',//60
  '','','','','A','B','C','D','E','F',//70
  'G','H','I','J','K','L','M','N','O','P',//80
  'Q','R','S','T','U','V','W','X','Y','Z',//90
  '','','','','','num0','num1','num2','num3','num4',//100
  'num5','num6','num7','num8','num9','num*','num+','','num-','num.',//110
  'num/','','','','','','','','','',//120
  '','','','','','','','','','',//130
//------------ none
  '','','','','','','','','','','','','','','','','','','','',
  '','','','','','','','','','','','','','','','','','','','',
  '','','','','','','','','','','','','','','','','','','','',
  '','','','','','','','','','','','','','','','','','','','',
  '','','','','','','','','','','','','','','','','','','','',
  '','','','','','','','','','','','','','','','','','','','mbutton1','mbutton2','mbutton3','mwheelup','mwheeldown','');

  KEYALIASES : array[0..255] of string =
 ('',
  '','','','','','','','1','1','',//10
  '','','1','','','1','1','1','','1',//20
  '','','','','','','','','','',//30
  '','1','1','1','1','1','1','1','1','1',//40
  '','1','','','1','1','','1','1','1',//50
  '1','1','1','1','1','1','1','','','',//60
  '','','','','1','1','1','1','1','1',//70
  '1','1','1','1','1','1','1','1','1','1',//80
  '1','1','1','1','1','1','1','1','1','1',//90
  '','','','','','1','1','1','1','1',//100
  '1','1','1','1','1','','1','','1','1',//110
  '1','','','','','','','','','',//120
  '','','','','','','','','','',//130
//------------ none
  '','','','','','','','','','','','','','','','','','','','',
  '','','','','','','','','','','','','','','','','','','','',
  '','','','','','','','','','','','','','','','','','','','',
  '','','','','','','','','','','','','','','','','','','','',
  '','','','','','','','','','','','','','','','','','','','',
  '','','','','','','','','','','','','','','','','','','','1','1','1','1','1','');

  GRAVITY = 0.02;
  PLAYERMAXSPEED = 3;
  MAX_BUF = 2048;       // buffer for map loading
  GRENADE_SLOWSPEED = 1.07;
  GIB_DEATH = -40;
  CWEAPON = 1;
  BRICK_X : byte = 20;
  BRICK_Y : byte = 30;
  MAX_MODEL : byte = 100;
  NUM_MODELS : byte = 0;
  INGAMEMENU : boolean = false;
  INSCOREBOARD : boolean = false;
  GAMEMENUORDER : byte = 0;
  G_BRICKREPLACE:byte=0;

  sys_lan_refresh_time : cardinal = 0;
var
//mp;

  BNET1 : TUDPdemon;
  TCPSERV : TSimpleTCPServer;
  TCPCLIENT : TSimpleTCPClient;

  BRefreshEnabled : boolean;

  MP_Providers, MP_Sessions, BNET_AU_LIST : TStringList;
  MP_ProvidersIndex, MP_STEP, MP_SessionIndex: byte;
  ParticleEngine: TParticleEngine;
//console
  SinTable,
  CosTable:Array[0..360] of extended;
  INCONSOLE,GODMODE,INMENU, INTEAMSELECTMENU : boolean;
  MENUORDER,MENUEDITMODE,MENUEDITMAX,MENUTIMEOUT,MENUWANTORDER : BYTE;
  constr,ROOTDIR,MENUEDITSTR : string[255];
  mainform: Tmainform;
  lastconadd, mapindex,mapofs,mapcansel,GX,GY : integer;
  serverofs:integer;

  demoindex,demoofs : word;
  Wave1,wave3,wave2,wave4,wave5,wave6 : integer;
        Wavey : shortint;
        Wavedir : byte;
        Waveoy : real;

  DemoStream, DeCompressedPaletteStream : TmemoryStream;
  DemoStreamBZ:TmemoryStream;
  DemoStreamProgressEvent : TProgressEvent;
  FMODStream: PFSoundStream;
  LocationsArray : array [1..50] of TLocationText;  // map locations text.
  combo1 : TComboBoxNFK;

  SPAWNX, SPAWNY : byte;

  scoreboard_ts : TStringList; // for scoreboard sorting,
  scoreboard_to : cardinal;

  menu1_alpha : cardinal;
  menu1_alpha_dir : byte;
  menu2_alpha : cardinal;
  menu2_alpha_dir : byte;
  menu3_alpha : cardinal;
  menu3_alpha_dir : byte;
  menu4_alpha : cardinal;
  menu4_alpha_dir : byte;
  menu5_alpha : cardinal;
  menu5_alpha_dir : byte;
  menu6_alpha : cardinal;
  menu6_alpha_dir : byte;

  NFKPLANET_KeepAlive_var : byte = 6;

  font_alpha : cardinal;
  font_invalpha : cardinal;
  font_alpha_dir : byte;

  font_alpha_s : cardinal;
  font_invalpha_s : cardinal;
  font_alpha_dir_s : byte;

  button_alpha : cardinal;
  button_alpha_dir : byte;
  button1_alpha : cardinal;
  button1_alpha_dir : byte;
  button2_alpha : cardinal;
  button2_alpha_dir : byte;
  button3_alpha : cardinal;
  button3_alpha_dir : byte;
  prevra : byte; // preview rect anim

  starttime, answertime, votetesttime : cardinal;
  tgR,tgG,tgB : real;
  ctgR,ctgG,ctgB : real;
  dompoint1, dompoint2, dompoint3 : byte;

  dedicated_gameend_time : cardinal;

  conmsg_index : word;
//  SYS_CONSOLE_XZ : real;
//  SYS_CONSOLE_YZ : real;

  keyup_, p1properties_backto: boolean;
  demodata: ddemodata;
  demofile : file of ddemodata;
  demofilename, LastDemoCommand : string;
  mapweapondata : Tmapweapondata;
  aaa : array [0..1000] of TMonoSprite; // array of game objects
  bbb : array [0..250,0..250] of TBrick; // array of bricks
  ddd : array [0..255] of TMAPOBJV2; // array of map objects
  eee : array [0..750] of TNFKModel; // modelz
  playerstats : array[0..7] of TPlayerStats; // mirror to players[0..7].
  conscrmsg,conscrmsg2,conscrmsg3,conscrmsg4 : string;
  conmsg : TStringList;
  conmsgcur : array[0..14] of string[255];
  conhist : tSTRINGLIST;
  contime,contime2,contime3,contime4 : longint;
  conshow, RESPAWNS_COUNT,LASTRESPAWN,hiclr : integer;
  RESPAWNSRED_COUNT,RESPAWNSBLUE_COUNT:integer;
  LASTRESPAWNRED,LASTRESPAWNBLUE:integer;

  ReadBuf{, ReadBuf2} : array[0..1023] of Byte;

  muslist,mp3list,contab,credlist : TStringlist;
  mp3lastsel: word;
  players : array [0..7] of TPlayer;
  LOG,maplist,demolist : TStringlist;
  mappath, demopath, loadmapsearch_lastfile : string;
  DISPLAYMESSAGE : string;
  crosh1,srosh2 : real;
  extback : TBITMAP;
  p1flashbar,p2flashbar,p1weapbar,p2weapbar,HEIG,fff,gamesudden,netsync,menuburn : byte;
  menux,menuy : word;
  gametime,gametic : integer;
  keyaccel,keyaccel1,pkeyaccel,pkeyaccel1,draworder,menu_sl,last_menu_sl,menu_tab : byte;
  map_author,map_name, map_filename, demo_name,demo_name_str : string [70];
  map_filename_fullpath : string;
  map_bg : byte;
  map_crc32 : cardinal;
  map_info : byte;
  lastmap : integer = -1;
  menuhic : boolean;
  Particles:array[1..6] of TParticle;
  zColor,Opacity : integer;

  // for fmod.
  SAMPLES:array[0..5000] of PFSoundSample;
  listenerpos: array[0..2] of single;
  FMOD_MAXSOUND : word;
  sampleformat:longint;

  mapinfo:TMapInfo;

  SV_Remember_Score_List : TList;
  SVVOTE : TSVCallVote;

  SpectatorList : TList;

//  SineLineTable: Array[0..360] Of single;

// bot.dll
type
  TCallProcSTR = function(text : shortstring):shortstring;
  TCallTextProc = procedure(text : shortstring);
  TCallProcCreatePlayer = procedure(name, model: shortstring; team : byte);
  TCallProcWordByteFunc = procedure(DXID : word ; keys: byte);
  TCallProcWordWordFunc = procedure(DXID : word ; angle: word);
  TCallProcWordWord_Bool = function(x, y : word):boolean;
  TCallProcWordWordString = procedure(x, y : word; text : shortstring);
  TCallProcBrickStruct = function(x, y : word):TBrick;
  TCallProcObjectsStruct = function (ID : word):TMonoSpriteBD;
  TCallProcSpecailObjectsStruct = function (ID : byte):TMAPOBJV2;
  TCallProcWord = procedure(par : WORD);
  TCallProcChat = procedure(DXID:word; text : shortstring; teamchat: boolean);

procedure FireRocket(f : TPlayer; x,y,ang : real);
function modu(a : real) : real;   // module
procedure PlayerAnim(id : byte);      // id
procedure ADDMESSAGE(s : string);
procedure ADDPLAYER (sender : TPLayer);
procedure ApplyDamage(f : TPlayer; dmg : integer; att : TMonoSprite; tp : byte);
procedure ApplyCommand(s : string);
procedure ApplyHCommand(s : string);
procedure DeathMessage(f : TPlayer ; att : TMonoSprite; tp : byte);
procedure FIRE (f : TPlayer; x,y,ang : real);
procedure SpawnBlood(f : TPlayer);
procedure SpawnXYBlood(f : TPlayer; x,y:real);
procedure ThrowPlayer(player : TPlayer; epicenter : TMonoSprite; dmg : integer);
procedure TABCommand(s : string);
procedure LOADMAP (Filename : string; inreal : boolean);
procedure LoadCFG (s : string; option:byte);
procedure SaveCFG (s : string);
//function sqrtt(x : real) : real;
function AssignUniqueDXID (tmp : word) : word;
procedure SpawnNetShots(x,y : smallint);
procedure SpawnNetShots1(x,y : smallint);
procedure PLAYSOUND(SNDINDEX : word;x,y : real);
procedure Gamma_set(a : byte);
function BrickOnHead(sender:TPlayer) : boolean;//do not jump over brickz
function formatbyte(n : integer) : integer;
procedure SpawnXYNulBlood(x,y:real);
procedure DrawBMPFont(s : string; x,y : Smallint ;size : byte);
procedure DrawCBMPFont(s:string;y:integer;size:byte);
function IsParamStr(ss : string) : boolean;
procedure GammaAnimation;
procedure Firegauntlet(f : TPlayer);
procedure FireBFG(f : TPlayer; x,y,ang : real);
procedure FirePlasma(f : TPlayer; x,y,ang : real);
procedure FireMachine(f : TPlayer; x,y,ang : real);
procedure FireShotGun(f : TPlayer; x,y,ang : real);
procedure FireRail(f : TPlayer; clr,x,y,ang : real);
procedure FireGren(f : TPlayer; x,y,ang : real);
procedure FireShaft(f : TPlayer; x,y,ang : real);
procedure FireShaftEx(f : tplayer; dude_ : boolean);
procedure RespawnFlash (x,y : real);
procedure ActivateOBJ(p : byte);
procedure ClipButton(xx,yy: integer);
procedure CorpsePhysic(id : byte);
procedure SpawnCorpse(f : TPlayer);
procedure DoWeapBar(i : byte);
Function ClipDoorTrigger(xx,yy: integer) : boolean;
function toValidFilename(str : string) : string;
procedure unbindkey(k : byte);
procedure p1defaults;
procedure p2defaults;
procedure GetMapWeaponData;
function IsWaterContentHEAD(sender : TPlayer) : boolean;  // this procedure checkz if the player onground
function player_region_touch (x,y,x1,y1 : word; f : tplayer) : boolean;
procedure ShowCriticalError(caption,text1,text2 : shortstring);
procedure resetmap;
function InScreen(x,y,bn : integer) : boolean;
procedure CTF_DropFlag (f : TPlayer);
procedure CTF_ReturnFlag (flag:byte); // flag returnto base.
procedure CTF_EVENT_FLAGTAKEN(x,y:byte;DXID:word);
procedure CTF_Event_FlagCapture(DXID:word);
procedure CTF_Event_Message(DXID:word;action:shortstring);
function MyteamIS():byte;
function MyDxidIS():word;
function TeamGame:boolean;
procedure CTF_Event_FlagDrop_Apply(sender : TMonoSprite); // correcting flag poz.
procedure CTF_Event_PickupFlag(sender : TMonoSprite; player:TPlayer);  // pickup selfteam flag, and start wear it...
procedure CTF_Event_ReturnFlag(DXID:WORD; team:byte);
procedure CTF_Event_GameStateScoreChanged();
procedure g_Network_droppableObjects(ToIP:ShortString; ToPort: word);
procedure CTF_SAVEDEMO_FlagDrop(sender : TMonoSprite);
procedure POWERUP_Event_Pickup(sender : TMonoSprite; player:TPlayer);  // pickup powerup
function CTF_BlueFlagAtBase:boolean;
function CTF_RedFlagAtBase:boolean;
procedure CalculateFragBar;
function GetRedTeamScore : Smallint;
function GetBlueTeamScore : Smallint;
procedure DOM_Capture(x,y,team,packet_type:byte);//captures a point.
procedure WPN_ProcessWeaponPhysics (sender : TMonoSprite);
procedure POWERUP_ProcessPowerupPhysics (sender : TMonoSprite);
procedure WPN_DropWeapon (f : TPlayer);
procedure POWERUP_Drop (f : TPlayer);
procedure WPN_Event_WeaponDrop(sender : TMonoSprite);
function WPN_GainWeapon(f : TPlayer; wpnindex:byte) : boolean;
function POWERUP_GainPowerup(f : TPlayer; pindex, amount: byte) : boolean;
procedure DoWeapBarEx(F : TPlayer);
procedure ALIAS_SaveAlias(var TS:TStringList);
procedure DOM_UpdateStatusBar;
procedure ApplyModels();
procedure ApplyOriginalModels();
procedure SPAWNCLIENT;
procedure NFKPLANET_UpdateCurrentUsers(Players_ : byte);
function DrawWINDOW(Caption, Button: shortString;x,y, width, height:word; type_: byte) :boolean;
function LOADMAPCRC32(filename:string):Cardinal;
function BD_GetSystemVariable(s : shortstring):shortstring;
procedure resetplayerstats(f : tplayer);
procedure resetplayer(f : tplayer);
function ASSIGNMODEL(f : TPlayer) : boolean;
procedure FindRespawnPoint (p : TPlayer; net : boolean);
function GetNumberOfPlayers:byte;
procedure setcrosshairpos(f : TPlayer; x,y,h : real;vis : boolean);
procedure ParseColorText(s: string;x,y:integer;fonttype:byte);
function MyPingIS():word;
procedure BNET_ServerStart;
procedure SV_Remember_Score_Add(netname, nfkmodel:string; frags : integer);
procedure SV_Remember_Score_Clear;
function MAPExists(filename:string; CRC32:cardinal) : boolean;
function GetNumberOfBots:byte;
function ISHotSeatMap:boolean;
procedure SendFloodTo(ToIP:shortstring; ToPort: word; order : byte);
procedure TestPlayerDead(i:byte);
procedure CL_AskLobbyGamestate(ToIP:String);
procedure ErrorSound;
procedure ThrowXYGib (x,y : single; typ : byte);
// -----------------------------------------------------------------------------
implementation

uses Unit2,demounit,net_unit;
{$R *.DFM}

function IsMultip() : byte; // 0=none; 1=host; 2=client
begin
        result := BNET_ISMULTIP;
end;

function FilterString(c : string) : string;     // leave only numberz;
var e : integer;
    w : string;
    a : string[1];
begin
     if(Length(c) >= 1) then begin
     w := ''; a := '';
     For e := 1 to (Length(c)) do
     begin
     a := Copy(c, e, (e+1));
     if ((a >= '0') and (a <= '9')) or (a = ',') or (a = '.') then begin
        if(a = ',') then a := '.';
        w := w + a; end;
     a := '';
     end;
     result := w;
     end else result := '0';
end;


function strpar_next(s:string; pos : word):string;
var     counter : byte;
        len, i : word;
const   delimeter : char = ' ';
begin
        result := ''; len := length(s);
        if len = 0 then exit; counter := 0;
        s := delimeter + s + delimeter;
        for i := 1 to len do
        if (s[i]=delimeter) then begin
                if counter = pos then begin
                        result := copy(s, i+1, len-i+1);
                        exit;
                        end;
                inc(counter);
        end;
end;

// return string between spaces.
function strpar_np(s:string; pos : word):string;
var     counter, del1 : byte;
        len, i : word;
const   delimeter : char = #0;
begin
        result := ''; len := length(s);  del1 := 1;
        if len = 0 then exit; counter := 0;

        for i := 1 to len do
        if (s[i]=delimeter) or (i=len) then begin
        if counter = pos then begin
                if pos=0 then result := copy(s, del1, i-del1) else
                if (i=len) and (s[i]<>delimeter) then result := copy(s, del1+1, i-del1+1) else
                result := copy(s, del1+1, i-del1-1);
                exit;
                end;
        del1 := i;
        inc(counter);
        end;
end;

Function strpar(s : string; i: integer) : string;
var z : integer;
      delim : integer;
begin
if s = '' then begin result := ''; exit;end;
delim := 0;
if i > 0 then begin
         for z := 1 to length(s) do begin
          if s[z] = ' ' then inc(delim);
          if delim = i then begin delim := z+1; break end;
         end;
         if delim < i then begin result := ''; exit;end;
end else delim := 1;
if delim = 0 then begin result := ''; exit; end;
//showmessage(s[delim]);
for z := delim to length(s) do
     if (s[z] = ' ') then
        begin result := copy(s,delim, z-delim); exit end;
result := copy(s,delim,length(s)-delim+1);
end;


procedure DLL_RegisterProc1(ACallProc : TCallProcWordWordFunc); external 'bot.dll';
procedure DLL_RegisterProc2(ACallProc : TCallTextProc; ProcID: byte); external 'bot.dll';
procedure DLL_RegisterProc3(ACallProc : TCallProcSTR; ProcID: byte); external 'bot.dll';
procedure DLL_RegisterProc4(ACallProc : TCallProcCreatePlayer; ProcID: byte); external 'bot.dll';
procedure DLL_RegisterProc5(ACallProc : TCallProcWordByteFunc; ProcID: byte); external 'bot.dll';
procedure DLL_RegisterProc6(ACallProc : TCallProcWordWord_Bool; ProcID: byte); external 'bot.dll';
procedure DLL_RegisterProc7(ACallProc : TCallProcWordWordString; ProcID: byte); external 'bot.dll';
procedure DLL_RegisterProc8(ACallProc : TCallProcBrickStruct); external 'bot.dll';
procedure DLL_RegisterProc9(ACallProc : TCallProcObjectsStruct); external 'bot.dll';
procedure DLL_RegisterProc10(ACallProc : TCallProcSpecailObjectsStruct); external 'bot.dll';
procedure DLL_RegisterProc11(ACallProc : TCallProcWord); external 'bot.dll';
procedure DLL_RegisterProc12(ACallProc : TCallProcChat); external 'bot.dll';
procedure DLL_EVENT_BeginGame; external 'bot.dll';
procedure DLL_EVENT_ResetGame; external 'bot.dll';
procedure DLL_EVENT_MapChanged;external 'bot.dll';
procedure DLL_SYSTEM_AddPlayer(Player : TPlayerEx); external 'bot.dll'
procedure DLL_SYSTEM_UpdatePlayer(Player : TPlayerEx); external 'bot.dll'
procedure DLL_SYSTEM_RemovePlayer(DXID:WORD); external 'bot.dll'
procedure DLL_CMD(s:string); external 'bot.dll'
procedure DLL_SYSTEM_RemoveAllPlayers; external 'bot.dll'
procedure DLL_MainLoop; external 'bot.dll';
procedure DLL_DMGReceived(TargetDXID, AttackerDXID:Word; dmg : word); external 'bot.dll';
procedure DLL_ChatReceived(DXID:Word; Text : shortstring); external 'bot.dll';
procedure DLL_AddModel(s : shortstring); external 'bot.dll';
function  DLL_QUERY_VERSION:shortstring; external 'bot.dll';

procedure ErrorSound; begin playsound(snd_error,0,0); end;

function BD_Avail: boolean;
begin
        result := false;
        if SYS_BOT = false then exit;
        if ismultip=2 then exit;
        if MATCH_DDEMOPLAY then exit;
        if inmenu then exit;
        result := true;
end;

// ----------------------------------------------------

function GetRedPlayers : byte; var i : byte; begin result := 0; for i := 0 to 7 do if players[i] <> nil then if players[i].team = 1 then inc(result);  end;
function GetBluePlayers : byte; var i : byte; begin result := 0; for i := 0 to 7 do if players[i] <> nil then if players[i].team = 0 then inc(result); end;
function GetRedTeamScore : Smallint; var i : byte; begin result := 0; if MATCH_STARTSIN > 0 then exit; for i := 0 to 7 do if players[i] <> nil then if players[i].team = 1 then result := result + players[i].frags;  end;
function GetBlueTeamScore : Smallint; var i : byte; begin result := 0; if MATCH_STARTSIN > 0 then exit; for i := 0 to 7 do if players[i] <> nil then if players[i].team = 0 then result := result + players[i].frags; end;

// ----------------------------------------------------
// BOT.DLL STUFF
// ----------------------------------------------------
procedure BD_FirstBoot;
var i : word;
begin
        if SYS_BOT_FIRSTBOOT then exit;
        SYS_BOT_FIRSTBOOT := true;

        AddMessage(DLL_QUERY_VERSION);

        for i := 0 to NUM_MODELS-1 do
        DLL_AddModel ( eee[i].classname+'+'+eee[i].skinname );
end;

procedure BD_AddMessage(S : shortstring);
begin
        AddMessage(S);
end;
// ----------------------------------------------------
procedure BD_AddPlayer(Netname_, nfkmodel_: shortstring; team_: byte);
var a : TPlayer;
  Msg: TMP_CreatePlayer;
  MsgSize : word;
begin
        if Getnumberofplayers >= OPT_SV_MAXPLAYERS then begin
                addmessage('^3Cannot addbot, ^5sv_maxplayers ^3reached.');
                exit;
                end;

        a := TPlayer.Create;
        with a do begin
        objname := 'player';
        idd := 2;       // BOT player.
        control := 255; // no control
        health := 125;
        armor := 0;
        x := 320;
        y := 200;
        netname   := netname_;
        netobject := false;     // local player
        nfkmodel  := nfkmodel_;
        dead := 0;
        frame := 0;
        netnosignal := 0;
        DXID := AssignUniqueDXID($FFFF);
        balloon := false;
        netupdated:=true;
        botrailcolor := random(7)+1;
        ipaddress := inttostr(random(255))+'.'+inttostr(random(255))+'.'+inttostr(random(255))+'.'+inttostr(random(255));
        if TeamGame then begin
                team := team_; // reset to null team...
                if team >= 2 then
                if GetRedPlayers > GetBluePlayers then team := 0 else if GetRedPlayers < GetBluePlayers then team := 1 else team := random(2);
        end;

        addplayer(a);
        resetplayer(a);
        resetplayerstats(a);

        // for demos
        if MATCH_DRECORD then begin
                DData.gametic := gametic;
                DData.gametime := gametime;
                DData.type0 := DDEMO_CREATEPLAYERV2;
                DemoStream.Write(DData, Sizeof(DData));
                DSpawnPlayerV2.x := round(a.x);
                DSpawnPlayerV2.y := round(a.y);
                DSpawnPlayerV2.dir := a.dir;
                DSpawnPlayerV2.team := a.team;
                DSpawnPlayerV2.dead := 0;
                DSpawnPlayerV2.DXID := a.DXID;
                DSpawnPlayerV2.modelname := a.nfkmodel;
                DSpawnPlayerV2.netname := a.netname;
                DSpawnPlayerV2.reserved := 0;
                DemoStream.Write(DSpawnPlayerV2, Sizeof(DSpawnPlayerV2));
        end;

        // Multiplayer stuff.
        if ismultip=1 then begin
                MsgSize := SizeOf(TMP_CreatePlayer);
                Msg.Data := MMP_CREATEPLAYER;
                Msg.x := round(a.x);
                Msg.y := round(a.y);
                Msg.DXID := a.dxid;
                Msg.ipaddress_ := a.IPAddress;
                Msg.ClientId := 0;
                Msg.netname := a.netname;
                Msg.nfkmodel := a.nfkmodel;
                Msg.Team := a.team;
                mainform.BNETSendData2All (Msg, MsgSize, 1);
        end;
        addmessage(a.netname+' ^7^njoin the game');

     end;
     AssignModel(a);
     findrespawnpoint(a,false);
end;
// ----------------------------------------------------
procedure BD_UpdatePlayers;
var pl : TPlayerEx;
    i: byte;
begin
        if GetNumberOfBots > 0 then
        for i := 0 to 7 do if players[i] <> nil then
        with pl do begin
                DXID := players[i].DXID;
                if players[i].dead > 0 then
                dead := true else dead := false;
                if players[i].idd = 2 then
                bot := true else bot := false;
                refire  := players[i].refire;
                weapchg  := players[i].weapchg;
                weapon  := players[i].weapon;
                threadweapon  := players[i].threadweapon;
                dir := players[i].dir;
                gantl_state := players[i].gantl_state;
                air := players[i].air;
                team := players[i].team;
                health := players[i].health;
                armor := players[i].armor;
                frags := players[i].frags;
                netname := players[i].netname;
                nfkmodel := players[i].nfkmodel;
                crouch := players[i].crouch;
                balloon := players[i].balloon;
                flagcarrier := players[i].flagcarrier;
                Location := players[i].Location;
                item_quad := players[i].item_quad;
                item_regen := players[i].item_regen;
                item_battle  := players[i].item_battle;
                item_flight := players[i].item_flight;
                item_haste := players[i].item_haste;
                item_invis := players[i].item_invis;
                have_rl := players[i].have_rl;
                have_gl  := players[i].have_gl;
                have_rg  := players[i].have_rg;
                have_bfg := players[i].have_bfg;
                have_sg := players[i].have_sg;
                have_sh   := players[i].have_sh;
                have_mg   := players[i].have_mg;
                have_pl  := players[i].have_pl;
                ammo_mg := players[i].ammo_mg;
                ammo_sg := players[i].ammo_sg;
                ammo_gl := players[i].ammo_gl;
                ammo_rl := players[i].ammo_rl;
                ammo_sh := players[i].ammo_sh;
                ammo_rg := players[i].ammo_rg;
                ammo_pl := players[i].ammo_pl;
                ammo_bfg := players[i].ammo_bfg;
                x := players[i].x;
                y := players[i].y;
                cx := players[i].cx;
                cy := players[i].cy;
                if players[i].idd <> 2 then begin // emulate player fangle
                        if (players[i].dir=0) or (players[i].dir=2) then
                        fangle := players[i].fangle*360/255 else
                        fangle := players[i].fangle*360/255+1;
                        end;
                InertiaX := players[i].InertiaX;
                InertiaY := players[i].InertiaY;
                DLL_SYSTEM_UpdatePlayer(pl);
        end;
end;
// ----------------------------------------------------
procedure BD_FixAngle(i : byte);
begin
if players[i]=nil then exit;
if players[i].idd <> 2 then exit;
if players[i].botangle < 0 then players[i].botangle := 360 + players[i].botangle;
if players[i].botangle > 360 then players[i].botangle := players[i].botangle - 360;

if (players[i].dir=1) or (players[i].dir=3) then begin
        if (players[i].botangle > 180) then players[i].botangle:= 360 - players[i].botangle;
end else
        if (players[i].botangle <= 180) then players[i].botangle:= 360 - players[i].botangle;

end;
// ----------------------------------------------------
procedure BD_SetAngle (DXID:Word; angle : word);
var i : byte;
    ang : integer;
    tmp : integer;
begin
        for i := 0 to 7 do if players[i] <> nil then if players[i].idd = 2 then
        if players[i].dxid = dxid then begin
                ang := round(angle);
                if angle > 360 then angle := angle mod 360;
                players[i].botangle := angle;
                BD_FixAngle(i);
                players[i].fangle := players[i].botangle * 255 / 360;

                // grenade launcher optimization
                if (players[i].dir = 1) or (players[i].dir = 3) then begin
                        if players[i].botangle >= 270 then players[i].botangle := 0;
                        if (players[i].botangle < 270) and (players[i].botangle > 180) then players[i].botangle := 180;
                        tmp := round(players[i].botangle * 200 / 180);
                        players[i].clippixel := tmp-100;
                end else begin
//                if (players[i].dir = 0) or (players[i].dir = 2) then begin
                        if players[i].botangle <= 90 then players[i].botangle := 360;
                        if (players[i].botangle > 90) and (players[i].botangle < 180) then players[i].botangle := 181;
                        tmp := round((players[i].botangle-180) * 200 / 180);
                        players[i].clippixel := -tmp+100;
                end;
                exit;
        end;
end;
// ----------------------------------------------------
procedure BD_SetWeapon (DXID:Word; wpn : byte);
var i : byte;
begin
        for i := 0 to 7 do if players[i] <> nil then if players[i].idd = 2 then
        if players[i].dxid = dxid then begin
                if (wpn=1) and (players[i].have_mg = false) then exit;
                if (wpn=2) and (players[i].have_sg = false) then exit;
                if (wpn=3) and (players[i].have_gl = false) then exit;
                if (wpn=4) and (players[i].have_rl = false) then exit;
                if (wpn=5) and (players[i].have_sh = false) then exit;
                if (wpn=6) and (players[i].have_rg = false) then exit;
                if (wpn=7) and (players[i].have_pl = false) then exit;
                if (wpn=8) and (players[i].have_bfg = false) then exit;
                players[i].threadweapon := wpn;
                exit;
        end;
end;
// ----------------------------------------------------
procedure BD_SetKeys (DXID:Word; keys : byte);
var i : byte;
begin
        for i := 0 to 7 do if players[i] <> nil then if players[i].idd = 2 then
        if players[i].dxid = dxid then begin
                players[i].keys := keys;
                exit;
        end;
end;
// ----------------------------------------------------
procedure BD_SetBalloon(DXID:Word; balloon : byte);
var i : byte;
begin
        for i := 0 to 7 do if players[i] <> nil then if players[i].idd = 2 then
        if players[i].dxid = dxid then begin
                if balloon=0 then
                        players[i].balloon := false else
                                players[i].balloon := true;
                exit;
        end;
end;
// ----------------------------------------------------
function BD_Test_Blocked(x,y:word):boolean;
begin
        if x > BRICK_X*32+32 then x := BRICK_X*32+32;
        if y > BRICK_Y*16+16 then y := BRICK_Y*16+16;
        result := bbb[ trunc(x) div 32, trunc(y) div 16].block;
end;
// ----------------------------------------------------
procedure BD_FontTextOut(x,y: word; text : shortstring);
begin
        parsecolortext(text, x, y, 2);
end;
// ----------------------------------------------------
procedure BD_FontTextOutC(x,y: word; text : shortstring);
begin
        parsecolortext(text, GX+x, GY+y, 2);
end;
// ----------------------------------------------------
function BD_GetBrickStructure(x,y:word):TBrick;
begin
        result := bbb[x,y];
end;
// ----------------------------------------------------
function BD_GetSpecialObjectStructure(ID:byte):TMAPOBJV2;
begin
        result := ddd[ID];
end;
// ----------------------------------------------------
function BD_GetObjectStructure(ID:word):TMonoSpriteBD;
begin
        if ID>1000 then begin
                ID := 1000;
                addmessage('^1BOT.DLL ERROR: Wrong ID requested in BD_GetObjectStructure');
                end;

        result.dead := aaa[ID].dead;
        result.speed := aaa[ID].speed;
        result.fallt := aaa[ID].fallt;
        result.weapon  := aaa[ID].weapon;
        result.doublejump := aaa[ID].doublejump;
        result.refire := aaa[ID].refire;
        result.imageindex := aaa[ID].imageindex;
        result.dir  := aaa[ID].dir;
        result.idd  := aaa[ID].idd;
        result.clippixel := aaa[ID].clippixel;
        if aaa[ID].spawner = nil then
        result.spawnerDXID := 0 else result.spawnerDXID := aaa[ID].spawner.DXID;
        result.frame  := aaa[ID].frame;
        result.health := aaa[ID].health;
        result.x := aaa[ID].x;
        result.y := aaa[ID].y;
        result.cx := aaa[ID].cx;
        result.cy := aaa[ID].cy;
        result.fangle := aaa[ID].fangle;
        result.fspeed := aaa[ID].fspeed;
        result.objname := aaa[ID].objname;
        result.DXID := aaa[ID].DXID;
        result.mass := aaa[ID].mass;
        result.InertiaX := aaa[ID].InertiaX;
        result.InertiaY := aaa[ID].InertiaY;
end;
// ----------------------------------------------------
procedure BD_RemoveBot(par : word);
var d : byte;
        msg : TMP_KickPlayer;
        msgsize : word;
begin
        for d := 0 to 7 do if players[d] <> nil then if (players[d].dxid = par) and (players[d].idd=2) then begin
                addmessage(players[d].netname +' ^7^nhas left the game.');
                RespawnFlash(players[d].x-16, players[d].y);
                if SYS_BOT then DLL_SYSTEM_RemovePlayer(players[d].DXID);

                if SYS_BOT then
                if (MATCH_GAMETYPE = GAMETYPE_CTF) and (players[d].flagcarrier = true) and (players[d].dead = 0) then begin
                        CTF_DropFlag(players[d]);
                        players[d].team := 2;
                        end;

                if MATCH_DRECORD then begin
                        DData.type0 := DDEMO_DROPPLAYER;
                        DData.gametic := gametic;
                        DData.gametime := gametime;
                        DemoStream.Write( DData, Sizeof(DData));
                        DNETKickDropPlayer.DXID := players[D].DXID;
                        DemoStream.Write( DNETKickDropPlayer, Sizeof(DNETKickDropPlayer));
                end;

                if ismultip=1 then begin
                        MsgSize := SizeOf(TMP_KickPlayer);
                        Msg.DATA := MMP_IAMQUIT;
                        Msg.DXID := players[D].DXID;
                        mainform.BNETSendData2All (Msg, MsgSize, 1);
                end;

                players[d] := nil;
                break;
        end;
end;
// ----------------------------------------------------
procedure BD_RegisterConsoleCommand(S : shortstring);
var i : word;
begin
        for i := 0 to contab.count-1 do
                if contab[i]=strpar(lowercase(s),0) then exit;

        contab.add(s);
        contab.sort;
end;
// ----------------------------------------------------
procedure BD_SendChat(DXID:word; text : shortstring; teamchat: boolean);
var i : byte;
    buf : array [0..$FF] of char;
    buff : array [0..$FF] of char;
    chatP : pointer;
    msgsize:word;
begin
        for i := 0 to 7 do if players[i] <> nil then if players[i].idd = 2 then
        if players[i].dxid = dxid then begin
                // send a chat.
                if not TeamGame then if teamchat = true then teamchat := false;

                if (teamchat=false) then begin
                        addmessage(players[i].netname+'^7^n: ^5'+ text);
                        playsound(SND_talk,0,0);
                end else if (myTeamIS=players[i].team) or (players[i].team = C_TEAMNON) then begin
                        if players[i].location = '' then addmessage(players[i].netname+'^7^n: ^5'+text) else
                        addmessage(players[i].netname+'^7^n ('+players[i].location+'^7^n): ^5'+text);
                        playsound(SND_talk,0,0);
                end;

                // record bot chat to demo
                if MATCH_DRECORD then begin
                        DData.type0 := DDEMO_CHATMESSAGE;
                        DData.gametic := gametic;
                        DData.gametime := gametime;
                        DemoStream.Write( DData, Sizeof(DData));
                        DNETCHATMessage.DXID := players[i].DXID;
                        DNETCHATMessage.messagelenght := length(text);
                        DemoStream.Write( DNETCHATMessage, Sizeof(DNETCHATMessage));
                        StrLCopy(Buff, pchar(string(text)), length(text));
                        DemoStream.Write(buff, length(text));
                        end;

                // send over multiplayer
                if ismultip=1 then begin
                        chatP := @buf;
                        if teamchat then addbyte(chatP, MMP_CHATTEAMMESSAGE) else
                        addbyte(chatP, MMP_CHATMESSAGE);
                        addword(chatP, players[i].dxid);
                        AddString(chatP,text);
                        msgsize := length(text)+4;
                        mainform.BNETSendData2All (buf, MsgSize, 1);
                        end;
                break;
        end;
end;
// ----------------------------------------------------
procedure BD_Init;
begin
        DLL_RegisterProc1(BD_SetAngle);
        DLL_RegisterProc2(BD_AddMessage, 1);
        DLL_RegisterProc2(BD_RegisterConsoleCommand, 2);
        DLL_RegisterProc3(BD_GetSystemVariable, 1);
        DLL_RegisterProc4(BD_AddPlayer, 1);
        DLL_RegisterProc5(BD_SetKeys,1);
//        DLL_RegisterProc5(BD_SetAngle,2);
        DLL_RegisterProc5(BD_SetWeapon,3);
        DLL_RegisterProc5(BD_SetBalloon,4);
        DLL_RegisterProc6(BD_Test_Blocked, 1);
        DLL_RegisterProc7(BD_FontTextOut,1);
        DLL_RegisterProc7(BD_FontTextOutC,2);
        DLL_RegisterProc8(BD_GetBrickStructure);
        DLL_RegisterProc9(BD_GetObjectStructure);
        DLL_RegisterProc10(BD_GetSpecialObjectStructure);
        DLL_RegisterProc11(BD_RemoveBot);
        DLL_RegisterProc12(BD_SendChat);
end;
// ------------------------------------
// ----------------------------------------------------
function IsTCP(IP:String):boolean;
begin
//        result := true;
        result := pos('.', IP) = 0;
end;

function GetLocalIP : string;
var
 WSAData : TWSAData;
  p : PHostEnt;
  Name : array [0..$FF] of Char;
begin
  WSAStartup($0101, WSAData);
  GetHostName(name, $FF);
  p := GetHostByName(Name);
  result := inet_ntoa(PInAddr(p.h_addr_list^)^);
  WSACleanup;
end;

procedure BNET_NFK_SEND(TransType:Integer; Var Data; Size:Integer;DestIP:ShortString;DestPort:Integer);
var i : byte;
    tmp : TSimpleTCPClient;
    found : boolean;
begin
        // New network.
        if istcp(DestIP) then begin
                addmessage('wrong data trying to be sended to: '+DestIP);
        end;

//        if not IsTCP(DestIP) then begin
        Network_AddToQueue(Data, Size, DestIP, DestPort);
        exit;
//        end;

        exit;
         if IsTCP(DestIP) then begin
                // server side sending.
                if ismultip=1 then begin

                        if not TCPSERV.Listen then begin
                                addmessage('^1TCPSERV: can''t send, server not listening ('+DestIP+':'+inttostr(DestPort));
                                ErrorSound;
                                exit;
                                end;

                        if TCPSERV.Connections.Count = 0 then exit;

                        found := false;
                        for i := 0 to TCPSERV.Connections.Count-1 do begin
                                tmp := TCPSERV.Connections[i];
                                if tmp.Socket = strtoint(DestIP) then begin
                                        found := true;
                                        break;
                                        end;
                        end;

                        if not found then begin
                                addmessage('^1TCPSERV: null client');
                                ErrorSound;
                                exit;
                                end;

                        TCPSERV.SendEx(tmp, Data, Size);

                // client side sending
                end else if ismultip=2 then begin
                        if not TCPClient.Connected then begin
                                addmessage('^1TCPCLIENT: can''t send, client not connected');
                                ErrorSound;
                                exit;
                                end;

                        TCPClient.SendEx (Data, Size);
                end;
        end else begin// overwise, using UDP.

                BNET1.SendData(TransType, Data, Size, DestIP, DestPort);
//                addmessage('^6UDPdemon--: send to :'+DestIP+':'+inttostr(DestPort));
        end;

end;

// NFK050 NETWORK
procedure TMainForm.BNETSend_SV_Data2All_Except(ExceptIP: ShortString; Var Data; Size, Flags:Word);
var i : byte;
begin
        if OPT_NETGUARANTEED = false then Flags := 0;

        if (ismultip = 1) and (SpectatorList.Count > 0) then
        for i := 0 to SpectatorList.Count-1 do
                BNET_NFK_SEND(Flags, Data, Size, TSpectator(SpectatorList.items[i]^).IP, TSpectator(SpectatorList.items[i]^).Port);

        for i := 0 to high(players) do if players[i] <> nil then
        if (players[i].IPAddress <> '127.0.0.1') and (players[i].IPAddress <> ExceptIP) then
        if players[i].netobject = true then
                BNET_NFK_SEND(Flags, Data, Size, players[i].IPAddress, players[i].Port);
end;


procedure TMainForm.BNETSendData2All(Var Data; Size, Flags:Word);
var i : byte;
    sended_to_host : boolean;
    p : byte;
begin
        if OPT_NETGUARANTEED = false then Flags := 0;

        if ismultip=2 then begin
                move(data,p,1);
                ADDMESSAGE('^1ERROR: Client sending mass message: '+ inttostr(p)+'. REPORT PLEASE.');
                end;

        sended_to_host := false;

        if (ismultip=1) and (SpectatorList.Count > 0) then
        for i := 0 to SpectatorList.Count-1 do
                BNET_NFK_SEND(Flags, Data, Size, TSpectator(SpectatorList.items[i]^).IP, TSpectator(SpectatorList.items[i]^).Port);

        for i := 0 to high(players) do if players[i] <> nil then
        if players[i].IPAddress <> '127.0.0.1' then
                if players[i].netobject = true then begin
                        if players[i].IPAddress = BNET_GAMEIP then sended_to_host := true;
                        BNET_NFK_SEND(Flags, Data, Size, players[i].IPAddress, players[i].Port);
                       end;

        if ismultip=2 then
        if not sended_to_host then
                BNET_NFK_SEND(Flags, Data, Size, BNET_GAMEIP, BNET_SERVERPORT);
end;

procedure TMainForm.BNETSendData2IP_(Host: ShortString; Port: Word;  Var Data; Size, Flags:Word);
begin
        if OPT_NETGUARANTEED = false then Flags := 0;
        if Host <> '127.0.0.1' then
                BNET_NFK_SEND(Flags, Data, Size, Host, Port);
        // Flags. 0-ttNormal, 1-ttGuaranteed.
end;

{procedure TMainForm.BNETSendData2IP(Host: ShortString; Var Data; Size, Flags:Word);
begin
        if OPT_NETGUARANTEED = false then Flags := 0;
        if Host <> '127.0.0.1' then
                BNET_NFK_SEND(Flags, Data, Size, Host, BNET_GAMEPORT);
        // Flags. 0-ttNormal, 1-ttGuaranteed.
end;
}
procedure TMainForm.BNETSendData2Player(PlayerID: byte ; Var Data; Size, Flags:Word);
begin
        if ismultip<> 1 then exit;
        BNET_NFK_SEND(Flags, Data, Size, players[PlayerID].IPAddress, players[PlayerID].Port);
end;

procedure TMainForm.BNETSendData2PlayerEx(Player: TPlayer ; Var Data; Size, Flags:Word);
begin
        if ismultip<> 1 then exit;
        if player.netobject = false then exit; // server cant send 2 server.
        if OPT_NETGUARANTEED = false then Flags := 0;
        BNET_NFK_SEND(Flags, Data, Size, Player.IPAddress, Player.Port);
end;

procedure TMainForm.BNETSendData2HOST(var Data; Size, Flags:Word);
begin
        if OPT_NETGUARANTEED = false then Flags := 0;
        BNET_NFK_SEND(Flags, Data, Size, BNET_GAMEIP, BNET_SERVERPORT);
end;

function checkclipplayer(sender : TMonoSprite) : boolean;
var i : integer;
    vclip :byte;
begin
with sender as TMonoSprite do begin
        for i := 0 to 7 do begin        //scan playerz;
                if players[i] <> nil then begin

                        if players[i].crouch then vclip := 8 else vclip := 24;

                        if (x > players[i].x -12) and (x < players[i].x + 12) and (y > players[i].y -vclip) and (y < players[i].y + 22) and (players[i].dead = 0) and (sender.spawner <> players[i]) then begin result := true; exit; end;
                end;
        end;
end;
result := false;
end;

function GetNumberOfPlayers:byte;
var i : byte;
begin
        result := 0;
        for i := 0 to 7 do if players[i] <> nil then inc(result);
end;

function GetNumberOfBots:byte;
var i : byte;
begin
        result := 0;
        for i := 0 to 7 do if players[i] <> nil then if players[i].idd = 2 then
                inc(result);
end;

function checkclipplayer_plasma(sender : TMonoSprite) : boolean;
var i : integer;
    vclip :byte;

begin
with sender as TMonoSprite do begin
        for i := 0 to 7 do begin        //scan playerz;
                if players[i] <> nil then begin
                        if players[i].crouch then vclip := 8 else vclip := 24;

                        if (x > players[i].x -12) and (x < players[i].x + 12) and (y > players[i].y -vclip) and (y < players[i].y + 22) and (players[i].dead = 0) and (sender.spawner  <> players[i]) then
                        begin
                                ApplyDamage(players[i],DAMAGE_PLASMA, sender,0);
                                SpawnBlood (players[i]);
                                SpawnBlood (players[i]);
                                SpawnBlood (players[i]);
                                if sender.spawner.item_quad > 0 then
                                ThrowPlayer(players[i],sender,DAMAGE_PLASMA*5) else
                                ThrowPlayer(players[i],sender,DAMAGE_PLASMA*2);
                                sender.dead := 2;
                                result := true;
                                exit;
                        end;
                end;
        end;
end;
result := false;
end;

function RemoveQuotes(s:string):string;
var i : word;
begin
        result := '';
        for i := 1 to length(s) do
                if s[i] <> '"' then result := result + s[i];
end;

function StripSymbols(symbol:char; s:string):string;
var i : word;
begin
        result := '';
        for i := 1 to length(s) do
                if s[i] <> symbol then result := result + s[i];
end;

function checkclipplayer_rail_dude(sender : TMonoSprite) : boolean;
var i,xx,yy : integer;
begin
        result := false;
        with sender as TMonoSprite do
        for i := 0 to 7 do
        if players[i] <> nil then begin
                if players[i].crouch then xx := -6 else xx := -22;
                if (x > players[i].x -9) and (x < players[i].x + 9) and (y > players[i].y +xx) and (y < players[i].y + yy) and (players[i].dead = 0) and (sender.spawner <> players[i]) then
                begin
                        result := true;
                        exit;
                end;
        end;
end;


function checkclipplayer_rail(sender : TMonoSprite) : boolean;
var i,dmg,xx,yy,dist : integer;
begin
{xx := -22; }yy:= 23;
//if (OPT_RESTRICTEDRAIL) and (sender.objname = 'rail') then begin
//xx := -10; yy:= 10;
//end;

with sender as TMonoSprite do begin
        for i := 0 to 7 do begin        //scan playerz;
                if players[i] <> nil then begin

                        if players[i].crouch then xx := -6 else xx := -22;

//                        addmessage('hit '+sender.objname);
                        if (x > players[i].x -9) and (x < players[i].x + 9) and (y > players[i].y +xx) and (y < players[i].y + yy) and (players[i].dead = 0) and (sender.spawner <> players[i]) then
                        begin
                                if sender.objname = 'shotgun' then begin
                                        xx := round(abs(players[i].x - sender.cx));
                                        yy := round(abs(players[i].y - sender.cy));
                                        dist := 1+round(sqrt(xx*xx + yy*yy));
                                        dmg := DAMAGE_SHOTGUN+trunc(5000/dist);
                                        if dmg > 75 then dmg := 75;
//                                      dmg := dmg-yy*5;
//                                      addmessage ('dmg: '+inttostr(dmg));

                                        applydamage(players[i],dmg,sender,0);
                                        SpawnBlood (players[i]);
                                        SpawnBlood (players[i]);
                                        SpawnBlood (players[i]);
                                        SpawnXYBlood(players[i],x,y);
                                        if sender.spawner.item_quad > 0 then
                                        ThrowPlayer(players[i],sender,dmg*2) else
                                        ThrowPlayer(players[i],sender,dmg);
                                        result := true;
                                        exit;
                                end;
                                if sender.objname = 'machine' then begin
                                        applydamage(players[i],DAMAGE_MACHINE,sender,0);
                                        SpawnXYBlood(players[i],x,y);
//                                      SpawnBlood (players[i]);
                                        if sender.spawner.item_quad > 0 then
                                        ThrowPlayer(players[i],sender,DAMAGE_MACHINE*5) else
                                        ThrowPlayer(players[i],sender,DAMAGE_MACHINE*3);
                                        result := true;
                                        exit;
                                end;
                                if (sender.objname = 'shaft') or (sender.objname = 'shaft2') then begin
                                        if random(3) = 0 then
                                        dmg := DAMAGE_SHAFT else dmg := DAMAGE_SHAFT2;
                                        applydamage(players[i], dmg, sender,0);

                                        if random(2) = 0 then begin
                                                if random(2) = 0 then SpawnXYBlood(players[i],x-random(3)+2,y-random(3)+2)
                                                else SpawnBlood (players[i]);
                                        end;

                                        if sender.spawner.item_quad > 0 then
                                        ThrowPlayer(players[i],sender,dmg*15) else
                                        ThrowPlayer(players[i],sender,dmg*9);
                                        result := true;
                                        exit;
                                end;
                                if sender.objname = 'gauntlet' then begin
                                        sender.spawner.gantl_refire := 25;
                                        if (sender.spawner.item_haste > 0) then sender.spawner.gantl_refire := 15;

                                        playsound(SND_gauntl_a,sender.spawner.x,sender.spawner.y);
                                        applydamage(players[i],DAMAGE_GAUNTLET,sender,0);
                                        SpawnBlood (players[i]);
                                        SpawnBlood (players[i]);
                                        SpawnBlood (players[i]);
                                        SpawnBlood (players[i]);
                                        if (sender.spawner.item_quad > 0) and (sender.spawner.item_quad_time = 0) then
                                        begin
                                                playsound(SND_damage3,sender.spawner.x,sender.spawner.y);
                                                sender.spawner.item_quad_time := 50;
                                        end;
                                        if sender.spawner.item_quad > 0 then ThrowPlayer(players[i],sender,90) else
                                        ThrowPlayer(players[i],sender,60);
                                        exit;
                                end;

                             if sender.objname = 'shaft2' then exit;
                             // HIT THROUTH BODYEZ!
                             if sender.railgunhit[i] = false then begin

                                if (MATCH_GAMETYPE=GAMETYPE_RAILARENA) and (OPT_RAILARENA_INSTAGIB) then
                                        applydamage(players[i],DAMAGE_RAIL*4,sender,0) else
                                applydamage(players[i],DAMAGE_RAIL,sender,0);
                                SpawnXYBlood(players[i],x,y);
                                SpawnBlood(players[i]);
                                SpawnBlood(players[i]);
                                SpawnBlood(players[i]);
                                SpawnBlood(players[i]);
                                if sender.spawner.item_quad > 0 then
                                ThrowPlayer(players[i],sender,DAMAGE_RAIL*2) else
                                ThrowPlayer(players[i],sender,DAMAGE_RAIL);
                                //result := true;
                                sender.railgunhit [i] := true;
                                continue;
                             end;
                        end;
                end;
        end;
result := false;
end;
end;

function checkcliprail(sender : TMonoSprite) : boolean;
begin
with sender as TMonoSprite do if (bbb[ ROUND(x) div 32, ROUND(y) div 16].block = true) and (bbb[ ROUND(x) div 32, ROUND(y) div 16].image <> 37) then result := true else result := false;
end;


function checkclip(sender : TMonoSprite) : boolean;
begin
with sender as TMonoSprite do begin
if (bbb[ trunc(x-clippixel) div 32, trunc(y - clippixel) div 16].block = true) and (bbb[ trunc(x-clippixel) div 32, trunc(y - clippixel) div 16].image <> 37)  then result := true else
if (bbb[ trunc(x+clippixel) div 32, trunc(y + clippixel) div 16].block = true) and (bbb[ trunc(x+clippixel) div 32, trunc(y + clippixel) div 16].image <> 37) then result := true else
if (bbb[ trunc(x-clippixel) div 32, trunc(y + clippixel) div 16].block = true) and (bbb[ trunc(x-clippixel) div 32, trunc(y + clippixel) div 16].image <> 37) then result := true else
if (bbb[ trunc(x+clippixel) div 32, trunc(y - clippixel) div 16].block = true) and (bbb[ trunc(x+clippixel) div 32, trunc(y - clippixel) div 16].image <> 37) then result := true else
if (bbb[ trunc(x-clippixel div 2) div 32, trunc(y - clippixel div 2) div 16].block = true) and (bbb[ trunc(x-clippixel div 2) div 32, trunc(y - clippixel div 2) div 16].image <> 37) then result := true else
if (bbb[ trunc(x+clippixel div 2) div 32, trunc(y + clippixel div 2) div 16].block = true) and (bbb[ trunc(x+clippixel div 2) div 32, trunc(y + clippixel div 2) div 16].image <> 37) then result := true else
if (bbb[ trunc(x-clippixel div 2) div 32, trunc(y + clippixel div 2) div 16].block = true) and (bbb[ trunc(x-clippixel div 2) div 32, trunc(y + clippixel div 2) div 16].image <> 37) then result := true else
if (bbb[ trunc(x+clippixel div 2) div 32, trunc(y - clippixel div 2) div 16].block = true) and (bbb[ trunc(x+clippixel div 2) div 32, trunc(y - clippixel div 2) div 16].image <> 37) then result := true else
        result := false;
end;
end;

function modu(a : real) : real;   // module
begin
if a < 0 then result := a * -1
else result := a;
end;



{function BAZZ_AddSample(filename:string) : byte;
var
//  p, last: PSource;
  newchan, newsamp: Integer;
  sam: BASS_SAMPLE;
begin

    newsamp := BASS_SampleLoad(FALSE, PChar(filename), 0, 0, 1, BASS_DEVICE_3D);
    if (newsamp <> 0) then
      begin
      // Set the min/max distance to 15/1000 meters
      BASS_SampleGetInfo(newsamp, sam);
      sam.mindist := 35.0;
      sam.maxdist := 1000.0;
      BASS_SampleSetInfo(newsamp, sam);
    end;

end;
 }

procedure SpawnGibBlood(f : TMonoSprite);
//var i : integer;
begin
        exit;
{        for i := 0 to 1000 do
        if aaa[i].dead = 2 then begin
                aaa[i].cx := f.x+4-random(8);
                aaa[i].cy := f.y+4-random(8);
//                aaa[i].spawner := f;
                aaa[i].dir := 0;
                aaa[i].frame := 0;
                aaa[i].objname := 'blood';
                aaa[i].dead := 0;
                exit;
        end;}
end;

procedure SpawnBubble(f : TPlayer);
var i : word;
begin
        if OPT_R_BUBBLES=false then exit;
        if f = nil then exit;
        for i := 0 to 1000 do if aaa[i].dead = 2 then begin
                aaa[i].x := f.x;
                aaa[i].y := f.y-25;
                aaa[i].spawner := f;
                aaa[i].dir := 120+random(70);
                aaa[i].DXID := 0;
                aaa[i].frame := 0;
                aaa[i].topdraw := 0;
                aaa[i].objname := 'bubble';
                aaa[i].dead := 0;
                aaa[i].dude := false;

        if MATCH_DRECORD then begin
                DData.type0 := DDEMO_BUBBLE;
                DData.gametic := gametic;
                DData.gametime := gametime;
                DBubble.DXID := f.DXID;
                DemoStream.Write( DData, Sizeof(DData));
                DemoStream.Write( DBubble, Sizeof(DBubble));
        end;


                exit;
        end;
end;


procedure SpawnBlood(f : TPlayer);
var i : word;
begin
        if f = nil then begin
                addmessage('^1DEBUG: blood not spawned, cuz player is null');
                exit;
                end;

//        if random< 0.44 then SpawnBlood(f); // :)))) this can halt nfk :)

        for i := 0 to 1000 do
        if aaa[i].dead = 2 then begin
                aaa[i].cx := 3-random(6);
                aaa[i].cy :=random(30)-5;
                aaa[i].spawner := f;
                aaa[i].dir := 0;
                aaa[i].DXID := 0;
                aaa[i].frame := 0;
                aaa[i].fangle := random(256);
                aaa[i].topdraw := 2;
                aaa[i].objname := 'blood';
                aaa[i].dead := 0;
                aaa[i].dude := false;
                exit;
        end;
end;

procedure SpawnXYBlood(f : TPlayer; x,y:real);
var i : word;
begin
        for i := 0 to 1000 do
        if aaa[i].dead = 2 then begin
                aaa[i].cx := f.x-x;
                aaa[i].cy := f.y-y;
                aaa[i].spawner := f;
                aaa[i].dir := 0;
                aaa[i].frame := 0;
                aaa[i].topdraw := 2;
                aaa[i].fangle := random(256);
                aaa[i].DXID := 0;
                aaa[i].objname := 'blood';
                aaa[i].dead := 0;
                aaa[i].dude := false;
                exit;
        end;
end;

procedure SpawnXYNulBlood(x,y:real);
var i : word;
begin
        for i := 0 to 1000 do
        if aaa[i].dead = 2 then begin
                aaa[i].cx := x;
                aaa[i].cy := y;
                aaa[i].spawner := nil;
                aaa[i].dir := 0;
                aaa[i].fangle := random(256);
                aaa[i].topdraw := 2;
                aaa[i].frame := 0;
                aaa[i].objname := 'blood';
                aaa[i].dead := 0;
                aaa[i].DXID := 0;
                aaa[i].dude := false;
                exit;
        end;
end;

procedure SpawnShots(f : TPlayer);
var i : word;
begin
        for i := 0 to 1000 do
        if aaa[i].dead = 2 then begin
        aaa[i].cx := f.x + 4-random(8);
        aaa[i].cy := f.y + 4-random(8);
        aaa[i].dir := 0;
        aaa[i].frame := 0;
        aaa[i].topdraw := 2;
        aaa[i].objname := 'shots';
        aaa[i].dead := 0;
        aaa[i].DXID := 0;
        aaa[i].dude := false;


        // multip...


        exit;
        end;
end;

procedure SpawnCorpse(f : TPlayer);
var i : word;
begin
        for i := 0 to 1000 do
        if aaa[i].dead = 2 then begin
//        addmessage('^1DEBUG: corpse spawn');
        aaa[i].cx := OPT_CORPSETIME*50;
        aaa[i].cy := 0;
        aaa[i].x := f.x;
        aaa[i].y := f.y;
        aaa[i].inertiax := f.inertiax;
        aaa[i].inertiay := f.inertiay;
        aaa[i].dir := f.dir;
        aaa[i].frame := 0;
        aaa[i].weapon := 0;
        aaa[i].health := 40;
        aaa[i].topdraw := 0;
        aaa[i].objname := 'corpse';
        aaa[i].dead := 0;
        aaa[i].DXID := AssignUniqueDXID($FFFF);
        aaa[i].spawner := f;
        aaa[i].fallt := f.nextframe;
        aaa[i].dude := false;
        exit;
        end;
end;


procedure SpawnNetShots(x,y : smallint);
var i : integer;
begin
        for i := 0 to 1000 do
        if aaa[i].dead = 2 then begin
        aaa[i].cx := x + 4-random(8);     
        aaa[i].cy := y + 4-random(8);
        aaa[i].dir := 0;
        aaa[i].frame := 0;
        aaa[i].topdraw := 2;
        aaa[i].objname := 'shots';
        aaa[i].dead := 0;
        aaa[i].dude := false;      
        aaa[i].DXID := 0;
        exit;
        end;
end;
procedure SpawnNetShots1(x,y : smallint);      // mach
var i : integer;
begin
        for i := 0 to 1000 do
        if aaa[i].dead = 2 then begin
        aaa[i].cx := x + 4-random(8);
        aaa[i].cy := y + 4-random(8);
        aaa[i].dir := 0;
        aaa[i].frame := 0;
        aaa[i].topdraw := 2;
        aaa[i].objname := 'shots2';
        aaa[i].dead := 0;
        aaa[i].dude := false;
        aaa[i].DXID := 0;
        exit;
        end;
end;

function InScreen(x,y,bn : integer) : boolean;
begin
        if not OPT_GRAPHICS then begin result := false; exit; end;
//        if (x+gx+bn > 40) and (x+gx < 580+bn) and (y+gy+bn > 80) and (y+gy < 400+bn) then result := true else result := false;
        if (x+gx+bn > 0) and (x+gx < mainform.PowerGraph.Width+bn) and (y+gy+bn > 0) and (y+gy < mainform.PowerGraph.Height+bn) then result := true else result := false;
end;

procedure SpawnSmoke(x,y : integer);
var i : integer;
begin
        for i := 0 to 1000 do
        if aaa[i].dead = 2 then begin
        if OPT_FXSMOKE then begin
                aaa[i].x := x;//-4;
                aaa[i].y := y;//-4;
        end else begin
                aaa[i].x := x-4;
                aaa[i].y := y-4;
        end;
        aaa[i].frame := 0;
        aaa[i].topdraw := 0;
        aaa[i].objname := 'smoke';
        aaa[i].fangle := random(255);
        aaa[i].dead := 0;
        aaa[i].dude := false;
        aaa[i].DXID := 0;
        exit;
        end;
end;

procedure SpawnShots2(f : TMonoSprite);
var i : integer;
begin
        for i := 0 to 1000 do
        if aaa[i].dead = 2 then begin
        aaa[i].cx := f.x + 4-random(8);
        aaa[i].cy := f.y + 4-random(8);
        aaa[i].objname := 'shots2';
        aaa[i].dir := 0;
        aaa[i].frame := 0;
        aaa[i].topdraw := 2;
        aaa[i].dead := 0;
        aaa[i].dude := false;
        aaa[i].DXID := 0;
        exit;
        end;
end;

procedure ThrowPlayer(player : TPlayer; epicenter : TMonoSprite; dmg : integer);
var
ix : real;
iy : real;
Msg: TMP_ThrowPlayer;
MsgSize: word;
begin
if ismultip=2 then exit; // not clients.

ix := 0;
iy := 0;

{ THE NEW THROW PHYZICS
if epicenter.x - player.x > 2 then player.inertiax := player.inertiax - dmg/50;
if epicenter.x - player.x < -2 then player.inertiax := player.inertiax + dmg/50;
if epicenter.y - player.y > 2 then begin
        player.inertiay := player.inertiay - dmg/90;
        if epicenter.y - player.y < 24 then
        player.inertiay := player.inertiay - (epicenter.y - player.y)/24;
        end;
if player.y - epicenter.y > 2 then begin
        player.inertiay := player.inertiay + dmg/90;
        if player.y - epicenter.y < 24 then
        player.inertiay := player.inertiay + (player.y - epicenter.y)/24;
        end;}


{if epicenter.x < player.x then player.InertiaX := player.inertiaX + dmg/50;
if epicenter.y < player.y then player.Inertiay := player.inertiay + dmg/60;
if epicenter.x > player.x then player.InertiaX := player.inertiaX + dmg/-50;
if epicenter.y > player.y then player.Inertiay := player.inertiay + dmg/-60;
if player.inertiax > 5 then player.inertiax := 5;
if player.inertiax < -5 then player.inertiax := -5;
if player.inertiay > 5 then player.inertiay := 5;
if player.inertiay < -5 then player.inertiay := -5;
exit;}

if epicenter.x < player.x then ix := dmg/50;
if epicenter.y < player.y then iy := dmg/60;
if epicenter.x > player.x then ix := dmg/-50;
if epicenter.y > player.y then iy := dmg/-60;

if player.netobject = false then begin
        if epicenter.x < player.x then player.InertiaX := player.inertiaX + ix;
        if epicenter.y < player.y then player.Inertiay := player.inertiay + iy;
        if epicenter.x > player.x then player.InertiaX := player.inertiaX + ix;
        if epicenter.y > player.y then player.Inertiay := player.inertiay + iy;
end;

        // another network optimization...

        if (epicenter.objname = 'shaft2') and (OPT_SYNC=3) then begin
                ix := ix*2;
                iy := iy*2;
        end;

if ix > 5 then ix := 5;
if iy > 5 then iy := 5;
if ix <-5 then ix := -5;
if iy <-5 then iy := -5;

if ((epicenter.objname = 'shaft2') and (gametic mod 2=1) and (OPT_SYNC=3)) or (epicenter.objname <> 'shaft2') then
if ismultip=1 then begin
        MsgSize := SizeOf(TMP_ThrowPlayer);
        Msg.Data := MMP_THROWPLAYER;
        Msg.DXID := player.dxid;
        Msg.ix := trunc((ix + 5) * 6553.5); // decrease traffic..
        Msg.iy := trunc((iy + 5) * 6553.5);
        mainform.BNETSendData2PlayerEx (player,Msg,MsgSize,0);
end;

if player.inertiax > 5 then player.inertiax := 5;
if player.inertiax < -5 then player.inertiax := -5;
if player.inertiay > 5 then player.inertiay := 5;
if player.inertiay < -5 then player.inertiay := -5;
end;

procedure SimpleDeathMessage(f : TPlayer; attname : shortstring;type1,sui:byte);
begin
        if sui = 1 then addmessage(f.netname + ' ^7^nblew himself up.');
        if sui = 2 then addmessage(f.netname + ' ^7^ntripped on his own grenade.');
        if sui = DIE_LAVA then addmessage(f.netname + ' ^7^ndoes flip in lava.');
        if sui = DIE_WRONGPLACE then addmessage(f.netname + ' ^7^nwas in the wrong place.');
        if sui = DIE_INPAIN then addmessage(f.netname + ' ^7^ndied in pain.');
        if sui = DIE_WATER then addmessage(f.netname + ' ^7^nsank like a rock.');
        if sui > 0 then exit;
        if type1 = 0 then addmessage(f.netname + ' ^7^nwas pummeled by '+attname);
        if type1 = 1 then addmessage(f.netname + ' ^7^nwas machinegunned by '+attname);
        if type1 = 2 then addmessage(f.netname + ' ^7^nwas gunned down by '+attname);
        if type1 = 3 then addmessage(f.netname + ' ^7^nwas shredded by '+attname+'^7^n''s shrapnel');
        if type1 = 4 then addmessage(f.netname + ' ^7^nate '+attname+'^7^n''s rocket');
        if type1 = 5 then addmessage(f.netname + ' ^7^nwas electrocuted by '+attname);
        if type1 = 6 then addmessage(f.netname + ' ^7^nwas railed by '+attname);
        if type1 = 7 then addmessage(f.netname + ' ^7^nwas melted by '+attname+'^7^n''s plasmagun');
        if type1 = 8 then addmessage(f.netname + ' ^7^nwas blasted by '+attname+'^7^n''s bfg');
end;

procedure DeathMessage(f : TPlayer ; att : TMonoSprite; tp : byte);
begin

//        addmessage(f.netname + ' died. killed by ' +att.spawner.netname+' .tp='+inttostr(tp));

        if (tp > 0) and (tp <= 2) then begin
                if att.weapon = 1 then addmessage(f.netname + ' ^7^ntripped on his own grenade.') else
                addmessage(f.netname + ' ^7^nblew himself up.');
                exit;
                end;

        if tp = DIE_LAVA then begin
                addmessage(f.netname + ' ^7^ndoes flip in lava.');
                exit;
                end;
        if tp = DIE_WRONGPLACE then begin
                addmessage(f.netname + ' ^7^nwas in the wrong place.');
                exit;
                end;

        if tp = DIE_INPAIN then begin
                addmessage(f.netname + ' ^7^ndied in pain.');
                exit;
                end;

        if tp = DIE_WATER then begin
                addmessage(f.netname + ' ^7^nsank like a rock.');
                exit;
                end;

        if att.objname = 'gauntlet'     then addmessage(f.netname +' ^7^nwas pummeled by '+att.spawner.netname);
        if att.objname = 'machine'      then addmessage(f.netname +' ^7^nwas machinegunned by '+att.spawner.netname);
        if att.objname = 'shotgun'      then addmessage(f.netname +' ^7^nwas gunned down by '+att.spawner.netname);
        if (att.objname= 'rocket') and (att.weapon = 0) then addmessage(f.netname +' ^7^nate '+att.spawner.netname+'^7^n''s rocket');
        if (att.objname= 'rocket') and (att.weapon = 1) then addmessage(f.netname +' ^7^nwas shredded by '+att.spawner.netname+'^7^n''s shrapnel');
        if (att.objname= 'rocket') and (att.weapon = 2) then addmessage(f.netname +' ^7^nwas blasted by '+att.spawner.netname+'^7^n''s bfg');
        if (att.objname = 'shaft') or (att.objname = 'shaft2') then addmessage(f.netname+' ^7^nwas electrocuted by '+att.spawner.netname);
        if att.objname = 'rail'         then addmessage(f.netname+' ^7^nwas railed by '+att.spawner.netname);
        if att.objname = 'plasma'       then addmessage(f.netname+' ^7^nwas melted by '+att.spawner.netname+'^7^n''s plasmagun');
end;

procedure DemoEnd(type1 : byte);
var i : byte;
begin
        if MATCH_DRECORD then begin // demo_stats version 3!
                for i := 0 to 7 do if players[i] <> nil then begin
                DData.type0 := DDEMO_STATS3;
                DData.gametic := gametic;
                DData.gametime := gametime;
                DStats3.DXID := players[i].dxid;
                DStats3.stat_kills := players[i].stats.stat_kills;
                DStats3.stat_suicide := players[i].stats.stat_suicide;
                DStats3.stat_deaths := players[i].stats.stat_deaths;
                DStats3.frags := players[i].frags;
                DStats3.stat_dmggiven := players[i].stats.stat_dmggiven;
                DStats3.stat_dmgrecvd := players[i].stats.stat_dmgrecvd;
                DStats3.gaun_hits := players[i].stats.gaun_hits;
                DStats3.mach_hits := players[i].stats.mach_hits;
                DStats3.shot_hits := players[i].stats.shot_hits;
                DStats3.gren_hits := players[i].stats.gren_hits;
                DStats3.rocket_hits := players[i].stats.rocket_hits;
                DStats3.shaft_hits := players[i].stats.shaft_hits;
                DStats3.plasma_hits := players[i].stats.plasma_hits;
                DStats3.rail_hits := players[i].stats.rail_hits;
                DStats3.bfg_hits := players[i].stats.bfg_hits;
                DStats3.mach_fire := players[i].stats.mach_fire;
                DStats3.shot_fire := players[i].stats.shot_fire;
                DStats3.gren_fire := players[i].stats.gren_fire;
                DStats3.rocket_fire := players[i].stats.rocket_fire;
                DStats3.shaft_fire := players[i].stats.shaft_fire;
                DStats3.plasma_fire := players[i].stats.plasma_fire;
                DStats3.rail_fire := players[i].stats.rail_fire;
                DStats3.bfg_fire := players[i].stats.bfg_fire;
                DStats3.bonus_impressive := players[i].stats.stat_impressives;
                DStats3.bonus_excellent := players[i].stats.stat_excellents;
                DStats3.bonus_humiliation := players[i].stats.stat_humiliations;
                DemoStream.Write( DData, Sizeof(DData));
                DemoStream.Write( DStats3, Sizeof(DStats3));
                end;

                DData.type0 := DDEMO_GAMEEND;               //
                DData.gametic := gametic;
                DData.gametime := gametime;
                DGameEnd.endtype := type1;
                DemoStream.Write( DData, Sizeof(DData));
                DemoStream.Write( DGameEnd, Sizeof(DGameEnd));

                DemoStream.position := 0;
                DemoStreamBZ.position := 0;
                PowerArcCompress(DemoStream, DemoStreamBZ, 0,'default',DemoStreamProgressEvent);
                DemoStreamBZ.position := 0;
                DemoStreamBZ.SaveToFile(demofilename);

                DemoStreamBZ.Clear;
                DemoStream.Clear;

                addmessage('Record is stopped.');
                MATCH_DRECORD := false;
        end;
end;

procedure SV_UpdateTeamScore(IP:ShortString;Port:word);
var
        Msg4: TMP_CTF_GameStateScore;
        Msg5: TMP_DOM_ScoreChanges;
        msgsize: word;

begin
        // update ctf score.
        if MATCH_GAMETYPE=GAMETYPE_CTF then begin
                MsgSize        := SizeOf(TMP_CTF_GameStateScore);
                Msg4.Data      := MMP_CTF_GAMESTATESCORE;
                Msg4.RedScore  := MATCH_REDTEAMSCORE;
                Msg4.BlueScore := MATCH_BLUETEAMSCORE;
                Mainform.BNETSendData2IP_ (IP,Port,Msg4, MsgSize, 1);
        end;

        // update dom score
        if MATCH_GAMETYPE=GAMETYPE_DOMINATION then begin
                MsgSize := SizeOf(TMP_DOM_ScoreChanges);
                Msg5.Data := MMP_DOM_SCORECHANGED;
                Msg5.RedScore := MATCH_REDTEAMSCORE div 3;
                Msg5.BlueScore := MATCH_BLUETEAMSCORE div 3;
                Mainform.BNETSendData2IP_(IP,Port,Msg5,MsgSize,1);
        end;
end;

procedure GameEnd(type1 : byte);
var     Msg:  TMP_SV_MatchStart;
        Msg2: TMP_Stats3;
        Msg3: TMP_TimeUpdate;
        Msg4: TMP_CTF_GameStateScore;
        Msg5: TMP_DOM_ScoreChanges;
        msgsize: word;
        i : word;
        s : string;
begin
        MATCH_GAMEEND := true;
        if type1<>END_JUSTEND then playsound(SND_gameend,0,0);
        OPT_SHOWSTATS := true;
        SYS_P1STATSX := 640;
        SYS_P2STATSX := 0;

        // send data : gameend;
        if ismultip=1 then begin

                // update ctf score.
                if type1 = END_CAPTURELIMIT then
                if MATCH_GAMETYPE=GAMETYPE_CTF then begin
                        MsgSize        := SizeOf(TMP_CTF_GameStateScore);
                        Msg4.Data      := MMP_CTF_GAMESTATESCORE;
                        Msg4.RedScore  := MATCH_REDTEAMSCORE;
                        Msg4.BlueScore := MATCH_BLUETEAMSCORE;
                        Mainform.BNETSendData2All (Msg4, MsgSize, 1);
                end;

                //MMP_DOM_SCORECHANGED
                if type1=END_DOMLIMIT then
                if MATCH_GAMETYPE=GAMETYPE_DOMINATION then begin
                        MsgSize := SizeOf(TMP_DOM_ScoreChanges);
                        Msg5.Data := MMP_DOM_SCORECHANGED;
                        Msg5.RedScore := MATCH_REDTEAMSCORE div 3;
                        Msg5.BlueScore := MATCH_BLUETEAMSCORE div 3;
                        Mainform.BNETSendData2All (Msg5,MsgSize,1);
                end;

                // send the final time.
                MsgSize := SizeOf(TMP_TimeUpdate);
                Msg3.Data := MMP_TIMEUPDATE;
                Msg3.WARMUP := false;
                Msg3.Min := GAMETIME;
                mainform.BNETSendData2All(Msg3, MsgSize, 1);

                for i := 0 to 7 do if players[i]<>nil then begin
                        // send the stats.
                        MsgSize := SizeOf(TMP_Stats3);
                        Msg2.Data := MMP_STATS;
                        Msg2.DXID := players[i].DXID;
                        Msg2.stat_kills := players[i].stats.stat_kills;
                        Msg2.stat_suicide := players[i].stats.stat_suicide;
                        Msg2.stat_deaths  := players[i].stats.stat_deaths ;
                        Msg2.stat_dmggiven := players[i].stats.stat_dmggiven;
                        Msg2.frags := players[i].frags;
                        Msg2.stat_dmgrecvd := players[i].stats.stat_dmgrecvd;
                        Msg2.bonus_impressive := players[i].stats.stat_impressives;
                        Msg2.bonus_excellent := players[i].stats.stat_excellents;
                        Msg2.bonus_humiliation := players[i].stats.stat_humiliations;
                        Msg2.gaun_hits := players[i].stats.gaun_hits;
                        Msg2.mach_hits := players[i].stats.mach_hits;
                        Msg2.shot_hits := players[i].stats.shot_hits;
                        Msg2.gren_hits := players[i].stats.gren_hits;
                        Msg2.rocket_hits := players[i].stats.rocket_hits;
                        Msg2.shaft_hits := players[i].stats.shaft_hits;
                        Msg2.plasma_hits := players[i].stats.plasma_hits;
                        Msg2.rail_hits := players[i].stats.rail_hits;
                        Msg2.bfg_hits := players[i].stats.bfg_hits;
                        Msg2.mach_fire := players[i].stats.mach_fire;
                        Msg2.shot_fire := players[i].stats.shot_fire;
                        Msg2.gren_fire := players[i].stats.gren_fire;
                        Msg2.rocket_fire := players[i].stats.rocket_fire;
                        Msg2.shaft_fire := players[i].stats.shaft_fire;
                        Msg2.plasma_fire := players[i].stats.plasma_fire;
                        Msg2.rail_fire := players[i].stats.rail_fire;
                        Msg2.bfg_fire := players[i].stats.bfg_fire;
                        mainform.BNETSendData2All(Msg2, MsgSize,1);
                end;

                if ismultip=1 then begin
                        MsgSize := SizeOf(TMP_SV_MatchStart);
                        Msg.DATA := MMP_MATCHSTART;
                        Msg.gameend := TRUE;
                        Msg.gameendid := type1;
                        mainform.BNETSendData2All(Msg, MsgSize,1);
                end;

        end;

        if ismultip=2 then case type1 of
                END_SUDDEN : addmessage('^3Sudden death hit.');
                END_FRAGLIMIT : addmessage('^3Fraglimit hit.');
                END_TIMELIMIT : addmessage('^3Timelimit hit.');
                END_CAPTURELIMIT : addmessage('^3Capturelimit hit.');
                END_DOMLIMIT : addmessage('^3Domlimit hit.');
        end;

        for i := 0 to 7 do if players[i] <> nil then
                players[i].shaft_state := 0;

        addmessage(' ');
        if type1 <> END_JUSTEND then
                for i := 0 to 7 do if players[i]<>nil then begin
                        addmessage('Stats for^7: '+players[i].netname);

                        if players[i].stats.gaun_hits > 0 then addmessage('^3Gauntlet:   ^7'+inttostr(players[i].stats.gaun_hits));

                        if mapweapondata.machine = true then begin
                        s := '^3Machinegun:   ^7' + inttostr(players[i].stats.mach_hits)+'/'+inttostr(players[i].stats.mach_fire)+ '     ^5';
                        if players[i].stats.mach_fire > 0 then s:= s + inttostr(round((players[i].stats.mach_hits * 100) / players[i].stats.mach_fire))+'%' else s := s + '0%';
                        addmessage(s);
                        end;

                        if mapweapondata.shotgun = true then begin
                        s := '^3Shotgun:   ^7' + inttostr(players[i].stats.shot_hits)+'/'+inttostr(players[i].stats.shot_fire)+ '     ^5';
                        if players[i].stats.shot_fire > 0 then s:= s + inttostr(round((players[i].stats.shot_hits * 100) / players[i].stats.shot_fire))+'%' else s := s + '0%';
                        addmessage(s);
                        end;

                        if mapweapondata.grenade  = true then begin
                        s := '^3Grenade L:   ^7' + inttostr(players[i].stats.gren_hits)+'/'+inttostr(players[i].stats.gren_fire)+ '     ^5';
                        if players[i].stats.gren_fire > 0 then s:= s + inttostr(round((players[i].stats.gren_hits * 100) / players[i].stats.gren_fire))+'%' else s := s + '0%';
                        addmessage(s);
                        end;

                        if mapweapondata.rocket = true then begin
                        s := '^3Rocket L:   ^7' + inttostr(players[i].stats.rocket_hits )+'/'+inttostr(players[i].stats.rocket_fire)+ '     ^5';
                        if players[i].stats.rocket_fire > 0 then s:= s + inttostr(round((players[i].stats.rocket_hits * 100) / players[i].stats.rocket_fire))+'%' else s := s + '0%';
                        addmessage(s);
                        end;

                        if mapweapondata.shaft = true then begin
                        s := '^3Shaft:   ^7' + inttostr(players[i].stats.shaft_hits  )+'/'+inttostr(players[i].stats.shaft_fire)+ '     ^5';
                        if players[i].stats.shaft_fire > 0 then s:= s + inttostr(round((players[i].stats.shaft_hits * 100) / players[i].stats.shaft_fire))+'%' else s := s + '0%';
                        addmessage(s);
                        end;

                        if mapweapondata.rail = true then begin
                        s := '^3Railgun:   ^7' + inttostr(players[i].stats.rail_hits)+'/'+inttostr(players[i].stats.rail_fire)+ '     ^5';
                        if players[i].stats.rail_fire > 0 then s:= s + inttostr(round((players[i].stats.rail_hits * 100) / players[i].stats.rail_fire))+'%' else s := s + '0%';
                        addmessage(s);
                        end;

                        if mapweapondata.plasma = true then begin
                        s := '^3Plasma gun:   ^7' + inttostr(players[i].stats.plasma_hits)+'/'+inttostr(players[i].stats.plasma_fire )+ '     ^5';
                        if players[i].stats.plasma_fire > 0 then s:= s + inttostr(round((players[i].stats.plasma_hits * 100) / players[i].stats.plasma_fire))+'%' else s := s + '0%';
                        addmessage(s);
                        end;

                        if mapweapondata.bfg = true then begin
                        s := '^3BFG:   ^7' + inttostr(players[i].stats.bfg_hits)+'/'+inttostr(players[i].stats.bfg_fire)+ '     ^5';
                        if players[i].stats.bfg_fire > 0 then s:= s + inttostr(round((players[i].stats.bfg_hits * 100) / players[i].stats.bfg_fire))+'%' else s := s + '0%';
                        addmessage(s);
                        end;

                        addmessage('^7Dmggiven: ^2'+inttostr(players[i].stats.stat_dmggiven));
                        addmessage('^7Dmgrecvd: ^1'+inttostr(players[i].stats.stat_dmgrecvd));
                        addmessage('^7Kills: ^5'+inttostr(players[i].stats.stat_kills)+'     ^7Deaths: ^5'+inttostr(players[i].stats.stat_deaths)+'     ^7Suicides: ^5'+inttostr(players[i].stats.stat_suicide)+'     ^7Frags: ^5'+inttostr(players[i].frags));
                        addmessage(' ');
        end;

        if (ismultip = 1) and (OPT_SV_DEDICATED) then
                dedicated_gameend_time := gettickcount;

        if TeamGame then begin
                Addmessage('^1RED ^7score: '+inttostr(GetRedTeamScore)+'      ^4BLUE ^7score:  '+inttostr(GetBlueTeamScore));
                if MATCH_GAMETYPE = GAMETYPE_CTF then Addmessage('^1RED ^7captures: '+inttostr(MATCH_REDTEAMSCORE)+'      ^4BLUE ^7captures:  '+inttostr(MATCH_BLUETEAMSCORE));
                if MATCH_GAMETYPE = GAMETYPE_DOMINATION then Addmessage('^1RED ^7domscore: '+inttostr(MATCH_REDTEAMSCORE)+'      ^4BLUE ^7domscore:  '+inttostr(MATCH_BLUETEAMSCORE));
        end;

        CalculateFragBar();
        DemoEnd(type1);
end;

procedure CalculateFragBar;
var i : byte;
        biggestscore : integer;//blu team
        mybestscore : integer;

begin
        OPT_DRAWFRAGBARMYFRAG := 0;
        OPT_DRAWFRAGBAROTHERFRAG := 0;

//        addmessage('CalculateFragBar');

        // ctf status;
        if MATCH_GAMETYPE = GAMETYPE_CTF then begin
                if CTF_RedFlagAtBase then CTF_REDFLAGSTATUS := 0 { base } else begin
                CTF_REDFLAGSTATUS := 2; {// lost} for i := 0 to 7 do if players[i] <> nil then if (players[i].team = C_TEAMRED) and (players[i].flagcarrier = true) then begin
                CTF_REDFLAGSTATUS := 1; {// carried} break; end;  end;
                if CTF_BlueFlagAtBase then CTF_BLUEFLAGSTATUS := 0 { base } else begin
                CTF_BLUEFLAGSTATUS := 2; {// lost} for i := 0 to 7 do if players[i] <> nil then if (players[i].team = C_TEAMBLU) and (players[i].flagcarrier = true) then begin
                CTF_BLUEFLAGSTATUS := 1; {// carried} break; end; end;
//                Exit;
        end;



        if MATCH_GAMETYPE = GAMETYPE_DOMINATION then
                DOM_UpdateStatusBar;

        if MATCH_STARTSIN > 0 then exit;

//        if ismultip=0 then exit;
        if {(ismultip=0) and }((MATCH_DDEMOPLAY=FALSE) and (SYS_BAR2AVAILABLE=true)) then exit;

        if getnumberofplayers < 2 then exit;

        biggestscore := -9999;
        mybestscore := -999;

        // best player. not me.
        if not MATCH_DDEMOPLAY then
        for i := 0 to 7 do if players[i] <> nil then begin
                if players[i].frags >= biggestscore then
                if players[i].idd <> 0 then biggestscore := players[i].frags;

                if players[i].frags >= mybestscore then begin
                        if OPT_SV_DEDICATED then begin
                                if i = OPT_1BARTRAX then mybestscore := players[i].frags;
                        end else
                        if players[i].idd = 0 then mybestscore := players[i].frags;
                end;
        end;

        if MATCH_DDEMOPLAY then begin // demo..
                if players[OPT_1BARTRAX] <> nil then //handl error
                mybestscore := players[OPT_1BARTRAX].frags
                else mybestscore := -9999;

                for i := 0 to 7 do if players[i] <> nil then begin
                        if players[i].frags >= biggestscore then
                        if i <> OPT_1BARTRAX then biggestscore := players[i].frags;
                end;
        end;

        if TeamGame then begin

                if (MATCH_GAMETYPE = GAMETYPE_CTF) then begin
                        biggestscore := MATCH_REDTEAMSCORE;
                        mybestscore := MATCH_BLUETEAMSCORE;
                end else if (MATCH_GAMETYPE = GAMETYPE_DOMINATION) then begin
                        if ismultip=1 then begin  // nasty hack... emulate frags = frags + 0.33 :)
                                biggestscore := MATCH_REDTEAMSCORE div 3;
                                mybestscore := MATCH_BLUETEAMSCORE div 3;
                        end else begin
                                biggestscore := MATCH_REDTEAMSCORE;
                                mybestscore := MATCH_BLUETEAMSCORE;
                        end;
                end else begin // by sum teammate frags.}
                        biggestscore := 0;
                        mybestscore := 0;
                        for i := 0 to 7 do if players[i] <> nil then begin
                                if players[i].team = 0 then mybestscore := mybestscore + players[i].frags;
                                if players[i].team = 1 then biggestscore := biggestscore + players[i].frags;
                        end;
                end;
        end;

        for i := 0 to 7 do if players[i] <> nil then begin
                if match_ddemoplay=false then
                if players[i].idd=0 then break
                else if players[i].dxid = players[OPT_1BARTRAX].dxid then break;
        end;


        if OPT_ANNOUNCER then
        if (mybestscore=biggestscore) or (OPT_DRAWFRAGBARMYFRAG <> mybestscore) or (OPT_DRAWFRAGBAROTHERFRAG <> biggestscore)  then begin

              // ---------------------------------------------------------
              // teamplay announser...
              if TeamGame then begin

                if SYS_ANNOUNCER<>1 then // blu lead sound.
                if mybestscore > biggestscore then begin
                        if (abs(mybestscore-biggestscore)>=2) or (MATCH_GAMETYPE <> GAMETYPE_DOMINATION) then begin
                        if SYS_ANNOUNCER>0 then playsound(SND_blueleads,0,0);
                        SYS_ANNOUNCER := 1;
                        end;
                end;

                if SYS_ANNOUNCER<>2 then// red lead sound.
                if mybestscore < biggestscore then begin
                        if (abs(mybestscore-biggestscore)>=2) or (MATCH_GAMETYPE <> GAMETYPE_DOMINATION) then begin
                        if SYS_ANNOUNCER>0 then playsound(SND_redleads,0,0);
                        SYS_ANNOUNCER := 2;
                        end;
                end;

                if SYS_ANNOUNCER<>3 then// tied team.
                if mybestscore = biggestscore then begin
                        if SYS_ANNOUNCER>0 then playsound(SND_teamstied,0,0);
                        SYS_ANNOUNCER := 3;
                end;

              end else begin // standart...
              // ---------------------------------------------------------

                if SYS_ANNOUNCER<>1 then // get lead sound.
                if mybestscore > biggestscore then begin
                        if SYS_ANNOUNCER>0 then playsound(SND_takenlead,0,0);
                        SYS_ANNOUNCER := 1;
                end;

                if SYS_ANNOUNCER<>2 then// lost lead sound.
                if mybestscore < biggestscore then begin
                        if SYS_ANNOUNCER>0 then playsound(SND_lostlead,0,0);
                        SYS_ANNOUNCER := 2;
                end;

                if SYS_ANNOUNCER<>3 then// tied lead sound.
                if mybestscore = biggestscore then begin
                        if SYS_ANNOUNCER>0 then playsound(SND_tiedlead,0,0);
                        SYS_ANNOUNCER := 3;
                end;
              end;
        end;

        OPT_DRAWFRAGBARMYFRAG := mybestscore;
        OPT_DRAWFRAGBAROTHERFRAG := biggestscore;
end;


function IsMapTied:boolean;
var i : byte;
        biggestscore : integer;
        littlebiggestscore : integer;
begin

        // INSERT HERE DOM AND CTF TIED RULES.

        if MATCH_STARTSIN > 0 then begin
                result := false; exit end;

        if (MATCH_GAMETYPE = GAMETYPE_TEAM) then begin
                if  GetRedTeamScore = GetBlueTeamScore then result := true else result := false;
                exit;
        end;

        biggestscore := -9999;
        littlebiggestscore := -10000;

        for i := 0 to 7 do if players[i] <> nil then begin
                if players[i].frags >= biggestscore then begin
                        littlebiggestscore := biggestscore;
                        biggestscore := players[i].frags;
                end;
        end;
        if biggestscore = littlebiggestscore then result := true else result := false;
end;


procedure PAINSOUNDZZ(F : TPlayer);
var d : byte;
begin
with f as TPlayer do begin


if ((f.health > GIB_DEATH) or (OPT_MEATLEVEL=0))  and (f.health <= 0) then begin
        d := random(3);
        if d = 0 then playsound(f.SND_death1,f.x,f.y);
        if d = 1 then playsound(f.SND_death2,f.x,f.y);
        if d = 2 then playsound(f.SND_death3,f.x,f.y);
        end else
if f.paintime = 0 then begin

if IsWaterContentHEAD(F) then SpawnBubble(f);

if f.health >= 76 then playsound(f.SND_pain100,f.x,f.y) else
if f.health >= 51 then playsound(f.SND_Pain75,f.x,f.y) else
if f.health >= 26 then playsound(f.SND_Pain50,f.x,f.y) else
if f.health >= 1 then playsound(f.SND_Pain25,f.x,f.y);
f.paintime := 25;
end;


end;
end;

function GetLocationsCount:byte;
var i : byte;
begin
     result := 0; for i := 1 to 50 do if LocationsArray[i].enabled then inc(result);
end;

function GetPlayerLocation(ID:byte):string;
var MINDIST,Dist:word;
    Selected, I:byte;
begin
        if players[ID] = nil then exit;

        Selected := 0;
        MINDIST := $FFFF;
        for i:=1 to 50 do if LocationsArray[i].enabled then begin
                Dist := round(sqrt(sqr(LocationsArray[i].x*32 - players[ID].x)+sqr(LocationsArray[i].y*16 - players[ID].y)));
                if dist < MINDIST then begin
                        MINDIST := DIST; SELECTED := I;
                end;
        end;
        if selected = 0 then result := '' else
        result := LocationsARRAY[SELECTED].Text;
end;

procedure ApplyDamage(f : TPlayer; dmg : integer; att : TMonoSprite; tp : byte);
var save : integer;
  Msg: TMP_DamagePlayer;
  Msg2: TMP_EarnReward;
  MsgSize: word;
  FlagCarrierKilled:boolean;
  cando, cansenddamagepacket:boolean;
  d : byte;

begin
if (GODMODE = TRUE) and (f.idd<>2) THEN exit;
if MATCH_DDEMOPLAY then exit;
if MATCH_GAMEEND then exit;
if f.health < 0 then exit;
if ismultip=2 then exit;

if tp = 0 then begin
        if att.weapon = 1 then if att.objname= 'rocket' then if dmg > DAMAGE_GRENADE then dmg := DAMAGE_GRENADE;       // grenade not more than DAMAGE_GRENADE;
        if att.spawner= f then if att.objname= 'rocket' then dmg := dmg div 2;   // damage self.
        if att.spawner.item_quad > 0 then dmg := dmg * 3;
        if f.item_battle > 0 then begin
                dmg := dmg div 2;
                if f.item_battle_time = 0 then begin
                        playsound(SND_protect3,f.x,f.y);
                        f.item_battle_time := 50;
                        end;
                end;
        end;

        if tp = 0 then
        if TeamGame then
        if (att.spawner.team = f.team) and (OPT_TEAMDAMAGE = false) and (tp=0) and (att.spawner <> f) then dmg := 0;;

if BD_Avail then
if tp=0 then DLL_DMGReceived(f.DXID, att.spawner.DXID, dmg) else
             DLL_DMGReceived(f.DXID, 0, dmg);

save := round(dmg*0.67);
if f.armor - save < 0 then begin save := save - f.armor; f.armor := 0; end else begin f.armor := f.armor - save; save := 0; end;
f.health := round(f.health - save - (dmg*0.33));

FlagCarrierKilled := f.flagcarrier;
if f.health <= 0 then begin
        WPN_DropWeapon(F); // weapon drop
        for d:= 0 to 5 do POWERUP_Drop(f);
        CTF_DropFlag(F);   // CTF
      end;


// Hit sound.
if (OPT_HITSND = true) and (tp = 0) then if att.spawner <> nil then if att.spawner <> f then if att.spawner.hitsnd = 0 then begin
                cando := false;
                if players[OPT_1BARTRAX] <> nil then if att.spawner.dxid = players[OPT_1BARTRAX].DXID then if cando=false then cando := true;
                if players[OPT_2BARTRAX] <> nil then if (att.spawner.dxid = players[OPT_2BARTRAX].DXID) and (SYS_BAR2AVAILABLE) then if cando=false then cando := true;

                if (TeamGame) and (att.spawner.team = f.team) then cando := false;
                if cando then begin
                        playsound(SND_hit,att.spawner.x,att.spawner.y);
                        att.spawner.hitsnd := 5;
                end;
        end;


// stats
if MATCH_STARTSIN = 0 then begin
 if tp = 0 then begin    /// stats

        if not ((TeamGame) and (att.spawner.team = f.team)) then // exclude teamplay
        begin
                if att.objname = 'gauntlet' then inc(att.spawner.stats.gaun_hits);
                if att.objname = 'machine' then inc(att.spawner.stats.mach_hits);
                if att.objname = 'shotgun' then inc(att.spawner.stats.shot_hits);
        end;

        if att.spawner = f then begin
                if att.spawner.health < 0 then begin
                att.spawner.stats.stat_dmgrecvd := att.spawner.stats.stat_dmgrecvd + att.spawner.health;
                inc(att.spawner.stats.stat_suicide);
                end;
                att.spawner.stats.stat_dmgrecvd := att.spawner.stats.stat_dmgrecvd + dmg;
        end else
        begin

                if not ((TeamGame) and (att.spawner.team = f.team)) then // exclude teamplay
                begin
                        if f.health <= 0 then inc(att.spawner.stats.stat_kills);
                        if (att.objname = 'rocket') and (att.weapon = 1) then inc(att.spawner.stats.gren_hits);
                        if (att.objname = 'rocket') and (att.weapon = 0) then inc(att.spawner.stats.rocket_hits);
                        if (att.objname = 'rocket') and (att.weapon = 2) then inc(att.spawner.stats.bfg_hits);
                end;
        end;

        if not ((TeamGame) and (att.spawner.team = f.team)) then // exclude teamplay
        begin
                if (att.objname = 'shaft') or (att.objname = 'shaft2') then inc(att.spawner.stats.shaft_hits);
                if att.objname = 'rail'   then inc(att.spawner.stats.rail_hits);
                if att.objname = 'plasma' then inc(att.spawner.stats.plasma_hits);
        end;

        if f <> att.spawner then begin
                f.stats.stat_dmgrecvd := f.stats.stat_dmgrecvd + dmg;

                if not ((TeamGame) and (att.spawner.team = f.team)) then // exclude teamplay
                        att.spawner.stats.stat_dmggiven := att.spawner.stats.stat_dmggiven + dmg;
        end;

        if f.health <= 0 then begin
                f.stats.stat_dmgrecvd := f.stats.stat_dmgrecvd + f.health;

                if not ((TeamGame) and (att.spawner.team = f.team)) then // exclude teamplay
                        if f <> att.spawner then att.spawner.stats.stat_dmggiven := att.spawner.stats.stat_dmggiven + f.health;

                inc(f.stats.stat_deaths);
                end;

//        if (f.health <= 0) and (att.spawner.weapon = 1) then inc(att.spawner.stats.mach_kills);
 end;
end;

        // impressive calculate.
        if tp = 0 then
        if not ((TeamGame) and (att.spawner.team = f.team)) then // exclude teamplay
        if att.objname = 'rail' then begin
                if (att.spawner.impressive < 2) then inc(att.spawner.impressive) else begin
                        att.spawner.impressive := 0;
                        att.spawner.rewardtype := 1;
//                        if (att.spawner.rewardtime = 0) and (att.spawner.rewardtype=1) then
                        if (att.spawner.rewardtime <= 199) then
                        playsound(SND_impressive,att.spawner.x,att.spawner.y);      // no double sound.
                        att.spawner.rewardtime := 200;

                        // multiprayer.
                        if ismultip = 1 then begin
                                MsgSize := SizeOf(TMP_EarnReward);
                                Msg2.Data := MMP_EARNREWARD;
                                Msg2.DXID := att.spawner.dxid;
                                Msg2.type0 := 1;
                                mainform.BNETSendData2All(Msg2, MsgSize, 0);
                        end;

                        if MATCH_DRECORD then begin              // record to demo !!!!!
                                DData.type0 := DDEMO_EARNREWARD;               //
                                DData.gametic := gametic;
                                DData.gametime := gametime;
                                DemoStream.Write( DData, Sizeof(DData));
                                DEarnReward.DXID := att.spawner.dxid;
                                DEarnReward.type1 := 1;
                                DemoStream.Write( DEarnReward, Sizeof(DEarnReward));
                        end;
                        IF MATCH_STARTSIN = 0 THEN inc(att.spawner.stats.stat_impressives);
                end;
        end;


//        if random(2)=0 then
        if MATCH_DRECORD then begin              // record to demo !!!!!
                DData.type0 := DDEMO_DAMAGEPLAYER;               //
                DData.gametic := gametic;
                DData.gametime := gametime;
                DemoStream.Write( DData, Sizeof(DData));
                DDamagePlayer.DXID := f.DXID;
                DDamagePlayer.ext := 0;
                DDamagePlayer.health := f.health;
                DDamagePlayer.armor := f.armor;

                if (att.spawner <> f) and (tp = 0) then DDamagePlayer.ATTDXID := att.spawner.DXID;
                if (att.spawner = f) and (tp = 0) then DDamagePlayer.ATTDXID := f.DXID;
                if (tp > 0) then begin
                                DDamagePlayer.ATTDXID := f.DXID;
                                DDamagePlayer.ext := tp;
                        end;

                if (att.spawner=f) and (tp=0) then begin
                        if (att.objname = 'rocket') and (att.weapon = 1) then DDamagePlayer.ext := 2;
                        if (att.objname = 'rocket') and (att.weapon = 0) then DDamagePlayer.ext := 1;
                        if (att.objname = 'rocket') and (att.weapon = 2) then DDamagePlayer.ext := 1;
                end;
                if (att.objname = 'gauntlet') then DDamagePlayer.attwpn := 0;
                if (att.objname = 'machine') then DDamagePlayer.attwpn := 1;
                if (att.objname = 'shotgun') then DDamagePlayer.attwpn := 2;
                if (att.objname = 'rocket') and (att.weapon = 1) then DDamagePlayer.attwpn := 3;
                if (att.objname = 'rocket') and (att.weapon = 0) then DDamagePlayer.attwpn := 4;
                if (att.objname = 'shaft') or (att.objname = 'shaft2') then DDamagePlayer.attwpn := 5;
                if (att.objname = 'rail') then DDamagePlayer.attwpn := 6;
                if (att.objname = 'plasma') then DDamagePlayer.attwpn := 7;
                if (att.objname = 'rocket') and (att.weapon = 2) then DDamagePlayer.attwpn := 8;
                DemoStream.Write( DDamagePlayer, Sizeof(DDamagePlayer));
        end;

        PAINSOUNDZZ (f);

        // multiprayer.
        cansenddamagepacket := true;

        if (att.objname = 'shaft2') and (f.health>=1) and (gametic mod 3 = 1) and (OPT_SYNC=3) then cansenddamagepacket := false;
        if (att.objname = 'machine') and (f.health>=1) and (gametic mod 2 = 1) and (OPT_SYNC=3) then cansenddamagepacket := false;

        if cansenddamagepacket then
        if ismultip = 1 then begin
                MsgSize := SizeOf(TMP_DamagePlayer);
                Msg.Data := MMP_DAMAGEPLAYER;
                Msg.dmgtype := 0; // unknown...
                if att.objname = 'machine' then Msg.dmgtype := 1;
                if att.objname = 'shotgun' then Msg.dmgtype := 2;
                if (att.objname = 'rocket') and (att.weapon = 1) then Msg.dmgtype := 3;
                if (att.objname = 'rocket') and (att.weapon = 0) then Msg.dmgtype := 4;
                if (att.objname = 'shaft') or (att.objname = 'shaft2') then Msg.dmgtype := 5;
                if (att.objname = 'rail') then Msg.dmgtype := 6;
                if (att.objname = 'plasma') then Msg.dmgtype := 7;
                if (att.objname = 'rocket') and (att.weapon = 2) then Msg.dmgtype := 8;

                Msg.x := att.x;
                Msg.y := att.y;
                Msg.DXID := f.dxid;
                if tp=0 then Msg.AttackerDXID := att.spawner.DXID else Msg.AttackerDXID := 0;

                Msg.health := f.health;
                Msg.armor := f.armor;
                Msg.exp := tp;

                if f=att.spawner then begin
                        if (att.objname = 'rocket') and (att.weapon = 1) then Msg.exp := 2;
                        if (att.objname = 'rocket') and (att.weapon = 0) then Msg.exp := 1;
                        if (att.objname = 'rocket') and (att.weapon = 2) then Msg.exp := 1;
                end;

                f.LArmor := f.armor; /// do not update on next restart.
                f.LHealth := f.health;
                mainform.BNETSendData2All(Msg, MsgSize, 1);
        end;

{       if (mainform.dxplay.opened = true) and (mainform.dxplay.ishost = true) then begin end;
}

if f.health <= 0 then begin
        if f.health > GIB_DEATH then begin
                        if MATCH_DRECORD then begin
                                DData.type0 := DDEMO_CORPSESPAWN;
                                DData.gametic := gametic;
                                DData.gametime := gametime;
                                DemoStream.Write( DData, Sizeof(DData));
                                DCorpseSpawn.DXID := f.dxid;
                                DemoStream.Write( DCorpseSpawn, Sizeof(DCorpseSpawn));
                        end;

                  IF OPT_CORPSETIME > 0 then SpawnCorpse(f);
          end;

        if IsWaterContentHEAD(F) then begin
                SpawnBubble(f);
                SpawnBubble(f);
                SpawnBubble(f);
        end;

        f.rewardtime := 0;
        if (tp >= DIE_LAVA) and (tp <= DIE_WATER) then begin   // killed by map.
                if MATCH_STARTSIN = 0 then begin
                        dec(f.frags);
                        inc(f.stats.stat_suicide);
                        inc(f.stats.stat_deaths);
                end;
                if tp = DIE_LAVA then deathmessage(f, aaa[0], DIE_LAVA);
                if tp = DIE_WRONGPLACE then deathmessage(f, aaa[0], DIE_WRONGPLACE);
                if tp = DIE_INPAIN then deathmessage(f, aaa[0], DIE_INPAIN);
                if tp = DIE_WATER then deathmessage(f, aaa[0], DIE_WATER);


                if not TeamGame then
                if (MATCH_DDEMOPLAY=false) and (MATCH_SUDDEN=true) and (IsMapTied=false) then begin
                        addmessage('sudden death hit.');
                        GameEnd(END_SUDDEN);
                        end;
                exit;
        end;

        if f = att.spawner then begin
                if MATCH_STARTSIN = 0 then dec(f.frags);
                deathmessage(f, att, 1);

                if not TeamGame then
                if (MATCH_DDEMOPLAY=false) and(MATCH_SUDDEN=true)and(IsMapTied=false) then begin
                        GameEnd(END_SUDDEN);
                        addmessage('sudden death hit.');
                        end;
                end

        else begin

                if MATCH_STARTSIN = 0 then begin
                        // teammate kill
                        if TeamGame then if (att.spawner.team = f.team) then dec(att.spawner.frags,2);
                        inc(att.spawner.frags);

                        // what you get for fragging enemy flag carrier
                        if (MATCH_GAMETYPE = GAMETYPE_CTF) and (att.spawner.team <> f.team) and (FlagCarrierKilled) then
                                inc(att.spawner.frags, CTF_FRAG_CARRIER_BONUS);
                end;

//                addmessage(f.netname+' killed by '+att.spawner.netname);
                deathmessage(f, att, 0);

                // humiliation calculate
                if not ((TeamGame) and (att.spawner.team = f.team)) then // exclude teamplay
                if (att.objname = 'gauntlet') and (f <> att.spawner) then begin
                        att.spawner.rewardtype := 3;
                        if (att.spawner.rewardtime <= 175) then
                        playsound(SND_humiliation,att.spawner.x,att.spawner.y);
                        att.spawner.rewardtime := 200;

                        // multiprayer.
                        if ismultip = 1 then begin
                                MsgSize := SizeOf(TMP_EarnReward);
                                Msg2.Data := MMP_EARNREWARD;
                                Msg2.DXID := att.spawner.dxid;
                                Msg2.type0 := 3;
                                mainform.BNETSendData2All(Msg2, MsgSize, 0);
                        end;

                        if MATCH_DRECORD then begin              // record to demo !!!!!
                                DData.type0 := DDEMO_EARNREWARD;               //
                                DData.gametic := gametic;
                                DData.gametime := gametime;
                                DemoStream.Write( DData, Sizeof(DData));
                                DEarnReward.DXID := att.spawner.dxid;
                                DEarnReward.type1 := 3;
                                DemoStream.Write( DEarnReward, Sizeof(DEarnReward));
                        end;
                        inc(att.spawner.stats.stat_humiliations);
                end;

                // excellent calculate
                if not ((TeamGame) and (att.spawner.team = f.team)) then // exclude teamplay
                if (att.spawner.excellent > 0) then begin
                        att.spawner.rewardtype := 2;
                        if (att.spawner.rewardtime <= 175) then
                        playsound(SND_excellent,att.spawner.x,att.spawner.y);
                        att.spawner.rewardtime := 200;

                        // multiprayer.
                        if ismultip = 1 then begin
                                MsgSize := SizeOf(TMP_EarnReward);
                                    Msg2.Data := MMP_EARNREWARD;
                                    Msg2.DXID := att.spawner.dxid;
                                    Msg2.type0 := 2;
                                    mainform.BNETSendData2All(Msg2, MsgSize, 0);
                        end;

                        if MATCH_DRECORD then begin              // record to demo !!!!!
                                DData.type0 := DDEMO_EARNREWARD;               //
                                DData.gametic := gametic;
                                DData.gametime := gametime;
                                DemoStream.Write( DData, Sizeof(DData));
                                DEarnReward.DXID := att.spawner.dxid;
                                DEarnReward.type1 := 2;
                                DemoStream.Write( DEarnReward, Sizeof(DEarnReward));
                        end;
                        inc(att.spawner.stats.stat_excellents);
                end;

                att.spawner.excellent := 250;


                if MATCH_GAMETYPE <> GAMETYPE_DOMINATION then
                if (MATCH_DDEMOPLAY=false) and (IsMapTied=false) then begin
                        if (att.spawner.frags >= MATCH_FRAGLIMIT) and (MATCH_FRAGLIMIT > 0) then
                        begin
                                //play
                                GameEnd(END_FRAGLIMIT);
                                addmessage('fraglimit hit.');
                        end;

                        if MATCH_SUDDEN = true then begin
                                GameEnd(END_SUDDEN);
                                addmessage('sudden death hit.');
                        end;
                end;

        end;
    end;
end;


function Get2Ddist(x1,y1, x2, y2 : single): word; begin result := round(sqrt(sqr(x2 - x1)+sqr(y2 - y1))); end;

procedure PopupGIBZ (epi : TMOnosprite;dist,dmg : real);
var i,a : word;
   rra{,dmgg} : real;  // disttoplayer
   xx,yy :real;
begin
for i := 0 to 1000 do if aaa[i].dead =0 then if (aaA[I].OBJNAME = 'gib') and (aaa[i].frame>=50) or (aaA[I].OBJNAME = 'corpse') then begin
        // corpse gib.
        if (aaA[I].OBJNAME = 'corpse') then begin
                if Get2Ddist(epi.x, epi.y, aaa[i].x, aaa[i].y+12) > 48 then continue;
                if aaa[i].cx > OPT_CORPSETIME*50-10 then continue;
                aaa[I].health := round(aaa[I].health - dmg);
                if aaa[I].health <= 0 then begin
                        ThrowXYGib( aaa[I].x+3-random(6), aaa[I].y+12, 1);
                        ThrowXYGib( aaa[I].x+3-random(6), aaa[I].y+12, 1);
                        ThrowXYGib( aaa[I].x+3-random(6), aaa[I].y+12, 1);
                        for a := 0 to 6 do
                                ParticleEngine.AddParticle(trunc(aaa[I].x)+10-random(20),trunc(aaa[I].y)+23-random(12), (Random(6) - 3)/5, (Random(6) -3) / 5,true);

                        aaa[I].dead := 2;
                end;
                continue;
        end;

        xx := abs(aaa[i].x - epi.x); yy := abs(aaa[i].y - epi.y);
        rra := sqrt(xx*xx + yy*yy);
//        addmessage('POPUP!');
        if (rra < dist) then begin
        if epi.x < aaA[I].x then aaA[I].InertiaX := aaA[I].inertiaX + dmg/50;
        if epi.y < aaA[I].y then aaA[I].Inertiay := aaA[I].inertiay + dmg/60;
        if epi.x > aaA[I].x then aaA[I].InertiaX := aaA[I].inertiaX + dmg/-50;
        if epi.y > aaA[I].y then aaA[I].Inertiay := aaA[I].inertiay + dmg/-60;
        if aaA[I].inertiax > 5 then  aaA[I].inertiax := 5;
        if aaA[I].inertiax < -5 then aaA[I].inertiax := -5;
        if aaA[I].inertiay > 5 then  aaA[I].inertiay := 5;
        if aaA[I].inertiay < -5 then aaA[I].inertiay := -5;
        end;
end;
end;

procedure SplashDamage(epi : TMOnosprite; x,y,dist,dmg : real);
var i : byte;
   rra,dmgg : real;  // disttoplayer
   xx,yy :real;
begin
//dist := trunc(sqrt(dmg/pi)); // the radiuz

PopupGIbz(epi,dist,dmg);

for i := 0 to 7 do begin
        if (players[i] <> nil) then
        if (players[i].health > 0) then begin

//                addmessage('expl radius:'+inttostr(trunc(dist)));

                xx := abs(players[i].x - x); yy := abs(players[i].y - y);
                rra := sqrt(xx*xx + yy*yy);
//                addmessage('expl radius:'+inttostr(trunc(dist))+'. dist to player:'+inttostr(trunc(rra)));
                if (rra < dist) and (players[i].dead = 0) then
                begin
                        dmgg := dist*dmg/rra;
                        dmgg := dmgg / 3.5;
                        if dmgg > dmg then dmgg := dmg;
                        applydamage(players[i],trunc(dmgg),epi,0);
                        SpawnBlood(players[i]);
                        SpawnBlood(players[i]);
                        SpawnBlood(players[i]);
                        SpawnBlood(players[i]);

                        // figure momentum add.
                        if epi.spawner.item_quad > 0 then
                        ThrowPlayer(players[i], epi, round(dmg*2)) else

                        ThrowPlayer(players[i], epi, round(dmg));
//                        addmessage('damage: '+inttostr(trunc(dmgg)));
                end;
        end;
end;
end;


{procedure VectorShaftNet(sender : TMonoSprite);
begin
 with sender as TMonoSprite do begin
        // fuck da nil
 end;
end;
 }
procedure VectorTraceVectorTrace(sender : TMonoSprite);
var ox,oy : real;
    sh : integer;
    Msg: TMP_ShotParticle;
    msg2: TMP_ShaftStreem;
    MsgSize: word;
    cancontinue : boolean;
    angle : smallint;
    i:word;
begin

        // once time function call.

with sender as TMonoSprite do begin

        if (sender.objname = 'shaft') and (sender.dude=true) then
        for i := 0 to 1000 do if (aaa[i].dead = 0) and (aaa[i].objname = 'shaft') and (aaa[i].spawner = sender.spawner) and (aaa[i] <> sender) then begin
                sender.dead := 2;
                exit;
        end;

        ox := x;
        oy := y;
        cx := x;
        cy := y;

{        if dude then begin
                x :=trunc(spawner.x);
                if spawner.crouch then y := trunc(spawner.y+3) else y := trunc(spawner.y-5);
                cx := trunc(spawner.x);
                if spawner.crouch then cy := trunc(spawner.y+3) else cy := trunc(spawner.y-5);
        end;}
//      addmessage('drawshaft '+inttostr(gametic));

        sh := 0;

{       if sender.objname = 'shaft' then begin
                inc(sender.spawner.shaftframe);
                inc(sender.spawner.shaftsttime,2);
                if sender.spawner.shaftsttime >= 22 then begin
                        playsound('lg_hum.wav',sender.spawner.x);
                        sender.spawner.shaftsttime := 2;
                end;
        end;
 }
//      if sender.dead = 2 then addmessage('^3 VectorTraceVectorTrace DEAD!');

        cancontinue := true;

        while (cancontinue) do begin
                angle := round(fangle-90);
                if angle < 0 then angle := 360+angle;
                x := x + CosTable[angle];
                y := y + SinTable[angle];
                {if sender.dude = false then }
                ClipButton(round(x),round(y));
                ClipDoorTrigger(round(x),round(y));

                if sender.objname = 'rail' then begin
                        if clippixel > 0 then dec(clippixel);
                        if clippixel = 1 then begin
                                ox := x;
                                oy := y;
                        end;
                end;

                if sender.objname = 'gauntlet' then begin
                        inc(sh);
                        if sh >= 20 then cancontinue := false;
                        if (checkclipplayer_rail(sender) = true) then cancontinue := false;
                        if sender.spawner.gantl_refire > 0 then exit;
                end;

                if (sender.objname = 'shaft') or (sender.objname = 'shaft2') then begin
                        inc(sh);
                        if (sender.spawner.item_haste > 0) then if sh >= SHAFT_DIST+25 then cancontinue:=false;
                        if (sender.spawner.item_haste = 0) then if sh >= SHAFT_DIST then cancontinue:=false;

                        if sender.doublejump >= 16 then sender.doublejump := 0; // cycle

                        mainform.PowerGraph.Antialias := true;

                        if sender.doublejump = 0 then mainform.PowerGraph.RotateEffect(mainform.Images[29],trunc(x)+GX, trunc(y)+GY,trunc(256/360*fangle),273,$FFDDDDDD,sender.spawner.shaftframe, effectAdd);
                        if (not MATCH_DDEMOPLAY) and (not ismultip =2) then inc(sender.fallt);

                        if (sender.doublejump) mod 4 = 0 then if OPT_FXSHAFT then begin
                                if SYS_STARWARS then
                                mainform.powergraph.RotateEffect(mainform.images[54],round(x)+gx,round(y)+gy,0,128,$88FFFF00,0,effectsrcalphaadd or $100)
                                else
                                mainform.powergraph.RotateEffect(mainform.images[54],round(x)+gx,round(y)+gy,0,64,$42FFFF00,0,effectsrcalphaadd or $100);

                        end;

                        mainform.powergraph.Antialias := false;

                        inc (sender.doublejump);
                end;

{               if (MATCH_DDEMOPLAY=false) and (sender.dude=true) and (sender.objname = 'shaft2') then begin
                        if (checkclipplayer_rail_dude(sender)) then cancontinue := false;
                        if (sh >= sender.fallt) then  cancontinue := false;

                end; }

                if (MATCH_DDEMOPLAY=true) then begin
                        if (CheckClipRail(sender) = true) then cancontinue := false;
                        if (checkclipplayer_rail_dude(sender)) then cancontinue := false;
                        IF DDEMO_VERSION<=4 then if (sh >= sender.fallt) then  cancontinue := false;
                end;

                if (MATCH_DDEMOPLAY=false)  then begin
                        if (CheckClipRail(sender) = true) then cancontinue := false;
                        if (sender.dude=false) then begin
                                if (checkclipplayer_rail(sender) = true) then cancontinue := false;
                                end else if (checkclipplayer_rail_dude(sender)) then cancontinue := false;
                        end;


        end;

        if (sender.objname = 'shaft') and (ismultip=1) then
        if sender.weapon = 0 then begin
                        MsgSize := SizeOf(TMP_ShaftStreem);
                          Msg2.DATA := MMP_SHAFTSTREEM;
  //                        Msg2.x := sender.cx;
//                          Msg2.y := sender.cy;
                          Msg2.Lenght := sh;
                          Msg2.angle := round(sender.fangle);
                          Msg2.DXID := sender.spawner.dxid;
                          sender.weapon := 1;
                          mainform.BNETSendData2All(Msg2, MsgSize, 0);
        end;


        if (sender.objname = 'shaft') and (MATCH_DRECORD) then
        if sender.dude = false then
        begin
                DData.type0 := 10;
                DData.gametic := gametic;
                DData.gametime := gametime;
                DVectorMissile.x :=round(cx);
                DVectorMissile.y := round(cy);
                DVectorMissile.inertiax := 0;
                DVectorMissile.inertiay := 0;
                DVectorMissile.DXID := 0;
                DVectorMissile.spawnerDxid := spawner.DXID;//spawner.DXID;
                DVectorMissile.dir := sh;
                DVectorMissile.angle := fangle;
                DemoStream.Write( DData, Sizeof(DData));
                DemoStream.Write( DVectorMissile, Sizeof(DVectorMissile));
        end;
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        if sender.objname = 'shotgun' then begin
                SpawnNetShots(round(sender.x),round(sender.y));
                SpawnNetShots(round(sender.x),round(sender.y));
                if MATCH_DRECORD then begin
                        DData.type0 := 11;
                        DData.gametic := gametic;
                        DData.gametime := gametime;
                        DVectorMissile.x :=round(x);
                        DVectorMissile.y := round(y);
                        DVectorMissile.inertiax := 0;
                        DVectorMissile.inertiay := 0;
                        DVectorMissile.DXID := 0;
                        DVectorMissile.spawnerDxid := spawner.DXID;//spawner.DXID;
                        DVectorMissile.dir := 0;
                        DVectorMissile.angle := 0;
                        DemoStream.Write( DData, Sizeof(DData));
                        DemoStream.Write( DVectorMissile, Sizeof(DVectorMissile));
                end;

                if ismultip=1 then begin
                        MsgSize := SizeOf(TMP_ShotParticle);
                            Msg.Data := MMP_SHOTPARTILE;
                            Msg.x := round(x);
                            Msg.y := round(y);
                            Msg.x1 := round(sender.spawner.x);
                            Msg.y1 := round(sender.spawner.y);
                            Msg.index := 2;     // 1=mach|2=shot
                            mainform.BNETSendData2All(Msg, MsgSize, 0);
                end;
        end else
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        if sender.objname = 'machine' then begin
                SpawnShots2(sender);
                if MATCH_DRECORD then begin
                        DData.type0 := 12;
                        DData.gametic := gametic;
                        DData.gametime := gametime;
                        DVectorMissile.x :=round(x);
                        DVectorMissile.y := round(y);
                        DVectorMissile.inertiax := 0;
                        DVectorMissile.inertiay := 0;
                        DVectorMissile.DXID := 0;
                        DVectorMissile.spawnerDxid := spawner.DXID;//spawner.DXID;
                        DVectorMissile.dir := 0;
                        DVectorMissile.angle := 0;
                        DemoStream.Write( DData, Sizeof(DData));
                        DemoStream.Write( DVectorMissile, Sizeof(DVectorMissile));
                end;


                if ismultip=1 then begin
                        MsgSize := SizeOf(TMP_ShotParticle);
                            Msg.Data := MMP_SHOTPARTILE;
                            Msg.x := round(x);
                            Msg.y := round(y);
                            Msg.x1 := round(sender.spawner.x);
                            Msg.y1 := round(sender.spawner.y);
                            Msg.index := 1;     // 1=mach|2=shot
                            mainform.BNETSendData2All(Msg, MsgSize, 0);
                end;
        end;

        cx := x; // target x;
        cy := y;
        x := ox;
        y := oy;

        if (sender.objname = 'shaft') or (sender.objname = 'shaft2') then sender.fallt := sh;

        end;
end;

Procedure DrawSineLineEx(A, wd, x1, y1, x2, y2: single; CLR: Cardinal);
Var
  Spacing, newx, newy, oldx, oldy: single;
  t, d, k, i, X, Y, alf, q, s, c: single;
  g       : Integer;


  Function sine(X: single): single;
  Begin
    Result := A * Sin(wd*X);
  End;

  Function Dist(x1, y1, x2, y2: Single): Single;
  Var
    fDiffX, fDiffY: Real;
  Begin
    fDiffX := x2 - x1;
    fDiffY := y2 - y1;
    Result := Sqrt((fDiffX * fDiffX) + (fDiffY * fDiffY));
  End;

Begin

  x1 := round(x1);
  x2 := round(x2);
  y1 := round(y1);
  y2 := round(y2);

  If (x1 = x2) And (y1 = y2) Then exit;

{  if (y1>y2) then begin
    oldx := x2;
    oldy := y2;
    x2 := x1;
    y2 := y1;
    x1 := oldx;
    y1 := oldy;
  end;
 }
  if (x1>x2) then begin
    oldx := x2;
    oldy := y2;
    x2 := x1;
    y2 := y1;
    x1 := oldx;
    y1 := oldy;
  end;

  d := Dist(x1, y1, x2, y2);
  If y2 = y1 Then
    alf := 0
  Else If x2 = x1 Then
    If y2 > y1 Then
      alf := -1.568
    Else
      alf := 1.568
  Else
    alf := arctan2((y2 - y1), (x2 - x1));
  q := alf;
  i := x1;
{  If x1 >= x2 Then
    k := -Spacing
  Else
    k := Spacing;}
  t := 0;
  g := 0;
  oldx := x1;
  oldy := y1;
  While t <= d Do
  Begin
    X := i;
    Y := y1 + sine(t);
    s := (Y - y1) / (A + 0.0001);
    If abs(s) >= 0.6 Then //       
      Spacing := 0.6 * abs(s) * 5 //  ,      
    Else //   ()   
      Spacing := (abs(s) + 1) * 1; //  ,      

    If x1 >= x2 Then
      k := -Spacing
    Else
      k := Spacing;
    s := Sin(q);
    c := cos(q);
    newx := x1 + (X - x1) * c - (y1 - Y) * s;
    newy := y1 + (X - x1) * s + (y1 - Y) * c;

    if (oldx >0) and (oldy > 0) and (newx > 0) and (newy > 0) then
    if (oldx <640) and (oldy < 480) and (newx <640) and (newy < 480) then
    If (oldx <> newx) Or (oldy <> newy) Then
    MainForm.PowerGraph.Line(round(oldx),round(oldy),round(newx),round(newy),CLR,effectSrcAlpha or EffectDiffuseAlpha);

    oldx := newx;
    oldy := newy;
    i := i + k;
    t := t + Spacing;
    Inc(g);
    If g >= 1100 Then break; // line limiter
  End;

End;

procedure RailPostTrace(sender : TMonoSprite);
var clr, alpha : cardinal;

begin

with sender as TMonoSprite do begin
                CLR:= ACOLOR[fallt];
                if OPT_RAILPROGRESSIVEALPHA then
                alpha := $FF + $01 - (trunc($FF/OPT_RAILTRAILTIME))*frame else
                alpha := $FF - 15*frame;

                case OPT_R_RAILSTYLE of
                0 : begin // standart rail, just line
                        if OPT_RAILSMOOTH then
                        mainform.PowerGraph.SmoothLine(trunc(cx)+GX,trunc(cy)+GY,trunc(x)+GX,trunc(y)+GY,(alpha shl 24)+clr) else
                        mainform.PowerGraph.Line(trunc(cx)+GX,trunc(cy)+GY,trunc(x)+GX,trunc(y)+GY,(alpha shl 24)+clr,effectSrcAlpha);
                end;
                // sine
                1 : DrawSineLineEx(2, 0.2, trunc(cx)+GX, trunc(cy)+GY, trunc(x)+GX, trunc(y)+GY, (alpha shl 24)+clr);
                // sine
                2 : begin
                        DrawSineLineEx(2.5, 0.2, trunc(cx)+GX, trunc(cy)+GY, trunc(x)+GX, trunc(y)+GY, (alpha shl 24)+clr);
                        if OPT_RAILSMOOTH then
                        mainform.PowerGraph.SmoothLine(trunc(cx)+GX,trunc(cy)+GY,trunc(x)+GX,trunc(y)+GY,(alpha shl 24)+clr) else
                        mainform.PowerGraph.Line(trunc(cx)+GX,trunc(cy)+GY,trunc(x)+GX,trunc(y)+GY,(alpha shl 24)+clr,effectSrcAlpha);
                        end;
               3 : DrawSineLineEx(3,3, trunc(cx)+GX, trunc(cy)+GY, trunc(x)+GX, trunc(y)+GY, (alpha shl 24)+clr);
               4 : begin
                        DrawSineLineEx(3, 3, trunc(cx)+GX, trunc(cy)+GY, trunc(x)+GX, trunc(y)+GY, (alpha shl 24)+clr);
                        if OPT_RAILSMOOTH then
                        mainform.PowerGraph.SmoothLine(trunc(cx)+GX,trunc(cy)+GY,trunc(x)+GX,trunc(y)+GY,(alpha shl 24)+clr) else
                        mainform.PowerGraph.Line(trunc(cx)+GX,trunc(cy)+GY,trunc(x)+GX,trunc(y)+GY,(alpha shl 24)+clr,effectSrcAlpha);
                        end;

                end;
//                DrawSineLine(round(3), 3, trunc(cx)+GX, trunc(cy)+GY, trunc(x)+GX, trunc(y)+GY, (alpha shl 24)+clr);

    end;
end;

function BrickOnHead_gren(sender:TMonoSprite) : boolean;
begin
with sender as TMonoSprite do begin
if (bbb[ trunc(x-clippixel) div 32, trunc(y-clippixel) div 16].block = true) and
   (bbb[ trunc(x-clippixel) div 32, trunc(y+clippixel) div 16].block = false) then begin result := true; exit; end;
if (bbb[ trunc(x+clippixel) div 32, trunc(y-clippixel) div 16].block = true) and
   (bbb[ trunc(x+clippixel) div 32, trunc(y+clippixel) div 16].block = false) then begin result := true; exit; end;
if (bbb[ trunc(x-clippixel) div 32, trunc(y-clippixel) div 16].block = true) and
   (bbb[ trunc(x-clippixel) div 32, trunc(y+clippixel) div 16].block = false) then begin result := true; exit; end;
if (bbb[ trunc(x+clippixel) div 32, trunc(y-clippixel) div 16].block = true) and
   (bbb[ trunc(x+clippixel) div 32, trunc(y+clippixel) div 16].block = false) then begin result := true; exit; end;
   result := false;
end;
end;

function OnBrick_gren(sender:TMonoSprite) : boolean;
begin
with sender as TMonoSprite do begin
if (bbb[ trunc(x-clippixel) div 32, trunc(y) div 16].block = false) and (bbb[ trunc(x-clippixel) div 32, trunc(y) div 16].image<>37) and
   (bbb[ trunc(x-clippixel) div 32, trunc(y+clippixel) div 16].block = true) and (bbb[ trunc(x-clippixel) div 32, trunc(y+clippixel) div 16].image <> 37) then begin result := true; exit; end;
if (bbb[ trunc(x+clippixel) div 32, trunc(y) div 16].block = false) and (bbb[ trunc(x+clippixel) div 32, trunc(y) div 16].image <> 37) and
   (bbb[ trunc(x+clippixel) div 32, trunc(y+clippixel) div 16].block = true) and (bbb[ trunc(x+clippixel) div 32, trunc(y+clippixel) div 16].image <> 37) then begin result := true; exit; end;
if   (bbb[ trunc(x) div 32, trunc(y) div 16].block = true) and (bbb[ trunc(x) div 32, trunc(y) div 16].image <> 37) then begin result := true; exit; end;
   result := false;
end;
end;

function OnBrick_flag(sender:TMonoSprite) : boolean;
begin
with sender as TMonoSprite do begin
if (bbb[ trunc(x-4) div 32, trunc(y) div 16].block = false) and (bbb[ trunc(x-4) div 32, trunc(y) div 16].image<>37) and
   (bbb[ trunc(x-4) div 32, trunc(y+4) div 16].block = true) and (bbb[ trunc(x-4) div 32, trunc(y+4) div 16].image <> 37) then begin result := true; exit; end;
if (bbb[ trunc(x+4) div 32, trunc(y) div 16].block = false) and (bbb[ trunc(x+4) div 32, trunc(y) div 16].image <> 37) and
   (bbb[ trunc(x+4) div 32, trunc(y+4) div 16].block = true) and (bbb[ trunc(x+4) div 32, trunc(y+4) div 16].image <> 37) then begin result := true; exit; end;
if   (bbb[ trunc(x) div 32, trunc(y) div 16].block = true) and (bbb[ trunc(x) div 32, trunc(y) div 16].image <> 37) then begin result := true; exit; end;
   result := false;
end;
end;

procedure GrenadeBounce (sender : TMonoSprite);
begin
if sender.objname <> 'grenade' then exit;       // for gib.
if (sender.health > 12) and (sender.inertiay <> 0) then begin
playsound(SND_bounce,sender.x,sender.y);
sender.health := 0;
end;
end;

procedure GrenadePhysics (sender : TMonoSprite);
//var defx : real;
begin
with sender as TMONOSPRITE do begin
if (inertiay = 0) and (inertiax = 0) then exit;
//  defx := x;
   if (inertiay > -0.3) and (Inertiay < 0.3) and (inertiax > -0.3) and (Inertiax < 0.3) and (bbb[ trunc(x) div 32, trunc(y+clippixel) div 16].block = true) then begin inertiax := 0; exit; end;

   InertiaY := InertiaY + (Gravity*mass);

{   if (inertiay > -1) and (inertiay < 0) then inertiay := inertiay/1.11; // progressive inertia
   if (inertiay > 0) and (inertiay < 5)  then inertiay := inertiay*1.1; // progressive inertia}

 if inertiay < 0 then
   Inertiay := Inertiay / 1.025;   // stopspeed.
   InertiaX := InertiaX / 1.003;   // stopspeed.


   x := x + inertiax;
   y := y + inertiay;

   if x < 24 then x := 24;
   if y < 12 then y := 12;

   if health < 255 then inc(health);

   // CLIPPING
    if (bbb[ trunc(x-clippixel) div 32, trunc(y) div 16].block = true) and (bbb[ trunc(x-clippixel) div 32, trunc(y) div 16].image <> 37) then begin
                if inertiax < 0 then inertiax := abs(inertiax);
                GrenadeBounce(sender);
                inertiax := inertiax / GRENADE_SLOWSPEED;
                dir := 0;
        end else
   if (bbb[ trunc(x+clippixel) div 32, trunc(y) div 16].block = true) and (bbb[ trunc(x+clippixel) div 32, trunc(y) div 16].image <> 37) then begin
                if inertiax > 0 then inertiax := -inertiax;
                GrenadeBounce(sender);
                inertiax := inertiax / GRENADE_SLOWSPEED;
                dir := 1;
        end;
   if (bbb[ trunc(x) div 32, trunc(y-clippixel) div 16].block = true) and (bbb[ trunc(x) div 32, trunc(y-clippixel) div 16].image <> 37) then begin // boom ceil
        if inertiay < 0 then inertiay := abs(inertiay);
        GrenadeBounce(sender);
        inertiax := inertiax / GRENADE_SLOWSPEED;
        end else
   if (bbb[ trunc(x) div 32, trunc(y+clippixel) div 16].block = true) and (bbb[ trunc(x) div 32, trunc(y+clippixel) div 16].image <> 37) then begin// boom floor
                if inertiay > 0 then inertiay := -inertiay;
                GrenadeBounce(sender);
                inertiax := inertiax / GRENADE_SLOWSPEED;
        end;

   if InertiaY< -5 then InertiaY := -5;
   if InertiaY> 5 then InertiaY := 5;
   if InertiaX< -7 then InertiaX := -7;
   if InertiaX> 7 then InertiaX := 7;

   if dir = 1 then
   fangle := fangle - 2 else fangle := fangle + 2;
   if fangle < 0 then fangle := 360;
   if fangle > 360 then fangle := 0;
   if (inertiax < 0.01) and (inertiax > -0.01) and (onbrick_gren(sender)) then inertiax := 0;
   if (inertiay < 0.02) and (inertiay > -0.02) and (onbrick_gren(sender)) then inertiay := 0;
end;
end;

{function VALUEEXISTS(b : integer; mode : byte) : boolean;
var e : integer;
begin
repeat
        r := b - 512;
        if r < 0 then result := false;

until

end;}

procedure AddAmmo(F : TPlayer; typ, count : byte);
begin
with F as TPlayer do begin
if typ = 1 then if ammo_mg + count > 200 then ammo_mg := 200 else ammo_mg := ammo_mg + count;
if typ = 2 then if ammo_sg + count > 100 then ammo_sg := 100 else ammo_sg := ammo_sg + count;
if typ = 3 then if ammo_gl + count > 100 then ammo_gl := 100 else ammo_gl := ammo_gl + count;
if typ = 4 then if ammo_rl + count > 100 then ammo_rl := 100 else ammo_rl := ammo_rl + count;
if typ = 5 then if ammo_sh + count > 200 then ammo_sh := 200 else ammo_sh := ammo_sh + count;
if typ = 6 then if ammo_rg + count > 100 then ammo_rg := 100 else ammo_rg := ammo_rg + count;
if typ = 7 then if ammo_pl + count > 200 then ammo_pl := 200 else ammo_pl := ammo_pl + count;
if typ = 8 then if ammo_bfg + count > 50 then ammo_bfg := 50 else ammo_bfg := ammo_bfg + count;
//addmessage(inttostr(ammo_mg));
end;
end;

procedure ClipTriggers(F : TPlayer);
var
   Msg3:TMP_SoundData;
   MsgSize:word;
    xx,yy,o : byte;
begin

if f.dead > 0 then exit;              // do not give itemz to zombiez.
if f.health <= 0 then exit;
if MATCH_DDEMOPLAY then exit;
xx := trunc(f.x) div 32;
yy := trunc(f.y+13) div 16;


{// water check.
if (ismultip=0) or ((ismultip=1) and (f.netobject=true)) then
        if IsWaterContentHEAD(f) then begin
        if f.air=0 then ApplyDamage(f,DMG_WATER,aaa[0],DIE_WATER);
        end;
 }

if (ismultip <> 1) or (f.netobject=false) then
if (bbb[xx,yy].image = 38) or (bbb[xx,yy].image = 39) then begin // jummpad

                //yy := trunc(f.y+13) div 16;
                if (f.inertiay > -3) and not (brickonhead(f)) then begin
                        playsound(SND_jumppad,f.x,f.y);

                                if ismultip>0 then begin
                                        MsgSize := SizeOf(TMP_SoundData);
                                        Msg3.Data := MMP_SENDSOUND;
                                        Msg3.DXID := f.dxid;
                                        Msg3.SoundType := 2; // jumppad code;
                                        if ismultip=1 then
                                        mainform.BNETSendData2All(Msg3, MsgSize, 0) else
                                        mainform.BNETSendData2HOST(Msg3, MsgSize, 0);
                                end;

                                if MATCH_DRECORD then begin
                                        DData.type0 := DDEMO_JUMPPADSOUND;
                                        DData.gametic := gametic;
                                        DData.gametime := gametime;
                                        DJumppadSound.x := round(f.x);
                                        DJumppadSound.y := round(f.y);
                                        DemoStream.Write( DData, Sizeof(DData));
                                        DemoStream.Write( DJumppadSound, Sizeof(DJumppadSound));
                                end;
                        end;
                if (bbb[xx,yy].image = 38) then f.InertiaY  := -4 else f.InertiaY  := -6;
        end;

if ismultip=2 then exit;

for o := 0 to 2 do begin
        case o of
        0 : yy := trunc(f.y+23) div 16;
        1 : yy := trunc(f.y-23) div 16;
        else yy := trunc(f.y) div 16;
        end;

if bbb[xx,yy].image = CONTENT_LAVA then begin
                if f.inlava > 0 then exit;
                ApplyDamage(f,12+random(6),aaa[0],DIE_LAVA);
                f.inlava := 8;

                playsound(SND_lava,f.x,f.y);
                if MATCH_DRECORD then begin
                        DData.type0 := DDEMO_LAVASOUND;
                        DData.gametic := gametic;
                        DData.gametime := gametime;
                        DLavaSound.x := round(f.x);
                        DLavaSound.y := round(f.y);
                        DemoStream.Write( DData, Sizeof(DData));
                        DemoStream.Write( DLavaSound, Sizeof(DLavaSound));
                end;
        end;
if bbb[xx,yy].image = 33 then begin     // wrong place
                ApplyDamage(f,500,aaa[0],DIE_WRONGPLACE);
                SpawnBlood (f);
                SpawnBlood (f);
                SpawnBlood (f);
                SpawnBlood (f);
                SpawnBlood (f);
                SpawnBlood (f);
        end;
end;

end;

procedure SwitchToBest (F : TPlayer);
var do_explosive : boolean;
    i,a: byte;
begin

        for i := 0  to 7 do if f = players[i] then begin a := i; break; end;
        do_explosive := false;

        if f.netobject = true then exit;
        if f.health <= 0 then exit;
        if MATCH_DDEMOPLAY then exit;
        if (f.idd = 0) and (OPT_WEAPONSWITCH_END = 0) then exit;
        if (f.idd = 1) and (OPT_P2WEAPONSWITCH_END = 0) then exit;
        if (f.idd = 0) and (OPT_WEAPONSWITCH_END = 2) then do_explosive := true;
        if (f.idd = 1) and (OPT_P2WEAPONSWITCH_END = 2) then do_explosive := true;

        if do_explosive = true then
        if (f.have_bfg) and (f.ammo_bfg > 0) then begin
                f.weapchg := 10;
                f.threadweapon := 8;
                DoWeapBar(a);
                exit;
        end;

        if (f.have_pl) and (f.ammo_pl > 0) then begin
                f.weapchg := 10;
                f.threadweapon := 7;
                DoWeapBar(a);
                exit;
        end;
        if (f.have_sh) and (f.ammo_sh > 0) then begin
                f.weapchg := 10;
                f.threadweapon := 5;
                DoWeapBar(a);
                exit;
        end;
        if (f.have_rg) and (f.ammo_rg > 0) then begin
                f.weapchg := 10;
                f.threadweapon := 6;
                DoWeapBar(a);
                exit;
        end;

        if do_explosive = true then
        if (f.have_rl) and (f.ammo_rl > 0) then begin
                f.weapchg := 10;
                f.threadweapon := 4;
                DoWeapBar(a);
                exit;
        end;

        if (f.have_sg) and (f.ammo_sg > 0) then begin
                f.weapchg := 10;
                f.threadweapon := 2;
                DoWeapBar(a);
                exit;
        end;

        if do_explosive = true then
        if (f.have_gl) and (f.ammo_gl > 0) then begin
                f.weapchg := 10;
                f.threadweapon := 3;
                DoWeapBar(a);
                exit;
        end;

        if (f.have_mg) and (f.ammo_mg > 0) then begin
                f.weapchg := 10;
                f.threadweapon := 1;
                DoWeapBar(a);
                exit;
        end;

        f.weapchg := 10; // dirty gauntlet
        f.threadweapon := 0;
        DoWeapBar(a);

end;


procedure Item_Dissapear(x,y,i : byte;f:TPLayer);
var
    msg: TMP_ItemDisappear;
    msgsize: word;

begin
        case i of
        1..7 : playsound(SND_wpkup,x*32,y*16);
        8..15 : playsound(SND_ammopkup,x*32,y*16);
        16 : playsound(SND_shard,x*32,y*16);
        17..18 : playsound(SND_armor,x*32,y*16);
        19 : playsound(SND_health5,x*32,y*16);
        20 : playsound(SND_health25,x*32,y*16);
        21 : playsound(SND_health50,x*32,y*16);
        22 : playsound(SND_health100,x*32,y*16);
        23 : playsound(SND_regeneration,x*32,y*16);
        24 : playsound(SND_holdable,x*32,y*16);
        25 : playsound(SND_haste,x*32,y*16);
        26 : playsound(SND_quaddamage,x*32,y*16);
        27 : playsound(SND_flight,x*32,y*16);
        28 : playsound(SND_invisibility,x*32,y*16);
        29..30 : playsound(SND_wpkup,x*32,y*16);
        else  playsound(SND_error,x*32,y*16);
        end;

        if i <> 40 then
        if MATCH_DRECORD then begin
                DData.type0 := DDEMO_ITEMDISSAPEAR;
                DData.gametic := gametic;
                DData.gametime := gametime;
                DItemDissapear.x := x;
                DItemDissapear.y := y;
                DItemDissapear.i := i;
                DemoStream.Write( DData, Sizeof(DData));
                DemoStream.Write( DItemDissapear, Sizeof(DItemDissapear));
        end;

        if i <> 40 then
        if ismultip = 1 then begin
                MsgSize := SizeOf(TMP_ItemDisappear);
                Msg.DATA := MMP_ITEMDISAPPEAR;
                Msg.x := x; Msg.y := y;
                if f<>nil then
                Msg.DXID := F.DXID
                else Msg.DXID := 0; 
                Msg.index := i;
                mainform.BNETSendData2All(Msg, MsgSize, 1);
        end;
end;

procedure ClipItems(F : TPlayer);
var
    xx,yy,o :byte;
begin

if MATCH_GAMEEND = TRUE THEN EXIT;
if f.dead > 0 then exit;              // do not give itemz to zombiez.
if MATCH_DDEMOPLAY then exit;
if ismultip = 2 then exit;
if (ismultip = 1) and (MATCH_STARTSIN >=1) and (MATCH_STARTSIN<=150) then exit;
if (GAMETIME=0) and (GAMETIC<10) then exit; // fix bug
if (F.netobject) and (f.justrespawned>0) then exit; // fix a bug.

xx := trunc(f.x) div 32;
for o := 0 to 2 do begin
        case o of
        0 : yy := trunc(f.y+23) div 16;
        1 : yy := trunc(f.y-23) div 16;
        else yy := trunc(f.y) div 16;
        end;

// -------------------------------------------------------------------
// DOMINATION!
// -------------------------------------------------------------------

if ismultip=1 then if MATCH_GAMETYPE = GAMETYPE_DOMINATION then
if MATCH_STARTSIN = 0 then
if (bbb[xx,yy].oy=0) then
if (bbb[xx,yy].image = 42) then begin
        if bbb[xx,yy].dir<>f.team then begin
                bbb[xx,yy].oy := 25;
                DOM_Capture(xx,yy,f.team, MMP_DOM_CAPTURE);
        end;
end;


// -------------------------------------------------------------------
// CAPTURE THE FLAG!
// -------------------------------------------------------------------
if ismultip=1 then if MATCH_GAMETYPE = GAMETYPE_CTF then
if MATCH_STARTSIN = 0 then if (bbb[xx,yy].image = 40) or (bbb[xx,yy].image = 41) then
if bbb[xx,yy].dir=0 then begin
        if (f.flagcarrier=false) then begin
                  if (f.team=1) and (bbb[xx,yy].image = 40) then begin//takeblue
                        f.flagcarrier := true;
                        playsound(SND_flagtk,0,0);
                        bbb[xx,yy].dir := 1; // not at base.
                        CTF_EVENT_FLAGTAKEN(xx,yy,f.dxid);
                        CTF_Event_Message(f.dxid,'taken');
                  end;
                  if (f.team=0) and (bbb[xx,yy].image = 41) then begin
                        playsound(SND_flagtk,0,0);
                        f.flagcarrier := true;
                        bbb[xx,yy].dir := 1; // not at base.
                        CTF_EVENT_FLAGTAKEN(xx,yy,f.dxid);
                        CTF_Event_Message(f.dxid,'taken');
                  end;
        end else begin
                if (f.team=1) and (bbb[xx,yy].image = 41) then begin
                        f.flagcarrier := false;
                        //REDTEAM SCORES!. check ctf scores here.
                        playsound(SND_flagcap,0,0);
                        inc(MATCH_REDTEAMSCORE, 1);
                        CTF_EVENT_FLAGCAPTURE(f.dxid);
                        CTF_ReturnFlag(0); //return flag..
                        CTF_Event_Message(f.dxid,'captu');
                        inc(f.frags, CTF_CAPTURE_BONUS);
                        CTF_Event_GameStateScoreChanged();
                end;
                if (f.team=0) and (bbb[xx,yy].image = 40) then begin
                        f.flagcarrier := false;
                        //BLUETEAM SCORES!. check ctf scores here.
                        playsound(SND_flagcap,0,0);
                        CTF_Event_Message(f.dxid,'captu');
                        inc(MATCH_BLUETEAMSCORE, 1);
                        CTF_EVENT_FLAGCAPTURE(f.dxid);
                        CTF_ReturnFlag(1); //return flag..
                        inc(f.frags, CTF_CAPTURE_BONUS);
                        CTF_Event_GameStateScoreChanged();
                end;
        end;

//        addmessage('dasdsadasdasd');
{                       if (f.team=1) and (bbb[xx,yy].image = 40) then begin
                                f.flagcarrier := true;
                                bbb[xx,yy].dir := 1; // not at base.
                        end;}
end;


if bbb[xx,yy].respawnable = false then continue;
if bbb[xx,yy].respawntime > 0 then continue;       // not respawned yet.

//p1flashbar := 1;
if bbb[xx,yy].image = 1 then begin // shotgun
        if f.ammo_sg >= 10 then begin if f.have_sg = true then AddAmmo(F, 2, 1)end else
        f.ammo_sg := 10;
        if f.have_sg=false then DoWeapBarEx(f);
        f.have_sg := true;
        if f.idd = 1 then p2flashbar := 1 else if f.idd = 0 then p1flashbar := 1;
        if OPT_NFKITEMS then bbb[xx,yy].respawntime := 1000 else
        bbb[xx,yy].respawntime := 250;
   //     ChangeWeapon(f);
        Item_Dissapear(xx,yy,bbb[xx,yy].image,f);
        end;

if bbb[xx,yy].image = 2 then begin // grenade
        if f.ammo_gl >= 10 then begin if f.have_gl = true then AddAmmo(F, 3, 1)end else
        f.ammo_gl := 10;
        if f.have_gl=false then DoWeapBarEx(f);
        f.have_gl := true;
        if f.idd = 1 then p2flashbar := 1 else if f.idd = 0 then p1flashbar := 1;
        if OPT_NFKITEMS then bbb[xx,yy].respawntime := 1000 else
        bbb[xx,yy].respawntime := 250;

   //     ChangeWeapon(f);
        Item_Dissapear(xx,yy,bbb[xx,yy].image,f);
        end;

if bbb[xx,yy].image = 3 then begin // rocket
        if f.ammo_rl >= 10 then begin if f.have_rl = true then AddAmmo(F, 4, 1)end else
        f.ammo_rl := 10;
        if f.have_rl=false then DoWeapBarEx(f);
        f.have_rl := true;
        if f.idd = 1 then p2flashbar := 1 else if f.idd = 0 then p1flashbar := 1;
        if OPT_NFKITEMS then bbb[xx,yy].respawntime := 1000 else
        bbb[xx,yy].respawntime := 250;
   //     ChangeWeapon(f);
        Item_Dissapear(xx,yy,bbb[xx,yy].image,f);
        end;

   // trix items
   if bbb[xx,yy].image = 29 then begin // trix gren
        AddAmmo(F, 3, 1);
        if f.have_gl=false then DoWeapBarEx(f);
        f.have_gl := true;
        if f.idd = 1 then p2flashbar := 1 else if f.idd = 0 then p1flashbar := 1;
        Item_Dissapear(xx,yy,bbb[xx,yy].image,f);
        bbb[xx,yy].respawntime := $FFFF;
        end;
   if bbb[xx,yy].image = 30 then begin // trix rocket
        AddAmmo(F, 4, 1);
        if f.have_rl=false then DoWeapBarEx(f);
        f.have_rl := true;
        if f.idd = 1 then p2flashbar := 1 else if f.idd = 0 then p1flashbar := 1;
        Item_Dissapear(xx,yy,bbb[xx,yy].image,f);
        bbb[xx,yy].respawntime := $FFFF;
        end;


if bbb[xx,yy].image = 4 then begin // SHAFT!
        if OPT_NFKITEMS then bbb[xx,yy].respawntime := 2000 else
        bbb[xx,yy].respawntime := 250;
        if f.ammo_sh >= 130 then begin if f.have_sh = true then AddAmmo(F, 5, 1)end else
        f.ammo_sh := 130;
        if f.idd = 1 then p2flashbar := 1 else if f.idd = 0 then p1flashbar := 1;
        if f.have_sh=false then DoWeapBarEx(f);
        f.have_sh := true;
   //     ChangeWeapon(f);
        Item_Dissapear(xx,yy,bbb[xx,yy].image,f);
        end;

if bbb[xx,yy].image = 5 then begin // rail
        if f.ammo_rg >= 10 then begin if f.have_rg = true then AddAmmo(F, 6, 1)end else
        f.ammo_rg := 10;
        if f.have_rg=false then DoWeapBarEx(f);
        f.have_rg := true;
        if OPT_NFKITEMS then bbb[xx,yy].respawntime := 1500 else
        bbb[xx,yy].respawntime := 250;
        if f.idd = 1 then p2flashbar := 1 else if f.idd = 0 then p1flashbar := 1;
   //     ChangeWeapon(f);
        Item_Dissapear(xx,yy,bbb[xx,yy].image,f);
        end;

if bbb[xx,yy].image = 6 then begin // plazma
        if f.ammo_pl >= 50 then begin if f.have_pl = true then AddAmmo(F, 7, 1)end else
        f.ammo_pl := 50;
        if f.have_pl=false then DoWeapBarEx(f);
        f.have_pl := true;
        if f.idd = 1 then p2flashbar := 1 else if f.idd = 0 then p1flashbar := 1;
        if OPT_NFKITEMS then bbb[xx,yy].respawntime := 1000 else
        bbb[xx,yy].respawntime := 250;
   //     ChangeWeapon(f);
        Item_Dissapear(xx,yy,bbb[xx,yy].image,f);
        end;

if       bbb[xx,yy].image = 7 then begin // BFG10K
        if f.ammo_bfg >= 15 then begin if f.have_bfg = true then AddAmmo(F, 8, 1)end else
        f.ammo_bfg := 15;
        if f.have_bfg=false then DoWeapBarEx(f);
        f.have_bfg := true;
        if f.idd = 1 then p2flashbar := 1 else if f.idd = 0 then p1flashbar := 1;
        bbb[xx,yy].respawntime := 5000;
//      ChangeWeapon(f);
        Item_Dissapear(xx,yy,bbb[xx,yy].image,f);
        end;

/////////////// ------------ ++++_AMMO_++++ -------------- \\\\\\\\\\\\\\\\\\\\
if bbb[xx,yy].image = 8 then begin // ammo mg
        if f.ammo_mg >= 200 then continue;
        AddAmmo(F, 1, 50);
        if f.idd = 1 then p2flashbar := 1 else if f.idd = 0 then p1flashbar := 1;
        if OPT_NFKITEMS then bbb[xx,yy].respawntime := 1000 else
        bbb[xx,yy].respawntime := 2000;
        Item_Dissapear(xx,yy,bbb[xx,yy].image,f);
        end;

if bbb[xx,yy].image = 9 then begin // ammo sgun
        if f.ammo_sg >= 100 then continue;
        AddAmmo(F, 2, 10);
        if OPT_NFKITEMS then bbb[xx,yy].respawntime := 1000 else
        bbb[xx,yy].respawntime := 2000;
        if f.idd = 1 then p2flashbar := 1 else if f.idd = 0 then p1flashbar := 1;
        Item_Dissapear(xx,yy,bbb[xx,yy].image,f);
        end;

if bbb[xx,yy].image = 10 then begin // ammo gl
        if f.ammo_gl >= 100 then continue;
        AddAmmo(F, 3, 5);
        if OPT_NFKITEMS then bbb[xx,yy].respawntime := 1000 else
        bbb[xx,yy].respawntime := 2000;
        if f.idd = 1 then p2flashbar := 1 else if f.idd = 0 then p1flashbar := 1;
        Item_Dissapear(xx,yy,bbb[xx,yy].image,f);
        end;

if bbb[xx,yy].image = 11 then begin // ammo rl
        if f.ammo_rl >= 100 then continue;
        AddAmmo(F, 4, 5);
        if OPT_NFKITEMS then bbb[xx,yy].respawntime := 1000 else
        bbb[xx,yy].respawntime := 2000;
        if f.idd = 1 then p2flashbar := 1 else if f.idd = 0 then p1flashbar := 1;
        Item_Dissapear(xx,yy,bbb[xx,yy].image,f);
        end;

if bbb[xx,yy].image = 12 then begin // ammo shaft
        if f.ammo_sh >= 200 then continue;
        AddAmmo(F, 5, 70);
        if OPT_NFKITEMS then bbb[xx,yy].respawntime := 1000 else
        bbb[xx,yy].respawntime := 2000;
        if f.idd = 1 then p2flashbar := 1 else if f.idd = 0 then p1flashbar := 1;
        Item_Dissapear(xx,yy,bbb[xx,yy].image,f);
        end;

if bbb[xx,yy].image = 13 then begin // ammo rail
        if f.ammo_rg >= 100 then continue;
        AddAmmo(F, 6, 5);
        if OPT_NFKITEMS then bbb[xx,yy].respawntime := 1000 else
        bbb[xx,yy].respawntime := 2000;
        if f.idd = 1 then p2flashbar := 1 else if f.idd = 0 then p1flashbar := 1;
        Item_Dissapear(xx,yy,bbb[xx,yy].image,f);
        end;

if bbb[xx,yy].image = 14 then begin // ammo plazma
        if f.ammo_pl >= 200 then continue;
        AddAmmo(F, 7, 30);
        if OPT_NFKITEMS then bbb[xx,yy].respawntime := 1000 else
        bbb[xx,yy].respawntime := 2000;
        if f.idd = 1 then p2flashbar := 1 else if f.idd = 0 then p1flashbar := 1;
        Item_Dissapear(xx,yy,bbb[xx,yy].image,f);
        end;

if bbb[xx,yy].image = 15 then begin // ammo BFG!!
        if f.ammo_bfg >= 50 then continue;
        AddAmmo(F, 8, 10);
        bbb[xx,yy].respawntime := 3000;
        if f.idd = 1 then p2flashbar := 1 else if f.idd = 0 then p1flashbar := 1;
        Item_Dissapear(xx,yy,bbb[xx,yy].image,f);
        end;

// ----------- ITEMZ ------------- \\
if bbb[xx,yy].image = 16 then begin             // shard
        if f.armor >= 200 then continue;
        if f.armor+5 < 200 then
        f.armor := f.armor + 5 else f.armor := 200;
        if OPT_NFKITEMS then bbb[xx,yy].respawntime := 1000 else
         bbb[xx,yy].respawntime := 1250;
        if f.idd = 1 then p2flashbar := 1 else if f.idd = 0 then p1flashbar := 1;
        Item_Dissapear(xx,yy,bbb[xx,yy].image,f);
        end;
if bbb[xx,yy].image = 17 then begin             // YA
        if f.armor >= 200 then continue;
        if f.armor+50 < 200 then
        f.armor := f.armor + 50 else f.armor := 200;
        if OPT_NFKITEMS then bbb[xx,yy].respawntime := 1500 else
         bbb[xx,yy].respawntime := 1250;
        if f.idd = 1 then p2flashbar := 1 else if f.idd = 0 then p1flashbar := 1;
        Item_Dissapear(xx,yy,bbb[xx,yy].image,f);
        end;

if bbb[xx,yy].image = 18 then begin             // RA
        if f.armor >= 200 then continue;
        if f.armor+100 < 200 then
        f.armor := f.armor + 100 else f.armor := 200;
        if OPT_NFKITEMS then bbb[xx,yy].respawntime := 1500 else
         bbb[xx,yy].respawntime := 1250;
        if f.idd = 1 then p2flashbar := 1 else if f.idd = 0 then p1flashbar := 1;
        Item_Dissapear(xx,yy,bbb[xx,yy].image,f);
        end;
if bbb[xx,yy].image = 19 then begin             // medkit +5
        if f.health >= 200 then continue;
        f.health := f.health + 5;
        if f.health > 200 then f.health := 200;
        if f.idd = 1 then p2flashbar := 1 else if f.idd = 0 then p1flashbar := 1;
        if OPT_NFKITEMS then bbb[xx,yy].respawntime := 1000 else
        bbb[xx,yy].respawntime := 1750;
        Item_Dissapear(xx,yy,bbb[xx,yy].image,f);
        end;
if bbb[xx,yy].image = 20 then begin             // medkit +25
        if f.health >= 100 then continue;
        f.health := f.health + 25;
        if f.health > 100 then f.health := 100;
        if f.idd = 1 then p2flashbar := 1 else if f.idd = 0 then p1flashbar := 1;
        if OPT_NFKITEMS then bbb[xx,yy].respawntime := 1000 else
        bbb[xx,yy].respawntime := 1750;
        Item_Dissapear(xx,yy,bbb[xx,yy].image,f);
        end;
if bbb[xx,yy].image = 21 then begin             // medkit +50
        if f.health >= 100 then continue;
        f.health := f.health + 50;
        if f.health > 100 then f.health := 100;
        if f.idd = 1 then p2flashbar := 1 else if f.idd = 0 then p1flashbar := 1;
        if OPT_NFKITEMS then bbb[xx,yy].respawntime := 1500 else
        bbb[xx,yy].respawntime := 1750;
        Item_Dissapear(xx,yy,bbb[xx,yy].image,f);
        end;
if bbb[xx,yy].image = 22 then begin             // medkit +100
        if f.health >= 200 then continue;
        f.health := f.health + 100;
        if f.health > 200 then f.health := 200;
        if f.idd = 1 then p2flashbar := 1 else if f.idd = 0 then p1flashbar := 1;
        if OPT_NFKITEMS then bbb[xx,yy].respawntime := 3000 else
        bbb[xx,yy].respawntime := 1750;
        Item_Dissapear(xx,yy,bbb[xx,yy].image,f);
        end;
if bbb[xx,yy].image = 23 then begin             // regeneration.
        if f.idd = 1 then p2flashbar := 1 else if f.idd = 0 then p1flashbar := 1;
        bbb[xx,yy].respawntime := 6000;
        Item_Dissapear(xx,yy,bbb[xx,yy].image,f);
        f.item_regen := 31;

        if MATCH_DRECORD then begin
                DData.type0 := DDEMO_EARNPOWERUP;
                DData.gametic := gametic;
                DData.gametime := gametime;
                DEarnPowerup.DXID := f.dxid;
                DEarnPowerup.type1 := 1;        // regen
                DEarnPowerup.time := f.item_regen;
                DemoStream.Write( DData, Sizeof(DData));
                DemoStream.Write( DEarnPowerup, Sizeof(DEarnPowerup));
        end;

        end;
if bbb[xx,yy].image = 24 then begin             // battlesuit.
        if f.idd = 1 then p2flashbar := 1 else if f.idd = 0 then p1flashbar := 1;
        bbb[xx,yy].respawntime := 6000;
        Item_Dissapear(xx,yy,bbb[xx,yy].image,f);
        f.item_battle := 31;
        if MATCH_DRECORD then begin
                DData.type0 := DDEMO_EARNPOWERUP;
                DData.gametic := gametic;
                DData.gametime := gametime;
                DEarnPowerup.DXID := f.dxid;
                DEarnPowerup.type1 := 3;        // battle
                DEarnPowerup.time := f.item_battle;
                DemoStream.Write( DData, Sizeof(DData));
                DemoStream.Write( DEarnPowerup, Sizeof(DEarnPowerup));
        end;
        end;
if bbb[xx,yy].image = 25 then begin             // haste.
        if f.idd = 1 then p2flashbar := 1 else if f.idd = 0 then p1flashbar := 1;
        bbb[xx,yy].respawntime := 6000;
        Item_Dissapear(xx,yy,bbb[xx,yy].image,f);
        f.item_haste := 31;
        if MATCH_DRECORD then begin
                DData.type0 := DDEMO_EARNPOWERUP;
                DData.gametic := gametic;
                DData.gametime := gametime;
                DEarnPowerup.DXID := f.dxid;
                DEarnPowerup.type1 := 4;        // haste
                DEarnPowerup.time := f.item_haste;
                DemoStream.Write( DData, Sizeof(DData));
                DemoStream.Write( DEarnPowerup, Sizeof(DEarnPowerup));
        end;
        end;
if bbb[xx,yy].image = 26 then begin             // quad.
        if f.idd = 1 then p2flashbar := 1 else if f.idd = 0 then p1flashbar := 1;
        bbb[xx,yy].respawntime := 6000;
        Item_Dissapear(xx,yy,bbb[xx,yy].image,f);
        f.item_quad := 31;
        if MATCH_DRECORD then begin
                DData.type0 := DDEMO_EARNPOWERUP;
                DData.gametic := gametic;
                DData.gametime := gametime;
                DEarnPowerup.DXID := f.dxid;
                DEarnPowerup.type1 := 5;        // quad
                DEarnPowerup.time := f.item_quad;
                DemoStream.Write( DData, Sizeof(DData));
                DemoStream.Write( DEarnPowerup, Sizeof(DEarnPowerup));
        end;
        end;
if bbb[xx,yy].image = 27 then begin             // flight.
        if f.idd = 1 then p2flashbar := 1 else if f.idd = 0 then p1flashbar := 1;
        bbb[xx,yy].respawntime := 6000;
        Item_Dissapear(xx,yy,bbb[xx,yy].image,f);
        f.item_flight := 31;
        if MATCH_DRECORD then begin
                DData.type0 := DDEMO_EARNPOWERUP;
                DData.gametic := gametic;
                DData.gametime := gametime;
                DEarnPowerup.DXID := f.dxid;
                DEarnPowerup.type1 := 2;        // flight
                DEarnPowerup.time := f.item_flight;
                DemoStream.Write( DData, Sizeof(DData));
                DemoStream.Write( DEarnPowerup, Sizeof(DEarnPowerup));
        end;
        end;
if bbb[xx,yy].image = 28 then begin             // invis.
        if f.idd = 1 then p2flashbar := 1 else if f.idd = 0 then p1flashbar := 1;
        bbb[xx,yy].respawntime := 6000;
        Item_Dissapear(xx,yy,bbb[xx,yy].image,f);
        f.item_invis := 31;
        if MATCH_DRECORD then begin
                DData.type0 := DDEMO_EARNPOWERUP;
                DData.gametic := gametic;
                DData.gametime := gametime;
                DEarnPowerup.DXID := f.dxid;
                DEarnPowerup.type1 := 6;        // flight
                DEarnPowerup.time := f.item_invis;
                DemoStream.Write( DData, Sizeof(DData));
                DemoStream.Write( DEarnPowerup, Sizeof(DEarnPowerup));
        end;
        end;

   end;//o
end;

Function ClipDoorTrigger(xx,yy: integer) : boolean;
var p,i : byte;
    x1,x2,y1,y2 : word;
begin
     result := false;
     for i := 0 to NUM_OBJECTS do if (ddd[i].active = true) and (ddd[i].objtype = 9) and (ddd[i].targetname = 0) then begin
                if ddd[i].orient=0 then begin // UP
                        x1 := ddd[i].x*32;
                        y1 := ddd[i].y*16;
                        x2 := ddd[i].x*32+32*ddd[i].lenght;
                        y2 := ddd[i].y*16+8;
                end;
                if ddd[i].orient=1 then begin // LEFT
                        x1 := ddd[i].x*32;
                        y1 := ddd[i].y*16;
                        x2 := ddd[i].x*32+8;
                        y2 := ddd[i].y*16+16*ddd[i].lenght;
                end;
                if ddd[i].orient=2 then begin // DOWN
                        x1 := ddd[i].x*32;
                        y1 := ddd[i].y*16+8;
                        x2 := ddd[i].x*32+32*ddd[i].lenght;
                        y2 := ddd[i].y*16+16;
                end;
                if ddd[i].orient=3 then begin // right
                        x1 := ddd[i].x*32+24;
                        y1 := ddd[i].y*16;
                        x2 := ddd[i].x*32+32;
                        y2 := ddd[i].y*16+16*ddd[i].lenght;
                end;

                if (xx >= x1) and (xx <= x2) and (yy >= y1) and (yy <= y2) then begin
                        for p := 0 to NUM_OBJECTS do if (ddd[p].active = true) and (ddd[p].target=1) and (ddd[p].dir = 0) and (ddd[p].orient <= 1) AND (ddd[p].targetname = ddd[i].target) and (ddd[p].objtype = 3) then begin
                                result := true;
                                ACTIVATEOBJ(p);
                        end;
                end;
        end;
end;

procedure ClipButton(xx,yy: integer);
var p,i : byte;
    Msg: TMP_ObjChangeState;
    MsgSize: word;

begin
     if xx < 0 then exit;
     if yy < 0 then exit;

     if MATCH_DDEMOPLAY then exit;
     if ismultip=2 then exit;



     for i := 0 to NUM_OBJECTS do if (ddd[i].active = true) and (ddd[i].objtype = 2) and (ddd[i].targetname=0) and (ddd[i].special = 1) then
        if (xx >= ddd[i].x*32) and (xx <= ddd[i].x*32+32) and (yy >= ddd[i].y*16-4) and (yy <= ddd[i].y*16+20) then begin
                ddd[i].targetname := 1;         //0\1=normal\activated
                ddd[i].lenght := ddd[i].wait;   // time of gametic to wait.
                playsound(SND_button,ddd[i].x*32,ddd[i].y*16);

                // send button off data to clients.
                if ismultip=1 then begin
                        MsgSize := SizeOf(TMP_ObjChangeState);
                        Msg.Data := MMP_OBJCHANGESTATE;
                        Msg.objindex := i;
                        Msg.state := 1;
                        mainform.BNETSendData2All(Msg, MsgSize, 1);
                end;

                if MATCH_DRECORD then begin
                        // change obj state!
                        ddata.gametic := gametic;
                        ddata.gametime := gametime;
                        ddata.type0 := DDEMO_OBJCHANGESTATE;
                        DemoStream.Write( DData, Sizeof(DData));
                        DObjChangeState.objindex := i;
                        DObjChangeState.state := 1;     // active
                        DemoStream.Write( DObjChangeState, Sizeof(DObjChangeState));
                end;
                for p := 0 to NUM_OBJECTS do
                        if (ddd[p].active = true) and (ddd[p].targetname = ddd[i].target) and ((ddd[p].objtype = 3) or (ddd[p].objtype = 6)) then ACTIVATEOBJ(p);
        end;
end;

// Flag movement..
procedure CTF_ProcessFlagPhysics (sender : TMonoSprite);
var i : byte;
begin
with sender as TMONOSPRITE do begin

//   if (MATCH_DDEMOPLAY=false) and (ismultip=1) then

if sender.dude = false then begin
   for i := 0 to 7 do if players[i] <> nil then
   if (players[i].health > 0) then
   if (players[i].justrespawned = 0) then
   if (sender.x >= players[i].x - 16) and (sender.x <= players[i].x + 16) and
   (sender.y >= players[i].y) and (sender.y <= players[i].y+64) then
   begin
        // pickup flag.
        if players[i].team <> sender.imageindex then begin
                players[i].flagcarrier := true;
                playsound(SND_flagtk,0,0);
                sender.dead := 2;
                CTF_Event_Message(players[i].dxid,'taken');
                CTF_Event_PickupFlag(sender, players[i]);
                exit;
              end;

        if players[i].team = sender.imageindex then begin
                sender.dead := 2;
                CTF_ReturnFlag(players[i].team);
                CTF_Event_Message(sender.imageindex,'retur');
                inc(players[i].frags, CTF_RECOVERY_BONUS); // what you get for recovery
                CTF_Event_ReturnFlag(sender.dxid, players[i].team);
                playsound(SND_Flagret,0,0);
                exit;
        end;
   end;

   // killed by lava, or death.
   if (bbb[ trunc(sender.x) div 32, trunc(sender.y) div 16 ].image = CONTENT_LAVA)
        or (bbb[ trunc(sender.x) div 32, trunc(sender.y) div 16 ].image = CONTENT_DEATH) then
                sender.health := 0;

   // timed out, auto return1ng to baze.
   if sender.health > 0 then sender.health := sender.health - 1 else begin
        CTF_ReturnFlag(sender.imageindex);
        CTF_Event_Message(sender.imageindex,'retur');
        CTF_Event_ReturnFlag(sender.dxid, sender.imageindex);
        playsound(SND_Flagret,0,0);
        sender.dead := 2;
   end;

end;//if sender.dude = false then


   if (inertiay = 0) and (Inertiax = 0) then begin
                if sender.dude=false then
                        if sender.weapon = 0 then begin
                                CTF_Event_FlagDrop_Apply(sender);
                                sender.weapon := 1;
                        end;
                exit;
        end;

   if (inertiay > -0.3) and (Inertiay < 0.3) and (inertiax > -0.3) and (Inertiax < 0.3) and (bbb[ trunc(x) div 32, trunc(y+2) div 16].block = true) then begin inertiax := 0; exit; end;

   InertiaY := InertiaY + (Gravity*mass);

   if inertiay < 0 then InertiaY := InertiaY / 1.025;   // stopspeed.
   InertiaX := InertiaX / 1.003;   // stopspeed.

   x := x + inertiax;
   y := y + inertiay;
//   if health < 255 then inc(health);????????

   // CLIPPING

   if (bbb[ trunc(x-7) div 32, trunc(y) div 16].block = true) or (bbb[ trunc(x+7) div 32, trunc(y) div 16].block = true) then
        inertiax := 0;
   if (bbb[ trunc(x) div 32, trunc(y-12) div 16].block = true) then begin // boom ceil
                if inertiay < 0 then inertiay := abs(inertiay);
                inertiax := inertiax / GRENADE_SLOWSPEED;
   end;
   if (bbb[ trunc(x) div 32, trunc(y+2) div 16].block = true) then begin// boom floor
//              addmessage('blocked floor');
                inertiay := 0;
                inertiax := 0;
               end;

   if InertiaY < -5 then InertiaY := -5;
   if InertiaY >  5 then InertiaY :=  5;
   if InertiaX < -7 then InertiaX := -7;
   if InertiaX >  7 then InertiaX :=  7;

   if (inertiax < 0.01) and (inertiax > -0.01) and (onbrick_flag(sender)) then inertiax := 0;
   if (inertiay < 0.02) and (inertiay > -0.02) and (onbrick_flag(sender)) then inertiay := 0;
 end;

end;

procedure TMonoSprite.DoMove(MoveCount: Integer);
var {f : TMonoSprite;}
    z,a : real;
    i : word;
    angle : smallint;
    Msg: TMP_RailTrail;
    Msg2: TMP_cl_ObjDestroy;
    MsgSize: word;
    alph:cardinal;
    weapony : shortint;
begin
        if (objname = 'player') then begin addmessage('MAJOR INTERNAL ERROR.#1');exit;end;
        if self.dead = 2 then exit;     //really dead. dead animation over;
        if dead = 1 then begin self.hit; exit; end; // animate death

//        if self.spawner = nil then dead := 2;

if objname = 'flash' then begin
        if frame < 7 then inc(frame) else self.dead := 2;
        if inscreen(round(x),round(y),48) then mainform.PowerGraph.RenderEffectCol(mainform.Images[32], trunc(x)+GX, trunc(y)+GY,$AAFFFFFF, frame, effectADD);
end else

if objname = 'bubble' then begin
        mainform.PowerGraph.RenderEffect(mainform.Images[3], trunc(x)+GX, trunc(y)+GY, 64,1, effectSrcAlphaAdd);
        if random(3)=0 then if random(2)=0 then x:=x-1 else x:=x+1;
        if random(4)>0 then
        y:= y - 1;
        inc(frame);
        if frame=dir then dead:=2;

        if (x<32) or (y < 16) then dead:=2;

        i := bbb[ trunc(x-4) div 32, trunc(y-4) div 16].image;
        if (i<>CONTENT_LAVA) and (i<>CONTENT_WATER) then dead := 2;
        i := bbb[ trunc(x+4) div 32, trunc(y+4) div 16].image;
        if (i<>CONTENT_LAVA) and (i<>CONTENT_WATER) then dead := 2;
        i := bbb[ trunc(x-4) div 32, trunc(y+4) div 16].image;
        if (i<>CONTENT_LAVA) and (i<>CONTENT_WATER) then dead := 2;
        i := bbb[ trunc(x+4) div 32, trunc(y-4) div 16].image;
        if (i<>CONTENT_LAVA) and (i<>CONTENT_WATER) then dead := 2;
end else

if objname = 'blood' then begin

        if self.spawner = nil then begin
                if inscreen(round(cx),round(cy),16) then ParticleEngine.AddParticle(trunc(cx)+4,trunc(cy)+4, (Random(2) - 1)/5, (Random(2) -1) / 5,false);
                end else
                if inscreen(round(spawner.x - cx),round(spawner.y - cy),16) then
                        ParticleEngine.AddParticle(trunc(spawner.x - cx)+4,trunc(spawner.y - cy)+4, (Random(4) - 2)/5, (Random(4) -2) / 5,TRUE);
        self.dead := 2;
end else

if objname = 'smoke' then begin
        if frame > 30 then dead := 2;
        if dead = 1 then dead := 2;
        inc(frame);

        if inscreen(round(x),round(y),24) then begin

        if OPT_FXSMOKE then begin
                if frame < 31 then
                        alph := 255-frame*8 else alph := 0;
                mainform.powergraph.Antialias := true;
                mainform.powergraph.RotateEffect(mainform.images[55],round(x)+gx,round(y)+gy,trunc(fangle),48-frame div 3,(alph shl 24) + $FFFFFF,0,effectsrcalphaadd or effectdiffusealpha);
                mainform.powergraph.Antialias := false;
                end else
                mainform.PowerGraph.RenderEffect(mainform.Images[28], trunc(x)+GX , trunc(y)+GY, Frame div 2, effectSrcColor or EffectDiffuseAlpha);
        end;
end else

if objname = 'shots2' then begin
        inc(frame);
        if frame <= 10 then dir := 0 else
        if frame <= 20 then dir := 1 else
        if frame <= 30 then dir := 2 else dead := 2;
        if inscreen(trunc(cx),trunc(cy),16) then

        if OPT_R_TRANSPARENTBULLETMARKS then
        mainform.PowerGraph.RenderEffect(mainform.Images[36],  trunc(cx)-4+GX, trunc(cy)-4+GY,3+dir, effectSrcAlphaAdd) else
        mainform.PowerGraph.RenderEffect(mainform.Images[36],  trunc(cx)-4+GX, trunc(cy)-4+GY,3+dir, effectSrcAlpha);
end else

if objname = 'shots' then begin
        inc(frame);
        if frame <= 10 then dir := 0 else
        if frame <= 20 then dir := 1 else
        if frame <= 30 then dir := 2 else dead := 2;
        if inscreen(trunc(cx),trunc(cy),24) then

        if OPT_R_TRANSPARENTBULLETMARKS then
        mainform.PowerGraph.RenderEffect(mainform.Images[35],  trunc(cx)-4+GX, trunc(cy)-4+GY, dir, effectSrcAlphaAdd) else
        mainform.PowerGraph.RenderEffect(mainform.Images[35],  trunc(cx)-4+GX, trunc(cy)-4+GY, dir, effectSrcAlpha);

//        mainform.ImageList.Items.Find('bullet').Draw(mainform.DXDraw.Surface, trunc(cx)-8+GX,trunc(cy)-8+GY, dir); // draw shots
end else

// CTF!
if objname = 'flag' then begin

        if inscreen(trunc(x),trunc(y),64) then begin
                if dir=0 then
                        Mainform.PowerGraph.RotateEffectFix(Mainform.Images[47], trunc(x)+GX+12, trunc(y)+gy-12,76,256, 14*imageindex+SYS_FLAGFRAME, effectSrcAlpha) else
                        Mainform.PowerGraph.RotateEffectFix(Mainform.Images[47], trunc(x)+GX-12, trunc(y)+gy-12,52,256, 14*imageindex+SYS_FLAGFRAME, effectSrcAlpha or effectMirror);

//                Mainform.PowerGraph.Line( trunc(x)+GX+16,trunc(y)+GY,trunc(x)+GX-16,trunc(y)+GY,cllime,effectNone);
//                Mainform.PowerGraph.Line( trunc(x)+GX,trunc(y)+GY,trunc(x)+GX,trunc(y)+GY-16,cllime,effectNone);
        end;

        CTF_ProcessFlagPhysics(self);
end else
// =============================================================================
// droppable weapon
if objname = 'weapon' then begin

        if inscreen(trunc(x),trunc(y),64) then begin
                if dir=1 then
                        Mainform.PowerGraph.RotateEffectFix(Mainform.Images[22], trunc(x)+GX, trunc(y)+gy-6,65,256, imageindex-1, effectSrcAlpha) else
                        Mainform.PowerGraph.RotateEffectFix(Mainform.Images[22], trunc(x)+GX, trunc(y)+gy-6,64,256, imageindex-1, effectSrcAlpha or effectMirror);

//                Mainform.PowerGraph.Line( trunc(x)+GX+16,trunc(y)+GY,trunc(x)+GX-16,trunc(y)+GY,cllime,effectNone);
//                Mainform.PowerGraph.Line( trunc(x)+GX,trunc(y)+GY,trunc(x)+GX,trunc(y)+GY-16,cllime,effectNone);
        end;

        WPN_ProcessWeaponPhysics(self);
end else
// =============================================================================
// droppable powerup
if objname = 'powerup' then begin

        if inscreen(trunc(x),trunc(y),64) then
        Mainform.PowerGraph.RotateEffectFix(Mainform.Images[22], trunc(x)+GX, trunc(y)+gy-6,65,256, 23+dir, effectSrcAlpha);
        POWERUP_ProcessPowerupPhysics(self);
end else
// =============================================================================
if (self.objname = 'grenade') then begin

//        addmessage('^3gren:'+inttostr(self.health));
        if self.imageindex > 0 then dec(self.imageindex) else self.dead := 2;

        inc(frame);
        ClipButton(round(x),round(y));

        if (frame>= 102) then frame:= 102; // HACK: avoid integer overflow bug.

        if (frame >= 6) and (frame < 100) then if OPT_SMOKE then
                if self.doublejump = 0 then begin
                        SpawnSmoke(round(x), round(y)); doublejump := 3;

                        if OPT_FXSMOKE then doublejump := 1;
                end else dec(doublejump);


        if (ismultip=2) then begin
                if frame < 100 then if MATCH_DDEMOPLAY=false then GrenadePhysics(self) else frame := 100;
                end;

        if ismultip<2 then begin
                if ((frame > 100) or (checkclipplayer(self) or (ClipDoorTrigger(round(self.x),round(self.y))))) and (MATCH_DDEMOPLAY=false) then // EXPLLLLLLL
                        begin
                        frame := 0;
                        dead := 1;
                        self.weapon := 1;
                        self.objname := 'rocket';
                        self.fangle := random(256);
                        topdraw:=2;

                        // send explosion to client;
                        if ismultip=1 then begin
                                MsgSize := SizeOf(TMP_cl_ObjDestroy);
                                Msg2.Data := MMP_CL_OBJDESTROY;
                                Msg2.killDXID := self.DXID;
                                MSG2.index := 0;
                                Msg2.x := round(self.x);
                                Msg2.y := round(self.y);
                                Mainform.BNETSendData2All(Msg2, MsgSize, 0);
                        end;
                        // & send explosion to client;

                        exit;
                        end;
                GrenadePhysics(self);
        end;


        if frame >= 6 then begin
                if inscreen(trunc(x),trunc(y),32) then
                if OPT_EASTERGRENADES then
                        mainform.PowerGraph.RotateEffect(mainform.Images[IMAGE_ITEM],trunc(x)+GX, trunc(y)+GY,trunc(256/360*fangle),256, refire  , effectSrcAlpha) else
                if OPT_ALTGRENADES then
                        mainform.PowerGraph.RotateEffect(mainform.Images[35],trunc(x)+GX, trunc(y)+GY,trunc(256/360*fangle),256,15, effectSrcAlpha) else
                mainform.PowerGraph.RotateEffect(mainform.Images[35],trunc(x)+GX, trunc(y)+GY,trunc(256/360*fangle),256,6, effectSrcAlpha);
        end;

end else
// -----------------------------------------------------------------------------
if (self.objname = 'gib') then begin
        inc(frame);
        if (frame > self.fallt)  then begin frame := 0;dead := 2; exit; end;

        if OPT_GIBBLOOD then if self.doublejump = 0 then begin
                SpawnXYNulBlood(round(x-4),round(y-4));
                doublejump := 5;
        end else dec(doublejump);

        GrenadePhysics(self);

        mainform.PowerGraph.Antialias := true;
        if inscreen(trunc(x),trunc(y),24) then
                  mainform.PowerGraph.RotateEffect(mainform.Images[59],   trunc(x)+GX, trunc(y)+GY,trunc(256/360*fangle),weapon, imageindex, effectSrcAlpha);
        mainform.PowerGraph.Antialias := false;
end else
// -----------------------------------------------------------------------------
if (self.objname = 'spark') then begin // easter;
        inc(frame);
        if health-frame*7 <= 0 then begin
                dead := 2;
                exit;
                end;
        mainform.powergraph.Antialias := true;
        mainform.powergraph.RotateEffect(mainform.images[54],round(x),round(y),0,health-frame*7,trunc($AA000000+ cx),0,effectsrcalphaadd);
        mainform.powergraph.Antialias := false;
end;
// -----------------------------------------------------------------------------
if (self.objname = 'rocket') then begin // rl;

        if self.health > 0 then dec(self.health) else self.dead := 2;

        // nasty trix.
        if self.dude = true then
        if CheckClip(self) = true then begin
                self.dead := 1;
                if self.fallt = 1 then  weapon := 2 else
                self.weapon := 0;
                self.frame := 0;
                self.topdraw := 2;
                self.fangle := random(256);
                exit;
        end;

        if self.dude = false then
        if (CheckClip(self) = true) or (CheckClipPlayer(self) = true) or (ClipDoorTrigger(round(self.x),round(self.y))) then
        begin
                self.dead := 1;
                if self.fallt = 1 then  weapon := 2 else
                self.weapon := 0;
                self.frame := 0;
                self.topdraw := 2;
                self.fangle := random(256);

                // send explosion to client;
                if self.dude=false then
                if ismultip=1 then begin
                        MsgSize := SizeOf(TMP_cl_ObjDestroy);
                            Msg2.Data := MMP_CL_OBJDESTROY;
                            Msg2.killDXID := self.DXID;
                            MSG2.index := 0;
                            Msg2.x := round(self.x);
                            Msg2.y := round(self.y);
                            mainform.BNETSendData2All(Msg2, MsgSize, 0);
                end;
                // & send explosion to client;


                exit;
        end;

        if SYS_DRUNKRL then
        if random(15) = 1 then fangle := random(360);

        if ((self.dude = true) and (CheckClip(self) = false)) or (dude=false) then begin // calculate fly.
                angle := round(fangle-90);
                if angle < 0 then angle := 360+angle;
                z := x-FSpeed/2*CosTable[angle];
                a:=  y-FSpeed/2*SinTable[angle];
                x := x + fspeed*CosTable[angle];
                y := y + fspeed*SinTable[angle];

                if x < 24 then x := 24;
                if y < 12 then y := 12;

                ClipButton(trunc(x),trunc(y));
        end;



        if (self.doublejump >=2) then begin
                if fallt = 1 then begin   // !BFG10K!
                       if inscreen(trunc(x),trunc(y),24) then
                                if OPT_FXLIGHTRLBFG then begin
                                        mainform.powergraph.Antialias := true;
                                        mainform.powergraph.RotateEffect(mainform.images[54],round(z)+gx,round(a)+gy,0,384,$AA55FF55,0,effectsrcalphaadd);
                                        mainform.powergraph.Antialias := false;
                                end;
                                mainform.PowerGraph.RotateEffect(mainform.Images[35],   trunc(x)+GX, trunc(y)+GY,trunc(256/360*fangle),256,$AA55FFFF,8, effectSrcAlphaADD or EffectDiffuseAlpha);
                end else begin

                        if ((self.dude = true) and (CheckClip(self) = false)) or (dude=false) then begin

                                if OPT_FXLIGHTRLBFG then begin
                                        mainform.powergraph.Antialias := true;
                                        mainform.powergraph.RotateEffect(mainform.images[54],round(z)+gx,round(a)+gy,0,384,$FF60D0FF,0,effectsrcalphaadd);
                                        mainform.powergraph.Antialias := false;
                                end;

                                if OPT_SMOKE then
                                if OPT_FXSMOKE then
                                        SpawnSmoke(round(z),round(a)) else

                                if self.refire = 0 then begin SpawnSmoke(round(z),round(a)); refire := 1; end else dec(refire);
                        // Draw Missile.
                        if inscreen(trunc(x),trunc(y),24) then
                        mainform.PowerGraph.RotateEffect(mainform.Images[35],   trunc(x)+GX, trunc(y)+GY,trunc(256/360*fangle),256,5, effectSrcAlpha);
                        end;
                end;

        end else inc(self.doublejump);
end else
// -----------------------------------------------------------------------------
if (self.objname = 'plasma') then begin // plazma;
        angle := round(fangle-90);
        if angle < 0 then angle := 360+angle;

        if ((self.dude = true) and (CheckClipRail(self) = false)) OR (DUDE=FALSE) then begin // calculate fly.
                x := x + fspeed*CosTable[angle];
                y := y + fspeed*SinTable[angle];
                if x < 24 then x := 24;
                if y < 12 then y := 12;

                ClipButton(round(x),round(y));
        end;

        if self.health > 0 then dec(self.health) else self.dead := 2;
        if self.dude = true then if (CheckClipRail(self) = true) or (checkclipplayer_plasma(self) = true) then self.dead := 2;

        if self.dude = false then
        if (CheckClipRail(self) = true) or (checkclipplayer_plasma(self) = true) or (ClipDoorTrigger(round(self.x),round(self.y))) then
        begin
{                if MATCH_DRECORD then begin
                        DData.type0 := 5;    // kill this object in demo
                        DData.gametic := gametic;
                        DData.gametime := gametime;
                        DDXIDKill.x := round(x);
                        DDXIDKill.y := round(y);
                        DDXIDKill.DXID := DXID;
                        DemoStream.Write( DData, Sizeof(DData));
                        DemoStream.Write( DDXIDKill, Sizeof(DDXIDKill));
                end;
}
                // send rmove to client;
                if ismultip=1 then begin
                        MsgSize := SizeOf(TMP_cl_ObjDestroy);
                            Msg2.Data := MMP_CL_OBJDESTROY;
                            Msg2.killDXID := self.DXID;
                            MSG2.index := 0;
                            Msg2.x := round(self.x);
                            Msg2.y := round(self.y);
                            mainform.BNETSendData2All(Msg2, MsgSize, 0);
                end;
                // & send rmove to client;

                self.dead := 2; exit;
        end;

        if (self.doublejump >=2) then begin
                if OPT_FXPLASMA then begin
                        mainform.powergraph.Antialias := true;
                        mainform.powergraph.RotateEffect(mainform.images[54],round(x)+gx,round(y)+gy,0,96,$FFFFFF00,0,effectsrcalphaadd);
                        mainform.powergraph.Antialias := false;
                end else begin
                        if inscreen(trunc(x),trunc(y),24) then
                               mainform.PowerGraph.RenderEffect(mainform.Images[35], trunc(x)-8+GX, trunc(y)-8+GY,7, effectSrcAlpha);
                end;
        end
        else inc(self.doublejump);
end else
// -----------------------------------------------------------------------------
        if (objname = 'rail') then begin // rail;


                if MATCH_DDEMOPLAY then begin
                        RailPostTrace(self);
                        dead := 1;
                        end else begin
                                speed := 1;
                                VectorTraceVectorTrace(self);

                                if MATCH_DRECORD then begin
                                        DData.type0 := 9;               //
                                        DData.gametic := gametic;
                                        DData.gametime := gametime;
                                        DVectorMissile.x :=round(self.x);
                                        DVectorMissile.y := round(self.y);
                                        DVectorMissile.inertiax := round(self.cx);
                                        DVectorMissile.inertiay := round(self.cy);
                                        DVectorMissile.DXID := DXID;
                                        DVectorMissile.spawnerDxid := spawner.DXID;//spawner.DXID;
                                        DVectorMissile.dir := self.fallt;
                                        DVectorMissile.angle := self.fangle;
                                        DemoStream.Write( DData, Sizeof(DData));
                                        DemoStream.Write( DVectorMissile, Sizeof(DVectorMissile));
                                end;

                        RailPostTrace(self);
                        dead := 1;

                if ismultip=1 then begin
                        MsgSize := SizeOf(TMP_RailTrail);
                            Msg.Data := MMP_RAILTRAIL;
                            Msg.x := round(x);
                            Msg.y := round(y);
                            Msg.endx := round(cx);
                            Msg.endy := round(cy);
                            Msg.color := self.fallt;
                            Msg.x1 := round(spawner.x);
                            Msg.y1 := round(spawner.y);
                            mainform.BNETSendData2All(Msg, MsgSize, 0);
                end;


                        end;

                for i := 0 to 7 do if railgunhit[i] = true then break
                        ELSE IF (i = 7) and (railgunhit[i] = false) then
                                spawner.impressive := 0;
 end else

// -----------------------------------------------------------------------------
        if (objname = 'shotgun') or (objname = 'shaft') or (objname = 'shaft2') or (objname = 'machine') or (objname='gauntlet') then begin // vector;

                if objname = 'shaft2' then begin
                        inc(spawner.shaftframe);
                        inc(spawner.stats.shaft_fire);

                        if spawner.shaftframe >= 16 then spawner.shaftframe := 0; // cycle frames
                        x := self.spawner.x;
                        cx := x;
                        if self.spawner.crouch then weapony := 3 else weapony := -5;
                        doublejump := 1;
                        y := self.spawner.y+weapony;
                        cx := y;

                        if self.spawner.netobject then begin
                                x := self.spawner.TESTPREDICT_X;
                                y := self.spawner.TESTPREDICT_y+weapony;
                                end;

                        topdraw := 1;
                        fallt := 80;
                        weapon := 0;
//                        self.spawner.refire := 2;
                        if (self.spawner.dir = 1) or (self.spawner.dir = 3) then
                        fAngle := (self.spawner.fangle-1)*360/254 else
                        fAngle := (self.spawner.fangle)*360/254;

                        inc(self.spawner.shaftsttime,2);
                        if self.spawner.shaftsttime >= 22 then begin
                                playsound(SND_lg_hum,self.spawner.x,self.spawner.y);
                                self.spawner.shaftsttime := 2;
                        end;

                        // NETWORK ANTILAG
                        if imageindex > 0 then dec(imageindex);

//                      if (self.dude = true) then
                        if (imageindex)=0 then begin
                                 dead := 2;
//                               addmessage('^2shaft is killed');
                                 self.spawner.shaft_state := 0;
//                                 addmessage('shaft killed by 1');
                                 end;

                        if self.spawner.dead > 0 then begin
                                self.spawner.shaft_state := 0;
                                dead := 2;
//                                addmessage('shaft killed by 2');
                                end;

                        if self.spawner.weapon <> C_WPN_SHAFT then begin
                                self.spawner.shaft_state := 0;
//                                addmessage('shaft killed by 3');
                                dead := 2;
                                end;
                end else

                if objname = 'shaft' then begin
                        if frame = 1 then dude := true;
                        if frame >= 1 then begin

                                for i := 0 to 1000 do if (aaa[i].dead=0) and (aaa[i].objname='shaft') and (aaa[i].spawner=spawner) and (aaa[i]<>self) then begin self.dead:=2;exit;end;

                                inc(spawner.shaftframe);
                                if spawner.shaftframe >= 16 then spawner.shaftframe := 0; // cycle frames
                                x := self.spawner.x;
                                cx := x;
                                if spawner.crouch then
                                y := trunc(self.spawner.y + 3) else
                                y := trunc(self.spawner.y - 5);
                                cy := y;
                                topdraw := 0;
                                doublejump := 1;
//                                if (spawner.shaftframe>0) then dec(spawner.shaftframe);
                                end;

                        if self.spawner.dead > 0 then dead := 2;
                        if self.spawner.weapon <> 5 then dead := 2;
                        if self.spawner.ammo_sh = 0 then dead := 2;
                        if frame < 3 then inc(frame) else dead := 2;
                end;// else

                speed := 1;
                VectorTraceVectorTrace(self);

                if (objname <> 'shaft') and (objname <> 'shaft2') then dead := 2;
                if (objname = 'shaft2') and (self.spawner.shaft_state = 0) then begin
//                        addmessage('shaft killed by 4');
                        dead := 2;
                        end;
        end;
end;

procedure TMonoSprite.Hit;
var alph:cardinal;
begin
        if (objname = 'blood') or (objname = 'smoke') then self.dead := 2;

if self.objname = 'rocket' then  begin

        // easter egg
        if frame = 32 then if SYS_FIREWORKSSTUDIOS then if random(4)<>0 then
                frame := 0;


        if frame = 32 then begin
                dead := 2; exit;
        end;

        mainform.PowerGraph.Antialias := true;

        if OPT_FXEXPLO then
        if inscreen(trunc(x),trunc(y),64) then begin
                if (frame >= 0) and (frame <= 255) then
                alph := (255 - 4*frame) else alph := 0;
                alph := (alph shl 24) + $60D0FF;

                if fallt = 0 then mainform.powergraph.RotateEffect(mainform.images[54],round(x)+gx,round(y)+gy,0,512-frame*16,alph,0,effectsrcalphaadd or effectdiffusealpha) else
                mainform.powergraph.RotateEffect(mainform.images[54],round(x)+gx,round(y)+gy,0,512-16*frame,$2255ff55,0,effectsrcalphaadd);
        end;


        if inscreen(trunc(x),trunc(y),24) then
        if fallt = 0 then if OPT_R_TRANSPARENTEXPLOSIONS then
        mainform.PowerGraph.RotateEffect(mainform.Images[33], trunc(x)+GX, trunc(y)+GY,round(fangle),256,frame div 4, effectSrcAlphaADD) else
        mainform.PowerGraph.RotateEffect(mainform.Images[33], trunc(x)+GX, trunc(y)+GY,round(fangle),256,frame div 4, effectSrcAlpha);


        if inscreen(trunc(x),trunc(y),24) then
        if fallt = 1 then if OPT_R_TRANSPARENTEXPLOSIONS then
        mainform.PowerGraph.RotateEffect(mainform.Images[33], trunc(x)+GX, trunc(y)+GY,round(fangle),256,$FF55FF55,frame div 4, effectSrcAlphaAdd) else
        mainform.PowerGraph.RotateEffect(mainform.Images[33], trunc(x)+GX, trunc(y)+GY,round(fangle),256,$FF55FF55,frame div 4, effectSrcAlpha);
        mainform.PowerGraph.Antialias := false;

        if frame = 0 then
        if MATCH_DRECORD then begin
                DData.type0 := DDEMO_KILLOBJECT;    // kill this object in demo
                DData.gametic := gametic;
                DData.gametime := gametime;
                DDXIDKill.x := round(x);
                DDXIDKill.y := round(y);
                DDXIDKill.DXID := DXID;
                DemoStream.Write( DData, Sizeof(DData));
                DemoStream.Write( DDXIDKill, Sizeof(DDXIDKill));
//              addmessage('recording kill: #'+inttostr(DDXIDKill.DXID));
        end;


        if frame = 0 then begin
                playsound(SND_expl,x,y);
                if (MATCH_DDEMOPLAY=false) then
                SplashDamage(self,x,y,60,100);
          end;
        inc(frame);
end;

   if (self.objname = 'rail') then begin // TRACE LINE;
                // flash here;
                RailPostTrace(self);
                if frame >= OPT_RAILTRAILTIME then dead := 2 else inc(frame);
   end;
end;


function BrickCrouchOnHead(sender:TPlayer) : boolean;//crouch head.
begin
with sender as TPlayer do begin
if (bbb[ trunc(x-8) div 32, trunc(y-9) div 16].block = true) and
   (bbb[ trunc(x-8) div 32, trunc(y-7) div 16].block = false) then begin result := true; exit; end;
if (bbb[ trunc(x+8) div 32, trunc(y-9) div 16].block = true) and
   (bbb[ trunc(x+8) div 32, trunc(y-7) div 16].block = false) then begin result := true; exit; end;
if  (bbb[ trunc(x-8) div 32,  trunc(y-23)  div 16].block = true) then begin result := true; exit; end;
if  (bbb[ trunc(x+8) div 32,  trunc(y-23)  div 16].block = true) then begin result := true; exit; end;
if  (bbb[ trunc(x-8) div 32,  trunc(y-16)  div 16].block = true) then begin result := true; exit; end;
if  (bbb[ trunc(x+8) div 32,  trunc(y-16)  div 16].block = true) then begin result := true; exit; end;
result := false;
end; end;


function BrickOnHead(sender:TPlayer) :boolean;//do not jump over brickz
var c : byte;
begin
c := 0;
//if sender.crouch then c := 5;
with sender as TPlayer do begin
if (bbb[ trunc(x-9) div 32, trunc(y-25+c) div 16].block = true) and
   (bbb[ trunc(x-9) div 32, trunc(y-23+c) div 16].block = false) then begin result := true; exit; end;
if (bbb[ trunc(x+9) div 32, trunc(y-25+c) div 16].block = true) and
   (bbb[ trunc(x+9) div 32, trunc(y-23+c) div 16].block = false) then begin result := true; exit; end;

if (bbb[ trunc(x-9) div 32, trunc(y-24+c) div 16].block = true) and
   (bbb[ trunc(x-9) div 32, trunc(y-8+c)  div 16].block = false) then begin result := true; exit; end;
if (bbb[ trunc(x+9) div 32, trunc(y-24+c) div 16].block = true) and
   (bbb[ trunc(x+9) div 32, trunc(y-8+c)  div 16].block = false) then begin result := true; exit; end;
result := false;
end;
end;

function BrickFOnHead(sender:TMonoSprite) : boolean;//whats that?????? brick female on head?":))
// no, it is for monosprite.. dude
begin
with sender as TMonoSprite do begin
if (bbb[ trunc(x-9) div 32, trunc(y-25) div 16].block = true) and
   (bbb[ trunc(x-9) div 32, trunc(y-23) div 16].block = false) then begin result := true; exit; end;
if (bbb[ trunc(x+9) div 32, trunc(y-25) div 16].block = true) and
   (bbb[ trunc(x+9) div 32, trunc(y-23) div 16].block = false) then begin result := true; exit; end;
if (bbb[ trunc(x-9) div 32, trunc(y-24) div 16].block = true) and
   (bbb[ trunc(x-9) div 32, trunc(y-8)  div 16].block = false) then begin result := true; exit; end;
if (bbb[ trunc(x+9) div 32, trunc(y-24) div 16].block = true) and
   (bbb[ trunc(x+9) div 32, trunc(y-8)  div 16].block = false) then begin result := true; exit; end;
result := false;
end;
end;

function IsFOnground(sender : TMonoSprite) : boolean;  // this procedure checkz if the corpse onground
begin // compare current coordinates via brick matrix;
if sender.x < 0 then exit;
if sender.y < 0 then exit;
result := false;
try
with sender as TMonoSprite do begin
if (bbb[ trunc(x-1) div 32, trunc(y+25) div 16].block = true) and
   (bbb[ trunc(x-1) div 32, trunc(y+23) div 16].block = false) then begin {addmessage('onground');}result := true; exit; end;
if (bbb[ trunc(x+1) div 32, trunc(y+25) div 16].block = true) and
   (bbb[ trunc(x+1) div 32, trunc(y+23) div 16].block = false) then begin {addmessage('onground');}result := true; exit; end;
if (bbb[ trunc(x-1) div 32, trunc(y+24) div 16].block = true) and
   (bbb[ trunc(x-1) div 32, trunc(y-8)  div 16].block = false) then begin {addmessage('onground');}result := true; exit; end;
if (bbb[ trunc(x+1) div 32, trunc(y+24) div 16].block = true) and
   (bbb[ trunc(x+1) div 32, trunc(y-8)  div 16].block = false) then begin {addmessage('onground');}result := true; exit; end;
//   result := false;
end;
except exit; end;
end;

function IsWaterContentJUMP(sender : TPlayer) : boolean;  // this procedure checkz if the player onground
var img : byte;
begin
result := false;
with sender as TPlayer do begin
           img := bbb[ trunc(x) div 32, trunc(y+8) div 16].image;
           if (img = CONTENT_WATER) or (img = CONTENT_LAVA) then result:= true;
end;
end;

function IsWaterContentHEAD(sender : TPlayer) : boolean;  // this procedure checkz if the player'head in water
var img : byte;
begin
result := false;
with sender as TPlayer do begin
           img := bbb[ trunc(sender.x) div 32, trunc(sender.y-20) div 16].image;
           if (img = CONTENT_WATER) or (img = CONTENT_LAVA) then result:= true;
end;
end;

function IsWaterContentCrouchHEAD(sender : TPlayer) : boolean;  // this procedure checkz if the player'head in water
var img : byte;
begin
result := false;
with sender as TPlayer do begin
           img := bbb[ trunc(sender.x) div 32, trunc(sender.y-8) div 16].image;
           if (img = CONTENT_WATER) or (img = CONTENT_LAVA) then result:= true;
end;
end;


function IsWaterContent(sender : TPlayer) : boolean;  // this procedure checkz if the player inwater.
var img : byte;
begin
result := false;
with sender as TPlayer do begin
//   img := bbb[ trunc(x) div 32, trunc(y) div 16].image;
  // if (img = CONTENT_WATER) or (img = CONTENT_LAVA) then BEGIN
           img := bbb[ trunc(x) div 32, trunc(y) div 16].image;
           if (img = CONTENT_WATER) or (img = CONTENT_LAVA) then result:= true;
   //END;
end;
end;

function isDoubleJumpPossible(sender : TPlayer) : boolean;
var z : integer;
begin
 with sender as TPlayer do begin

z := 9;
   result := false;

   exit;
if (bbb[ trunc(x+z) div 32, trunc(y+24) div 16].block = true) and
   (bbb[ trunc(x+z) div 32, trunc(y+8)  div 16].block = false) then begin
        doublejump := 10;
        playsound(snd_hit,0,0);
        result := true; exit; end;

if (bbb[ trunc(x-z+1) div 32, trunc(y+24) div 16].block = true) and
   (bbb[ trunc(x-z+1) div 32, trunc(y+8)  div 16].block = false) then begin
        doublejump := 10;   
        playsound(snd_hit,0,0);
        result := true; exit; end;

end;
end;

function IsOnground(sender : TPlayer) : boolean;  // this procedure checkz if the player onground
var z : integer;
begin // compare current coordinates via brick matrix;
 with sender as TPlayer do begin

if dead > 0 then z := 0 else z := 9;  // corpses donot stuck on wallz
 if x <= 0 then x := 100; // HACK: crash fix.
 if y <= 0 then y := 100;

if (bbb[ trunc(x-z) div 32, trunc(y+25) div 16].block = true) and
   (bbb[ trunc(x-z) div 32, trunc(y+23) div 16].block = false) then begin result := true; exit; end;
if (bbb[ trunc(x+z) div 32, trunc(y+25) div 16].block = true) and
   (bbb[ trunc(x+z) div 32, trunc(y+23) div 16].block = false) then begin result := true; exit; end;
if (bbb[ trunc(x-z) div 32, trunc(y+24) div 16].block = true) and
   (bbb[ trunc(x-z) div 32, trunc(y+8)  div 16].block = false) then begin result := true; exit; end;
if (bbb[ trunc(x+z) div 32, trunc(y+24) div 16].block = true) and
   (bbb[ trunc(x+z) div 32, trunc(y+8)  div 16].block = false) then begin result := true; exit; end;


// mainform.PowerGraph.Line(trunc(x-z-100), trunc(y+25), trunc(x-z), trunc(y+25),cllime,effectNone);
{
if (bbb[ trunc(x-z) div 32, trunc(y+25) div 16].block = true) and
   (bbb[ trunc(x-z) div 32, trunc(y+16) div 16].block = false) then begin result := true; exit; end;

if (bbb[ trunc(x+z) div 32, trunc(y+25) div 16].block = true) and
   (bbb[ trunc(x+z) div 32, trunc(y+16) div 16].block = false) then begin result := true; exit; end;

if (bbb[ trunc(x+z+2) div 32, trunc(y+25) div 16].block = true) and
   (bbb[ trunc(x+z+2) div 32, trunc(y+23)  div 16].block = false) then begin result := true; exit; end;

if inertiax<0 then
if (bbb[ trunc(x-z-2) div 32, trunc(y+25) div 16].block = true) and
   (bbb[ trunc(x-z-2) div 32, trunc(y+23)  div 16].block = false) then begin result := true; exit; end;
 }
   result := false;
 end;
end;

procedure CorpsePhysic(id : byte);
var   defx : real;
      alph : cardinal;
begin
//                aaa[id].dead := 2;
  //              exit;

        if (aaa[id].spawner = nil) then begin
                aaa[id].dead := 2;
                exit;
        end;

        defx := aaa[id].x;

        // DIE ANIM
        if (aaa[id].weapon=0) and (aaa[id].spawner.dead > 0) then begin
                aaa[id].x := aaa[id].spawner.TESTPREDICT_X;
                aaa[id].y := aaa[id].spawner.TESTPREDICT_y;
                aaa[id].inertiax := aaa[id].spawner.inertiax;
                aaa[id].inertiay := aaa[id].spawner.inertiay;
        end;

        if (aaa[id].cx < OPT_CORPSETIME*50 - 20) then
        if (aaa[id].spawner.dead = 0) then
               aaa[id].weapon := 1;

               if aaa[id].cx >= 25 then alph := 255
               else alph := trunc(aaa[id].cx*10);

              // emulate player dead movement.
               if (aaa[id].dir = 1) or (aaa[id].dir = 3) then
               mainform.PowerGraph.RenderEffectCol(mainform.Images[aaa[id].spawner.die_index], trunc(aaa[id].x-26)+GX, trunc(aaa[id].y-27)+GY+52-aaa[id].spawner.diesizey, 256, (Alph shl 24) +$FFFFFF, aaa[id].frame, 2 or $100) else
               mainform.PowerGraph.RenderEffectCol(mainform.Images[aaa[id].spawner.die_index], trunc(aaa[id].x-26)+GX, trunc(aaa[id].y-27)+GY+52-aaa[id].spawner.diesizey, 256, (Alph shl 24) +$FFFFFF, aaa[id].frame, 2 or $100 or effectMirror);
               if (aaa[id].frame < aaa[id].spawner.dieframes-1) then
               if aaa[id].fallt <= 0 then inc(aaa[id].frame);
               if aaa[id].fallt > 0 then dec(aaa[id].fallt) else aaa[id].fallt := aaa[id].spawner.dieframerefreshtime;

                if aaa[id].cx > 0 then aaa[id].cx := aaa[id].cx-1  else begin
                aaa[id].dead := 2;
                exit;
                end;
{       if MATCH_DDEMOPLAY then begin
        if (players[id].frame < players[id].dieframes-1) then
                if players[id].nextframe <= 0 then inc(players[id].frame);
                if players[id].rewardtime > 0 then if (players[id].frame >= players[id].dieframes-1) then players[id].rewardtime := 0;
                end;
                if players[id].nextframe > 0 then dec(players[id].nextframe) else players[id].nextframe := players[id].framerefreshtime;
                exit;
        end;
 }
        // emulate player physics.
        if aaa[id].objname <> 'corpse' then exit;
        if aaa[id].dead=2 then exit;

        aaa[id].InertiaY := aaa[id].InertiaY + (Gravity*2.8); // --> 10
        if (aaa[id].inertiay > -1) and (aaa[id].inertiay < 0) then aaa[id].inertiay := aaa[id].inertiay/1.11; // progressive inertia
        if (aaa[id].inertiay > 0) and (aaa[id].inertiay < 5)  then aaa[id].inertiay := aaa[id].inertiay*1.1;   // progressive inertia
        if (aaa[id].inertiax < -0.2) or (aaa[id].Inertiax > 0.2) then begin
        try
           if (aaa[id].dir > 1) then begin
           if (isFonground(aaa[id])) then
                aaa[id].InertiaX := aaa[id].InertiaX / 1.14    /// ongroud stop speed.
           else
                aaa[id].InertiaX := aaa[id].InertiaX / 1.025;   // inair stopspeed.
           end;
        except aaa[id].inertiax := 0; end;
        end else aaa[id].inertiax := 0;
        if (isFonground(aaa[id])) then aaa[id].InertiaX := aaa[id].InertiaX / 1.03;   // corpse stop speed.

        aaa[id].x := aaa[id].x + aaa[id].inertiax;
        aaa[id].y := aaa[id].y + aaa[id].inertiay;


   // CLIPPING
  if aaa[id].inertiax < 0 then begin    // check clip wallz.
   if (bbb[ (round(defx - 10) div 32), round(aaa[id].Y-16) div 16].block = true)
   or (bbb[ (round(defx - 10) div 32), round(aaa[id].Y) div 16].block = true)
   or (bbb[ (round(defx - 10) div 32), round(aaa[id].Y+16) div 16].block = true) then begin
        aaa[id].X := trunc(defx/32)*32+9;
        aaa[id].Inertiax := 0;
        end;
   end;
  if aaa[id].inertiax > 0 then begin
   if (bbb[ (round(defx + 10) div 32), round(aaa[id].Y-16) div 16].block = true)
   or (bbb[ (round(defx + 10) div 32), round(aaa[id].Y) div 16].block = true)
   or (bbb[ (round(defx + 10) div 32), round(aaa[id].Y+16) div 16].block = true) then begin
        aaa[id].X := trunc(defx/32)*32+22;
        aaa[id].Inertiax := 0;
        end;
   end;

   if (BrickFOnHead(aaa[id])) and (isFonground(aaa[id])) then begin
        aaa[id].inertiaY := 0;
        aaa[id].Y := (round(aaa[id].Y) div 16) * 16 + 8;
   end else
   if (BrickFOnHead(aaa[id])) and (aaa[id].inertiay < 0) then begin      // fly up
        aaa[id].inertiaY := 0;
        aaa[id].Y := (round(aaa[id].Y) div 16) * 16 + 8;
   end else
   if (isFonground(aaa[id])) and (aaa[id].inertiay > 0)  then begin
        aaa[id].inertiay := 0;
        aaa[id].Y := (round(aaa[id].Y) div 16) * 16 + 8;
   end;

   // water move.
   if (bbb[ trunc(aaa[id].x) div 32, trunc(aaa[id].y) div 16].image = CONTENT_WATER) or
      (bbb[ trunc(aaa[id].x) div 32, trunc(aaa[id].y) div 16].image = CONTENT_LAVA) then begin
           if aaa[id].InertiaY< -1 then aaa[id].InertiaY := -1;
           if aaa[id].InertiaY> 1 then aaa[id].InertiaY := 1;
           if aaa[id].InertiaX< -2 then aaa[id].InertiaX := -2;
           if aaa[id].InertiaX> 2 then aaa[id].InertiaX := 2;
   end else begin //normal move.
           if aaa[id].InertiaY< -5 then aaa[id].InertiaY := -5;
           if aaa[id].InertiaY> 5 then aaa[id].InertiaY := 5;
           if aaa[id].InertiaX< -5 then aaa[id].InertiaX := -5;
           if aaa[id].InertiaX> 5 then aaa[id].InertiaX := 5;
      end;

   if aaa[id].y > 16*250 then aaa[id].dead := 2; //bugfix.

end;

procedure playerphysic(id : byte); // here up and down player physics
var
  defx : real;
  defy : real;
begin

// --!-!-!=!=!= ULTIMATE 3d[Power]'s PHYSIX M0DEL =!=!=!-!-!--

//if (players[id].dead > 1){ and (isonground(players[id]))} then exit;

        defx := players[id].x;
        defy := players[id].y;
        players[id].InertiaY := players[id].InertiaY + (Gravity*2.80); // --> 10


   if (players[id].inertiay > -1) and (players[id].inertiay < 0) then players[id].inertiay := players[id].inertiay/1.11; // progressive inertia
   if (players[id].inertiay > 0) and (players[id].inertiay < 5)  then players[id].inertiay := players[id].inertiay*1.1; // progressive inertia


  if (players[id].inertiax < -0.2) or (players[id].Inertiax > 0.2) then begin
   try
   if (players[id].dir > 1) then begin
        if (isonground(players[id])) then
                players[id].InertiaX := players[id].InertiaX / 1.14    /// ongroud stop speed.
        else
                players[id].InertiaX := players[id].InertiaX / 1.025;   // inair stopspeed.
        end;

   except players[id].inertiax := 0; end;

  end else players[id].inertiax := 0;

   if(players[id].dead > 0 ) and (isonground(players[id])) then  players[id].InertiaX := players[id].InertiaX / 1.03;   // corpse stop speed.

   players[id].x := players[id].x + players[id].inertiax;
   players[id].y := players[id].y + players[id].inertiay;

   // wall CLIPPING

   if players[id].crouch then begin

           //VERTICAL CHECNING
           if (brickcrouchonhead(players[id])) and (isonground(players[id])) then begin
                players[id].inertiaY := 0;
                players[id].crouch := true;
                players[id].Y := (round(players[id].Y) div 16) * 16 + 8;
           end else
           if (brickcrouchonhead(players[id])) and (players[id].inertiay < 0) then begin      // fly up
                players[id].inertiaY := 0;
                players[id].doublejump := 3;
                players[id].crouch := true;
                players[id].Y := (round(players[id].Y) div 16) * 16 + 8;
        //        players[id].y := players[id].Y - round(players[id].InertiaY);
           end else
           if (isonground(players[id])) and (players[id].inertiay > 0)  then begin
                players[id].crouch := true;
                players[id].inertiay := 0;
                players[id].Y := (round(players[id].Y) div 16) * 16 + 8;
           end; // udivitelno ! why this bullshit works?


           // HORZ CHECK
             if players[id].inertiax < 0 then begin    // check clip wallz.
           if (bbb[ (round(defx - 10) div 32), round(players[id].Y-8) div 16].block = true)
           or (bbb[ (round(defx - 10) div 32), round(players[id].Y) div 16].block = true)
           or (bbb[ (round(defx - 10) div 32), round(players[id].Y+16) div 16].block = true) then begin
                players[id].X := trunc(defx/32)*32+9;
                players[id].Inertiax := 0;
                end;
           end;
          if players[id].inertiax > 0 then begin
           if (bbb[ (round(defx + 10) div 32), round(players[id].Y-8) div 16].block = true)
           or (bbb[ (round(defx + 10) div 32), round(players[id].Y) div 16].block = true)
           or (bbb[ (round(defx + 10) div 32), round(players[id].Y+16) div 16].block = true) then begin
                players[id].X := trunc(defx/32)*32+22;
                players[id].Inertiax := 0;
                end;
   end;

   end else begin
          if players[id].inertiax < 0 then begin    // check clip wallz.
           if (bbb[ (round(defx - 10) div 32), round(defy-16) div 16].block = true)
           or (bbb[ (round(defx - 10) div 32), round(defy) div 16].block = true)
           or (bbb[ (round(defx - 10) div 32), round(defy+16) div 16].block = true)
//           or (bbb[ (round(defx - 10) div 32), round(defy+22) div 16].block = true)
        then begin
                players[id].X := trunc(defx/32)*32+9;
                players[id].Inertiax := 0;
                end;
           end;
          if players[id].inertiax > 0 then begin
           if (bbb[ (round(defx + 10) div 32), round(defy-16) div 16].block = true)
           or (bbb[ (round(defx + 10) div 32), round(defy) div 16].block = true)
           or (bbb[ (round(defx + 10) div 32), round(defy+16) div 16].block = true)
//           or (bbb[ (round(defx + 10) div 32), round(defy+22) div 16].block = true)
        then begin
                players[id].X := trunc(defx/32)*32+22;
                players[id].Inertiax := 0;
                end;
           end;
   end;


 //  end else begin
           if (brickonhead(players[id])) and (isonground(players[id])) then begin
                players[id].inertiaY := 0;
                players[id].Y := (round(players[id].Y) div 16) * 16 + 8;
           end else
           if (brickonhead(players[id])) and (players[id].inertiay < 0) then begin      // fly up
                players[id].inertiaY := 0;
                players[id].doublejump := 3;
                players[id].Y := (round(players[id].Y) div 16) * 16 + 8;
        //        players[id].y := players[id].Y - round(players[id].InertiaY);
           end else

           if isonground(players[id]) and (players[id].inertiay > 0) then begin
                players[id].inertiay := 0;
                players[id].Y := (round(players[id].Y) div 16) * 16 + 8;
           end;

{           if (isonground(players[id])) and (players[id].inertiay > 0)  then begin
                players[id].inertiay := 0;
                players[id].Y := (round(players[id].Y) div 16) * 16 + 8;
           end; // udivitelno ! why this bullshit works?

           if (isonground(players[id])) and (players[id].inertiay < 0)  then begin
                players[id].inertiay := 0;
                playsound(snd_hit,0,0);
                players[id].Y := (round(players[id].Y) div 16) * 16 + 8;
           end; // udivitelno ! why this bullshit works?

           }
//   end;

   // WATER\LAVA MOVEMENT
   if IsWaterContent(players[id]) then begin
           if players[id].InertiaY< -1 then players[id].InertiaY := -1;
           if players[id].InertiaY> 1 then players[id].InertiaY := 1;
           if players[id].InertiaX< -2 then players[id].InertiaX := -2;
           if players[id].InertiaX> 2 then players[id].InertiaX := 2;
   end else begin
           if players[id].InertiaY< -5 then players[id].InertiaY := -5;
           if players[id].InertiaY> 5 then players[id].InertiaY := 5;
           if players[id].InertiaX< -5 then players[id].InertiaX := -5;
           if players[id].InertiaX> 5 then players[id].InertiaX := 5;
      end;


   if players[id].y > 16*250 then players[id].y := 16*250-16;

end;

procedure PredictNetworkPlayerPos(id : byte);
var latency, i : integer;
        xxx : real;
        yyy : real;

begin
        if OPT_NETPREDICT = false then Exit;

{        players[ID].TST_X := players[ID].X;
        players[ID].TST_Y := players[ID].Y;
        players[ID].TEN_X := players[ID].X;
        players[ID].TEN_Y := players[ID].Y;
        PLAYERS[ID].TESTPREDICT_X := players[ID].X;
        PLAYERS[ID].TESTPREDICT_Y := players[ID].Y;
}
        if players[id] = nil then exit;
        if ismultip=0 then exit;
        latency := 0;

        if (players[id].netobject=true) and (ismultip=2) then latency := MyPingIS;
        if (players[id].netobject=true) and (ismultip=1) then latency := players[id].ping;

//        if latency < 5 then exit; // heh
        latency := latency div 2;
        if latency > 300 then latency := 300;//max limit.

{
                TST_X, TST_Y - start position
                TEN_X, TEN_Y - end position
                TMT - max ticks available
                CTI - current tick process.
}

{        players[ID].TST_X := players[ID].X;
        players[ID].TST_Y := players[ID].Y;
 }


//                if (dr = 1) or (dr = 3) then
//        mainform.PowerGraph.RenderEffectCol(mainform.Images[players[id].walk_index], trunc(players[id].x -players[id].modelsizex div 2)+GX, trunc(players[id].y-24)+GY,$77FFFFFF,0, effectSrcAlpha or effectDiffuseAlpha);
//                mainform.PowerGraph.RenderEffectCol(mainform.Images[players[id].walk_index], trunc(players[id].x-players[id].modelsizex div 2)+GX, trunc(players[id].y-24)+GY,$77FFFFFF,frm, effectSrcAlpha or effectDiffuseAlpha or effectMirror);


        xxx := players[id].x ;
        yyy := players[id].y ;

        for i := 0 to latency div (20 + abs(round(players[id].inertiax)) + abs(round(players[id].inertiay))) do begin
                playerphysic(id);

{                if abs(xxx-players[id].x)> 4 then begin
//                      addmessage('^1WARNING: player coord interpolation overload!');
                        break;
                        end;
                if abs(yyy-players[id].y)> 8 then begin
//                      addmessage('^1WARNING: player coord interpolation overload!');
                        break;
                        end;
}
        end;

//        addmessage('^1MODIFIED to: '+floattostr(xxx-players[id].x));

{        players[ID].TEN_X := players[ID].X;
        players[ID].TEN_Y := players[ID].Y;

        players[ID].TMT := OPT_SYNC;
        players[ID].CTI := 0;}
end;

procedure setcrosshairpos(f : TPlayer; x,y,h : real;vis : boolean);
var xx,yy : integer;
begin
     if f.dead > 0 then exit;
     if MATCH_DDEMOPLAY then exit;
{     if f.idd=2 then begin // bot;
                ang := round(f.botangle);
                if ang < 0 then ang := 360+ang;
                if ang >= 360 then ang := ang-360;
                f.cx := f.x - CROSHDIST*CosTable[ang];
                f.cy := f.y - CROSHDIST*SinTable[ang];
                exit; // not bot.
        end;
}
     if h > CROSHDIST+CROSHADD then h := CROSHDIST+CROSHADD;
     if h < -CROSHDIST-CROSHADD then h := -CROSHDIST-CROSHADD;

     if f.crouch then
     yy := round(y+3+CROSHDIST*sin(h/64)) else
     yy := round(y-5+CROSHDIST*sin(h/64));

     if (f.dir = 0) or (f.dir = 2) then begin
        xx := round(x-CROSHDIST*cos(h/64));
//        yy := yy + 1;
     end else
     xx := round(x+CROSHDIST*cos(h/64));
     f.cx := xx; f.cy := yy;
end;


procedure RespawnFlash (x,y : real);
var i: integer;
begin
        for i := 0 to 1000 do
        if aaa[i].dead = 2 then begin
        aaa[i].x := x;
        aaa[i].y := y-32;
        aaa[i].frame := 0;
        aaa[i].objname := 'flash';
        aaa[i].dead := 0;
        aaa[i].topdraw := 2;
        aaa[i].dude := false;
        aaa[i].DXID := 0;
        if MATCH_DRECORD then begin
                DData.type0 := DDEMO_FLASH;
                DData.gametic := gametic;
                DData.gametime := gametime;
                DRespawnFlash.x := round(x);
                DRespawnFlash.y := round(y);
                DemoStream.Write( DData, Sizeof(DData));
                DemoStream.Write( DRespawnFlash, Sizeof(DRespawnFlash));
        end;
        exit;
        end;
end;


// more clever respawn point finding.
procedure FindRespawnPointV2 (p : TPlayer);
var can : bOOlean;
    x,y,i,b:word;
    desiredresp,currentresp : byte;
    itisrespawn:boolean;
    REALRESPAWNCOUNT:integer;
begin

        REALRESPAWNCOUNT := RESPAWNS_COUNT;

        if MATCH_GAMETYPE=GAMETYPE_CTF then begin
                x := p.team;
                if x = 2 then x := random(2);
                if x = C_TEAMRED then REALRESPAWNCOUNT := RESPAWNSRED_COUNT;
                if x = C_TEAMBLU then REALRESPAWNCOUNT := RESPAWNSBLUE_COUNT;
        end;

        // if only one respawn point....
        if not MATCH_GAMETYPE=GAMETYPE_CTF then
        if REALRESPAWNCOUNT=1 then
        for x := 0 to BRICK_X-1 do for y := 0 to BRICK_Y-1 do if bbb[x,y].respawntime = -1 then begin
                SPAWNX := x;
                SPAWNY := y;
                exit;
        end;

        if MATCH_GAMETYPE=GAMETYPE_CTF then begin
                if p.team=C_TEAMRED then
                if REALRESPAWNCOUNT=1 then
                for x := 0 to BRICK_X-1 do for y := 0 to BRICK_Y-1 do if bbb[x,y].image = content_respawnred then begin
                SPAWNX := x;
                SPAWNY := y;
                exit;
                end;

                if p.team=C_TEAMBLU then
                if REALRESPAWNCOUNT=1 then
                for x := 0 to BRICK_X-1 do for y := 0 to BRICK_Y-1 do if bbb[x,y].image = content_respawnblue then begin
                SPAWNX := x;
                SPAWNY := y;
                exit;
                end;
        end;

        SPAWNX := 10;
        SPAWNY := 5;
{        s := 'respawning ';
        if p.team=C_TEAMRED then s:=s+' red player. ';
        if p.team=C_TEAMBLU then s:=s+' blue player. ';
        addmessage(s);
        s := '^1RED ^7respawns: '+inttostr(RESPAWNSRED_COUNT)+'   ^4BLUE ^7respawns: '+inttostr(RESPAWNSBLUE_COUNT);
        addmessage(s);
 }
        // 50 - max loop triez
        for i := 0 to 50 do begin
                desiredresp := random(REALRESPAWNCOUNT)+1;
                currentresp := 0;

                for x := 0 to BRICK_X-1 do
                for y := 0 to BRICK_Y-1 do begin

                //respawn selection..
                itisrespawn := false;
                if MATCH_GAMETYPE=GAMETYPE_CTF then begin
                        if (bbb[x,y].image = CONTENT_RESPAWNRED) and (p.team=C_TEAMRED) then itisrespawn := true;
                        if (bbb[x,y].image = CONTENT_RESPAWNBLUE) and (p.team=C_TEAMBLU) then itisrespawn := true;
                        if ((bbb[x,y].image = CONTENT_RESPAWNBLUE) or (bbb[x,y].image = CONTENT_RESPAWNRED)) and (p.team=C_TEAMNON) then itisrespawn := true; // dont care.
                end else if bbb[x,y].respawntime = -1 then
                    itisrespawn := true;

                if itisrespawn then begin
                        inc(currentresp);

                        // check thiz.
                        if desiredresp = currentresp then begin

                                // not tired of finding yet.
                                if i < 50 then begin
                                        // ignore CTF last respawns.
                                        if MATCH_GAMETYPE=GAMETYPE_CTF then begin
                                                if p.team=C_TEAMRED then if currentresp=LASTRESPAWNRED then continue;
                                                if p.team=C_TEAMBLU then if currentresp=LASTRESPAWNBLUE then continue;
                                        end else
                                                if currentresp=LASTRESPAWN then continue;       // do not spawn at last resp.

                                        can := true;
                                        for b := 0 to 7 do if players[b] <> nil then    // do not spawn near players.
                                        if player_region_touch (x,y,x,y, players[b])=true then begin
                                                can := false;
                                                break;
                                                end;
                                        if can=false then continue;
                                        end;

                                // thats here.
                                SPAWNX := x;
                                SPAWNY := y;

                                if MATCH_GAMETYPE=GAMETYPE_CTF then begin
                                        if p.team=C_TEAMRED then LASTRESPAWNRED := currentresp;
                                        if p.team=C_TEAMBLU then LASTRESPAWNBLUE := currentresp;
                                end else
                                        LASTRESPAWN := currentresp;
                                exit;
                                end;
                        end;
                end;
        end;
end;

// choose respawn position
procedure WritePOSUPDATEV3_temp(dx:word);
var stp:byte;
begin
        for stp:= 0 to 7 do if players[stp] <> nil then
        if players[stp].DXID = dx then break;
//              DDEMO NEW FORMAT!
                DData.type0 := DDEMO_PLAYERPOSV3;
                DData.gametic := gametic;
                DData.gametime := gametime;
                DPlayerUpdateV3.DXID := round(players[stp].dxid);
                DPlayerUpdateV3.x := players[stp].x;
                DPlayerUpdateV3.y := players[stp].y;
                DPlayerUpdateV3.inertiax  := players[stp].inertiax;
                DPlayerUpdateV3.Inertiay := players[stp].inertiay;
                DPlayerUpdateV3.PUV3 := 0;
                DPlayerUpdateV3.PUV3B := 0;
                if players[stp].dir=0 then DPlayerUpdateV3.PUV3 := DPlayerUpdateV3.PUV3 + PUV3_DIR0;
                if players[stp].dir=1 then DPlayerUpdateV3.PUV3 := DPlayerUpdateV3.PUV3 + PUV3_DIR1;
                if players[stp].dir=2 then DPlayerUpdateV3.PUV3 := DPlayerUpdateV3.PUV3 + PUV3_DIR2;
                if players[stp].dir=3 then DPlayerUpdateV3.PUV3 := DPlayerUpdateV3.PUV3 + PUV3_DIR3;
                if players[stp].dead=0 then DPlayerUpdateV3.PUV3 := DPlayerUpdateV3.PUV3 + PUV3_DEAD0;
                if players[stp].dead=1 then DPlayerUpdateV3.PUV3 := DPlayerUpdateV3.PUV3 + PUV3_DEAD1;
                if players[stp].dead=2 then DPlayerUpdateV3.PUV3 := DPlayerUpdateV3.PUV3 + PUV3_DEAD2;
                if players[stp].weapon=0 then DPlayerUpdateV3.PUV3 := DPlayerUpdateV3.PUV3 + PUV3_WPN0;
                if players[stp].weapon=1 then DPlayerUpdateV3.PUV3 := DPlayerUpdateV3.PUV3 + PUV3_WPN1;
                if players[stp].weapon=2 then DPlayerUpdateV3.PUV3 := DPlayerUpdateV3.PUV3 + PUV3_WPN2;
                if players[stp].weapon=3 then DPlayerUpdateV3.PUV3 := DPlayerUpdateV3.PUV3 + PUV3_WPN3;
                if players[stp].weapon=4 then DPlayerUpdateV3.PUV3 := DPlayerUpdateV3.PUV3 + PUV3_WPN4;
                if players[stp].weapon=5 then DPlayerUpdateV3.PUV3 := DPlayerUpdateV3.PUV3 + PUV3_WPN5;
                if players[stp].weapon=6 then DPlayerUpdateV3.PUV3 := DPlayerUpdateV3.PUV3 + PUV3_WPN6;
                if players[stp].weapon=7 then DPlayerUpdateV3.PUV3 := DPlayerUpdateV3.PUV3 + PUV3_WPN7;
                if players[stp].weapon=8 then DPlayerUpdateV3.PUV3B := DPlayerUpdateV3.PUV3B + PUV3B_WPN8;
                if players[stp].crouch then DPlayerUpdateV3.PUV3B := DPlayerUpdateV3.PUV3B + PUV3B_CROUCH;
                if players[stp].balloon then DPlayerUpdateV3.PUV3B := DPlayerUpdateV3.PUV3B + PUV3B_BALLOON;

                DPlayerUpdateV3.wpnang := trunc(players[stp].fangle);
                        case players[stp].weapon of
                        1 : DplayerUpdateV3.currammo := players[stp].ammo_mg;
                        2 : DplayerUpdateV3.currammo := players[stp].ammo_sg;
                        3 : DplayerUpdateV3.currammo := players[stp].ammo_gl;
                        4 : DplayerUpdateV3.currammo := players[stp].ammo_rl;
                        5 : DplayerUpdateV3.currammo := players[stp].ammo_sh;
                        6 : DplayerUpdateV3.currammo := players[stp].ammo_rg;
                        7 : DplayerUpdateV3.currammo := players[stp].ammo_pl;
                        8 : DplayerUpdateV3.currammo := players[stp].ammo_bfg;
                        else DplayerUpdateV3.currammo := 0;
                        end;
                DemoStream.Write( DData, Sizeof(DData));
                DemoStream.Write( DPlayerUpdateV3, Sizeof(DPlayerUpdateV3));
end;

procedure FindRespawnPoint (p : TPlayer; net : boolean);
begin

        if net=false then FindRespawnPointV2(p);

        p.x := SPAWNX*32+16;
        p.y := SPAWNY*16-8;
        p.have_mg := true;
        p.weapon := 1;
        p.threadweapon := 1;
        p.refire := 15;
        p.ammo_mg := 100;

        if MATCH_DRECORD then begin
                WritePOSUPDATEV3_temp(p.dxid); // hack :)
                DData.type0 := DDEMO_RESPAWNSOUND;
                DData.gametic := gametic;
                DData.gametime := gametime;
                DRespawnSound.x := round(p.x);
                DRespawnSound.y := round(p.y);
                DemoStream.Write(DData, Sizeof(DData));
                DemoStream.Write(DRespawnSound, Sizeof(DRespawnSound));
        end;

        if (MATCH_GAMETYPE <> GAMETYPE_RAILARENA) then
        if (MATCH_STARTSIN > 1) or (MATCH_GAMETYPE = GAMETYPE_PRACTICE) then begin
                p.armor := OPT_WARMUPARMOR;
                p.have_mg := true;
                if MapWeaponData.shotgun = true then begin
                        p.have_sg := true;
                        p.ammo_sg := 50;
                end;
                if MapWeaponData.grenade = true then begin
                        p.have_gl := true;
                        p.ammo_gl := 25;
                end;
                if MapWeaponData.rocket = true then begin
                        p.have_rl := true;
                        p.ammo_rl := 50;
                end;
                if MapWeaponData.shaft = true then begin
                        p.have_sh := true;
                        p.ammo_sh := 200;
                end;
                if MapWeaponData.rail = true then begin
                        p.have_rg := true;
                        p.ammo_rg := 50;
                end;
                if MapWeaponData.plasma = true then begin
                        p.have_pl := true;
                        p.ammo_pl := 100;
                end;
                if MapWeaponData.bfg = true then begin
                        p.have_bfg := true;
                        p.ammo_bfg := 30;
                end;
        end;

        if MATCH_GAMETYPE = GAMETYPE_RAILARENA then begin
                p.armor := OPT_WARMUPARMOR;
                p.have_mg := false;
                p.ammo_mg := 0;
                p.have_rg := true;
                p.ammo_rg := 100;
                p.armor := 100;
                p.weapon := 6;
                p.threadweapon := 6;
        end;

        if MATCH_GAMETYPE = GAMETYPE_PRACTICE then begin
                p.armor := 200;
                p.health := 200;
                if MapWeaponData.rocket = true then begin
                        p.weapon := 4;
                        p.threadweapon := 4;
                end else
                if MapWeaponData.rail = true then begin
                        p.weapon := 6;
                        p.threadweapon := 6;
                end else begin
                        p.weapon := 1;
                        p.threadweapon := 1;
                        end;
        end;

        if net=false then begin


                if p.x >= 320 then p.dir := 2 else p.dir := 3;
                if BRICK_X > 20 then if p.x >= BRICK_X*16 then p.dir := 2 else p.dir := 3;

                RespawnFlash(spawnx*32,spawny*16);
                if p.netobject=false then
                        playsound(SND_respawn,p.x,p.y);
        end;
end;

{function sqrtt(x : real) : real;
begin
if x = 0 then result := 0 else
if x < 0 then x := -x;
result := sqrt(x);
end;              }

procedure NormalAngle(F : Tplayer);
begin
        if (f.dir = 0) or (f.dir = 2) then
                f.fangle := 180 else
        f.fangle := 64;
end;

procedure resetplayerstats(f : tplayer);
begin
                f.excellent := 0;
                f.impressive := 0;
                f.rewardtime := 0;
                f.stats.stat_impressives := 0;
                f.stats.stat_excellents := 0;
                f.stats.stat_humiliations := 0;
                f.stats.stat_suicide := 0;
                f.stats.stat_kills := 0;
                f.stats.stat_dmggiven := 0;
                f.stats.stat_dmgrecvd := 0;
                f.stats.stat_deaths := 0;
                f.stats.gaun_hits := 0;
                f.stats.mach_kills := 0;
                f.stats.mach_hits := 0;
                f.stats.mach_fire := 0;
                f.stats.shot_kills := 0;
                f.stats.shot_hits := 0;
                f.stats.shot_fire := 0;
                f.stats.gren_kills := 0;
                f.stats.gren_hits := 0;
                f.stats.gren_fire := 0;
                f.stats.rocket_kills := 0;
                f.stats.rocket_hits := 0;
                f.stats.rocket_fire := 0;
                f.stats.shaft_kills := 0;
                f.stats.shaft_hits := 0;
                f.stats.shaft_fire := 0;
                f.stats.rail_kills := 0;
                f.stats.rail_hits := 0;
                f.stats.rail_fire := 0;
                f.stats.plasma_kills := 0;
                f.stats.plasma_hits  := 0;
                f.stats.plasma_fire := 0;
                f.stats.bfg_kills := 0;
                f.stats.bfg_hits  := 0;
                f.stats.bfg_fire := 0;
end;

procedure resetplayer(f : tplayer);
begin
                f.excellent := 0;
                f.gantl_state := 0; // gauntlet not fire;
                f.impressive := 0;
                f.rewardtime := 0;
                f.health := 125; // raise from dead :E~~
                f.armor := 0;
                f.dead := 0;
                f.air := SYS_MAXAIR;
                f.have_rl := false;
                f.have_rg := false;
                f.have_gl := false;
                f.have_sg := false;
                f.have_pl := false;
                f.have_sh := false;
                f.have_bfg := false;
                f.inertiay := 0;
                f.inertiax := 0;
                f.doublejump := 0;
                f.refire := 0;
                f.flagcarrier := false;
              //  if f.netobject=false then f.ping := 0;
                f.item_regen := 0;
                f.item_quad  := 0;
                f.item_battle  := 0;
                f.item_haste  := 0;
                f.item_flight  := 0;
                f.item_invis := 0;
                f.ammo_sg := 0;
                f.ammo_gl := 0;
                f.ammo_rl := 0;
                f.ammo_sh := 0;
                f.ammo_rg := 0;
                f.ammo_pl := 0;
                f.ammo_bfg := 0;
                f.clippixel := 0; //reset crosshair.
                f.keys := 0; // botz....
                f.shaft_state := 0;
                NormalAngle(f);
end;

function ISKEY(key : byte):boolean;
begin
if key=mScrollUp then result := mainform.dxinput.mouse.Z > 0 else
if key=mScrollDn then result := mainform.dxinput.mouse.Z < 0 else
if key=mbutton1 then result := mainform.dxinput.mouse.Buttons[0] else
if key=mbutton2 then result := mainform.dxinput.mouse.Buttons[1] else
if key=mbutton3 then result := mainform.dxinput.mouse.Buttons[2] else
        result := mainform.dxinput.Keyboard.KEYS[key];
end;

procedure BotThink (i : byte);
begin
if players[i].health <= 0 then exit;
if players[i].dead >= 1 then exit;
if random(6)=4 then Fire(players[i],0,0,0);
if players[0].x > players[i].x then players[i].dir := 1 else players[i].dir := 0;
end;
// -----------------------------------------------------------------------------
procedure DoWeapBarEx(F : TPlayer);
begin
        if f = nil then exit;
        if f.netobject then exit;
        if f.idd = 0 then p1weapbar := OPT_P1BARTIME;
        if f.idd = 1 then p2weapbar := OPT_P2BARTIME;
end;
// -----------------------------------------------------------------------------
procedure DoWeapBar(i : byte);
begin
        if players[i] = nil then exit;
        if players[i].idd = 0 then p1weapbar := OPT_P1BARTIME;
        if players[i].idd = 1 then p2weapbar := OPT_P2BARTIME;
end;
// -----------------------------------------------------------------------------
procedure playermove(i : byte);
var Msg: TMP_IamRespawn;
    Msg2: TMP_GauntletState;
    Msg3: TMP_SoundData;
    Msg4: TMP_049t4_ShaftEnd;
    Msg5: TMP_SV_PlayerRespawn;
    MsgSize : word;
    e: integer;
    SPEED:byte;
    nwse:boolean;
begin
        if players[i] = nil then exit;

        if not MATCH_DDEMOPLAY then
        if (players[i].health <= 0) and (players[i].dead = 0) then begin        // kill prayer (ANIM ONLY). and DEAD := 2 herre;
                        players[i].dead := 1; players[i].frame := 0;
                        players[i].respawn := OPT_FORCERESPAWN*50;
                        players[i].gantl_state := 0;
                        players[i].gantl_s := 0;
                        if (MATCH_GAMETYPE=GAMETYPE_TRIXARENA) and (OPT_TRIXMASTA) and (MATCH_STARTSIN=0) then applyHcommand('restart');
                end;

//        if players[i].loadframe>0 then dec(players[i].loadframe) else players[i].loadframe:=23;

        // hack.. fix a bug.
        if players[i].justrespawned >50 then players[i].justrespawned:=50;
        if players[i].justrespawned >0 then dec(players[i].justrespawned);
        if players[i].justrespawned2>0 then dec(players[i].justrespawned2);

        players[i].Location := GetPlayerLocation(I);

        if players[i].netobject = true then begin
                        playerphysic(i);

                        // special timing for net. or demo player.
                        if players[i].shaftsttime>0 then dec(players[i].shaftsttime);
                        if players[i].inlava>0 then dec(players[i].inlava);
                        if players[i].paintime>0 then dec(players[i].paintime);
                        if players[i].hitsnd>0 then dec(players[i].hitsnd);
                        if players[i].rewardtime > 0 then dec(players[i].rewardtime);
                        if players[i].excellent > 0 then dec(players[i].excellent);
                        if players[i].gantl_s > 0 then dec(players[i].gantl_s);
                        if players[i].netnosignal < $FFFF then inc(players[i].netnosignal);
                        if players[i].netnosignal > 150 then players[i].netupdated := False; // kickin, disconnectin, droppin.
                        if players[i].gantl_refire > 0 then dec(players[i].gantl_refire);
                        if players[i].item_quad_time>0 then dec(players[i].item_quad_time);
                        if players[i].item_regen_time> 0 then dec(players[i].item_regen_time);
                        if players[i].item_battle_time> 0 then dec(players[i].item_battle_time);
                        if players[i].item_flight_time> 0 then dec(players[i].item_flight_time);
                        if players[i].item_haste > 0 then begin
                                if players[i].item_haste_time = 0 then begin SpawnSmoke(round(players[i].x),round(players[i].y+20)); players[i].item_haste_time := 5;
                                end
                                else dec(players[i].item_haste_time);
                        end;

                        if players[i].weapon = 0 then begin // gauntlet;

                                if players[i].gantl_state > 0 then
                                if players[i].gantl_refire = 0 then
                                        FireGauntlet(players[i]);

                                if players[i].gantl_state > 0 then
                                if players[i].gantl_s = 0 then begin


                                if players[i].gauntl_s_order=0 then begin
                                        playsound(SND_gauntl_r1,players[i].x,players[i].y);
                                        players[i].gauntl_s_order := 1;
                                end else
                                begin
                                        playsound(SND_gauntl_r2,players[i].x,players[i].y);
                                        players[i].gauntl_s_order := 0;
                                end;

                                        players[i].gantl_s := 12;
                                end;

                                if players[i].gantl_state > 0 then inc(players[i].gantl_state);
                                if players[i].gantl_state > 3 then players[i].gantl_state := 1;
                        end;
                        exit;
        end;

        if (MATCH_GAMEEND) then begin
                playerphysic(i);

                // stop players at gameend.
                if (players[i].InertiaX = 0) and (players[i].InertiaX = 0) then begin
                        if players[i].dir = 0 then players[i].dir := 2;
                        if players[i].dir = 1 then players[i].dir := 3;
                end;
                exit;
        end;

        playerphysic(i);

        // timing
        if players[i].weapchg > 0 then dec(players[i].weapchg);
        if players[i].rewardtime > 0 then dec(players[i].rewardtime);
        if players[i].excellent > 0 then dec(players[i].excellent);
        if players[i].refire > 0 then dec(players[i].refire);
        if players[i].doublejump>0 then dec(players[i].doublejump);
        if players[i].shaftsttime>0 then dec(players[i].shaftsttime);
        if players[i].ammo_snd>0 then dec(players[i].ammo_snd);
        if players[i].inlava>0 then dec(players[i].inlava);
        if players[i].paintime>0 then dec(players[i].paintime);
        if players[i].hitsnd>0 then dec(players[i].hitsnd);
        if players[i].item_quad_time>0 then dec(players[i].item_quad_time);
        if players[i].item_regen_time> 0 then dec(players[i].item_regen_time);
        if players[i].item_battle_time> 0 then dec(players[i].item_battle_time);
        if players[i].item_flight_time> 0 then dec(players[i].item_flight_time);
        if players[i].gantl_s > 0 then dec(players[i].gantl_s);
        if players[i].gantl_refire > 0 then dec(players[i].gantl_refire);

        if not MATCH_DDEMOPLAY then begin// respawn to demo
                if(players[i].dead >= 1) then
                if players[i].respawn > 0 then dec(players[i].respawn);
        end;

        if players[i].dead > 0 then
//        if players[i].ammo_mg <> 255 then
        if players[i].respawn = 0 then begin
//                resetplayer(players[i]);

                if (ismultip=2) and ((players[i].ammo_mg < 255) or (players[i].clientrespawntimeout < gettickcount)) then begin
                        players[i].ammo_mg := 255; // avoid double packed send.
                        MsgSize := SizeOf(TMP_IamRespawn);
                        Msg.Data := MMP_IAMRESPAWN;
                        Msg.DXID := players[i].dxid;
                        mainform.BNETSendData2HOST(Msg, MsgSize,1);
                        players[i].clientrespawntimeout := gettickcount + 3000; // avoid cant respawn bug.
                end else
                if ismultip=1 then begin
                        resetplayer(players[i]);
                        FindRespawnPoint(players[i], false); // setrespawn point here;
                        MsgSize := SizeOf(TMP_SV_PlayerRespawn);
                        Msg5.Data := MMP_PLAYERRESPAWN;
                        Msg5.DXID := players[i].dxid;
                        Msg5.x := SPAWNX;
                        Msg5.y := SPAWNY;
                        mainform.BNETSendData2All(Msg5,MsgSize,1);
                end else if (ismultip<>2) then begin
                        resetplayer(players[i]);
                        FindRespawnPoint(players[i],false); // setrespawn point here;
                end;
        end;

        if players[i].dead > 0 then begin
                if (((ISKEY(CTRL_FIRE) and (players[i].control=1)) or
                   ((ISKEY(CTRL_P2FIRE)) and (players[i].control=2)))) or
                   ((players[i].idd = 2) and (players[i].keys and BKEY_FIRE=BKEY_FIRE))
                   then
                   if players[i].respawn >= 3 then
                   if players[i].respawn < OPT_FORCERESPAWN*50 - OPT_MINRESPAWNTIME then begin
                        players[i].respawn := 2;
                        players[i].refire := 25;
                   end;
                exit;
        end;

        if (players[i].idd <>2) then
        if (INCONSOLE) or (INGAMEMENU) then begin
                ClipTriggers(players[i]);
                if players[i].dir < 2 then players[i].dir := players[i].dir+2;
                setcrosshairpos(players[i], trunc(players[i].x),trunc(players[i].y), players[i].clippixel,true);
                exit;
        end;


{       if isparamstr('-showinput') then begin
       for e := 1 to 255 do
                if mainform.dxinput.Keyboard.Keys [e] then addmessage('KEY-'+chr(e)+'-'+inttostr(e));
       end;
}

       if MATCH_DDEMOPLAY then exit;


       if (players[i].control = 1) then begin     // up and down crosshair height; crossheight var is used as clippixel
                if (OPT_P1MOUSELOOK) then begin

                       if OPT_MROTATED=false then begin
                               e := mainform.dxinput.Mouse.y;
                               if OPT_MINVERT then e:=-e;
                               end else begin
                               e := mainform.dxinput.Mouse.x;
                               if OPT_MINVERT then e:=-e;
                       end;

                       if e > 0 then begin
                        if OPT_MOUSESMOOTH > 0 then
                        if e > 0 then if e > OPT_MOUSESMOOTH then e := OPT_MOUSESMOOTH;
                        players[i].clippixel := players[i].clippixel + round(e / (10-OPT_SENS)) + round(e * OPT_MOUSEACCELDELIM/(10-OPT_SENS) / 10);
                        if players[i].clippixel > CROSHDIST+CROSHADD then players[i].clippixel := CROSHDIST+CROSHADD;
                       end;

                       if e < 0 then begin

                        if OPT_MOUSESMOOTH > 0 then
                        if e < 0 then if e < -OPT_MOUSESMOOTH then e := -OPT_MOUSESMOOTH;
                        players[i].clippixel := players[i].clippixel + round(e / (10-OPT_SENS)) + round(e * OPT_MOUSEACCELDELIM/(10-OPT_SENS) / 10);
                        if players[i].clippixel < -CROSHDIST-CROSHADD then players[i].clippixel := -CROSHDIST-CROSHADD;
                       end;
                end;

//                if (not (OPT_P1MOUSELOOK)) OR (NOT((ISKEY(CTRL_LOOKUP) and ISKEY(CTRL_LOOKDOWN)) then
//                if not ) then
                if not (OPT_P1MOUSELOOK) THEN
                IF NOT (ISKEY(CTRL_LOOKUP) and ISKEY(CTRL_LOOKDOWN)) THEN
                begin
                        if OPT_P1KEYBACCELDELIM > 0 then begin
                        if ISKEY(CTRL_LOOKUP) then begin dec(players[i].clippixel,OPT_SENS+pkeyaccel div (10-OPT_P1KEYBACCELDELIM)); if pkeyaccel1 = 1 then inc(pkeyaccel) else pkeyaccel := 0; pkeyaccel1 := 1;end else
                        if ISKEY(CTRL_LOOKDOWN) then begin inc(players[i].clippixel,OPT_SENS+pkeyaccel div (10-OPT_P1KEYBACCELDELIM)); if pkeyaccel1 = 0 then inc(pkeyaccel) else pkeyaccel := 0; pkeyaccel1 := 0;end else pkeyaccel := 0;
                        if pkeyaccel > (10-OPT_P1KEYBACCELDELIM)*10 then pkeyaccel := (10-OPT_P1KEYBACCELDELIM)*10;
                        end else begin
                                if ISKEY(CTRL_LOOKUP)  then begin dec(players[i].clippixel,OPT_SENS) end else
                                if ISKEY(CTRL_LOOKDOWN) then begin inc(players[i].clippixel,OPT_SENS) end;
                        end;
                        if players[i].clippixel >  CROSHDIST+CROSHADD then players[i].clippixel :=  CROSHDIST+CROSHADD;
                        if players[i].clippixel < -CROSHDIST-CROSHADD then players[i].clippixel := -CROSHDIST-CROSHADD;
                end;

                if ISKEY(CTRL_CENTER) then begin
                        pkeyaccel := 0;
                        players[i].clippixel := 0;
                end;
       end;

       if (players[i].control = 2) and (players[i].netobject = false) then
       if not (ISKEY(CTRL_P2LOOKUP) and ISKEY(CTRL_P2LOOKDOWN)) then
       begin  // local second prayer. keyboard.

                if OPT_KEYBACCELDELIM > 0 then begin
                if ISKEY(CTRL_P2LOOKUP) then begin dec(players[i].clippixel,OPT_KSENS+keyaccel div (10-OPT_KEYBACCELDELIM)); if keyaccel1 = 1 then inc(keyaccel) else keyaccel := 0; keyaccel1 := 1;end else
                if ISKEY(CTRL_P2LOOKDOWN) then begin inc(players[i].clippixel,OPT_KSENS+keyaccel div (10-OPT_KEYBACCELDELIM)); if keyaccel1 = 0 then inc(keyaccel) else keyaccel := 0; keyaccel1 := 0;end else keyaccel := 0;
                if keyaccel > (10-OPT_KEYBACCELDELIM)*10 then keyaccel := (10-OPT_KEYBACCELDELIM)*10;
                end else begin
                        if ISKEY(CTRL_P2LOOKUP)  then begin dec(players[i].clippixel,OPT_KSENS) end else
                        if ISKEY(CTRL_P2LOOKDOWN) then begin inc(players[i].clippixel,OPT_KSENS) end;
                end;
                if players[i].clippixel >  CROSHDIST+CROSHADD then players[i].clippixel :=  CROSHDIST+CROSHADD;
                if players[i].clippixel < -CROSHDIST-CROSHADD then players[i].clippixel := -CROSHDIST-CROSHADD;
       end;

       if (players[i].control = 2) then
       if ISKEY(CTRL_P2CENTER) then begin
                keyaccel := 0;
                players[i].clippixel := 0;
       end;


        if (isonground(players[i])) then players[i].inertiay := 0; // really nice thing :)

       // team movement block.
       if TeamGame then
        if SYS_TEAMSELECT>0 then exit;

   if  (( (ISKEY(CTRL_MOVEUP)) and (players[i].control=1)) or ((ISKEY(CTRL_P2MOVEUP)) and (players[i].control=2)))
       or ( (players[i].idd=2) and (players[i].keys and BKEY_MOVEUP = BKEY_MOVEUP) ) // bot
        then      // JUMP!
        begin

        if (IsWaterContent(players[i])) or (IsWaterContentJUMP(players[i])) then begin
                players[i].inertiay := -1.5;
        end else

        if (isonground(players[i]) = false) and (brickonhead(players[i]) = false) and (players[i].item_flight > 0) then begin
                        players[i].inertiay := -2;
                        players[i].crouch := false;
                        if players[i].item_flight_time = 0 then begin
                                playsound(SND_flight,players[i].x,players[i].y);
                                players[i].item_flight_time := 35;

                                if ismultip>0 then begin
                                        MsgSize := SizeOf(TMP_SoundData);
                                        Msg3.Data := MMP_SENDSOUND;
                                        Msg3.DXID := players[i].dxid;
                                        Msg3.SoundType := 1; // flight code;
                                        if ismultip=1 then
                                        mainform.BNETSendData2All(Msg3, MsgSize, 0) else
                                        mainform.BNETSendData2HOST(Msg3, MsgSize, 0);
                                end;

                                if MATCH_DRECORD then begin
                                        DData.type0 := DDEMO_FLIGHTSOUND;
                                        DData.gametic := gametic;
                                        DData.gametime := gametime;
                                        DFlightSound.x := round(players[i].x);
                                        DFlightSound.y := round(players[i].y);
                                        DemoStream.Write( DData, Sizeof(DData));
                                        DemoStream.Write( DFlightSound, Sizeof(DFlightSound));
                                end;
                        end;

                end ELSE

        if ( (isonground(players[i])) or (isDoubleJumpPossible(players[i]))   ) and (brickonhead(players[i]) = false) then begin
                if(players[i].doublejump > 4) then // double jumpz
                begin
                        players[i].doublejump := 14;
                        players[i].inertiay := -3;
                        players[i].crouch := false;
                end else begin
                        if players[i].doublejump = 0 then
                        begin
                                players[i].doublejump := 14;
                                playsound(players[i].SND_Jump,players[i].x,players[i].y);

                                if ismultip>0 then begin
                                        MsgSize := SizeOf(TMP_SoundData);
                                        Msg3.Data := MMP_SENDSOUND;
                                        Msg3.DXID := players[i].dxid;
                                        Msg3.SoundType := 0; // jump code;
                                        if ismultip=1 then
                                        mainform.BNETSendData2All(Msg3, MsgSize, 0) else
                                        mainform.BNETSendData2HOST(Msg3, MsgSize, 0);
                                end;

                                if MATCH_DRECORD then begin
                                        DData.type0 := DDEMO_JUMPSOUND;
                                        DData.gametic := gametic;
                                        DData.gametime := gametime;
                                        DPlayerJump.dxid := players[i].dxid;
                                        DemoStream.Write( DData, Sizeof(DData));
                                        DemoStream.Write( DPlayerJump, Sizeof(DPlayerJump));
                                end;
                        end;
                        if CON_SIMPLEPHYSICS = true then players[i].inertiay := -2.9 else players[i].inertiay := -2;
                end;
        end;
        end;

        // CROUCH
        if not (( (ISKEY(CTRL_MOVEUP)) and (players[i].control=1)) or ((ISKEY(CTRL_P2MOVEUP)) and (players[i].control=2))) then
        if ((ISKEY(CTRL_MOVEDOWN) and (players[i].control=1)) or
           ((ISKEY(CTRL_P2MOVEDOWN)) and (players[i].control=2))) then begin
                if (IsOnground(players[i])) then
                        players[i].crouch := true;
           end else if not BrickCrouchOnHead(players[i]) then players[i].crouch := false;


        // bot crouch..& wpn change. fire
        if players[i].idd = 2 then begin

                if players[i].keys and BKEY_MOVEUP <> BKEY_MOVEUP then
                if players[i].keys and BKEY_MOVEDOWN = BKEY_MOVEDOWN then begin
                if (IsOnground(players[i])) then
                       players[i].crouch := true;
                end else if not BrickCrouchOnHead(players[i]) then players[i].crouch := false;

                if (players[i].refire = 0) and (players[i].weapon <> players[i].threadweapon) then
                        players[i].weapon := players[i].threadweapon;

                if players[i].refire = 0 then
                if players[i].keys and BKEY_FIRE = BKEY_FIRE then
                        Fire(players[i],players[i].x,players[i].y,90);
        end;


        if (BrickCrouchOnHead(players[i])=false) and (IsOnground(players[i])=false) then players[i].crouch := false;

     if OPT_TREADWEAPON then begin
        if (players[i].refire = 0) and (players[i].weapon <> players[i].threadweapon) then begin
                players[i].weapon := players[i].threadweapon;
                DoWeapBar(i);
                end;
     end;

        // player fire
        if players[i].weapchg = 0 then
        if ((ISKEY(CTRL_FIRE) and (players[i].control=1)) or
           ((ISKEY(CTRL_P2FIRE)) and (players[i].control=2))) then begin
                if players[i].refire = 0 then Fire(players[i],players[i].x,players[i].y,90);

        // Disable Shaft Firing.
        end else if players[i].shaft_state > 0 then begin
                players[i].shaft_state := 0;

//                addmessage('^5SEND: MMP_049test4_SHAFT_END');
                if (ismultip>0) then begin
                        MsgSize := SizeOf(TMP_049t4_ShaftEnd);
                        Msg4.Data := MMP_049test4_SHAFT_END;
                        Msg4.DXID := players[i].dxid;

                        if ismultip=2 then
                        mainform.BNETSendData2HOST(Msg4, MsgSize,0) else
                        mainform.BNETSendData2All(Msg4, MsgSize,0);
                end;

                if MATCH_DRECORD then begin
                        DData.type0 := DDEMO_NEW_SHAFTEND;
                        DData.gametic := gametic;
                        DData.gametime := gametime;
//                        addmessage('recording: DDEMO_NEW_SHAFTEND');
                        D_049t4_ShaftEnd.DXID := players[i].DXID;
                        DemoStream.Write(DData, Sizeof(DData));
                        DemoStream.Write(D_049t4_ShaftEnd, Sizeof(D_049t4_ShaftEnd));
                end;
        end;

        // disable gauntlet BZZZZZZZ.
        if (players[i].refire = 0) then if players[i].gantl_state > 0 then begin

                        players[i].gantl_state := 0;

                        // send gauntlet off packet
                        if ismultip>0 then
                        if (players[i].netobject =false) then begin
                                MsgSize := SizeOf(TMP_GauntletState);
                                Msg2.DATA := MMP_GAUNTLETSTATE;
                                Msg2.DXID := Players[i].DXID;
                                Msg2.state := false;    // off gauntlet
                                if ismultip=1 then
                                mainform.BNETSendData2All(Msg2,MsgSize,0) else
                                mainform.BNETSendData2HOST(Msg2,MsgSize,0);
                        end;

                        if MATCH_DRECORD then begin
                                DData.type0 := DDEMO_GAUNTLETSTATE;
                                DData.gametic := gametic;
                                DData.gametime := gametime;
                                DGauntletState.DXID := players[i].DXID;
                                DGauntletState.State := 0;
                                DemoStream.Write( DData, Sizeof(DData));
                                DemoStream.Write( DGauntletState, Sizeof(DGauntletState));
                        end;

        end;


        // next weapon
        if ((ISKEY(CTRL_NEXTWEAPON)) and (players[i].control=1) and (players[i].weapchg = 0)) or // nextweapon
           ((ISKEY(CTRL_P2NEXTWEAPON)) and (players[i].control=2) and (players[i].weapchg = 0)) then begin

                if players[i].control=1 then
                        nwse := OPT_P1NEXTWPNSKIPEMPTY
                else if players[i].control=2 then
                        nwse := OPT_P2NEXTWPNSKIPEMPTY;

                with players[i] do begin
                inc(threadweapon);
                if (threadweapon = 1) and ((have_mg = false) or ((ammo_mg=0) and (nwse=true)) ) then inc(threadweapon);
                if (threadweapon = 2) and ((have_sg = false) or ((ammo_sg=0) and (nwse=true)) ) then inc(threadweapon);
                if (threadweapon = 3) and ((have_gl = false) or ((ammo_gl=0) and (nwse=true)) ) then inc(threadweapon);
                if (threadweapon = 4) and ((have_rl = false) or ((ammo_rl=0) and (nwse=true)) ) then inc(threadweapon);
                if (threadweapon = 5) and ((have_sh = false) or ((ammo_sh=0) and (nwse=true)) ) then inc(threadweapon);
                if (threadweapon = 6) and ((have_rg = false) or ((ammo_rg=0) and (nwse=true)) ) then inc(threadweapon);
                if (threadweapon = 7) and ((have_pl = false) or ((ammo_pl=0) and (nwse=true)) ) then inc(threadweapon);
                if (threadweapon = 8) and ((have_bfg = false) or ((ammo_bfg=0) and (nwse=true)) ) then inc(threadweapon);
                if threadweapon > 8 then begin // gauntlet toggle.
                        if (have_sg=false) and (have_gl=false) and (have_rl=false) and (have_sh=false) and (have_rg=false) and (have_pl=false) and (have_bfg=false) then
                        threadweapon := 0 else begin
                                threadweapon := 0;//hheh
                                if MATCH_GAMETYPE <> GAMETYPE_RAILARENA then begin
                                        if players[i].control = 1 then if not OPT_P1GAUNTLETNEXTWPN then threadweapon := 1;
                                        if players[i].control = 2 then if not OPT_P2GAUNTLETNEXTWPN then threadweapon := 1;
                                end;
                                end;
                        end;
                if threadweapon <> C_WPN_SHAFT then players[i].shaft_state := 0; 
                DoWeapBar(i);
                weapchg := 10;
                end;
        end;

        // prev weapon
        if ((ISKEY(CTRL_PREVWEAPON)) and (players[i].control=1) and (players[i].weapchg = 0)) or // nextweapon
           ((ISKEY(CTRL_P2PREVWEAPON)) and (players[i].control=2) and (players[i].weapchg = 0)) then begin
                with players[i] do begin
                if threadweapon=0 then threadweapon := 8 else
                dec(threadweapon);

                if threadweapon = 0 then begin // gauntlet toggle.
                        if (have_sg=false) and (have_gl=false) and (have_rl=false) and (have_sh=false) and (have_rg=false) and (have_pl=false) and (have_bfg=false) then
                                        threadweapon := 0
                                else begin
                                        threadweapon := 0;//hheh
                                        if MATCH_GAMETYPE <> GAMETYPE_RAILARENA then begin
                                                if players[i].control = 1 then if not OPT_P1GAUNTLETNEXTWPN then threadweapon := 8;
                                                if players[i].control = 2 then if not OPT_P2GAUNTLETNEXTWPN then threadweapon := 8;
                                        end;
                                end;
                        end;

                if players[i].control=1 then
                        nwse := OPT_P1NEXTWPNSKIPEMPTY
                else if players[i].control=2 then
                        nwse := OPT_P2NEXTWPNSKIPEMPTY;

                if (threadweapon = 8) and ((have_bfg = false) or ((ammo_bfg=0) and (nwse=true)) )  then dec(threadweapon);
                if (threadweapon = 7) and ((have_pl = false) or ((ammo_pl=0) and (nwse=true)) ) then dec(threadweapon);
                if (threadweapon = 6) and ((have_rg = false) or ((ammo_rg=0) and (nwse=true)) ) then dec(threadweapon);
                if (threadweapon = 5) and ((have_sh = false) or ((ammo_sh=0) and (nwse=true)) ) then dec(threadweapon);
                if (threadweapon = 4) and ((have_rl = false) or ((ammo_rl=0) and (nwse=true)) ) then dec(threadweapon);
                if (threadweapon = 3) and ((have_gl = false) or ((ammo_gl=0) and (nwse=true)) ) then dec(threadweapon);
                if (threadweapon = 2) and ((have_sg = false) or ((ammo_sg=0) and (nwse=true)) ) then dec(threadweapon);
                if (threadweapon = 1) and ((have_mg = false) or ((ammo_mg=0) and (nwse=true)) ) then dec(threadweapon);
                DoWeapBar(i);
                weapchg := 10;
                end;
        end;

       //weaponz
       if ((ISKEY(CTRL_WEAPON0)) and (players[i].control=1) and (players[i].weapchg = 0)) then begin DoWeapBar(i); players[i].weapchg := 10; players[i].threadweapon := 0; end;
       if ((ISKEY(CTRL_WEAPON1)) and (players[i].control=1) and (players[i].weapchg = 0)) and (players[i].have_mg = true) then begin DoWeapBar(i); players[i].weapchg := 10; players[i].threadweapon := 1; end;
       if ((ISKEY(CTRL_WEAPON2)) and (players[i].control=1) and (players[i].weapchg = 0)) and (players[i].have_sg = true) then begin DoWeapBar(i); players[i].weapchg := 10; players[i].threadweapon := 2; end;
       if ((ISKEY(CTRL_WEAPON3)) and (players[i].control=1) and (players[i].weapchg = 0)) and (players[i].have_gl = true) then begin DoWeapBar(i); players[i].weapchg := 10; players[i].threadweapon := 3; end;
       if ((ISKEY(CTRL_WEAPON4)) and (players[i].control=1) and (players[i].weapchg = 0)) and (players[i].have_rl = true) then begin DoWeapBar(i); players[i].weapchg := 10; players[i].threadweapon := 4; end;
       if ((ISKEY(CTRL_WEAPON5)) and (players[i].control=1) and (players[i].weapchg = 0)) and (players[i].have_sh = true) then begin DoWeapBar(i); players[i].weapchg := 10; players[i].threadweapon := 5; end;
       if ((ISKEY(CTRL_WEAPON6)) and (players[i].control=1) and (players[i].weapchg = 0)) and (players[i].have_rg = true) then begin DoWeapBar(i); players[i].weapchg := 10; players[i].threadweapon := 6; end;
       if ((ISKEY(CTRL_WEAPON7)) and (players[i].control=1) and (players[i].weapchg = 0)) and (players[i].have_pl = true) then begin DoWeapBar(i); players[i].weapchg := 10; players[i].threadweapon := 7; end;
       if ((ISKEY(CTRL_WEAPON8)) and (players[i].control=1) and (players[i].weapchg = 0)) and (players[i].have_bfg = true) then begin DoWeapBar(i); players[i].weapchg := 10; players[i].threadweapon := 8; end;
       if ((ISKEY(CTRL_P2WEAPON0)) and (players[i].control=2) and (players[i].weapchg = 0)) then begin DoWeapBar(i); players[i].weapchg := 10; players[i].threadweapon := 0; end;
       if ((ISKEY(CTRL_P2WEAPON1)) and (players[i].control=2) and (players[i].weapchg = 0)) and (players[i].have_mg = true) then begin DoWeapBar(i); players[i].weapchg := 10; players[i].threadweapon := 1; end;
       if ((ISKEY(CTRL_P2WEAPON2)) and (players[i].control=2) and (players[i].weapchg = 0)) and (players[i].have_sg = true) then begin DoWeapBar(i); players[i].weapchg := 10; players[i].threadweapon := 2; end;
       if ((ISKEY(CTRL_P2WEAPON3)) and (players[i].control=2) and (players[i].weapchg = 0)) and (players[i].have_gl = true) then begin DoWeapBar(i); players[i].weapchg := 10; players[i].threadweapon := 3; end;
       if ((ISKEY(CTRL_P2WEAPON4)) and (players[i].control=2) and (players[i].weapchg = 0)) and (players[i].have_rl = true) then begin DoWeapBar(i); players[i].weapchg := 10; players[i].threadweapon := 4; end;
       if ((ISKEY(CTRL_P2WEAPON5)) and (players[i].control=2) and (players[i].weapchg = 0)) and (players[i].have_sh = true) then begin DoWeapBar(i); players[i].weapchg := 10; players[i].threadweapon := 5; end;
       if ((ISKEY(CTRL_P2WEAPON6)) and (players[i].control=2) and (players[i].weapchg = 0)) and (players[i].have_rg = true) then begin DoWeapBar(i); players[i].weapchg := 10; players[i].threadweapon := 6; end;
       if ((ISKEY(CTRL_P2WEAPON7)) and (players[i].control=2) and (players[i].weapchg = 0)) and (players[i].have_pl = true) then begin  DoWeapBar(i); players[i].weapchg := 10; players[i].threadweapon := 7; end;
       if ((ISKEY(CTRL_P2WEAPON8)) and (players[i].control=2) and (players[i].weapchg = 0)) and (players[i].have_bfg = true) then begin DoWeapBar(i); players[i].weapchg := 10; players[i].threadweapon := 8; end;


        ClipTriggers(players[i]);

        if (players[i].control=1) then begin
                if (ISKEY(CTRL_MOVELEFT)) and (ISKEY(CTRL_MOVERIGHT)) then begin
                if players[i].dir < 2 then players[i].dir := players[i].dir+2;
                exit;
                end;
        end;

        if (players[i].control = 2) then begin
        if (ISKEY(CTRL_P2MOVELEFT)) and (ISKEY(CTRL_P2MOVERIGHT)) then begin
                if players[i].dir < 2 then players[i].dir := players[i].dir+2;
                exit;
                end;
        end;


        if players[i].item_haste > 0 then begin
                        if players[i].item_haste_time = 0 then begin SpawnSmoke(round(players[i].x),round(players[i].y+20)); players[i].item_haste_time := 5;
                end
                        else dec(players[i].item_haste_time);
        end;

        if players[i].dir < 2 then
                players[i].dir := players[i].dir+2;

if (((ISKEY(CTRL_MOVELEFT)) and (players[i].control=1)) or ((ISKEY(CTRL_P2MOVELEFT)) and (players[i].control=2)))
       or ( (players[i].idd=2) and (players[i].keys and BKEY_MOVELEFT = BKEY_MOVELEFT) )  then begin


//      if players[i].inertiax > -1 then players[i].inertiax := -1;

      SPEED := PLAYERMAXSPEED;
      if players[i].crouch=true then SPEED := PLAYERMAXSPEED-1;
      if players[i].item_haste>0 then SPEED := SPEED+1;

      if players[i].inertiax > 0 then players[i].inertiax := players[i].inertiax - 0.8;
      if players[i].inertiax > -SPEED then players[i].inertiax := players[i].inertiax - 0.35;
      if players[i].inertiax < -SPEED then players[i].inertiax := -SPEED;
      players[i].dir := 0;
      end;

    if (((ISKEY(CTRL_MOVERIGHT)) and (players[i].control=1)) or ((ISKEY(CTRL_P2MOVERIGHT)) and (players[i].control=2)))
       or ( (players[i].idd=2) and (players[i].keys and BKEY_MOVERIGHT = BKEY_MOVERIGHT) ) then begin

      SPEED := PLAYERMAXSPEED;
      if players[i].crouch=true then SPEED := PLAYERMAXSPEED-1;
      if players[i].item_haste>0 then SPEED := SPEED+1;

      if players[i].inertiax < 0 then players[i].inertiax := players[i].inertiax + 0.8;
      if players[i].inertiax < SPEED then players[i].inertiax := players[i].inertiax + 0.35;
      if players[i].inertiax > SPEED then players[i].inertiax := SPEED;
      players[i].dir := 1;

    end;

{      if (OPT_MOUSEANGRY) and (players[i].control=1) then begin
                if mainform.PowerInput.mDeltaX > 25 then players[i].dir := 1;
                if mainform.PowerInput.mDeltaX < -25 then players[i].dir := 0;
      end;
}
end;


function WPN_GainWeapon(f : TPlayer; wpnindex:byte) : boolean;
begin
        if MATCH_DDEMOPLAY then exit;
        case wpnindex of
        C_WPN_SHOTGUN:begin
                result := not f.have_sg;
                f.have_sg := true;
                AddAmmo(F, wpnindex, 10);
                end;
        C_WPN_GRENADE:begin
                result := not f.have_gl;
                f.have_gl := true;
                AddAmmo(F, wpnindex, 10);
                end;
        C_WPN_ROCKET:begin
                result := not f.have_rl;
                f.have_rl := true;
                AddAmmo(F, wpnindex, 10);
                end;
        C_WPN_SHAFT:begin
                result := not f.have_sh;
                f.have_sh := true;
                AddAmmo(F, wpnindex, 130);
                end;
        C_WPN_RAIL:begin
                result := not f.have_rg;
                f.have_rg := true;
                AddAmmo(F, wpnindex, 10);
                end;
        C_WPN_PLASMA:begin
                result := not f.have_pl;
                f.have_pl := true;
                AddAmmo(F, wpnindex, 50);
                end;
        C_WPN_BFG:begin
                result := not f.have_bfg;
                f.have_bfg := true;
                AddAmmo(F, wpnindex, 15);
                end;
        end;
end;

//==

procedure WPN_CLNETWORK_DropWeapon(PacketType : byte; Data: Pointer);
var z:byte;
    i:word;
begin
        if ismultip <> 2 then exit;

//        addmessage('^5WPN_CLNETWORK_DropWeapon #'+inttostr(TMP_WPN_DropWeapon(Data^).DropperDXID));

        if PacketType = MMP_WPN_EVENT_WEAPONDROP then
                for z := 0 to 7 do if players[z] <> nil then
                        if (players[z].dxid = TMP_WPN_DropWeapon(Data^).DropperDXID) then
                                break;

        for i := 0 to 1000 do begin

        if PacketType = MMP_WPN_EVENT_WEAPONDROP then if (aaa[i].dead = 0) and (aaa[i].objname = 'weapon') and (aaa[i].DXID = TMP_WPN_DropWeapon(Data^).DXID) then exit; // this is dublicate;

        if aaa[i].dead = 2 then begin
                aaa[i].objname := 'weapon';
                aaa[i].x    := TMP_WPN_DropWeapon(Data^).X;
                aaa[i].y    := TMP_WPN_DropWeapon(Data^).Y;
                aaa[i].DXID := TMP_WPN_DropWeapon(Data^).DXID;
                aaa[i].dead := 0;
                aaa[i].dude := true;
                aaa[i].topdraw := 0;
                aaa[i].frame := 0;
                aaa[i].mass := 5;
                aaa[i].weapon := 0;
                aaa[i].fangle := TMP_WPN_DropWeapon(Data^).DropperDXID; //that should work..
                aaa[i].health := 50*60 + 50*10;
                // one minute. + 10 sec.. (cuz networked removal).

                if z > 7 then z := 0;

                if PacketType = MMP_WPN_EVENT_WEAPONDROP then begin
                        if players[z] <> nil then if (players[z].dir=0) or (players[z].dir=2) then aaa[i].dir := 0 else aaa[i].dir := 1;
                end else
                        aaa[i].dir := random(2);

                aaa[i].inertiax := TMP_WPN_DropWeapon(Data^).Inertiax;
                aaa[i].inertiay := TMP_WPN_DropWeapon(Data^).Inertiay;
                aaa[i].clippixel := 4;
                aaa[i].imageindex := TMP_WPN_DropWeapon(Data^).WeaponID;

                if MATCH_DRECORD then WPN_Event_WeaponDrop(aaa[i]);
                exit;
        end;
        end;
end;

procedure WPN_DEMO_DropWeapon();
var z:byte;
    i:word;
begin
//        addmessage('PROC: ^3CTF_DEMO_DropFlag');
        if not MATCH_DDEMOPLAY then exit;

        if DData.type0 = DDEMO_WPN_EVENT_WEAPONDROP then
                for z := 0 to 7 do if players[z] <> nil then
                        if (players[z].dxid = DWPN_DropWeapon.DropperDXID) then
                                break;

        for i := 0 to 1000 do
        if aaa[i].dead = 2 then begin
                aaa[i].objname := 'weapon';
                aaa[i].x := DWPN_DropWeapon.X;
                aaa[i].y := DWPN_DropWeapon.Y;
                aaa[i].DXID := DWPN_DropWeapon.DXID;
                aaa[i].dead := 0;
                aaa[i].dude := true;
                aaa[i].topdraw := 1;
                aaa[i].frame := 0;
                aaa[i].mass := 5;
                aaa[i].weapon := 0;
                aaa[i].health := 50*60 + 50*10; // one minute. + 10 sec.. (cuz networked removal).

                if (DData.type0 = DDEMO_WPN_EVENT_WEAPONDROP) then begin
                        if (players[z].dir=0) or (players[z].dir=2) then
                        aaa[i].dir := 0 else aaa[i].dir := 1;
                end else
                        aaa[i].dir := random(2);
                aaa[i].imageindex := DWPN_DropWeapon.WeaponID;
                aaa[i].inertiax := DWPN_DropWeapon.Inertiax;
                aaa[i].inertiay := DWPN_DropWeapon.Inertiay;
                aaa[i].clippixel := 4;
                exit;
        end;
end;

// player weapon drop. save to demo.
procedure WPN_Event_WeaponDrop(sender : TMonoSprite);
var Msg: TMP_WPN_DropWeapon;
    MsgSize: word;
begin
        if MATCH_DRECORD then begin // player Weapondrop. save to demo.
                DData.type0 := DDEMO_WPN_EVENT_WEAPONDROP;
                DData.gametic := gametic;
                DData.gametime := gametime;
                DemoStream.Write( DData, Sizeof(DData));

                DWPN_DropWeapon.DXID := sender.DXID;
                DWPN_DropWeapon.DropperDXID := trunc(sender.fangle);
                DWPN_DropWeapon.WeaponID := sender.imageindex;
                DWPN_DropWeapon.X := sender.x;
                DWPN_DropWeapon.Y := sender.y;
                DWPN_DropWeapon.Inertiax := sender.InertiaX;
                DWPN_DropWeapon.Inertiay := sender.InertiaY;
                DemoStream.Write(DWPN_DropWeapon,Sizeof(DWPN_DropWeapon));
        end;

        if ismultip = 1 then begin
                MsgSize := SizeOf(TMP_WPN_DropWeapon);
                Msg.Data := MMP_WPN_EVENT_WEAPONDROP;
                Msg.DXID := sender.DXID;
                Msg.DropperDXID := trunc(sender.fangle);
                Msg.WeaponID := sender.imageindex;
                Msg.X := sender.x;
                Msg.Y := sender.y;
                Msg.Inertiax := sender.InertiaX;
                Msg.Inertiay := sender.InertiaY;
                mainform.BNETSendData2All(Msg,MsgSize,1);
        end;
end;

procedure WPN_DropWeapon (f : TPlayer);
var i : word;
begin
        if f=nil then begin
                addmessage('^1ERROR: null player weapon drop');
                exit;
        end;

        if (f.weapon <=1) then exit; // do not drop gauntlet or machine;
        if (f.weapon = C_WPN_SHOTGUN) and (f.ammo_sg <= 0) then exit;
        if (f.weapon = C_WPN_GRENADE) and (f.ammo_gl <= 0) then exit;
        if (f.weapon = C_WPN_ROCKET) and (f.ammo_rl <= 0) then exit;
        if (f.weapon = C_WPN_SHAFT) and (f.ammo_sh <= 0) then exit;
        if (f.weapon = C_WPN_RAIL) and (f.ammo_rg <= 0) then exit;
        if (f.weapon = C_WPN_PLASMA) and (f.ammo_pl <= 0) then exit;
        if (f.weapon = C_WPN_BFG) and (f.ammo_bfg <= 0) then exit;

        if
        (MATCH_GAMETYPE = GAMETYPE_TRIXARENA) or
        (MATCH_GAMETYPE = GAMETYPE_PRACTICE) or
        (MATCH_GAMETYPE = GAMETYPE_RAILARENA)
        then exit;

        for i := 0 to 1000 do
        if aaa[i].dead = 2 then begin
                aaa[i].objname := 'weapon';
                aaa[i].x := f.x;

                if not f.crouch then
                aaa[i].y := f.y-1 else
                aaa[i].y := f.y+6;

                aaa[i].DXID := AssignUniqueDXID($FFFF);
                aaa[i].dead := 0;
                aaa[i].dude := false;
                aaa[i].topdraw := 1;
                aaa[i].frame := 0;
                aaa[i].mass := 5;
                aaa[i].weapon := 0;
                aaa[i].health := 50*60; // one minute.
                if (f.dir=0) or (f.dir=2) then aaa[i].dir := 0 else aaa[i].dir := 1;

                //pos adjust.
                if aaa[i].dir = 1 then aaa[i].x := aaa[i].x + 6 else
                aaa[i].x := aaa[i].x - 6;

                aaa[i].imageindex := f.weapon;
                aaa[i].inertiax := (random(16)-8)/7;
                aaa[i].inertiay := -1-(random(8)/6);
                aaa[i].clippixel := 4;
                aaa[i].fangle := F.DXID;
                WPN_Event_WeaponDrop(aaa[i]);
                exit;
        end;

end;

procedure WPN_SVNETWORK_WeaponDropGameState(ToIP:ShortString; ToPort: word;  sender : TMonoSprite);
var Msg: TMP_WPN_DropWeapon;
    MsgSize: word;
begin
        if ismultip <> 1 then exit;
        MsgSize := SizeOf(TMP_WPN_DropWeapon);
        Msg.Data := MMP_WPN_EVENT_WEAPONDROPGAMESTATE;
        Msg.DXID := sender.DXID;
        Msg.DropperDXID := 0;
        Msg.WeaponID := sender.imageindex;
        Msg.X := sender.x;
        Msg.Y := sender.y;
        Msg.Inertiax := sender.InertiaX;
        Msg.Inertiay := sender.InertiaY;
        mainform.BNETSendData2IP_(ToIP, ToPort, Msg, MsgSize, 1);
end;

procedure WPN_SAVEDEMO_WeaponDropGameState(sender : TMonoSprite);
begin
        if not MATCH_DRECORD then exit;

        DData.type0 := DDEMO_WPN_EVENT_WEAPONDROPGAMESTATE;
        DData.gametic := gametic;
        DData.gametime := gametime;
        DemoStream.Write( DData, Sizeof(DData));

        with sender as TMonoSprite do begin
                DWPN_DropWeapon.DXID := sender.DXID;
                DWPN_DropWeapon.DropperDXID := 0;
                DWPN_DropWeapon.WeaponID := sender.imageindex;
                DWPN_DropWeapon.X := sender.x;
                DWPN_DropWeapon.Y := sender.y;
                DWPN_DropWeapon.Inertiax := sender.InertiaX;
                DWPN_DropWeapon.Inertiay := sender.InertiaY;
        end;
        DemoStream.Write(DWPN_DropWeapon, Sizeof(DWPN_DropWeapon));
end;



procedure WPN_Event_WeaponDrop_Apply(sender:TMonoSprite);
var Msg: TMP_CTF_DropFlagApply;
    MsgSize: word;
begin
        if MATCH_DRECORD then begin
                DData.type0 := DDEMO_WPN_EVENT_WEAPONDROP_APPLY;
                DData.gametic := gametic;
                DData.gametime := gametime;
                DemoStream.Write( DData, Sizeof(DData));
                DCTF_DropFlagApply.DXID := sender.DXID;
                DCTF_DropFlagApply.X := sender.X;
                DCTF_DropFlagApply.Y := sender.Y;
                DemoStream.Write( DCTF_DropFlagApply, Sizeof(DCTF_DropFlagApply));
        end;

        if ismultip = 1 then begin
                MsgSize := SizeOf(TMP_CTF_DropFlagApply);
                Msg.Data := MMP_WPN_EVENT_WEAPONDROP_APPLY;
                Msg.DXID := sender.DXID;
                Msg.X := sender.x;
                Msg.Y := sender.y;
                Mainform.BNETSendData2All (Msg,MsgSize,1);
        end;
end;

procedure WPN_Event_Destroy(sender : TMonoSprite);
var
    Msg2: TMP_cl_ObjDestroy;
    MsgSize : word;
begin
        if MATCH_DRECORD then begin
                DData.type0 := DDEMO_KILLOBJECT;    // kill this object in demo
                DData.gametic := gametic;
                DData.gametime := gametime;
                DDXIDKill.x := 0;
                DDXIDKill.y := 0;
                DDXIDKill.DXID := sender.DXID;
                DemoStream.Write(DData, Sizeof(DData));
                DemoStream.Write(DDXIDKill, Sizeof(DDXIDKill));
        end;

        if ismultip=1 then begin // using standard cl_ObjDestroy routine.
                MsgSize := SizeOf(TMP_cl_ObjDestroy);
                Msg2.Data := MMP_CL_OBJDESTROY;
                Msg2.killDXID := sender.DXID;
                MSG2.index := 0;
                Msg2.x := 0;
                Msg2.y := 0;
                Mainform.BNETSendData2All (Msg2,MsgSize,1);
        end;
end;

procedure WPN_Event_Pickup(sender : TMonoSprite; player:TPlayer);  // pickup wpn
var Msg: TMP_CTF_FlagPickUp;
    MsgSize: word;
begin
        if MATCH_DRECORD then begin
                DData.type0 := DDEMO_WPN_EVENT_PICKUP;
                DData.gametic := gametic;
                DData.gametime := gametime;
                DemoStream.Write( DData, Sizeof(DData));
                DCTF_FlagPickUp.FlagDXID := sender.dxid;
                DCTF_FlagPickUp.PlayerDXID := player.dxid;
                DemoStream.Write( DCTF_FlagPickUp, Sizeof(DCTF_FlagPickUp));
        end;

        if ismultip = 1 then begin
                MsgSize := SizeOf(TMP_CTF_FlagPickUp);
                Msg.Data := MMP_WPN_EVENT_PICKUP;
                Msg.FlagDXID := sender.dxid;
                Msg.PlayerDXID := player.dxid;
                Mainform.BNETSendData2All (Msg,MsgSize,1);
        end;
end;

// =====================================================------------------------



procedure WPN_ProcessWeaponPhysics (sender : TMonoSprite);
var i : byte;
begin
with sender as TMONOSPRITE do begin

if sender.dude = false then begin
   for i := 0 to 7 do if players[i] <> nil then
   if (players[i].justrespawned = 0) then
   if (players[i].health > 0) then
   if (players[i].dead=0) then
   if (sender.x >= players[i].x - 16) and (sender.x <= players[i].x + 16) and
   (sender.y >= players[i].y-16) and (sender.y <= players[i].y+32) then
   begin
        // pickup wpn
        playsound(SND_wpkup,players[i].x,players[i].y);
        WPN_GainWeapon(players[i], imageindex);
        if players[i].netobject = false then
                DoWeapBar(i); // new weapon.. notice that
        if players[i].idd = 1 then p2flashbar := 1 else if players[i].idd = 0 then p1flashbar := 1;
        sender.dead := 2;
        WPN_Event_Pickup(sender, players[i]);
        exit;
   end;

   // killed by lava, or death.
   if (bbb[ trunc(sender.x) div 32, trunc(sender.y) div 16 ].image = CONTENT_LAVA)
        or (bbb[trunc(sender.x) div 32, trunc(sender.y) div 16 ].image = CONTENT_DEATH) then
                sender.health := 0;

   if sender.y > 16*250 then sender.health := 0; //bugfix.

end;//if sender.dude = false then

   // timed out, removing..
   if sender.health > 0 then sender.health := sender.health - 1 else begin
        if sender.dude = false then WPN_Event_Destroy(sender);
        sender.dead := 2;
   end;

   if (inertiay = 0) and (Inertiax = 0) then begin
                if sender.dude=false then
                        if sender.weapon = 0 then begin
                                WPN_Event_WeaponDrop_Apply(sender);
                                sender.weapon := 1;
                        end;
                exit;
        end;

   if (inertiay > -0.3) and (Inertiay < 0.3) and (inertiax > -0.3) and (Inertiax < 0.3) and (bbb[ trunc(x) div 32, trunc(y+2) div 16].block = true) then begin inertiax := 0; exit; end;

   InertiaY := InertiaY + (Gravity*mass);

   if inertiay < 0 then InertiaY := InertiaY / 1.025;   // stopspeed.
   InertiaX := InertiaX / 1.003;   // stopspeed.

   x := x + inertiax;
   y := y + inertiay;
//   if health < 255 then inc(health);????????

   // CLIPPING

   if (bbb[ trunc(x-7) div 32, trunc(y) div 16].block = true) or (bbb[ trunc(x+7) div 32, trunc(y) div 16].block = true) then
        inertiax := 0;
   if (bbb[ trunc(x) div 32, trunc(y-12) div 16].block = true) then begin // boom ceil
                if inertiay < 0 then inertiay := abs(inertiay);
                inertiax := inertiax / GRENADE_SLOWSPEED;
   end;
   if (bbb[ trunc(x) div 32, trunc(y) div 16].block = true) then begin// boom floor
//              addmessage('blocked floor');
                Y := (round(Y) div 16) * 16 - 1; // correcting to floor.
//                addmessage('^2correcting');

                inertiay := 0;
                inertiax := 0;
               end;

   if InertiaY < -5 then InertiaY := -5;
   if InertiaY >  5 then InertiaY :=  5;
   if InertiaX < -7 then InertiaX := -7;
   if InertiaX >  7 then InertiaX :=  7;

   if (inertiax < 0.01) and (inertiax > -0.01) and (onbrick_flag(sender)) then inertiax := 0;
   if (inertiay < 0.02) and (inertiay > -0.02) and (onbrick_flag(sender)) then inertiay := 0;
 end;

end;

// ======================================================-----------------------

// player powerup drop. multi, save to demo.
procedure POWERUP_Event_PowerupDrop(sender : TMonoSprite);
var Msg: TMP_Powerup_DropPowerup;
    MsgSize: word;
begin
        if MATCH_DRECORD then begin // player Weapondrop. save to demo.
                DData.type0 := DDEMO_POWERUP_EVENT_POWERUPDROP;
                DData.gametic := gametic;
                DData.gametime := gametime;
                DemoStream.Write( DData, Sizeof(DData));
                DPOWERUP_DropPowerup.DXID := sender.DXID;
                DPOWERUP_DropPowerup.DropperDXID := trunc(sender.fangle);
                DPOWERUP_DropPowerup.dir := sender.dir;
                DPOWERUP_DropPowerup.imageindex := sender.imageindex;
                DPOWERUP_DropPowerup.X := sender.x;
                DPOWERUP_DropPowerup.Y := sender.y;
                DPOWERUP_DropPowerup.Inertiax := sender.InertiaX;
                DPOWERUP_DropPowerup.Inertiay := sender.InertiaY;
                DemoStream.Write(DPOWERUP_DropPowerup,Sizeof(DPOWERUP_DropPowerup));
        end;

        if ismultip = 1 then begin
                MsgSize := SizeOf(TMP_Powerup_DropPowerup);
                Msg.Data := MMP_POWERUP_EVENT_POWERUPDROP;
                Msg.DXID := sender.DXID;
                Msg.DropperDXID := trunc(sender.fangle);
                Msg.dir := sender.dir;
                Msg.imageindex := sender.imageindex;
                Msg.X := sender.x;
                Msg.Y := sender.y;
                Msg.Inertiax := sender.InertiaX;
                Msg.Inertiay := sender.InertiaY;
                mainform.BNETSendData2All(Msg,MsgSize,1);
        end;
end;


procedure POWERUP_SVNETWORK_PowerupDropGameState(ToIP:ShortString; ToPort: word;  sender : TMonoSprite);
var Msg: TMP_Powerup_DropPowerup;
    MsgSize: word;
begin
        if ismultip <> 1 then exit;
        MsgSize := SizeOf(TMP_Powerup_DropPowerup);
        Msg.Data := MMP_POWERUP_EVENT_POWERUPGAMESTATE;
        Msg.DXID := sender.DXID;
        Msg.DropperDXID := 0;
        Msg.dir := sender.dir;
        Msg.imageindex := sender.imageindex;
        Msg.X := sender.x;
        Msg.Y := sender.y;
        Msg.Inertiax := sender.InertiaX;
        Msg.Inertiay := sender.InertiaY;
        mainform.BNETSendData2IP_(ToIP, ToPort, Msg, MsgSize, 1);
end;

procedure POWERUP_SAVEDEMO_PowerupDropGameState(sender : TMonoSprite);
begin
        if not MATCH_DRECORD then exit;

        DData.type0 := DDEMO_POWERUP_EVENT_POWERUPDROPGAMESTATE;
        DData.gametic := gametic;
        DData.gametime := gametime;
        DemoStream.Write( DData, Sizeof(DData));

        with sender as TMonoSprite do begin
                DPOWERUP_DropPowerup.DXID := sender.DXID;
                DPOWERUP_DropPowerup.DropperDXID := 0;
                DPOWERUP_DropPowerup.imageindex := sender.imageindex;
                DPOWERUP_DropPowerup.dir := sender.dir;
                DPOWERUP_DropPowerup.X := sender.x;
                DPOWERUP_DropPowerup.Y := sender.y;
                DPOWERUP_DropPowerup.Inertiax := sender.InertiaX;
                DPOWERUP_DropPowerup.Inertiay := sender.InertiaY;
        end;
        DemoStream.Write(DPOWERUP_DropPowerup, Sizeof(DPOWERUP_DropPowerup));
end;

// =====================================================------------------------

function POWERUP_GainPowerup(f : TPlayer; pindex, amount: byte) : boolean;
begin
//        if MATCH_DDEMOPLAY then exit;

        case pindex of
        0 : begin // regen
                f.item_regen := amount;
                playsound(SND_regeneration, f.x,f.y);
            end;
        1 : begin // battle
                f.item_battle := amount;
                playsound(SND_holdable, f.x,f.y);
            end;
        2 : begin // haste
                f.item_haste := amount;
                playsound(SND_haste, f.x,f.y);
            end;
        3 : begin // quad
                f.item_quad := amount;
                playsound(SND_quaddamage, f.x,f.y);
            end;
        4 : begin // flight
                f.item_flight := amount;
                playsound(SND_flight, f.x,f.y);
            end;
        5 : begin // invis
                f.item_invis := amount;
                playsound(SND_invisibility, f.x,f.y);
            end;
        end;
end;

// =====================================================------------------------

procedure POWERUP_ProcessPowerupPhysics (sender : TMonoSprite);
var i : byte;
begin
with sender as TMONOSPRITE do begin

if sender.dude = false then begin
   for i := 0 to 7 do if players[i] <> nil then
   if (players[i].justrespawned = 0) then
   if (players[i].health > 0) then
   if (players[i].dead=0) then
   if (sender.x >= players[i].x - 16) and (sender.x <= players[i].x + 16) and
   (sender.y >= players[i].y-16) and (sender.y <= players[i].y+32) then
   begin
        // pickup powerup
        POWERUP_GainPowerup(players[i], dir, imageindex);
        if players[i].netobject = false then DoWeapBar(i); // new powerup.. notice that
        sender.dead := 2;
        POWERUP_Event_Pickup(sender, players[i]);
        exit;
   end;


   if sender.y > 16*250 then sender.health := 0; //bugfix.

end;//if sender.dude = false then

   // killed by lava, or death.
   if (bbb[ trunc(sender.x) div 32, trunc(sender.y) div 16 ].image = CONTENT_LAVA)
   or (bbb[trunc(sender.x) div 32, trunc(sender.y) div 16 ].image = CONTENT_DEATH) then
        sender.health := 0;

   // timed out, removing..
   if sender.health > 0 then sender.health := sender.health - 1 else begin
        if sender.dude = false then WPN_Event_Destroy(sender);
        sender.dead := 2;
   end;

   if (inertiay = 0) and (Inertiax = 0) then begin
        if sender.dude=false then
        if sender.weapon = 0 then begin
                WPN_Event_WeaponDrop_Apply(sender);
                sender.weapon := 1;
                end;
        exit;
   end;

   if (inertiay > -0.3) and (Inertiay < 0.3) and (inertiax > -0.3) and (Inertiax < 0.3) and (bbb[ trunc(x) div 32, trunc(y+2) div 16].block = true) then begin inertiax := 0; exit; end;

   InertiaY := InertiaY + (Gravity*mass);

   if inertiay < 0 then InertiaY := InertiaY / 1.025;   // stopspeed.
   InertiaX := InertiaX / 1.003;   // stopspeed.

   x := x + inertiax;
   y := y + inertiay;

   // CLIPPING
   if (bbb[ trunc(x-7) div 32, trunc(y) div 16].block = true) or (bbb[ trunc(x+7) div 32, trunc(y) div 16].block = true) then
        inertiax := 0;
   if (bbb[ trunc(x) div 32, trunc(y-12) div 16].block = true) then begin // boom ceil
                if inertiay < 0 then inertiay := abs(inertiay);
                inertiax := inertiax / GRENADE_SLOWSPEED;
        end;
   if (bbb[ trunc(x) div 32, trunc(y) div 16].block = true) then begin// boom floor
                Y := (round(Y) div 16) * 16 - 1; // correcting to floor.
                inertiay := 0;
                inertiax := 0;
        end;
   if InertiaY < -5 then InertiaY := -5;
   if InertiaY >  5 then InertiaY :=  5;
   if InertiaX < -7 then InertiaX := -7;
   if InertiaX >  7 then InertiaX :=  7;
   if (inertiax < 0.01) and (inertiax > -0.01) and (onbrick_flag(sender)) then inertiax := 0;
   if (inertiay < 0.02) and (inertiay > -0.02) and (onbrick_flag(sender)) then inertiay := 0;
 end;

end;

// =====================================================------------------------

procedure POWERUP_Event_Pickup(sender : TMonoSprite; player:TPlayer);  // pickup powerup
var Msg: TMP_CTF_FlagPickUp;
    MsgSize: word;
begin
        if MATCH_DRECORD then begin
                DData.type0 := DDEMO_POWERUP_EVENT_PICKUP;
                DData.gametic := gametic;
                DData.gametime := gametime;
                DemoStream.Write( DData, Sizeof(DData));
                DCTF_FlagPickUp.FlagDXID := sender.dxid;
                DCTF_FlagPickUp.PlayerDXID := player.dxid;
                DemoStream.Write( DCTF_FlagPickUp, Sizeof(DCTF_FlagPickUp));
        end;

        if ismultip = 1 then begin
                MsgSize := SizeOf(TMP_CTF_FlagPickUp);
                Msg.Data := MMP_POWERUP_EVENT_PICKUP;
                Msg.FlagDXID := sender.dxid;
                Msg.PlayerDXID := player.dxid;
                Mainform.BNETSendData2All (Msg,MsgSize,1);
        end;
end;

// =====================================================------------------------

procedure POWERUP_Drop (f : TPlayer);
var i : word;
begin
        if f=nil then begin
                addmessage('^1ERROR: null player weapon drop');
                exit;
        end;

        if (f.item_quad < 3) and (f.item_regen < 3) and (f.item_battle < 3) and
           (f.item_flight < 3) and (f.item_haste < 3) and (f.item_invis < 3) then exit;

        if (MATCH_GAMETYPE = GAMETYPE_TEAM) then exit;

        for i := 0 to 1000 do
        if aaa[i].dead = 2 then begin
                aaa[i].objname := 'powerup';
                aaa[i].x := f.x;

                if not f.crouch then
                aaa[i].y := f.y-1 else
                aaa[i].y := f.y+6;

                aaa[i].DXID := AssignUniqueDXID($FFFF);
                aaa[i].dead := 0;
                aaa[i].dude := false;
                aaa[i].topdraw := 1;
                aaa[i].frame := 0;
                aaa[i].mass := 5;
                aaa[i].weapon := 0;
                aaa[i].health := 50*60; // one minute.

                //pos adjust.
                if aaa[i].dir = 1 then aaa[i].x := aaa[i].x + 6 else
                aaa[i].x := aaa[i].x - 6;

                if f.item_quad > 2 then begin            // Quad
                        aaa[i].dir := 3;
                        aaa[i].imageindex := f.item_quad;
                        f.item_quad := 0;
                end else if f.item_regen > 2 then begin  // regen
                        aaa[i].dir := 0;
                        aaa[i].imageindex := f.item_regen;
                        f.item_regen := 0;
                end else if f.item_battle > 2 then begin  // battle
                        aaa[i].dir := 1;
                        aaa[i].imageindex := f.item_battle;
                        f.item_battle := 0;
                end else if f.item_flight > 2 then begin  // flight
                        aaa[i].dir := 4;
                        aaa[i].imageindex := f.item_flight;
                        f.item_flight := 0;
                end else if f.item_haste > 2 then begin  // haste
                        aaa[i].dir := 2;
                        aaa[i].imageindex := f.item_haste;
                        f.item_haste := 0;
                end else if f.item_invis > 2 then begin  // invis
                        aaa[i].dir := 5;
                        aaa[i].imageindex := f.item_invis;
                        f.item_invis := 0;
                end;

                aaa[i].inertiax := (random(16)-8)/7;
                aaa[i].inertiay := -1-(random(8)/6);
                aaa[i].clippixel := 4;
                aaa[i].fangle := F.DXID;
                POWERUP_Event_PowerupDrop(aaa[i]);
                exit;
        end;
end;


procedure POWERUP_DEMO_DropPowerup();
var z:byte;
    i:word;
begin
        if not MATCH_DDEMOPLAY then exit;

        for i := 0 to 1000 do
        if aaa[i].dead = 2 then begin
                aaa[i].objname := 'powerup';
                aaa[i].x := DPOWERUP_DropPowerup.X;
                aaa[i].y := DPOWERUP_DropPowerup.Y;
                aaa[i].DXID := DPOWERUP_DropPowerup.DXID;
                aaa[i].dead := 0;
                aaa[i].dude := true;
                aaa[i].topdraw := 1;
                aaa[i].frame := 0;
                aaa[i].mass := 5;
                aaa[i].weapon := 0;
                aaa[i].health := 50*60 + 50*10; // one minute. + 10 sec.. (cuz networked removal).
                aaa[i].dir := DPOWERUP_DropPowerup.dir;
                aaa[i].imageindex := DPOWERUP_DropPowerup.imageindex;
                aaa[i].inertiax := DPOWERUP_DropPowerup.Inertiax;
                aaa[i].inertiay := DPOWERUP_DropPowerup.Inertiay;
                aaa[i].clippixel := 4;
                exit;
        end;
end;

// =====================================================------------------------

procedure POWERUP_CLNETWORK_DropPowerup(PacketType : byte; Data: Pointer);
var z:byte;
    i:word;
begin
        if ismultip <> 2 then exit;

        if PacketType = MMP_POWERUP_EVENT_POWERUPDROP then
                for z := 0 to 7 do if players[z] <> nil then
                        if (players[z].dxid = TMP_POWERUP_DropPowerup(Data^).DropperDXID) then
                                break;

        for i := 0 to 1000 do begin

        if PacketType = MMP_POWERUP_EVENT_POWERUPDROP then if (aaa[i].dead = 0) and (aaa[i].objname = 'weapon') and (aaa[i].DXID = TMP_POWERUP_DropPowerup(Data^).DXID) then exit; // this is dublicate;

        if aaa[i].dead = 2 then begin
                aaa[i].objname := 'powerup';
                aaa[i].x    := TMP_POWERUP_DropPowerup(Data^).X;
                aaa[i].y    := TMP_POWERUP_DropPowerup(Data^).Y;
                aaa[i].DXID := TMP_POWERUP_DropPowerup(Data^).DXID;
                aaa[i].dead := 0;
                aaa[i].dude := true;
                aaa[i].topdraw := 0;
                aaa[i].frame := 0;
                aaa[i].mass := 5;
                aaa[i].weapon := 0;
                aaa[i].fangle := TMP_POWERUP_DropPowerup(Data^).DropperDXID; //that should work..
                aaa[i].health := 50*60 + 50*10;
                // one minute. + 10 sec.. (cuz networked removal).

                if z > 7 then z := 0;

                aaa[i].inertiax := TMP_POWERUP_DropPowerup(Data^).Inertiax;
                aaa[i].inertiay := TMP_POWERUP_DropPowerup(Data^).Inertiay;
                aaa[i].clippixel := 4;
                aaa[i].dir := TMP_POWERUP_DropPowerup(Data^).dir;
                aaa[i].imageindex := TMP_POWERUP_DropPowerup(Data^).imageindex;

                if MATCH_DRECORD then POWERUP_Event_PowerupDrop(aaa[i]);
                exit;
        end;
        end;
end;

// ======================================================

function DOM_ValidMap:boolean;
var i,a,nr:byte;
begin
        nr := 0;
        for i := 0 to BRICK_X-1 do
        for a := 0 to BRICK_Y-1 do begin
                if (bbb[i,a].image = CONTENT_DOMPOINT) then inc(nr);
        end;
        if (nr=3) then result:=true else result := false;
end;

procedure DOM_UpdateStatusBar;
var x,y,i:byte;
begin
        i := 0;
        for x := 0 to BRICK_X-1 do
        for y := 0 to BRICK_Y-1 do
        if bbb[x,y].image = CONTENT_DOMPOINT then begin
                inc(i);
                        case i of
                        1 : Dompoint1 := bbb[x,y].dir;
                        2 : Dompoint2 := bbb[x,y].dir;
                        3 : Dompoint3 := bbb[x,y].dir;
                        end;
                end;
end;

procedure DOM_Reset;
var x,y,i:byte;
begin
        MATCH_REDTEAMSCORE := 0;
        MATCH_BLUETEAMSCORE := 0;

        i := 0;
        for x := 0 to BRICK_X-1 do
        for y := 0 to BRICK_Y-1 do
        if bbb[x,y].image = CONTENT_DOMPOINT then begin
                bbb[x,y].dir := C_TEAMNON;
                bbb[x,y].scale := random(46);
                bbb[x,y].y := i;
                inc(i);
                end;

        dompoint1 := C_TEAMNON;
        dompoint2 := C_TEAMNON;
        dompoint3 := C_TEAMNON;
//        addmessage('^1DEBUG: DOM RESET();');
end;

procedure DOM_Capture(x,y,team,packet_type:byte);//captures a point.
var    Msg: TMP_DOM_Capture;
    MsgSize: word;
begin
        bbb[x,y].dir := team;

        if packet_type=MMP_DOM_CAPTURE then begin
                playsound(SND_domtake,32*x,16*y);
                playsound(SND_domtake2,0,0);
        end;

        if MATCH_DRECORD then begin
                DData.type0 := DDEMO_DOM_CAPTURE;
                DData.gametic := gametic;
                DData.gametime := gametime;
                DemoStream.Write( DData, Sizeof(DData));
                DDOM_Capture.x := x;
                DDOM_Capture.y := y;
                DDOM_Capture.team := team;
                DemoStream.Write(DDOM_Capture, Sizeof(DDOM_Capture));
        end;

        if ismultip=1 then begin
                MsgSize := SizeOf(TMP_DOM_Capture);
                        Msg.Data := MMP_DOM_CAPTURE;
                        Msg.x := x;
                        Msg.y := y;
                        Msg.team := team;
                        Mainform.BNETSendData2All (Msg,MsgSize,1);
        end;
end;


procedure DOM_SaveDemo_Gamestate;
var x,y:byte;
begin
        if not MATCH_DRECORD then exit;

        for x := 0 to BRICK_X-1 do
        for y := 0 to BRICK_Y-1 do
        if (bbb[x,y].image = CONTENT_DOMPOINT) then begin

                DData.type0 := DDEMO_DOM_CAPTUREGAMESTATE;
                DData.gametic := gametic;
                DData.gametime := gametime;
                DemoStream.Write( DData, Sizeof(DData));
                DDOM_Capture.x := x;
                DDOM_Capture.y := y;
                DDOM_Capture.team := bbb[x,y].dir;
                DemoStream.Write(DDOM_Capture, Sizeof(DDOM_Capture));
        end;
end;

procedure DOM_SvNetwork_Gamestate;
var    x,y:byte;
    Msg: TMP_DOM_Capture;
    MsgSize: word;
begin
        if ismultip<>1 then exit; //
        for x := 0 to BRICK_X-1 do
        for y := 0 to BRICK_Y-1 do
        if (bbb[x,y].image = CONTENT_DOMPOINT) then begin
                MsgSize := SizeOf(TMP_DOM_Capture);
                Msg.Data := MMP_DOM_CAPTUREGAMESTATE;
                Msg.x := x;
                Msg.y := y;
                Msg.team := bbb[x,y].dir;
                Mainform.BNETSendData2All (Msg,MsgSize,1);
        end;
end;

procedure DOM_CLScoreChanged();
begin
        if MATCH_DRECORD then begin
                DData.type0 := DDEMO_DOM_SCORECHANGED;
                DData.gametic := gametic;
                DData.gametime := gametime;
                DemoStream.Write( DData, Sizeof(DData));
                DDOM_ScoreChanges.RedScore := MATCH_REDTEAMSCORE;
                DDOM_ScoreChanges.BlueScore := MATCH_BLUETEAMSCORE;
                DemoStream.Write(DDOM_ScoreChanges, Sizeof(DDOM_ScoreChanges));
        end;


end;

procedure DOM_Think();        // called every second.
var x,y:byte;
    orts, obts : word;//old team score;
    Msg: TMP_DOM_ScoreChanges;
    MsgSize: word;
begin
        if MATCH_STARTSIN <> 0 then exit;
        if ismultip<>1 then exit;

        orts := MATCH_REDTEAMSCORE div 3;
        obts := MATCH_BLUETEAMSCORE div 3;

        for x := 0 to BRICK_X-1 do
        for y := 0 to BRICK_Y-1 do
        if bbb[x,y].image = CONTENT_DOMPOINT then begin
                if bbb[x,y].dir = C_TEAMRED then inc(MATCH_REDTEAMSCORE);
                if bbb[x,y].dir = C_TEAMBLU then inc(MATCH_BLUETEAMSCORE);
        end;

        // network, and demopackets.

        // SCORECHANGED

        if (MATCH_REDTEAMSCORE div 3 <> orts) or
           (MATCH_BLUETEAMSCORE div 3 <> obts) then begin

                if MATCH_DRECORD then begin
                DData.type0 := DDEMO_DOM_SCORECHANGED;
                DData.gametic := gametic;
                DData.gametime := gametime;
                DemoStream.Write( DData, Sizeof(DData));
                DDOM_ScoreChanges.RedScore := MATCH_REDTEAMSCORE div 3;
                DDOM_ScoreChanges.BlueScore := MATCH_BLUETEAMSCORE div 3;
                DemoStream.Write(DDOM_ScoreChanges, Sizeof(DDOM_ScoreChanges));
                end;

                if ismultip=1 then begin
                        MsgSize := SizeOf(TMP_DOM_ScoreChanges);
                        Msg.Data := MMP_DOM_SCORECHANGED;
                        Msg.RedScore := MATCH_REDTEAMSCORE div 3;
                        Msg.BlueScore := MATCH_BLUETEAMSCORE div 3;
                        Mainform.BNETSendData2All (Msg,MsgSize,1);
                end;
        end;

        // Domlimit
        if MATCH_DOMLIMIT > 0 then
        if ((MATCH_REDTEAMSCORE div 3 >= MATCH_DOMLIMIT) or (MATCH_BLUETEAMSCORE div 3>= MATCH_DOMLIMIT)) then begin
                addmessage('^3Domlimit hit.');
                GameEnd(END_DOMLIMIT);
        end;

end;


procedure CTF_DEMO_DropFlag();
var z:byte;
    i:word;
begin
//        addmessage('PROC: ^3CTF_DEMO_DropFlag');
        if not MATCH_DDEMOPLAY then exit;

        if DData.type0 = DDEMO_CTF_EVENT_FLAGDROP then begin
                CTF_Event_Message(DCTF_DropFlag.DropperDXID, 'lost');
                for z := 0 to 7 do if players[z] <> nil then
                if (players[z].dxid = DCTF_DropFlag.DropperDXID) then begin
                        players[z].flagcarrier := false;
                        break;
                end;
        end;

        for i := 0 to 1000 do
        if aaa[i].dead = 2 then begin
                aaa[i].objname := 'flag';
                aaa[i].x := DCTF_DropFlag.X;
                aaa[i].y := DCTF_DropFlag.Y;
                aaa[i].DXID := DCTF_DropFlag.DXID;
                aaa[i].dead := 0;
                aaa[i].dude := true;
                aaa[i].topdraw := 0;
                aaa[i].frame := 0;
                aaa[i].mass := 5;
                aaa[i].weapon := 0;
                aaa[i].health := 50*60 + 50*10; // one minute. + 10 sec.. (cuz networked removal).
                if (DData.type0 = DDEMO_CTF_EVENT_FLAGDROP) then begin
                        if (players[z].dir=0) or (players[z].dir=2) then aaa[i].dir := 0 else aaa[i].dir := 1;
                        if players[z].team=0 then aaa[i].imageindex := 1 else aaa[i].imageindex := 0;
                end else begin
                        aaa[i].dir := random(2);
                        aaa[i].imageindex := DCTF_DropFlag.DropperDXID;
                end;
                aaa[i].inertiax := DCTF_DropFlag.Inertiax;
                aaa[i].inertiay := DCTF_DropFlag.Inertiay;
                aaa[i].clippixel := 4;
                exit;
        end;

end;

procedure CTF_CLNETWORK_DropFlag(PacketType : byte; Data: Pointer);
var z:byte;
    i:word;
begin
        if ismultip <> 2 then exit;

//        addmessage('CTF_CLNETWORK_DropFlag. DXID:'+ inttostr(TMP_CTF_DropFlag(Data^).DXID));

        if PacketType = MMP_CTF_EVENT_FLAGDROP then begin

                CTF_Event_Message(TMP_CTF_DropFlag(Data^).DropperDXID, 'lost');

                for z := 0 to 7 do if players[z] <> nil then
                if (players[z].dxid = TMP_CTF_DropFlag(Data^).DropperDXID) then begin
//                        addmessage('^6CTF_CLNETWORK_DropFlag: '+ players[z].netname+' lost the flag');
                        players[z].flagcarrier := false;
                        break;
                end;
        end;


        // remove old droppped flags
        if PacketType = MMP_CTF_EVENT_FLAGDROP then
        for i := 0 to 1000 do
        if (aaa[i].dead = 0) and (aaa[i].objname = 'flag') then begin
                if (aaa[i].imageindex = 0) and (players[z].team = 1) then aaa[i].dead := 2;
                if (aaa[i].imageindex = 1) and (players[z].team = 0) then aaa[i].dead := 2;
        end;

        for i := 0 to 1000 do
        if aaa[i].dead = 2 then begin
                aaa[i].objname := 'flag';
                aaa[i].x := TMP_CTF_DropFlag(Data^).X;
                aaa[i].y := TMP_CTF_DropFlag(Data^).Y;
                aaa[i].DXID := TMP_CTF_DropFlag(Data^).DXID;
                aaa[i].dead := 0;
                aaa[i].dude := true;
                aaa[i].topdraw := 0;
                aaa[i].frame := 0;
                aaa[i].mass := 5;
                aaa[i].weapon := 0;
                aaa[i].health := 50*60 + 50*10; // one minute. + 10 sec.. (cuz networked removal).
                if PacketType = MMP_CTF_EVENT_FLAGDROP then begin
                        if (players[z].dir=0) or (players[z].dir=2) then aaa[i].dir := 0 else aaa[i].dir := 1;
                        if players[z].team=0 then aaa[i].imageindex := 1 else aaa[i].imageindex := 0;
                        aaa[i].fangle := TMP_CTF_DropFlag(Data^).DropperDXID; //demo compartibility
                end else begin
                        aaa[i].dir := random(2);
                         aaa[i].imageindex := TMP_CTF_DropFlag(Data^).DropperDXID;
                end;
                aaa[i].inertiax := TMP_CTF_DropFlag(Data^).Inertiax;
                aaa[i].inertiay := TMP_CTF_DropFlag(Data^).Inertiay;
                aaa[i].clippixel := 4;

                if MATCH_DRECORD then CTF_SAVEDEMO_FlagDrop(aaa[i]); // client save to demo

                exit;
        end;
end;

// player fragdrop. save to demo.
procedure CTF_SAVEDEMO_FlagDrop(sender : TMonoSprite);
begin
        if not MATCH_DRECORD then exit;

        DData.type0 := DDEMO_CTF_EVENT_FLAGDROP;
        DData.gametic := gametic;
        DData.gametime := gametime;
        DemoStream.Write( DData, Sizeof(DData));

        with sender as TMonoSprite do begin
                DCTF_DropFlag.DXID := sender.DXID;
                DCTF_DropFlag.DropperDXID := trunc(sender.fangle);
                DCTF_DropFlag.X := sender.x;
                DCTF_DropFlag.Y := sender.y;
                DCTF_DropFlag.Inertiax := sender.InertiaX;
                DCTF_DropFlag.Inertiay := sender.InertiaY;
        end;
        DemoStream.Write( DCTF_DropFlag, Sizeof(DCTF_DropFlag));
end;

// player fragdrop. server
procedure CTF_SVNETWORK_FlagDrop(sender : TMonoSprite);
var Msg: TMP_CTF_DropFlag;
    MsgSize: word;
begin
        if ismultip <> 1 then exit;
        MsgSize := SizeOf(TMP_CTF_DropFlag);
        Msg.Data := MMP_CTF_EVENT_FLAGDROP;
        Msg.DXID := sender.DXID;
        Msg.DropperDXID := trunc(sender.fangle);
        Msg.X := sender.x;
        Msg.Y := sender.y;
        Msg.Inertiax := sender.InertiaX;
        Msg.Inertiay := sender.InertiaY;
        Mainform.BNETSendData2All (Msg,MsgSize,1);
end;

procedure CTF_SVNETWORK_FlagDropGameState(ToIP:ShortString; ToPort: word; sender : TMonoSprite);
var Msg: TMP_CTF_DropFlag;
    MsgSize: word;
begin
        if ismultip <> 1 then exit;
        MsgSize := SizeOf(TMP_CTF_DropFlag);
                Msg.Data := MMP_CTF_EVENT_FLAGDROPGAMESTATE;
                Msg.DXID := sender.DXID;
                Msg.DropperDXID := sender.imageindex;
                Msg.X := sender.x;
                Msg.Y := sender.y;
                Msg.Inertiax := sender.InertiaX;
                Msg.Inertiay := sender.InertiaY;
                Mainform.BNETSendData2IP_ (ToIP, ToPort, Msg,MsgSize,1);
end;

procedure CTF_SAVEDEMO_FlagDropGameState(sender : TMonoSprite);
begin
        if not MATCH_DRECORD then exit;

        DData.type0 := DDEMO_CTF_EVENT_FLAGDROPGAMESTATE;
        DData.gametic := gametic;
        DData.gametime := gametime;
        DemoStream.Write( DData, Sizeof(DData));

        with sender as TMonoSprite do begin
                DCTF_DropFlag.DXID := sender.DXID;
                DCTF_DropFlag.DropperDXID := sender.imageindex;
                DCTF_DropFlag.X := sender.x;
                DCTF_DropFlag.Y := sender.y;
                DCTF_DropFlag.Inertiax := sender.InertiaX;
                DCTF_DropFlag.Inertiay := sender.InertiaY;
        end;
        DemoStream.Write( DCTF_DropFlag, Sizeof(DCTF_DropFlag));
end;

// correct flag poz.
procedure CTF_SAVEDEMO_FlagDrop_Apply(sender : TMonoSprite);
begin
        if not MATCH_DRECORD then exit;

        DData.type0 := DDEMO_CTF_EVENT_FLAGDROP_APPLY;
        DData.gametic := gametic;
        DData.gametime := gametime;
        DemoStream.Write( DData, Sizeof(DData));
        with sender as TMonoSprite do begin
                DCTF_DropFlagApply.DXID := sender.DXID;
                DCTF_DropFlagApply.X := sender.X;
                DCTF_DropFlagApply.Y := sender.Y;
                end;
        DemoStream.Write( DCTF_DropFlagApply, Sizeof(DCTF_DropFlagApply));
end;

procedure CTF_SVNETWORK_FlagDrop_Apply(sender : TMonoSprite);
var Msg: TMP_CTF_DropFlagApply;
    MsgSize: word;
begin
        if ismultip <> 1 then exit;
        MsgSize := SizeOf(TMP_CTF_DropFlagApply);
                Msg.Data := MMP_CTF_EVENT_FLAGDROP_APPLY;
                Msg.DXID := sender.DXID;
                Msg.X := sender.x;
                Msg.Y := sender.y;
                Mainform.BNETSendData2All (Msg, MsgSize, 1);
end;

procedure CTF_Event_FlagDrop_Apply(sender : TMonoSprite); // correcting flag poz.
begin
        CTF_SAVEDEMO_FlagDrop_Apply(sender);
        CTF_SVNETWORK_FlagDrop_Apply(sender);
end;

procedure CTF_Event_PickupFlag(sender : TMonoSprite; player:TPlayer);  // pickup selfteam flag, and start wear it...
var Msg: TMP_CTF_FlagPickUp;
    MsgSize: word;
begin
        if MATCH_DRECORD then begin
                DData.type0 := DDEMO_CTF_EVENT_FLAGPICKUP;
                DData.gametic := gametic;
                DData.gametime := gametime;
                DemoStream.Write( DData, Sizeof(DData));
                DCTF_FlagPickUp.FlagDXID := sender.dxid;
                DCTF_FlagPickUp.PlayerDXID := player.dxid;
                DemoStream.Write( DCTF_FlagPickUp, Sizeof(DCTF_FlagPickUp));
        end;

        if ismultip = 1 then begin
                MsgSize := SizeOf(TMP_CTF_FlagPickUp);
                        Msg.Data := MMP_CTF_EVENT_FLAGPICKUP;
                        Msg.FlagDXID := sender.dxid;
                        Msg.PlayerDXID := player.dxid;
                        Mainform.BNETSendData2All (Msg, MsgSize, 1);
        end;
end;

procedure CTF_Event_ReturnFlag(DXID:WORD; team:byte);
var Msg: TMP_CTF_FlagReturnFlag;
    MsgSize: word;
begin
        if MATCH_DRECORD then begin
                DData.type0 := DDEMO_CTF_EVENT_FLAGRETURN;
                DData.gametic := gametic;
                DData.gametime := gametime;
                DemoStream.Write( DData, Sizeof(DData));
                DCTF_FlagReturnFlag.FlagDXID := DXID;
                DCTF_FlagReturnFlag.team := team;
                DemoStream.Write( DCTF_FlagReturnFlag, Sizeof(DCTF_FlagReturnFlag));
        end;

        if ismultip = 1 then begin
                MsgSize := SizeOf(TMP_CTF_FlagReturnFlag);
                        Msg.Data := MMP_CTF_EVENT_FLAGRETURN;
                        Msg.FlagDXID := DXID;
                        Msg.team := team;
                        Mainform.BNETSendData2All (Msg, MsgSize, 1);
        end;
end;

procedure CTF_Event_FlagTaken(x,y:byte;DXID:word);
var Msg: TMP_CTF_FlagTaken;
    MsgSize: word;
begin
        if MATCH_DRECORD then begin
                DData.type0 := DDEMO_CTF_EVENT_FLAGTAKEN;
                DData.gametic := gametic;
                DData.gametime := gametime;
                DCTF_FlagTaken.x := x;
                DCTF_FlagTaken.y := y;
                DCTF_FlagTaken.DXID := DXID;
                DemoStream.Write( DData, Sizeof(DData));
                DemoStream.Write( DCTF_FlagTaken, Sizeof(DCTF_FlagTaken));
        end;

        if ismultip = 1 then begin
                MsgSize := SizeOf(TMP_CTF_FlagTaken);
                        Msg.Data := MMP_CTF_EVENT_FLAGTAKEN;
                        Msg.DXID := DXID;
                        Msg.x := x;
                        Msg.y := y;
                        Mainform.BNETSendData2All (Msg, MsgSize, 1);
        end;
end;

procedure CTF_Event_FlagDrop(sender:TMonoSprite);
begin
        CTF_SAVEDEMO_FlagDrop(sender);
        CTF_SVNETWORK_FlagDrop(sender);
end;

procedure CTF_Event_GameStateScoreChanged();
var Msg: TMP_CTF_GameStateScore;
    MsgSize: word;
begin
        // DDEMO_CTF_GAMESTATESCORE
        if MATCH_DRECORD then begin
                DData.type0 := DDEMO_CTF_GAMESTATESCORE;
                DData.gametic := gametic;
                DData.gametime := gametime;
                DemoStream.Write( DData, Sizeof(DData));
                DCTF_GameStateScore.RedScore := MATCH_REDTEAMSCORE;
                DCTF_GameStateScore.BlueScore := MATCH_BLUETEAMSCORE;
                DemoStream.Write( DCTF_GameStateScore, Sizeof(DCTF_GameStateScore));
        end;

        if ismultip = 1 then begin
                MsgSize := SizeOf(TMP_CTF_GameStateScore);
                        Msg.Data := MMP_CTF_GAMESTATESCORE;
                        Msg.RedScore := MATCH_REDTEAMSCORE;
                        Msg.BlueScore := MATCH_BLUETEAMSCORE;
                        Mainform.BNETSendData2All (Msg, MsgSize, 1);
        end;

{
        if ismultip = 1 then
        if MATCH_CAPTURELIMIT > 0 then
        if (MATCH_BLUETEAMSCORE >= MATCH_CAPTURELIMIT) or (MATCH_BLUETEAMSCORE >= MATCH_CAPTURELIMIT) then begin
                GAMEEND
        end;
 }


end;

procedure CTF_Event_FlagCapture(DXID:word);
var Msg: TMP_CTF_FlagCapture;
    MsgSize: word;
begin
        if MATCH_DRECORD then begin
                DData.type0 := DDEMO_CTF_EVENT_FLAGCAPTURE;
                DData.gametic := gametic;
                DData.gametime := gametime;
                DCTF_FlagCapture.DXID := DXID;
                DemoStream.Write( DData, Sizeof(DData));
                DemoStream.Write( DCTF_FlagCapture, Sizeof(DCTF_FlagCapture));
        end;

        if ismultip = 1 then begin
                MsgSize := SizeOf(TMP_CTF_FlagCapture);
                        Msg.Data := MMP_CTF_EVENT_FLAGCAPTURE;
                        Msg.DXID := DXID;
                        Mainform.BNETSendData2All (Msg, MsgSize, 1);
        end;

        if MATCH_CAPTURELIMIT > 0 then
        if ((MATCH_REDTEAMSCORE >= MATCH_CAPTURELIMIT) or (MATCH_BLUETEAMSCORE >= MATCH_CAPTURELIMIT)) then begin
                addmessage('^3Capturelimit hit.');



                GameEnd(END_CAPTURELIMIT);
        end;

end;

procedure CTF_RedFlagAssign(atbase:boolean);
var i,a:byte;
begin
        for i := 0 to BRICK_X-1 do
        for a := 0 to BRICK_Y-1 do begin
                if (bbb[i,a].image = 40) then begin
                        if atbase then bbb[i,a].dir := 0 else bbb[i,a].dir := 1;
                        exit;
                        end;
        end;
end;

procedure CTF_BlueFlagAssign(atbase:boolean);
var i,a:byte;
begin
        for i := 0 to BRICK_X-1 do
        for a := 0 to BRICK_Y-1 do begin
                if (bbb[i,a].image = 41) then begin
                        if atbase then bbb[i,a].dir := 0 else bbb[i,a].dir := 1;
                        exit;
                        end;
        end;
end;

function CTF_RedFlagAtBase:boolean;
var i,a:byte;
begin
        result := true;
        for i := 0 to BRICK_X-1 do
        for a := 0 to BRICK_Y-1 do begin
                if (bbb[i,a].image = 40) and (bbb[i,a].dir > 0) then begin
                        result := false;
                        exit;
                        end;
        end;
end;

function CTF_BlueFlagAtBase:boolean;
var i,a:byte;
begin
        result := true;
        for i := 0 to BRICK_X-1 do
        for a := 0 to BRICK_Y-1 do begin
                if (bbb[i,a].image = 41) and (bbb[i,a].dir > 0) then begin
                        result := false;
                        exit;
                        end;
        end;
end;

function CTF_ValidMap:boolean;
var i,a,nr,nb:byte;
begin
        nr := 0;
        nb := 0;
        for i := 0 to BRICK_X-1 do
        for a := 0 to BRICK_Y-1 do begin
                if (bbb[i,a].image = 40) then inc(nr);
                if (bbb[i,a].image = 41) then inc(nb);
        end;
        if (nr=1) and (nb=1) then result:=true else result := false;
        if (RESPAWNSRED_COUNT=0) or (RESPAWNSBLUE_COUNT=0) then result := false;
end;

procedure CTF_ReturnFlag (flag:byte); // flag returnto base.
var i,a:byte;
begin
        for i := 0 to BRICK_X-1 do
        for a := 0 to BRICK_Y-1 do begin
                if (flag=C_TEAMBLU) and (bbb[i,a].image = 40) then begin
                        bbb[i,a].dir := 0;
                        exit;
                        end;

                if (flag=C_TEAMRED) and (bbb[i,a].image = 41) then begin
                        bbb[i,a].dir := 0;
                        exit;
                        end;
        end;
end;

procedure CTF_Event_Message(DXID:word;action:shortstring);
var d:byte;
begin
        if action='retur' then begin
                if dxid=C_TEAMRED then addmessage('^5RED flag returned to base!');
                if dxid=C_TEAMBLU then addmessage('^5BLUE flag returned to base!');
                exit;
        end;

for d := 0 to 7 do if players[d] <> nil then if players[d].dxid = DXID then begin
        if action='captu' then begin
                if players[d].dxid=MyDxidIS then addmessage('^5You captured ENEMY flag!') else
                if players[d].team <> myteamis then addmessage(players[d].netname+'^n^5 captured YOUR flag!') else
                addmessage(players[d].netname+'^n^5 captured ENEMY flag!');
        end else
        if action='taken' then begin
                if players[d].dxid=MyDxidIS then addmessage('^5You got the ENEMY flag! Return to base.') else
                if players[d].team <> myteamis then addmessage('^5YOUR flag was taken by ^7'+players[d].netname) else
                addmessage('^5ENEMY flag has been taken by ^7'+players[d].netname);
        end else
        if action='lost' then begin
                if players[d].dxid=MyDxidIS then addmessage('^5You lost ENEMY flag!') else
                if players[d].team <> myteamis then addmessage(players[d].netname+'^n^5 lost ENEMY flag!') else
                addmessage(players[d].netname+'^n^5 lost YOUR flag!');
        end else
        if action='picku' then begin
//                if players[d].dxid=MyDxidIS then addmessage('^5You lost ENEMY flag!') else
  //              if players[d].team <> myteamis then addmessage(players[d].netname+'^n^5 lost ENEMY flag!') else
                addmessage(players[d].netname+'^n^5 pickup flag');
        end;
end;
end;

procedure CTF_DropFlag (f : TPlayer);
var i : word;
begin
        if f=nil then begin
                addmessage('ERROR: ctf error. flag carrier is null');
                exit;
        end;

        if MATCH_GAMETYPE <> GAMETYPE_CTF then exit;

        if not f.flagcarrier then exit;

        if f.team=2 then exit;

        CTF_Event_Message(f.dxid,'lost');
        f.flagcarrier := false;

        // remove old droppped flags
        for i := 0 to 1000 do
        if (aaa[i].dead = 0) and (aaa[i].objname = 'flag') then begin
                if (aaa[i].imageindex = 0) and (f.team = 1) then aaa[i].dead := 2;
                if (aaa[i].imageindex = 1) and (f.team = 0) then aaa[i].dead := 2;
        end;

        for i := 0 to 1000 do
        if aaa[i].dead = 2 then begin
                aaa[i].objname := 'flag';
                aaa[i].x := f.x;
                aaa[i].y := f.y+14;
                aaa[i].DXID := AssignUniqueDXID($FFFF);
                aaa[i].dead := 0;
                aaa[i].dude := false;
                aaa[i].topdraw := 0;
                aaa[i].frame := 0;
                aaa[i].mass := 5;
                aaa[i].weapon := 0;
                aaa[i].health := 50*60; // one minute.
                if (f.dir=0) or (f.dir=2) then aaa[i].dir := 0 else aaa[i].dir := 1;
                if f.team=0 then aaa[i].imageindex := 1 else aaa[i].imageindex := 0;
                aaa[i].inertiax := (random(16)-8)/7;
                aaa[i].inertiay := -1-(random(8)/6);
                aaa[i].clippixel := 4;
                aaa[i].fangle := f.DXID;
                CTF_Event_FlagDrop(aaa[i]);
                exit;
        end;
end;

procedure CTF_SVNETWORK_FirstGameState(ToIP:ShortString; ToPort: word);
var Msg: TMP_CTF_GameState;
    Msg2:TMP_CTF_FlagCarrier;
    MsgSize: word;
    i : byte;
begin
        if ismultip <> 1 then exit;

        MsgSize := SizeOf(TMP_CTF_GameState);
        Msg.Data := MMP_CTF_GAMESTATE;
        Msg.RedFlagAtBase := CTF_RedFlagAtBase;
        Msg.BlueFlagAtBase := CTF_BlueFlagAtBase;
        Msg.RedScore := MATCH_REDTEAMSCORE;
        Msg.BlueScore := MATCH_BLUETEAMSCORE;
        Mainform.BNETSendData2IP_ (ToIP, ToPort, Msg, MsgSize, 1);

        // remember ctf flagcarriers.
        for i := 0 to 7 do if players[i] <> nil then
        if players[i].flagcarrier then begin
                MsgSize := SizeOf(TMP_CTF_FlagCarrier);
                Msg2.DATA := MMP_CTF_FLAGCARRIER;
                Msg2.DXID := players[i].DXID;
                Mainform.BNETSendData2IP_ (ToIP, ToPort, Msg2, MsgSize, 1);
        end;
end;
// ****************************************************8


procedure ThrowGib (f : TPlayer; typ : byte);
var    i : integer;
       a : byte;
begin
        for i := 0 to 1000 do
        if aaa[i].dead = 2 then begin
        aaa[i].objname := 'gib';
        aaa[i].clippixel := 4;
        aaa[i].x := f.x;
        aaa[i].frame := 0;
        aaa[i].y := f.y;
        aaa[i].mass := 5;
        aaa[i].topdraw := 0;
        aaa[i].DXID := 0;
        aaa[i].dir := random(2);
        aaa[i].fallt := 125+random(75);
        aaa[i].fangle := random(360);
        aaa[i].imageindex := random(SYS_GIBIMAGES);
        aaa[i].weapon := 128 + random(38);

        for a := 0 to 3 do
                ParticleEngine.AddParticle(trunc(f.x)+10-random(20),trunc(f.y)+20-random(40), (Random(6) - 3)/5, (Random(6) -3) / 5,true);

        if OPT_GIBVELOCITY then begin
                aaa[i].inertiax := f.inertiax + (random(200)-100)/100;
                aaa[i].inertiay := f.inertiay + (random(200)-100)/100;
                if aaa[i].inertiax > 2.5 then aaa[i].inertiax := 2.5;
                if aaa[i].inertiax < -2.5 then aaa[i].inertiax := -2.5;
                if aaa[i].inertiay > 2 then aaa[i].inertiay := 2;
                if aaa[i].inertiay < -2 then aaa[i].inertiay := -2;
        end else begin
                aaa[i].inertiax := (random(30)-15)/7;
                aaa[i].inertiay := -1-(random(12)/6);
        end;
        aaa[i].dead := 0;
        aaa[i].dude := false;
        exit;
        end;
end;


procedure ThrowXYGib (x,y : single; typ : byte);
var    i : integer;
       a : byte;
begin
        for i := 0 to 1000 do
        if aaa[i].dead = 2 then begin
        aaa[i].objname := 'gib';
        aaa[i].clippixel := 4;
        aaa[i].x := x;
        aaa[i].frame := 0;
        aaa[i].y := y;
        aaa[i].mass := 5;
        aaa[i].topdraw := 0;
        aaa[i].DXID := 0;
        aaa[i].dir := random(2);
        aaa[i].fallt := 125+random(75);
        aaa[i].fangle := random(360);
        aaa[i].imageindex := random(SYS_GIBIMAGES);
        aaa[i].weapon := 128 + random(38);

        for a := 0 to 3 do
                ParticleEngine.AddParticle(trunc(x)+10-random(20),trunc(y)+20-random(40), (Random(6) - 3)/5, (Random(6) -3) / 5,true);

        aaa[i].inertiax := (random(30)-15)/7;
        aaa[i].inertiay := -1-(random(12)/6);
        aaa[i].dead := 0;
        aaa[i].dude := false;
        exit;
        end;
end;

// DRAW ALL GRAPHICZ

procedure PlayerWeaponAnim(id : byte);
var zangle : real;
        weapony:shortint;
        RealX, RealY : Real;
        clr : cardinal;
begin
        if players[id].dead > 0 then exit;
        if players[id].crouch then weapony := 3 else weapony := -5;
        if (players[id].netobject = false) and (MATCH_DDEMOPLAY = false) and (players[id].idd<>2) then begin
//              if (players[id].dir = 1) or (players[id].dir = 3) then zAngle := RadToDeg(ArcTan2(players[id].y-players[id].cy+weapony,players[id].x-players[id].cx))-90 else
                zAngle := RadToDeg(ArcTan2(players[id].y-players[id].cy+weapony-3,players[id].x-players[id].cx))-90;
                if zAngle < 0 then zAngle:=360+zAngle;
                zangle := 255/360*zangle;
                if zangle > 256 then zangle := 256;
                players[id].fangle := zangle;
        end else
                if players[id].idd=2 then    // bot
                        zangle := 256/360*(players[id].botangle) else
                zangle := players[id].fangle;

//        if id=0 then addmessage(floattostr(players[id].fangle));

        // nasty hack...
//        if players[id].idd<>2 then
        if (players[id].dir = 0) or (players[id].dir = 2) then
                if zangle < 130 then zangle := zangle - 2;

//        if (players[id].dir = 0) or (players[id].dir = 2) then
{        if id=1 then begin
        mainform.font1.textout(floattostr(zangle),100,100,clred);
        end;
}
        RealX := players[id].TESTPREDICT_X;
        RealY := players[id].TESTPREDICT_Y;
        clr := $FFFFFFFF;

        if (players[id].item_invis>0) then begin
                if (players[id].netobject=false) then clr := $33FFFFFF;
                if (players[id].netobject=true) then clr := $01FFFFFF;
                if (players[id].idd = 2) then clr := $01FFFFFF;
                if MATCH_DDEMOPLAY then clr := $33FFFFFF;
                if (players[id].item_quad > 0) or (players[id].item_battle > 0) or ((players[id].item_regen > 0) and (players[id].item_regen_time>0)) then clr:=$FFFFFFFF;
        end;

        if SYS_COMETOPAPA then begin
        if players[id].weapon > 0 then begin
              if (players[id].dir = 1) or (players[id].dir = 3) then mainform.powergraph.RotateEffect(mainform.images[26],trunc(RealX)+GX,trunc(RealY+weapony)+GY,trunc(zangle),512,clr,players[id].weapon-1,EffectSrcAlpha or effectDiffuseAlpha);
              if (players[id].dir = 0) or (players[id].dir = 2) then mainform.powergraph.RotateEffect(mainform.images[26],trunc(RealX)+GX,trunc(RealY+weapony)+GY,trunc(zangle),512,clr,players[id].weapon-1,EffectSrcAlpha or effectDiffuseAlpha or EffectFlip);
              end;
        end else

        if players[id].weapon = 0 then begin
              if ((players[id].dir = 0) or (players[id].dir = 2)) then
              mainform.powergraph.RotateEffect(mainform.images[25],trunc(RealX)+GX,trunc(RealY+weapony)+GY,trunc(zangle),256,clr,players[id].gantl_state*2,EffectSrcAlpha or effectDiffuseAlpha) else
              mainform.powergraph.RotateEffect(mainform.images[25],trunc(RealX)+GX,trunc(RealY+weapony)+GY,trunc(zangle),256,clr,players[id].gantl_state*2,EffectSrcAlpha or effectDiffuseAlpha or EffectFlip);
        end else begin
              if (players[id].dir = 1) or (players[id].dir = 3) then mainform.powergraph.RotateEffect(mainform.images[26],trunc(RealX)+GX,trunc(RealY+weapony)+GY,round(zangle),256,clr,players[id].weapon-1,EffectSrcAlpha or effectDiffuseAlpha);
              if (players[id].dir = 0) or (players[id].dir = 2) then mainform.powergraph.RotateEffect(mainform.images[26],trunc(RealX)+GX,trunc(RealY+weapony)+GY-1,round(zangle),256,clr,players[id].weapon-1,EffectSrcAlpha or effectDiffuseAlpha or EffectFlip);
        end;
//      mainform.powergraph.Antialias := false;
//      mainform.font1.textout(inttostr(trunc(zangle)),round(RealX+gx), round(RealY+gy),clwhite);
end;

procedure RenderPlayerFlag (realx,realy:real; ID:byte);
var tmps:byte;
begin
        if (players[id].team = 2) then exit;
        if (players[id].flagcarrier = false) then exit;
        tmps := 0;

        if (players[id].team = 0) then tmps := 14;

        if (players[id].dir=0) or (players[id].dir=2) then begin
                if (players[id].crouch=false) then
                mainform.PowerGraph.RotateEffect(mainform.Images[47], trunc(realx+GX)+12, trunc(realy+GY)+2,76,256,SYS_FLAGFRAME+tmps, effectSrcAlpha)
                else mainform.PowerGraph.RotateEffect(mainform.Images[47], trunc(realx+GX)+12, trunc(realy+GY)+12,76,256,SYS_FLAGFRAME+tmps, effectSrcAlpha);
        end else begin
                if (players[id].crouch=false) then
                mainform.PowerGraph.RotateEffect(mainform.Images[47], trunc(realx+GX)-12, trunc(realy+GY)+2,52,256,SYS_FLAGFRAME+tmps, effectSrcAlpha or effectMirror)
                else mainform.PowerGraph.RotateEffect(mainform.Images[47], trunc(realx+GX)-12, trunc(realy+GY)+12,52,256,SYS_FLAGFRAME+tmps, effectSrcAlpha or effectMirror);
        end;

{
        if (players[id].dir=0) or (players[id].dir=2) then begin
                if (players[id].crouch=false) then
                mainform.PowerGraph.RotateNatural(mainform.Images[47], trunc(realx+GX)+12, trunc(realy+GY)+2,76,SYS_FLAGFRAME+tmps, effectSrcAlpha)
                else mainform.PowerGraph.RotateNatural(mainform.Images[47], trunc(realx+GX)+12, trunc(realy+GY)+12,76,SYS_FLAGFRAME+tmps, effectSrcAlpha);
        end else begin
                if (players[id].crouch=false) then
                mainform.PowerGraph.RotateNatural(mainform.Images[47], trunc(realx+GX)-12, trunc(realy+GY)+2,52,SYS_FLAGFRAME+tmps, effectSrcAlpha or effectMirror)
                else mainform.PowerGraph.RotateNatural(mainform.Images[47], trunc(realx+GX)-12, trunc(realy+GY)+12,52,SYS_FLAGFRAME+tmps, effectSrcAlpha or effectMirror);
        end;

}
end;

procedure PlayerAnim (id : byte);
var frm : byte;
    dr : byte;
    clr : cardinal;

    RealX, RealY : real;
    i : integer;

begin
        if players[id] = nil then exit;

        // NET PREDICTION\interpolation.
        // --------------------------------------------------------

{        if players[id].netobject = true then begin
                if (abs(abs(players[id].TESTPREDICT_X - players[id].x))) > 4 then begin

                if abs(players[id].InertiaX) >= 4 then
                realx := players[id].InertiaX-4 else realx := 0;

                if players[id].TESTPREDICT_X  < players[id].x then
                players[id].TESTPREDICT_X := players[id].TESTPREDICT_X+abs(4+realx) else
                players[id].TESTPREDICT_X := players[id].TESTPREDICT_X-abs(4+realx);
                end else players[id].TESTPREDICT_X := players[id].x;

                if (abs(abs(players[id].TESTPREDICT_y - players[id].y))) > 4 then begin

                if abs(players[id].Inertiay) >= 4 then
                realy := players[id].Inertiay-4 else realy := 0;

                if players[id].TESTPREDICT_y  < players[id].y then
                players[id].TESTPREDICT_y := players[id].TESTPREDICT_y+abs(4+realy) else
                players[id].TESTPREDICT_y := players[id].TESTPREDICT_y-abs(4+realy);
                end else players[id].TESTPREDICT_y := players[id].y;

                // TOO BIG ERROR!
//                if OPT_NETCORRECTINTERPOLATEERROR then begin
                if (abs(trunc(players[id].x -players[id].TESTPREDICT_X))) >= 32 then players[id].TESTPREDICT_X := players[id].x;
                if (abs(trunc(players[id].y -players[id].TESTPREDICT_y))) >= 16 then players[id].TESTPREDICT_Y := players[id].y;
  //              end;

                RealX := players[id].TESTPREDICT_X;
                RealY := players[id].TESTPREDICT_Y;
        end else begin
               RealX := players[id].x;
               RealY := players[id].y;
               players[id].TESTPREDICT_X := RealX;
               players[id].TESTPREDICT_Y := RealY;
        end;

  //      end;
}
        if players[id].netobject = true then begin

        // New interpolation here.

{        IF players[id].CTI < players[id].TMT THEN BEGIN
                with players[id] do TESTPREDICT_X := (players[id].TST_X - players[id].TEN_X) / (players[id].TMT / (players[id].CTI+1) ) + players[id].TST_X;
                with players[id] do TESTPREDICT_Y := (players[id].TST_Y - players[id].TEN_Y) / (players[id].TMT / (players[id].CTI+1) ) + players[id].TST_Y;
                IF players[id].CTI < players[id].TMT THEN INC(players[id].CTI);
        END;
}
{        NewX := (EndX - stX) / (FrameRate / (FramewAIT+1)) + StX;
        NewY := (EndY - stY) / (FrameRate / (FramewAIT+1)) + StY;
        NewZ := (Endz - stZ) / (FrameRate / (FramewAIT+1)) + StZ;
}

        i := trunc(abs(abs(players[id].TESTPREDICT_X - players[id].x) * (OPT_NETPREDICTION/2.5) - abs(players[id].TESTPREDICT_X - players[id].x) * OPT_NETPREDICTION));
        if trunc(players[id].TESTPREDICT_X) <> trunc(players[id].x) then if i = 0 then i := 1;
        if players[id].TESTPREDICT_X  < players[id].x then
        players[id].TESTPREDICT_X := players[id].TESTPREDICT_X+i else
        players[id].TESTPREDICT_X := players[id].TESTPREDICT_X-i;

        i := trunc(abs(abs(players[id].TESTPREDICT_Y - players[id].y) * (OPT_NETPREDICTION/3) - abs(players[id].TESTPREDICT_Y - players[id].y) * OPT_NETPREDICTION));
        if trunc(players[id].TESTPREDICT_y) <> trunc(players[id].y) then if i = 0 then i := 1;
        if players[id].TESTPREDICT_Y  < players[id].Y then
        players[id].TESTPREDICT_Y := players[id].TESTPREDICT_Y+i else
        players[id].TESTPREDICT_Y := players[id].TESTPREDICT_Y-i;

//      // TOO BIG ERROR!
//      if OPT_NETCORRECTINTERPOLATEERROR then begin
        if (abs(trunc(players[id].x -players[id].TESTPREDICT_X))) >= 32 then players[id].TESTPREDICT_X := players[id].x;
        if (abs(trunc(players[id].y -players[id].TESTPREDICT_y))) >= 16 then players[id].TESTPREDICT_Y := players[id].y;

//      end;

        RealX := players[id].TESTPREDICT_X;
        RealY := players[id].TESTPREDICT_Y;


        end else begin
               RealX := players[id].x;
               RealY := players[id].y;
               players[id].TESTPREDICT_X := RealX;
               players[id].TESTPREDICT_Y := RealY;
        end;



{        if MATCH_DDEMOPLAY then begin
               RealX := players[id].x;
               RealY := players[id].y;
               players[id].TESTPREDICT_X := RealX;
               players[id].TESTPREDICT_Y := RealY;
        end;
 }
        // --------------------------------------------------------

        if (players[id].dead = 2) and (players[id].health <= GIB_DEATH) and (OPT_MEATLEVEL > 0) then exit;
        dr := players[id].dir;

        if MATCH_DDEMOPLAY then if OPT_MEATLEVEL > 0 then if players[id].health <= GIB_DEATH then begin players[id].dead := 2; exit; end;

        // gib anim :)
        if(players[id].dead >= 1) then begin
               if OPT_MEATLEVEL > 0 then begin
                if players[id].health <= GIB_DEATH then begin
                    if random(2) = 0 then
                    PLAYSOUND(SND_gib1,players[id].x,players[id].y) else
                    PLAYSOUND(SND_gib2,players[id].x,players[id].y);
                    if OPT_MEATLEVEL >= 2 then begin     // WOW. YOURE WIN A BONUS MEAT!
                            ThrowGib(Players[id],1);
                            ThrowGib(Players[id],1);
                            ThrowGib(Players[id],0);
                    end;
                    if OPT_MEATLEVEL = 3 then begin
                            ThrowGib(Players[id],1);
                            ThrowGib(Players[id],1);
                            ThrowGib(Players[id],0);
                    end;
                    ThrowGib(Players[id],1);
                    ThrowGib(Players[id],1);
                    ThrowGib(Players[id],1);
                    ThrowGib(Players[id],0);
                    players[id].dead := 2;
                    exit;
                end;
               end;   // fuck that niger.

// ===========================================================================
// DIE ANIM    // no die anim... death animated by corpse..
{               if (dr = 1) or (dr = 3) then
                mainform.PowerGraph.RenderEffect(mainform.Images[players[id].die_index], trunc(players[id].x-26)+GX, trunc(players[id].y-27)+GY+52-players[id].diesizey,players[id].frame, effectSrcAlpha) else
                mainform.PowerGraph.RenderEffect(mainform.Images[players[id].die_index], trunc(players[id].x-26)+GX, trunc(players[id].y-27)+GY+52-players[id].diesizey,players[id].frame, effectSrcAlpha or effectMirror);

                if not MATCH_DDEMOPLAY then begin
                if players[id].dead = 2 then exit;
                if (players[id].frame >= players[id].dieframes-1) then begin players[id].dead := 2; exit; end else
                if players[id].nextframe <= 0 then inc(players[id].frame);
                end;
                if MATCH_DDEMOPLAY then begin
                        if (players[id].frame < players[id].dieframes-1) then
                                if players[id].nextframe <= 0 then inc(players[id].frame);
                        if players[id].rewardtime > 0 then if (players[id].frame >= players[id].dieframes-1) then players[id].rewardtime := 0;
                end;
                if players[id].nextframe > 0 then dec(players[id].nextframe) else players[id].nextframe := players[id].dieframerefreshtime;
                exit;}
        end;
// ===========================================================================
// WALK ANIM

       if players[id].dead>0 then exit;

       if NOT MATCH_DDEMOPLAY then
       if DDEMO_VERSION=0 then
       if players[id].netupdated=false then mainform.PowerGraph.RenderEffect(mainform.Images[3], trunc(players[id].TESTPREDICT_X-16)+GX, trunc(players[id].TESTPREDICT_Y-55)+GY,0, effectSrcAlpha or EffectDiffuseAlpha);

        if players[id].nextframe > 0 then dec(players[id].nextframe);// else players[id].nextframe := players[id].framerefreshtime;

        if(players[id].dir = 1) or (players[id].dir = 0) then
        if players[id].nextframe = 0 then begin
                if players[id].crouch then begin
                        if players[id].item_haste > 0 then
                        players[id].nextframe := players[id].crouchrefreshtime-1 else
                        players[id].nextframe := players[id].crouchrefreshtime;
                end else begin
                        if players[id].item_haste > 0 then
                        players[id].nextframe := players[id].framerefreshtime-1 else
                        players[id].nextframe := players[id].framerefreshtime;
                end;

                if not players[id].crouch then begin
                        if (players[id].frame < players[id].walkframes-1) then inc(players[id].frame) else players[id].frame:=0;
                end else begin
                        if (players[id].frame < players[id].crouchframes-1) then inc(players[id].frame) else players[id].frame:=0;
                        end;
        end;

        if SYS_BLOODPUNK then ParticleEngine.AddParticle(trunc(players[id].x +  GX),trunc(players[id].y + Gy)-22, (Random(12) - 6)/5, -Random(4)-1,TRUE);

        if(players[id].dir = 0) or (players[id].dir = 1) then frm := 1+players[id].frame; // walking\crouching
        if(players[id].dir = 2) or (players[id].dir = 3) then begin // Stanging
                frm := 0;
               if players[id].crouch=true then
                players[id].frame := players[id].crouchstartframe else
                players[id].frame := players[id].walkstartframe;
        end;

        // ghost preview.
{                if (dr = 1) or (dr = 3) then
                mainform.PowerGraph.RenderEffectCol(mainform.Images[players[id].walk_index], trunc(players[id].x -players[id].modelsizex div 2)+GX, trunc(players[id].y-24)+GY,$77FFFFFF,frm, effectSrcAlpha or effectDiffuseAlpha) else
                mainform.PowerGraph.RenderEffectCol(mainform.Images[players[id].walk_index], trunc(players[id].x-players[id].modelsizex div 2)+GX, trunc(players[id].y-24)+GY,$77FFFFFF,frm, effectSrcAlpha or effectDiffuseAlpha or effectMirror);
 }
 
        RenderPlayerFlag(realx,realy,ID);

        clr:=$FFFFFFFF;
        if (players[id].item_invis>0) then begin
                if (players[id].netobject=false) and (players[id].idd <> 2) then clr := $33FFFFFF;
                if (players[id].netobject=true) then clr := $01FFFFFF;
                if (players[id].idd = 2) then clr := $01FFFFFF;
                if MATCH_DDEMOPLAY then clr := $33FFFFFF;
                if (players[id].item_quad > 0) or (players[id].item_battle > 0) or ((players[id].item_regen > 0) and (players[id].item_regen_time>0)) then clr:=$FFFFFFFF;
        end;

        if(players[id].crouch) then begin
                if (dr = 1) or (dr = 3) then
                mainform.PowerGraph.RenderEffectCol(mainform.Images[players[id].crouch_index], trunc(RealX-players[id].crouchsizex div 2)+GX, trunc(RealY-24)+GY+48-players[id].crouchsizey,clr,frm, effectSrcAlpha or effectDiffuseAlpha) else
                mainform.PowerGraph.RenderEffectCOl(mainform.Images[players[id].crouch_index], trunc(RealX-players[id].crouchsizex div 2)+GX, trunc(RealY-24)+GY+48-players[id].crouchsizey,clr,frm, effectSrcAlpha or effectDiffuseAlpha or effectMirror);
        end else begin
                if (dr = 1) or (dr = 3) then
                mainform.PowerGraph.RenderEffectCol(mainform.Images[players[id].walk_index], trunc(RealX-players[id].modelsizex div 2)+GX, trunc(RealY-24)+GY,clr,frm, effectSrcAlpha or effectDiffuseAlpha) else
                mainform.PowerGraph.RenderEffectCol(mainform.Images[players[id].walk_index], trunc(RealX-players[id].modelsizex div 2)+GX, trunc(RealY-24)+GY,clr,frm, effectSrcAlpha  or effectDiffuseAlpha or effectMirror);
        end;

        // P0werUpz.
        if (players[id].item_quad > 0) or (players[id].item_battle > 0) or (players[id].item_regen > 0) then begin
                clr:=$0;
                if players[id].item_quad > 0 then begin
                        if (TeamGame) and (players[id].Team = c_teamred) and (OPT_FXQUAD) then
                        clr := $300000FF else
                        clr := $77FFFF00;
                end;
                if players[id].item_battle > 0 then clr := $770B92FF;
                if (players[id].item_battle > 0) and (players[id].item_quad > 0) then
                if players[id].paintime > 0 then clr := $770B92FF else begin
                        //quad color
                                if (TeamGame) and (players[id].Team = c_teamred) and (OPT_FXQUAD) then
                                clr := $300000FF else
                                clr := $77FFFF00;
                        end;

                if (players[id].item_regen > 0) and (players[id].item_regen_time > 0) then clr := $770000FF;

                if(players[id].crouch=true) then begin
                        if (dr = 1) or (dr = 3) then
                        mainform.PowerGraph.RenderEffectCol(mainform.Images[players[id].cpower_index], trunc(RealX-players[id].crouchsizex div 2)+GX, trunc(RealY-24)+GY+48-players[id].crouchsizey,clr,frm, effectSrcAlphaAdd or EffectDiffuseAlpha) else
                        mainform.PowerGraph.RenderEffectCol(mainform.Images[players[id].cpower_index], trunc(RealX-players[id].crouchsizex div 2)+GX, trunc(RealY-24)+GY+48-players[id].crouchsizey,clr,frm, effectSrcAlphaAdd or EffectDiffuseAlpha or effectMirror);
                end else begin
                        if (dr = 1) or (dr = 3) then
                        mainform.PowerGraph.RenderEffectCol(mainform.Images[players[id].power_index], trunc(RealX-players[id].modelsizex div 2)+GX, trunc(RealY-24)+GY,clr,frm, effectSrcAlphaAdd or EffectDiffuseAlpha) else
                        mainform.PowerGraph.RenderEffectCol(mainform.Images[players[id].power_index], trunc(RealX-players[id].modelsizex div 2)+GX, trunc(RealY-24)+GY,clr,frm, effectSrcAlphaAdd or EffectDiffuseAlpha or effectMirror);
                end;
        end;

//         mainform.PowerGraph.line(trunc(RealX)+GX+9, trunc(RealY)+GY + 23, trunc(RealX)+GX+9, trunc(RealY)+GY + 8, $FF00FF00,0);

//if (bbb[ trunc(x-z) div 32, trunc(y+24) div 16].block = true) and
  // (bbb[ trunc(x-z) div 32, trunc(y-4)  div 16].block = false) then begin result := true; exit; end;


// ===========================================================================
end;

// play music
procedure notif;
begin
end;

{procedure PLAYSOUND(SNDINDEX : word;x,y : real);
var pos, vel: TFSoundVector;
begin

//    if SNDINDEX > SND_gauntl_a then exit;
    Channel1 := FSOUND_PlaySound(FSOUND_FREE, SAMPLES[SNDINDEX]);
    FSOUND_SetPan(Channel1,255);

end;
}
procedure PLAYSOUND(SNDINDEX : word;x,y : real);
var
    realx, realy : double;
    channel1 : longint;
    PanValue : integer;
begin
//        addmessage('^6Sound at '+inttostr(round(x))+'x'+inttostr(round(y)));

  if OPT_SOUND = false then exit;
  if OPT_VOLUME=0 then exit;

  // stereo sound for big maps.
  // --------------------------
   if ((BRICK_X <> 20) or (BRICK_Y <> 30)) and (opt_cameratype=1) and (x > 0) and (y > 0) then begin // Direct 3d Sound must be here.
         if players[OPT_1BARTRAX] = nil then exit;

         // listener position.
         realx := X - round(players[OPT_1BARTRAX].X);
         realy := y - round(players[OPT_1BARTRAX].Y);

///      if sndindex=SND_respawn then addmessage(players[OPT_1BARTRAX].netname+' at: '+inttostr(round(realx))+'x'+inttostr(round(realy)));
//       addmessage(inttostr(round(realx)));

         if realx < - 450 then exit;
         if realx > 450 then exit;
         if realy < - 350 then exit;
         if realy > 350 then exit;

         if OPT_STEREO = true then begin

         PanValue := round(realx);
//         PanValue := round(X-320);
         PanValue := PanValue div (OPT_CHANNELAPPROACH div 3+3);
         PanValue := PanValue + 127;
         if PanValue < 0 then PanValue := 0;
         if PanValue > $FF then PanValue := $FF;
         if OPT_REVERSESTEREO then PanValue := -panvalue;
         end else panvalue := 0;

         Channel1 := FSOUND_PlaySound(FSOUND_FREE, SAMPLES[SNDINDEX]);
         FSOUND_SetVolume( channel1, trunc(OPT_VOLUME*2.5));
         FSOUND_SetPan(Channel1,panvalue);

         exit;
  end;
  // --------------------------

  if OPT_STEREO = true then begin
        PanValue := round(X-320);
        PanValue := PanValue div (OPT_CHANNELAPPROACH div 3+3);
        PanValue := PanValue + 127;
        if PanValue < 0 then PanValue := 0;
        if PanValue > $FF then PanValue := $FF;
        if OPT_REVERSESTEREO then PanValue := -panvalue;
  end else panvalue := 0;

  if (x=0) and (y=0) then panvalue := 127;
  Channel1 := FSOUND_PlaySound(FSOUND_FREE, SAMPLES[SNDINDEX]);
  FSOUND_SetVolume(channel1, trunc(OPT_VOLUME*2.5));
  FSOUND_SetPan(Channel1,panvalue);
end;


procedure MP3_STOP;
begin
if not OPT_SOUND then exit;
if SYS_NFKAMPSTATE = 1 then FSOUND_Stream_Stop(FMODStream);
SYS_NFKAMPSTATE := 0;
addmessage('nfkamp - ^5stopped');
end;

procedure MP3_RESET;
begin

        if OPT_SOUND=false then exit;
        SYS_NFKAMP_PLAYINGCOMMENT := false;

        if SYS_NFKAMPSTATE = 1 then FSOUND_Stream_Stop(FMODStream);

        SYS_NFKAMPSTATE := 0;
        mp3lastsel:=$FFFF;

        if not fileexists(ROOTDIR+'\music\mp3list.dat') then begin
                addmessage('file mp3list.dat not found in the basenfk\music\');
                exit;
        end;

        mp3list.loadfromfile(ROOTDIR+'\music\mp3list.dat');
        if mp3list.Count = 0 then begin
                addmessage('file mp3list.dat is empty');
                exit;
        end;
        addmessage('nfkamp - ^5reset');
end;


procedure MP3_START;
var sel :word;channel:integer;
begin
        if not GAME_FULLLOAD then begin
                SYS_NFKAMP_SHOULDSTARTMP3 := true;
                exit;
                end;

        if OPT_SOUND=false then exit;
        if SYS_NFKAMP_PLAYINGCOMMENT then MP3_RESET;
        if SYS_NFKAMPSTATE=1 then FSOUND_Stream_Stop(FMODStream);

        if not fileexists(ROOTDIR+'\music\mp3list.dat') then begin
                addmessage('file mp3list.dat not found in the basenfk\music\');
                exit;
        end;

        if mp3list.Count = 0 then begin
                mp3list.loadfromfile(ROOTDIR+'\music\mp3list.dat');
                if mp3list.Count = 0 then begin
                        addmessage('file mp3list.dat is empty');
                        exit;
                end;
        end;

        // no double mp3 load.
        // mp3 playlist randomizer
        if mp3list.count > 1 then begin
                sel := random(mp3list.count);
                mp3lastsel := sel;
        end else begin
                sel := 0;
                mp3lastsel:=$FFFF;
        end;

        if fileexists(mp3list[sel]) then addmessage('nfkamp - ^5playing ^7[^3'+extractfilename(mp3list[sel])+'^7]');

        FMODStream := FSOUND_Stream_OpenFile(pchar(mp3list[sel]), FSOUND_LOOP_OFF or FSOUND_NORMAL, 0);
        if FMODstream = nil then begin
                Addmessage('nfkamp: error playing '+mp3list[sel]+' ('+FMOD_ErrorString(FSOUND_GetError())+')');
                SYS_NFKAMPSTATE := 0;
                exit;
        end;

        channel := FSOUND_Stream_Play(FSOUND_FREE, FMODStream);
        FSOUND_SetVolume( channel, trunc(OPT_MP3VOLUME*2.5));

        if channel < 0 then begin
                Addmessage('nfkamp: error playing '+mp3list[sel]+' ('+FMOD_ErrorString(FSOUND_GetError())+')');
                SYS_NFKAMPSTATE := 0;
                exit;
        end;

        SYS_NFKAMPREFRESH := 0;
        SYS_NFKAMPSTATE := 1;
        mp3list.delete(sel);
end;

procedure STARTMUSIC(id : byte);
var sr : TSearchRec;
    sel : word;
begin
if id = 0 then begin
 chdir(ROOTDIR+'\music');
 if FindFirst('*.mid', faAnyFile, sr) = 0 then begin
        muslist.add(sr.Name);
        while FindNext(sr) = 0 do
                muslist.add(sr.Name);
        end;
 chdir(ROOTDIR);
 end;
 sel := random(muslist.count);
 mainform.mediaplayer1.filename := ROOTDIR+'\music\'+muslist[sel];
 mainform.mediaplayer1.Close;
 mainform.mediaplayer1.open;
 mainform.mediaplayer1.play;
 addmessage('Playing midi "^3'+muslist[sel]+'^7"');
 muslist.Delete (sel);
end;

function ExtractModelClassName (s : shortstring) : shortstring;
begin
        result := copy(s,1, Pos('+', S)-1);
end;

function ExtractModelSkinName (s : shortstring) : shortstring;
begin
        if Pos('+', S) = 0 then begin
                result := '';
                exit;
                end;
        result := copy(s,Pos('+', S)+1,length(s)-Pos('+', S)+1);
end;

function MODELEXISTS (s : shortstring): boolean;
var i : word;
begin
        result := false;
        for i := 0 to NUM_MODELS-1 do if (eee[i].classname+'+'+eee[i].skinname) = s then result := true;
end;

function TeamGame:boolean;
begin
        result:=false;
        if (MATCH_GAMETYPE = GAMETYPE_TEAM) or (MATCH_GAMETYPE = GAMETYPE_CTF)
        or (MATCH_GAMETYPE = GAMETYPE_DOMINATION) then result := true;
end;

function MyDxidIS():word;
var i :byte;
begin
        result := 0;
        if MATCH_DDEMOPLAY then begin
                if players[OPT_1BARTRAX] <> nil then
                result := players[OPT_1BARTRAX].dxid
                else result := 0;
                exit;
                end;
        for i := 0 to 7 do if players[i] <> nil then
        if players[i].netobject = false then begin
                result := players[i].dxid;
                exit;
        end;
end;

function FindPlayerByIP(Ip: string):boolean;
var i :byte;
begin
        result := false;
        for i := 0 to 7 do if players[i] <> nil then
        if players[i].IPAddress <> '0.0.0.0' then
        if players[i].IPAddress <> '127.0.0.1' then
        if players[i].IPAddress = Ip then begin
                result := true;
                exit;
        end;
end;

function MyPingIS():word;
var i :byte;
begin
        result := 0;
{        if MATCH_DDEMOPLAY then begin
                if players[OPT_1BARTRAX] <> nil then
                result := players[OPT_1BARTRAX].dxid
                else result := 0;
                exit;
                end;}
        for i := 0 to 7 do if players[i] <> nil then
        if players[i].netobject = false then begin
                result := players[i].ping;
                exit;
        end;
end;

function MyteamIS():byte;
var i :byte;
begin
        if MATCH_DDEMOPLAY then begin
                if players[OPT_1BARTRAX] <> nil then
                result := players[OPT_1BARTRAX].team else result := 2;
                exit;
                end;
        for i := 0 to 7 do if players[i] <> nil then
        if players[i].netobject = false then begin
                result := players[i].team;
                exit;
        end;
end;

function MyNameIS():string;
var i:byte;
begin
        if MATCH_DDEMOPLAY then begin
                if players[OPT_1BARTRAX] <> nil then
                result := players[OPT_1BARTRAX].netname;
                exit;
                end;
        for i := 0 to 7 do if players[i] <> nil then
        if players[i].netobject = false then begin
                result := players[i].netname;
                exit;
        end;
end;

function ASSIGNMODEL(f : TPlayer) : boolean;
var i : byte;
    fail : boolean;
    originalmodel:string[30];
begin
        fail := false;
        f.nfkmodel := lowercase(f.nfkmodel);
        originalmodel := f.nfkmodel;
//        addmessage('^2debug: original '+f.netname+' model is '+originalmodel);

        if not MATCH_DDEMOPLAY then
        if (f.netobject = true) or (f.idd=2) then begin  // networked
                if OPT_ENEMYMODEL<>'' then begin
                        if not TeamGame then f.nfkmodel := OPT_ENEMYMODEL else
                        if (f.team <> MyTeamIS) and (f.team <> C_TEAMNON) then
                                f.nfkmodel := OPT_ENEMYMODEL;
                end;

                if OPT_TEAMMODEL<>'' then
                if TeamGame then
                if (f.team = MyTeamIS) and (f.team <> C_TEAMNON) then
                        f.nfkmodel := OPT_TEAMMODEL;
        end;

        // teamplay model selection
        if TeamGame() then begin
                        if f.team = C_TEAMRED then// blu
                        if MODELEXISTS(ExtractModelClassName(f.nfkmodel)+'+red') then
                        f.nfkmodel := ExtractModelClassName(f.nfkmodel)+'+red' else begin
                                addmessage('cant find teamskin ('+ExtractModelClassName(f.nfkmodel)+'+red)');
                                f.nfkmodel := 'sarge+red';
                                fail := true;
                        end;

                        if f.team = C_TEAMBLU then// blu
                        if MODELEXISTS(ExtractModelClassName(f.nfkmodel)+'+blue') then
                        f.nfkmodel := ExtractModelClassName(f.nfkmodel)+'+blue' else begin
                                addmessage('cant find teamskin ('+ExtractModelClassName(f.nfkmodel)+'+blue)');
                                f.nfkmodel := 'sarge+blue';
                                fail := true;
                        end;

                        if f.team = C_TEAMNON then// none
                        if MODELEXISTS(ExtractModelClassName(f.nfkmodel)+'+default') then
                        f.nfkmodel := ExtractModelClassName(f.nfkmodel)+'+default' else begin
                                addmessage('cant find teamskin ('+ExtractModelClassName(f.nfkmodel)+'+default)');
                                f.nfkmodel := 'sarge+default';
                                fail := true;
                        end;
        end;

        for i := 0 to NUM_MODELS-1 do if (eee[i].classname+'+'+eee[i].skinname) = f.nfkmodel then begin
                f.dieframes := eee[i].dieframes;
                f.walkframes := eee[i].walkframes;
                f.modelsizex := eee[i].modelsizex;
                f.soundmodel := eee[i].classname;
                f.walk_index := eee[i].walk_index;
                f.die_index := eee[i].die_index;
                f.crouch_index := eee[i].crouch_index;
                f.power_index := eee[i].power_index;
                f.cpower_index := eee[i].cpower_index;
                f.diesizey := eee[i].diesizey;
                f.crouchsizex := eee[i].crouchsizex;
                f.crouchsizey := eee[i].crouchsizey;
                f.crouchframes := eee[i].crouchframes;
                f.framerefreshtime := eee[i].framerefreshtime;
                f.crouchrefreshtime := eee[i].crouchrefreshtime;
                f.crouchstartframe := eee[i].crouchstartframe;
                f.dieframerefreshtime := eee[i].dieframerefreshtime;
                f.walkstartframe := eee[i].walkstartframe;
                f.SND_death1 := eee[i].SND_death1;
                f.SND_death2 := eee[i].SND_death2;
                f.SND_death3 := eee[i].SND_death3;
                f.SND_Jump := eee[i].SND_Jump;
                f.SND_Pain100 := eee[i].SND_Pain100;
                f.SND_Pain75 := eee[i].SND_Pain75;
                f.SND_Pain50 := eee[i].SND_Pain50;
                f.SND_Pain25 := eee[i].SND_Pain25;
//                f.crouch := false;       //!!! temp. remove it;
                f.frame := 0;
                result := true;
                if MODELEXISTS(originalmodel) then f.nfkmodel := originalmodel;
                exit;
        end;
        addmessage('invalid model+skin name '+'('+f.nfkmodel+')');

        // set to default model...
        for i := 0 to NUM_MODELS-1 do if (eee[i].classname+'+'+eee[i].skinname) = 'sarge+default' then begin
                f.dieframes := eee[i].dieframes;
                f.walkframes := eee[i].walkframes;
                f.modelsizex := eee[i].modelsizex;
                f.soundmodel := eee[i].classname;
                f.walk_index := eee[i].walk_index;
                f.die_index := eee[i].die_index;
                f.crouch_index := eee[i].crouch_index;
                f.power_index := eee[i].power_index;
                f.cpower_index := eee[i].cpower_index;
                f.diesizey := eee[i].diesizey;
                f.crouchsizex := eee[i].crouchsizex;
                f.crouchsizey := eee[i].crouchsizey;
                f.crouchframes := eee[i].crouchframes;
                f.framerefreshtime := eee[i].framerefreshtime;
                f.crouchrefreshtime := eee[i].crouchrefreshtime;
                f.crouchstartframe := eee[i].crouchstartframe;
                f.dieframerefreshtime := eee[i].dieframerefreshtime;
                f.walkstartframe := eee[i].walkstartframe;
                f.SND_death1 := eee[i].SND_death1;
                f.SND_death2 := eee[i].SND_death2;
                f.SND_death3 := eee[i].SND_death3;
                f.SND_Jump := eee[i].SND_Jump;
                f.SND_Pain100 := eee[i].SND_Pain100;
                f.SND_Pain75 := eee[i].SND_Pain75;
                f.SND_Pain50 := eee[i].SND_Pain50;
                f.SND_Pain25 := eee[i].SND_Pain25;
                f.crouch := false;
                if eee[i].cached = true then eee[i].cached := false;
                f.frame := 0;
                if MODELEXISTS(originalmodel) then f.nfkmodel := originalmodel;
                exit;
        end;

        result := false;
end;

function SpawnServer_PreInit : boolean;
var
    I,c:word;
    xx,yy:byte;

begin
    mainform.dxtimer.FPS := 50;
    MATCH_STARTSIN := 4;

        result := false;


        c:=0; // there is no respawns on this map!!
        for xx := 0 to BRICK_X-1 do
        for yy := 0 to BRICK_Y-1 do begin
                if (bbb[xx,yy].respawntime = -1) then begin
                        c:=1;
                        break;
                end;
        end;

        if c=0 then begin
                addmessage('Invalid map. Selected map doesn''t have respawn points!');
                ShowCriticalError('Invalid map','Selected map doesn''t have','respawn points!');
                Applyhcommand('disconnect');
                exit;
        end;


    if MATCH_GAMETYPE = GAMETYPE_CTF then
    if not CTF_VALIDMAP then begin
                addmessage('Invalid map. This is not correct Capture The Flag map');
                ShowCriticalError('Invalid map','This is not correct ','Capture The Flag map');
                ApplyHcommand('disconnect');
                exit;
    end;

    if MATCH_GAMETYPE = GAMETYPE_DOMINATION then
    if not DOM_VALIDMAP then begin
                addmessage('Invalid map. This is not correct Domination map');
                ShowCriticalError('Invalid map','This is not correct ','Domination map');
                ApplyHcommand('disconnect');
                exit;
    end;


    // trick arena enable...
    for i := 0 to NUM_OBJECTS do if (ddd[i].active = true) and (ddd[i].objtype = 7) then begin

         if ISMULTIP=1 then begin
                ShowCriticalError('Can''t change map','Can''t use trick arena maps for multiplayer','');
                ApplyHcommand('disconnect');
                playsound(snd_error,0,0);
                exit;
         end;

         MATCH_GAMETYPE := GAMETYPE_TRIXARENA;
         if OPT_NOPLAYER=0 then OPT_NOPLAYER:=2;
    end;
    if not MATCH_DDEMOPLAY then MATCH_DDEMOMPPLAY := 0;
    GetMapWeaponData;
    INSCOREBOARD := false;
    starttime := gettickcount;
    answertime := gettickcount;
    LASTRESPAWN := 0;
    LASTRESPAWNRED := 0;
    LASTRESPAWNBLUE := 0;
    OPT_DRAWFRAGBARMYFRAG := 0;
    OPT_DRAWFRAGBAROTHERFRAG := 0;
    GAMEMENUORDER := 0;
    MATCH_REDTEAMSCORE := 0;
    MATCH_BLUETEAMSCORE := 0;

    result := true;
end;

procedure SpawnServer_PostInit;
var    I,c:word;
begin
        GetMapWeaponData;
        resetmap;

        if (MATCH_GAMETYPE = GAMETYPE_PRACTICE) or (MATCH_GAMETYPE = GAMETYPE_RAILARENA) then begin
                for i := 0 to BRICK_X-1 do      // remove itemz.
                for c := 0 to BRICK_Y-1 do begin
                        if bbb[i,c].image > 0 then
                                if bbb[i,c].respawnable = TRUE then begin
                                        bbb[i,c].respawntime := 0;
                                        bbb[i,c].scale := 255;
                                        bbb[i,c].respawnable := false;
                                end;
                end;
        end;

        if ismultip=2 then
        for i := 0 to BRICK_X-1 do      // remove itemz.
        for c := 0 to BRICK_Y-1 do
        if bbb[i,c].image > 0 then
        if bbb[i,c].respawnable = TRUE then begin
                bbb[i,c].respawntime := 2;
                bbb[i,c].scale := 255;
        end;

        MATCH_STARTSIN := MATCH_WARMUP*50;

        gametic := 0; gametime := 0;
        INMENU := false;
        GX := 0; GY := 0;
        map_info := 8;

        if not OPT_NETSPECTATOR then
        if TeamGame then SYS_TEAMSELECT := 30;

        if (OPT_SV_DEDICATED) and (ismultip=1) then SYS_TEAMSELECT := 0;

        if MATCH_GAMETYPE = GAMETYPE_TRIXARENA then begin
                if OPT_TRIXMASTA then begin
                        MATCH_STARTSIN := 250;
                        applyhcommand('record temp');
                        end
                else MATCH_STARTSIN := 500;
        end;

        if ismultip=1 then begin
                if MATCH_GAMETYPE=GAMETYPE_CTF then OPT_TEAMDAMAGE := false;
                if MATCH_GAMETYPE=GAMETYPE_DOMINATION then OPT_TEAMDAMAGE := false;
                if MATCH_GAMETYPE=GAMETYPE_TEAM then OPT_TEAMDAMAGE := true;
        end;


        if (mainform.LOBBY.active) and (ismultip=1) then addmessage('^3NFKPLANET: Your server successfully registered. Please wait for players.') else if ismultip=1 then begin
                // lan or direct connect game
                HIST_DISABLE := true;
                ALIASCOMMAND := true;
                applycommand('ipaddress');
                ALIASCOMMAND := false;
                HIST_DISABLE := false;

        end;

end;

procedure SPAWNSERVER;
var a,b : TPlayer;
    msg:  TMP_RegisterPlayer;
    msg2: TMP_SpectatorJoin;
    msgsize: word;
begin
try

with mainform do begin

     if not SpawnServer_PreInit() then exit;

        // LOCAL p1 Spawn.
    if ismultip=0 then begin
         if OPT_NOPLAYER <> 1 then begin
                a := TPlayer.Create;
                with a do begin
                        objname := 'player';
                        idd := 0; /// first player.
                        control := 1;   // mouse control
                        health := 125;
                        armor := 0;
                        x := 320;
                        y := 200;
                        netname := p1name;
                        netobject := false;     // local player
                        nfkmodel := OPT_NFKMODEL1;
                        OPT_1BARTRAX := 0;
                        dead := 0;
                        frame := 0;
                        netnosignal := 0;
                        DXID := AssignUniqueDXID($FFFF);
                        netupdated:=true;
                        if TeamGame then team := 2; // reset to null team...

                        addplayer(a);
                        resetplayer(a);
                        resetplayerstats(a);
                end;
                ASSIGNMODEL(a);
        end;

        if OPT_NOPLAYER <> 2 then
        if ISMULTIP=0 THEN BEGIN //only local?
        b := TPlayer.Create;               // second player :)
        with b do begin
                idd := 1; ///player.
                objname := 'player';
                health := 125;
                control := 2;   // kbrd control
                netname := p2name;
                armor := 0;
                nfkmodel := OPT_NFKMODEL2;
                OPT_2BARTRAX := 1;
                netobject := false;     // local player
                DXID := AssignUniqueDXID($FFFF);
                dead := 0;
                netnosignal := 0;
                frame := 0;
                if TeamGame then team := 2; // reset to null team...

                addplayer(b);
                resetplayer(b);
                netupdated:=true;
                resetplayerstats(b);
        end;
        ASSIGNMODEL(b);
       end;
        if OPT_NOPLAYER <> 1 then findrespawnpoint(a,false);
        if OPT_NOPLAYER <> 2 then findrespawnpoint(b,false);
    end;        // end players server spawn;

    if ismultip=0 then if (OPT_NOPLAYER=1) or (OPT_NOPLAYER=2) then SYS_BAR2AVAILABLE := false else SYS_BAR2AVAILABLE := true;

    // Networked SV P1 Spawn.
        if OPT_SV_DEDICATED=false then
        if ismultip=1 then begin
                a := TPlayer.Create;
                SYS_BAR2AVAILABLE := false;
                with a do begin
                        objname := 'player';
                        idd := 0;       // first player.
                        control := 1;   // mouse control
                        health := 125;
                        armor := 0;
                        netname := p1name;
                        netobject := false;     // local player
                        nfkmodel := OPT_NFKMODEL1;
                        dead := 0;
                        x := 320;
                        y := 200;
                        netnosignal := 0;
                        netupdated:=true;
                        IPAddress := MainForm.GlobalIP;
                        frame := 0;
                        DXID := AssignUniqueDXID($FFFF);
                        if TeamGame then team := 2; // reset to null team...

                        addplayer(a);
                        resetplayer(a);
                        OPT_1BARTRAX := 0;
                        OPT_2BARTRAX := 1;
                        resetplayerstats(a);
                end;
                ASSIGNMODEL(a);
                FindRespawnPoint(a,false);

//              if (MATCH_GAMETYPE <> GAMETYPE_CTF) or (MATCH_GAMETYPE = GAMETYPE_TEAM)
                // Networked SV P2 Spawn (only if OPT_SV_TESTPLAYER2);
                if not mainform.lobby.active then
                if OPT_SV_TESTPLAYER2 then begin // testcommand...
                       b := TPlayer.Create;
                        SYS_BAR2AVAILABLE := true;
                        with b do begin
                                objname := 'player';
                                idd := 1;       // first player.
                                control := 2;   // mouse control
                                health := 125;
                                armor := 0;
                                netname := p2name;
                                netobject := false;     // local player
                                nfkmodel := OPT_NFKMODEL2;
                                IPAddress := inttostr(random(255))+'.'+inttostr(random(255))+'.'+inttostr(random(255))+'.'+inttostr(random(255));
                                dead := 0;
                                x := 320;
                                y := 200;
                                netnosignal := 0;
                                netupdated:=true;
                                frame := 0;
                                DXID := AssignUniqueDXID($FFFF);
                                if TeamGame then team := random(2); // sv_test2 have no rights to choose team...

                                addplayer(b);
                                resetplayer(b);
                                OPT_1BARTRAX := 0;
                                OPT_2BARTRAX := 1;
                                resetplayerstats(b);
                        end;
                        ASSIGNMODEL(b);
                        FindRespawnPoint(b,false);
                end;

        end;

       OPT_1BARTRAX := 0;
       OPT_2BARTRAX := 1;

       // overwise,, client ask for spawning..
        if ismultip=2 then
        if OPT_NETSPECTATOR=false then
        begin
                SYS_BAR2AVAILABLE := false;
                MsgSize := SizeOf(TMP_RegisterPlayer);
                Msg.DATA := MMP_REGISTERPLAYER;
                Msg.SIGNNATURE := NFK_SIGNNATURE;
                Msg.DXID := 0;
                Msg.ClientId := CLIENTID;
                Msg.nfkmodel := OPT_NFKMODEL1;
                Msg.netname := P1NAME;
                MainForm.BNETSendData2HOST(Msg, MsgSize,1);
        end else begin // join as spectator...
                MsgSize := SizeOf(TMP_SpectatorJoin);
                Msg2.DATA := MMP_SPECTATORCONNECT;
                Msg2.netname := P1NAME;
                MainForm.BNETSendData2HOST(Msg2, MsgSize,1); // there is no players yet!!! should be a bug..
        end;

       SpawnServer_PostInit();
       playsound(SND_prepare,0,0);
       NFKPLANET_UpdateCurrentUsers(GetNumberOfPlayers);
       if ismultip=1 then BNET_ServerStart;

       if BD_Avail then begin
             BD_FirstBoot();
             DLL_EVENT_BeginGame;
             DLL_EVENT_ResetGame;
       end;

end;

except addmessage('error spawning server'); end;

end;

procedure WrapTextOut (x,x1,y,y1 : integer; txt : string;cnv : TCanvas; fnt : Tfont);
var i,fin,yoffset,currls : integer;
    txtpr,textls : String;
begin
    txtpr := txt;
    yoffset := 0;
    if cnv.TextWidth(copy(txt,1,length(txt))) < x1-x then begin
                cnv.TextOut(x,(y+yoffset), txt);
                exit;
        end;
    fin := 0;
    yoffset := 0;
    repeat
    currls := 1;
    textls := '';
    for i := 1 to length(txtpr) do begin
                if txtpr[i] = #13 then begin
                                        cnv.TextOut(x,(y+yoffset), textls);
                                        yoffset := yoffset + 15;
                                        txtpr := copy(txtpr, currls+1, length(txtpr));
                                        if(i = length(txtpr)) then begin
                                                cnv.TextOut(x,(y+yoffset), txtpr);
                                                fin := 1;
                                                end;
                                        break;
                                        end else
                                                begin
                                                        textls := copy(txtpr, 1, i-1);
                                                        currls := i;
                                                end;
        end;
    until (fin = 1);
end;

procedure LoadingShow(text: string);
//var x : word;
begin
        exit;
{      if not OPT_SHOWLOADING then exit;
//        if mainform.dxdraw.candraw = false then exit;
        with mainform.dxdraw.surface.canvas do begin
          Brush.Style := bsSolid;
          Pen.color := clBlack;
          Brush.Color := clBlack;
//          pen.color := $0000AA;
          font.name := 'arial';
          rectangle(250,400,390,460);
          font.style := [fsBold];
          Font.Size := 14;
          Font.Color := clWhite;
//          x := round(320-(mainform.dxdraw.surface.canvas.TextWidth(text)/2));
  //        addmessage(inttostr(X));
          Textout(276, 420, 'LOADING');
          release;
        end;
        mainform.dxdraw.Flip;}
end;

procedure ShadowTextOut(x,y : integer;text : string; canvas : TCanvas; fontcolor : integer;fontsize : byte);
begin
with canvas do begin
    Brush.Style := bsClear;
    font.name := canvas.font.name;
    Font.Size := fontsize;
    Font.Color := clblack;
    Textout(menux+x+2, menuy+y+2, text);
    Font.Color := fontcolor;
    Textout(menux+x, menuy+y, text);
end;
end;
// MENU

procedure GoMenuPage(id : byte);
begin
        IF id=MENU_PAGE_MAIN then begin
                menu1_alpha := 0;
                menu2_alpha := 0;
                menu3_alpha := 0;
                menu4_alpha := 0;
                menu5_alpha := 0;
                menu6_alpha := 0;
                button_alpha := 0;
                button1_alpha := 0;
        end;

        if id=MENU_PAGE_MULTIPLAYER then begin
                MP_STEP:=0;
                tgb := 0;
                end;

        if id=MENU_PAGE_HOTSEAT then
                if TeamGame then
                        MATCH_GAMETYPE := GAMETYPE_FFA;

        playsound(SND_menu3,0,0);
        MENUEDITMODE := 0;
        MENUEDITMAX := 0;
        MENUEDITSTR := '';
        mapcansel := 20;
        menuburn:=1;
        menuwantorder := id;
        menu_sl := 0;
        ctgr := 0;
        tgr := 255;
end;


var
  WindowHandle : HWND;

function EnumWindowsProc(WHandle: HWND; lParam: LPARAM): BOOL; export; stdcall;
const
  MAX_WINDOW_NAME_LEN = 80;
var
  WindowName : array[0..MAX_WINDOW_NAME_LEN] of char;
begin
  {Can't test GetWindowText's return value since some windows don't have a title}
  GetWindowText(WHandle,WindowName,MAX_WINDOW_NAME_LEN);
  Result := (StrLIComp(WindowName,PChar(lParam), StrLen(PChar(lParam))) <> 0);
  If (not Result) then WindowHandle:=WHandle;
end;

function AppActivate_(WindowName : PChar) : boolean;
begin
  try
    Result:=true;
    WindowHandle:=FindWindow(nil,WindowName);
    If (WindowHandle=0) then EnumWindows(@EnumWindowsProc,Integer(PChar(WindowName)));
    If (WindowHandle<>0) then begin
      SendMessage(WindowHandle, WM_SYSCOMMAND, SC_HOTKEY, WindowHandle);
      SendMessage(WindowHandle, WM_SYSCOMMAND, SC_RESTORE, WindowHandle);
    end else Result:=false;
  except
    on Exception do Result:=false;
  end;
end;

procedure closewin;
var
        h : HWnd;
        capt:PCHAR;
        c:word;
        handle:THandle;
begin
        appactivate_(pchar(''));
  //      exit;
//        c := 0;
  //               h := GetWindow(Application.Handle, GW_HWNDFIRST);
    //             while h <> 0 do
      //           begin
        //           inc(c);
          //         if (GetWindow(h, GW_OWNER) = 0) and (GetParent(h) = 0) then begin
//          //              PostMessage(h, WM_SYSCOMMAND, SC_MINIMIZE, 0);
              //            getwindowtext(h,capt,5);
                //  //        if capt=pchar('delph') then showmessage('YO');
//               //           showmessage(capt[0]);
  //                      if capt='Delph'+#00 then addmessage('FOUND!');
//                        if capt=pchar('Delph') then addmessage('winamp found');
                   //       inc(c);
    //               end;
      //             h := GetWindow(h, GW_HWNDNEXT);
        //        end;

//addmessage('found: '+inttostr(c));
end;



procedure TexturedNumbersOut(number:integer; x, y, n_width, n_height: integer; color:cardinal);
var a, i : byte;
        arr : array[0..2] of byte;
        s : string;
begin
        if number < 0 then exit;
        if number < 10 then i := 1 else
        if number < 100 then i := 2 else
        i := 3;

        s := inttostr(number);
        for a := 1 to i do begin
                arr[a-1] := strtoint(s[a]);

                if OPT_HUD_SHADOWED then
//                mainform.PowerGraph.TextureMapRect (mainform.images[61],x-2 + (a*2-1)*round(n_width / 2) - (n_width*i) div 2 ,y-2,n_width+4,n_height+4,arr[a-1],(OPT_HUD_ALPHA div 1) shl 24+$000000,2 or $100);
                mainform.PowerGraph.TextureMapRect (mainform.images[61],x+2 + (a*2-1)*round(n_width / 2) - (n_width*i) div 2 ,y+3,n_width,n_height,arr[a-1],(OPT_HUD_ALPHA div 2) shl 24+$000000,2 or $100);
                mainform.PowerGraph.TextureMapRect (mainform.images[61],x + (a*2-1)*round(n_width / 2) - (n_width*i) div 2 ,y,n_width,n_height,arr[a-1],color,2 or $100);
        end;
end;

function GetColorTextCount(s:string):word;
var charcount:byte;
    readcolor : boolean;
    i:word;
begin
        charcount:=0;
        if s='' then begin result := 0; exit; end;
        for i := 1 to length(s) do begin

                if (readcolor) and (s[i]<>'^') then begin
                        readcolor := false;
                        end else
                if (readcolor=false) and (s[i]='^') then readcolor:=true else begin
                        inc(charcount);
                end;
        end;
        result := charcount;
end;

function GetColorTextWidth(s:string;fonttype:byte): word;
var
    readcolor : boolean;
    i : word;
    lastpos:integer;
begin
        if s='' then begin result := 0; exit; end;
        lastpos := 0;
        for i := 1 to length(s) do begin

                if (readcolor) and (s[i]<>'^') then begin
                        readcolor := false;
                        end else
                if (readcolor=false) and (s[i]='^') then readcolor:=true else begin
                        if fonttype=0 then begin        // font1.
                                lastpos := lastpos+mainform.font1.TextWidth (s[i]);
                        end else
                        if fonttype=1 then begin        // font2b.
                                lastpos := lastpos+mainform.font2b.TextWidth (s[i]);
                        end else
                        if fonttype=2 then begin        // font2s.
                                lastpos := lastpos+mainform.font2s.TextWidth (s[i]);
                        end else
                        if fonttype=3 then        // font2ss.
                                lastpos := lastpos+mainform.font2ss.TextWidth (s[i]) else
                        if fonttype=4 then        // font4.
                                lastpos := lastpos+mainform.font4.TextWidth (s[i]) else
                        if fonttype=5 then        // font2.
                                lastpos := lastpos+mainform.font2.TextWidth (s[i]);
                        if fonttype=6 then        // font2.
                                lastpos := lastpos+mainform.font3.TextWidth (s[i]);

                end;
        end;
        result := lastpos;
end;


function StripColorName(s:String):string;
var readcolor : boolean;
    i : word;
begin
        readcolor:=false;
        result := '';
        for i := 1 to length(s) do
        if (readcolor) and (s[i]<>'^') then readcolor := false else
        if (readcolor=false) and (s[i]='^') and (i < length(s))  then readcolor:=true else result := result + s[i];
end;



procedure ParseColorText(s: string;x,y:integer;fonttype:byte);
var
    readcolor : boolean;
    i : word;
    clr,a:cardinal;
    lastpos:integer;
    doblink:boolean;
    ali : boolean;
begin
        if s='' then exit;
        lastpos := x;
        a := $FF;
        clr:=$FFFFFF;
        doblink:=false;
        ali := mainform.PowerGraph.Antialias;
        mainform.PowerGraph.Antialias := true;

        for i := 1 to length(s) do begin

                if (readcolor) and (s[i]<>'^') then begin
                        readcolor := false;

                        if s[i]='#' then clr := $EB9D07 else
                        if s[i]='%' then clr := $00CEA0 else
                        if s[i]='&' then clr := $0073CB else
                        if s[i]='!' then clr := $aaaaaa else
                        if s[i]='0' then clr := $000000 else
//                        if s[i]='@' then clr := $666666 else
//                        if s[i]='@' then clr := $7700CB else

                        if (ord(s[i]) >= 49) and (ord(s[i]) <= 55) then begin
                                clr:=ACOLOR[strtoint(s[i])];
                        end;

                        if s[i] = 'b' then doblink:=true;
                        if s[i] = 'n' then doblink:=false;

                        if doblink then a:=font_alpha else a := $FF;
                        end else
                if (readcolor=false) and (s[i]='^') and (i < length(s)) then readcolor:=true else begin
                        if fonttype=0 then begin        // font1.
                                mainform.font1.TextOutEx(s[i],lastpos,y,(a shl 24)+clr,effectSrcAlpha or EffectDiffuseAlpha);
                                lastpos := lastpos+mainform.font1.TextWidth (s[i]);
                        end else
                        if fonttype=1 then begin        // font2b.
                                mainform.font2b.TextOutEx(s[i],lastpos,y,(a shl 24)+clr,effectSrcAlpha or EffectDiffuseAlpha);
                                lastpos := lastpos+mainform.font2b.TextWidth (s[i]);
                        end else
                        if fonttype=2 then begin        // font2s.
                                mainform.font2s.TextOutEx(s[i],lastpos,y,(a shl 24)+clr,effectSrcAlpha or EffectDiffuseAlpha);
                                lastpos := lastpos+mainform.font2s.TextWidth (s[i]);
                        end else
                        if fonttype=3 then begin        // font2ss.
                                mainform.font2ss.TextOutEx(s[i],lastpos,y,(a shl 24)+clr,effectSrcAlpha or EffectDiffuseAlpha);
                                lastpos := lastpos+mainform.font2ss.TextWidth (s[i]);
                        end else
                        if fonttype=4 then begin        // font4.
                                mainform.font4.TextOutEx(s[i],lastpos,y,(a shl 24)+clr,effectSrcAlpha or EffectDiffuseAlpha);
                                lastpos := lastpos+mainform.font4.TextWidth (s[i]);
                        end else
                        if fonttype=5 then begin        // font2.
                                mainform.font2.TextOutEx(s[i],lastpos,y,(a shl 24)+clr,effectSrcAlpha or EffectDiffuseAlpha);
                                lastpos := lastpos+mainform.font2.TextWidth (s[i]);
                        end;
                        if fonttype=6 then begin        // font3.
                                mainform.font3.TextOutEx(s[i],lastpos,y,(a shl 24)+clr,effectSrcAlpha or EffectDiffuseAlpha);
                                lastpos := lastpos+mainform.font3.TextWidth (s[i]);
                        end;
                end;
        end;
        mainform.PowerGraph.Antialias := ali;
end;

procedure ParseColorTextLimited(s: string;x,y:integer;fonttype:byte; limit:word);
var
    readcolor : boolean;
    i : word;
    clr,a:cardinal;
    lastpos:integer;
    doblink:boolean;
begin
        if s='' then exit;
        lastpos := x;
        a := $FF;
        clr:=$FFFFFF;
        doblink:=false;

        for i := 1 to length(s) do begin

                if (readcolor) and (s[i]<>'^') then begin
                        readcolor := false;

                        if s[i]='#' then clr := $EB9D07 else
                        if (ord(s[i]) >= 49) and (ord(s[i]) <= 55) then begin
                                clr:=ACOLOR[strtoint(s[i])];
                        end;

                        if s[i] = 'b' then doblink:=true;
                        if s[i] = 'n' then doblink:=false;

                        if doblink then a:=font_alpha else a := $FF;
                        end else
                if (readcolor=false) and (s[i]='^') then readcolor:=true else begin
                        if fonttype=0 then begin        // font1.
                                mainform.font1.TextOutEx(s[i],lastpos,y,(a shl 24)+clr,effectSrcAlpha or EffectDiffuseAlpha);
                                lastpos := lastpos+mainform.font1.TextWidth (s[i]);
                        end else
                        if fonttype=1 then begin        // font2b.
                                mainform.font2b.TextOutEx(s[i],lastpos,y,(a shl 24)+clr,effectSrcAlpha or EffectDiffuseAlpha);
                                lastpos := lastpos+mainform.font2b.TextWidth (s[i]);
                        end else
                        if fonttype=2 then begin        // font2s.
                                mainform.font2s.TextOutEx(s[i],lastpos,y,(a shl 24)+clr,effectSrcAlpha or EffectDiffuseAlpha);
                                lastpos := lastpos+mainform.font2s.TextWidth (s[i]);
                        end else
                        if fonttype=3 then begin        // font2ss.
                                mainform.font2ss.TextOutEx(s[i],lastpos,y,(a shl 24)+clr,effectSrcAlpha or EffectDiffuseAlpha);
                                lastpos := lastpos+mainform.font2ss.TextWidth (s[i]);
                        end else
                        if fonttype=4 then begin        // font4.
                                mainform.font4.TextOutEx(s[i],lastpos,y,(a shl 24)+clr,effectSrcAlpha or EffectDiffuseAlpha);
                                lastpos := lastpos+mainform.font4.TextWidth (s[i]);
                        end else
                        if fonttype=5 then begin        // font2.
                                mainform.font2.TextOutEx(s[i],lastpos,y,(a shl 24)+clr,effectSrcAlpha or EffectDiffuseAlpha);
                                lastpos := lastpos+mainform.font2.TextWidth (s[i]);
                        end;
                        if fonttype=6 then begin        // font3.
                                mainform.font3.TextOutEx(s[i],lastpos,y,(a shl 24)+clr,effectSrcAlpha or EffectDiffuseAlpha);
                                lastpos := lastpos+mainform.font3.TextWidth (s[i]);
                        end;
                        if limit<(lastpos-x) then exit;
                end;
        end;
end;

procedure ParseCenterColorText(s: string;y:integer;fonttype:byte);
begin
        ParseColorText(s,320-(GetColorTextWidth(s,fonttype) div 2),y,fonttype);
end;


procedure DrawConsole;
var i,b,wdh: word;
begin

if (not inconsole) and (SYS_CONSOLE_Y = 0) then exit;

  if inconsole then begin
                if SYS_CONSOLE_Y < SYS_CONSOLE_MAXY then begin
                inc(SYS_CONSOLE_Y, SYS_CONSOLE_DELIMETER);
                if SYS_CONSOLE_Y > SYS_CONSOLE_MAXY then SYS_CONSOLE_Y := SYS_CONSOLE_MAXY;
                end;
        end else
        if SYS_CONSOLE_Y > 0 then begin
                if SYS_CONSOLE_Y - SYS_CONSOLE_DELIMETER > 0 then
                dec(SYS_CONSOLE_Y,SYS_CONSOLE_DELIMETER)
                else SYS_CONSOLE_Y := 0;
        end;

 // console scroller scrolling.
 if OPT_NOCONSOLESCROLL=false then
 if mapcansel=0 then
 if inconsole then begin
        if iskey(mScrollUp) then if conmsg_index < conmsg.count+1-SYS_CONSOLE_MAXY div 15 then inc(conmsg_index);
        if iskey(mScrollDn) then if conmsg_index > 0  then dec(conmsg_index);
 end;

with mainform do begin
                        if SYS_CUSTOM_GRAPH_CONSOLE then begin
                                POwerGraph.Antialias := true;
                                if SYS_CONSOLE_STRETCH then
                                POwerGraph.TextureCol (images[49],0,0,640,0,640,SYS_CONSOLE_Y,0,SYS_CONSOLE_Y,(SYS_CONSOLE_ALPHA shl 24) + $FFFFFF,0,effectSrcAlpha or effectDiffuseAlpha) else

                                POwerGraph.TextureCol (images[49],0,SYS_CONSOLE_Y-480,640,SYS_CONSOLE_Y-480,640,SYS_CONSOLE_Y,0,SYS_CONSOLE_Y,(SYS_CONSOLE_ALPHA shl 24) + $FFFFFF,0,effectSrcAlpha or effectDiffuseAlpha);
                                POwerGraph.Antialias := false;
                        end else begin

                        for i := 0 to 4 do for b := 0 to 4 do if 32*b-16 > 0 then
                                        PowerGraph.RenderEffectCol(Images[6], round(128*i), round(SYS_CONSOLE_Y-480+128*b-32-128), (SYS_CONSOLE_ALPHA shl 24) + $FFFFFF , 0, effectSrcAlpha or effectDiffuseAlpha);
    end;

                        Font1.scale := 256;
                        Font1.AlignedOut(Version, 0, SYS_CONSOLE_Y-17,taFinal,tanone, $0000EE);

                        Font1.TextOut(']', 1, SYS_CONSOLE_Y-17, clWhite);


                        if SYS_CONSOLE_POS = Length(constr) then begin
                                ParseColorText(constr+'^b_', 8, SYS_CONSOLE_Y-17,0);
                        end else begin
                                wdh := Font1.TextWidth (']'+ copy( StripColorName(constr), 1, SYS_CONSOLE_POS)  );
                                ParseColorText('^b_', wdh+2, SYS_CONSOLE_Y-17, 0);
                                ParseColorText(constr, 8, SYS_CONSOLE_Y-17,0);
                        end;


//                        font1.textout(inttostr(SYS_CONSOLE_POS), 400,200,$FFFFFF);
//
                        for i := 0 to conmsg.count-1 do begin
                        if (SYS_CONSOLE_Y-30-15*i) > -20 then
                                if i+conmsg_index <conmsg.count then
                                        ParseColorText(conmsg[i+conmsg_index], 1, SYS_CONSOLE_Y - 32 - 15*i,0);
                        if i >=30 then break;
                        end;
                        if conmsg_index>0 then Font1.TextOut('^ ^ ^ ^ ^',565,SYS_CONSOLE_Y-30,clwhite);
                        PowerGraph.Line (0,SYS_CONSOLE_Y,640,SYS_CONSOLE_Y,clWhite,effectNone);
end;
end;



procedure AddDirContent(StartDir: string; var List:TStringList);
var SearchRec : TSearchRec;
    i : word;
    tmp: TStringList;
    tss:string;
begin
        list.clear;
        if StartDir[Length(StartDir)] <> '\' then StartDir := StartDir + '\';

        if FindFirst(startdir+'*.*', faAnyFile, SearchRec) = 0 then begin

                tss := lowercase(extractfileext(searchrec.name));

        if (SearchRec.Attr and faDirectory) = faDirectory then
                if (SearchRec.Name <> '.') then
//                if (tss='.mapa') or (tss='.ndm') then
                        list.add(searchrec.name);

                while FindNext(SearchRec) = 0 do if (SearchRec.Name <> '.') then
                if (SearchRec.Attr and faDirectory) = faDirectory then
//                if (tss='.mapa') or (tss='.ndm') then
                        list.add(searchrec.name);
        end;
        FindClose(SearchRec);
        list.sort;

        tmp := TStringList.create;
        if FindFirst(startdir+'*.*', faAnyFile, SearchRec) = 0 then begin
                tss := lowercase(extractfileext(searchrec.name));

        if (SearchRec.Attr and faDirectory) <> faDirectory then
                if (tss='.mapa') or (tss='.ndm') then
                        tmp.add(searchrec.name);

                while FindNext(SearchRec) = 0 do if (SearchRec.Name <> '.') then begin
                        tss := searchrec.name;
                        tss := lowercase(extractfileext(searchrec.name));

                        if (SearchRec.Attr and faDirectory) <> faDirectory then
                                if (tss='.mapa') or (tss='.ndm') then
                                        tmp.add(searchrec.name);
                end;
        end;
        FindClose(SearchRec);
        tmp.sort;
        list.AddStrings(tmp);
        tmp.free;
end;

// executes changedir in map selection dialog.
procedure BrimMapList(Dir:String);
var gobw : boolean; // going backwards
    i : word;
    searchdir : string;
begin
        gobw := false;
        if extractfilename(dir)= '..' then begin
                searchdir := extractfilename(MapPath);
                lastmap := -1;
                gobw := true;
                end;

        chdir(dir);
        dir := GetCurrentDir;

//      addmessage('^2 NOW DIR IS:'+dir);
        AddDirContent(Dir, maplist);
        if lowercase(dir) = lowercase(rootdir+'\maps') then maplist.delete(0); // cant get out from basenfk\maps..

        mapindex := 0;
        if gobw = false then mapofs := 0;
        MapPath := dir;

        if gobw then begin
                for i := 0 to maplist.count-1 do
                        if maplist[i] = searchdir then begin
                                mapindex := i;
                                break;
                                end;

                if mapindex < 0 then mapindex := 0;
                if mapindex > maplist.count-1 then
                mapindex := maplist.count-1;
                mapofs := 0;
                if mapindex-8 >0 then mapofs := mapindex -7;
        end;
end;

function DirectoryExists(const Name: string): Boolean;
var
  Code: Integer;
begin
  Code := GetFileAttributes(PChar(Name));
  Result := (Code <> -1) and (FILE_ATTRIBUTE_DIRECTORY and Code <> 0);
end;

procedure BrimDemosList(Dir:String);
var gobw : boolean; // going backwards
    i : word;
    searchdir : string;
begin
        gobw := false;
        if extractfilename(dir)= '..' then begin
                searchdir := extractfilename(DemoPath);
                gobw := true;
                end;

        if not directoryexists(dir) then exit;

        chdir(dir);
        dir := GetCurrentDir;

        AddDirContent(Dir, demolist);
        if lowercase(dir) = lowercase(rootdir+'\demos') then demolist.delete(0); // cant get out from basenfk\demos..

        if gobw = false then demoofs := 0;
        DemoPath := dir;

        if gobw then begin
                for i := 0 to Demolist.count-1 do
                        if demolist[i] = searchdir then begin
                                demoindex := i;
                                break;
                                end;

                if demoindex < 0 then demoindex := 0;
                if demoindex > demolist.count-1 then
                demoindex := demolist.count-1;
                demoofs := 0;
                if demoindex-21 >0 then demoofs := demoindex -20;
        end;
end;

//draw Map Preview, at hotseat and multiplayer scree(eeE)eeeens.
procedure DrawMenu_MapMang;
var    ofs : real;
        i,c,a:integer;
        cur:Tpoint;
       clr:cardinal;

       off : tpoint;

begin
with mainform do begin

                DrawWindow('Map','',7,54,259,168,0);

                // preview rect
                if (extractfileext(maplist[mapindex]) <> '') and (maplist[mapindex] <> '..') then begin
                        PowerGraph.FillRect(43, 272, 162, 122, $333333, effectMul);
                        PowerGraph.Rectangle(43, 272, 162, 122, $0000ca, $000000, effectadd);
                end;

                if maplist.count > 2 then begin
                try
                        ofs := ((mapindex)/(maplist.count-1));
                except ofs := 0; end;
                if ofs > 1 then ofs := 1;
                if ofs < 0 then ofs := 0;
                end else ofs := 0;

//              PowerGraph.FillRect(249, round(87+104*ofs), 18, 12, $0000ca, effectnONE);

                if maplist.count >= 2 then
                        PowerGraph.RenderEffectCol(images[57],249,85+ (100*mapindex div (maplist.Count-1)),$0000da, 5,effectSrcAlpha);

                PowerGraph.SetClipRect(rect(7,54,246,168+54));

                for i := 0 to 8 do begin
                        if i+mapofs <= maplist.Count -1 then begin
                        if i+mapofs = mapindex then begin
                                PowerGraph.FillRectMap ( 12 , 72+16*i , 246, 72+16*i , 12 + 234, 72+16*i + 17, 12 , 72+16*i + 17, (font_alpha_s shl 24)+$0000Ca, (font_alpha_s shl 24)+$0000Ca , (font_invalpha_s shl 24)+$0000Ca,(font_invalpha_s shl 24)+$0000Ca, 2 or $100);
                                  if (extractfileext(maplist[i+mapofs]) = '') or (maplist[i+mapofs] = '..') then begin
                                  if maplist[i+mapofs] = '..' then // render .. icon.
                                          PowerGraph.RenderEffect (Images[35],14,74+16*i,10,effectSrcAlpha) else
                                          begin // render folder icon
                                               PowerGraph.RenderEffectCol(Images[35],13,72+16*i,$0000ea,11,effectSrcAlpha);
                                               Font2.TextOut(maplist[i+mapofs],30,74+16*i,clWhite);
                                          end;
                                  end  else
                                  Font2.TextOut(maplist[i+mapofs],14,74+16*i,clWhite);
                                end else
                                if (extractfileext(maplist[i+mapofs]) = '') or (maplist[i+mapofs] = '..') then begin
                                  if maplist[i+mapofs] = '..' then // render .. icon.
                                          PowerGraph.RenderEffect (Images[35],14,74+16*i,10,effectSrcAlpha) else
                                          begin // render folder icon
                                               PowerGraph.RenderEffectCol (Images[35],13,72+16*i,$0000ea,9,effectSrcAlpha);
                                               Font2.TextOut(maplist[i+mapofs],30,74+16*i,clWhite);
                                          end;
                                  end  else
                                Font2.TextOut(maplist[i+mapofs],14,74+16*i,clWhite);

                        end;
                end;

                PowerGraph.SetClipRect(rect(0,0,640,480));
//      LOL
//      rectangle(menux+12,menuy+292,menux+248,menuy+398);
//      WrapTextOut(menux+16,menux+240,menuy+294,menuy+446,'Hi there wanna fuck. or whatever.... heehhee hehhehe. shts killa asd d sd df dsf sflkj lfsd sldkf sdlkfj sdf sldkfjs ldkf jsld jsdl kfjsldk fjsdlfkj sdlfkj sldfk jsdlkf jsldkfj sdlfkj sdlkfjlksd jf sdlkfj sldkjf sldfj sdlkfj sldkfj lsdkfj sldkfj lkjs ',DXDraw.Surface.Canvas,DXDraw.Surface.Canvas.font);
//      end;


        // Mouse pick
        getcursorpos(cur);
        if MENUEDITMODE=0 then
        if iskey(mbutton1) and (mapcansel=0) and (cur.x >= 15) and (cur.x <= 246) and (cur.y >= 72) and (cur.y <= 72+280) then
        for i := 0 to 8 do
        if (cur.y >= 72+16*i) and (cur.y < 72+16*i+16 ) then
        if i + mapofs <= maplist.count-1 then
        if mapindex <> i + mapofs then begin
        mapindex := i + mapofs;
        playsound(SND_Menu2,0,0);
        mapcansel:=2;
        if abs(cur.y-72+16*i) > 30 then
        mapcansel:=1;
        end;


        if (extractfileext(maplist[mapindex]) <> '') and (maplist[mapindex] <> '..') then
        if lastmap <> mapindex then begin
//                addmessage('^3DEBUG: trying to load: '+MAPPATH+'\'+maplist[mapindex]);
                LOADMAP (MAPPATH+'\'+maplist[mapindex],true);
                lastmap := mapindex;
                end;

        // map preview..

        off.x := 0;
        off.y := 0;
        if not IsHotSeatMap then begin
                off.x := BRICK_X div 4 - round(cos(gettickcount/1600)* ((BRICK_X div 2)-1));
                if off.x <= 0 then off.x := 0;
                if off.x >= BRICK_X-20 then off.x := BRICK_X-20;

                off.y := BRICK_Y div 4 - round(sin(gettickcount/1600)* ((BRICK_Y div 2)-1));
                if off.y <= 0 then off.y := 0;
                if off.y >= BRICK_Y-30 then off.y := BRICK_Y-30;
        end;

        if (extractfileext(maplist[mapindex]) <> '') and (maplist[mapindex] <> '..') then
        for c := off.x to 19+off.x do begin      // PREVIEW!!!!
        for a := off.y to 29+off.y do begin
                if bbb[c,a].image > 0 then begin
                      powergraph.antialias := true;
                      if (bbb[c,a].image > 0) and (bbb[c,a].image< 54) then PowerGraph.TextureMap(Images[IMAGE_ITEM], 44+c*8-off.x*8, 273+a*4-off.y*4,44+c*8+8-off.x*8,273+a*4-off.y*4,44+c*8+8-off.x*8,273+a*4+4-off.y*4,44+c*8-off.x*8,273+a*4+4-off.y*4, bbb[c,a].image, effectSrcAlpha) else
                      if (bbb[c,a].image >= 54) and (bbb[c,a].image< 182) then begin
                                if SYS_USECUSTOMPALETTE then begin
                                        if SYS_USECUSTOMPALETTE_TRANSPARENT then
                                                PowerGraph.TextureMap(Images[48], 44+c*8-off.x*8, 273+a*4-off.y*4,44+c*8+8-off.x*8,273+a*4-off.y*4,44+c*8+8-off.x*8,273+a*4+4-off.y*4,44+c*8-off.x*8,273+a*4+4-off.y*4, bbb[c,a].image-54, effectSrcAlpha)
                                        else
                                                PowerGraph.TextureMap(Images[48], 44+c*8-off.x*8, 273+a*4-off.y*4,44+c*8+8-off.x*8,273+a*4-off.y*4,44+c*8+8-off.x*8,273+a*4+4-off.y*4,44+c*8-off.x*8,273+a*4+4-off.y*4, bbb[c,a].image-54, effectNone)
                                        end else
                        PowerGraph.TextureMap(Images[IMAGE_BR1], 44+c*8-off.x*8, 273+a*4-off.y*4,44+c*8+8-off.x*8,273+a*4-off.y*4,44+c*8+8-off.x*8,273+a*4+4-off.y*4,44+c*8-off.x*8,273+a*4+4-off.y*4, bbb[c,a].image-54, effectNone)
                      end else if (bbb[c,a].image >= 181) then PowerGraph.TextureMap(Images[IMAGE_BR2], 44+c*8-off.x*8, 273+a*4-off.y*4,44+c*8+8-off.x*8,273+a*4-off.y*4,44+c*8+8-off.x*8,273+a*4+4-off.y*4,44+c*8-off.x*8,273+a*4+4-off.y*4, bbb[c,a].image-182, effectNone);
                      powergraph.antialias := false;
                end;
            end;
        end;


{       // specobj preview.
        if NUM_OBJECTS_0 = false then for c := 0 to NUM_OBJECTS do if ddd[c].active = true then
                if ddd[c].objtype = 1 then begin
                        mainform.PowerGraph.RenderEffect(mainform.Images[30], 44+(ddd[c].x*32-16) div 4, 273+(ddd[c].y*16-30) div 4,64,0, effectSrcAlpha);
                        mainform.PowerGraph.RenderEffect(mainform.Images[31], 44+(ddd[c].x*32+6) div 4, 273+(ddd[i].y*16-25) div 4,64,0, effectSrcAlpha);
                        end;
                      powergraph.antialias := false;
}

        // available gamemodes icons
        if (extractfileext(maplist[mapindex]) <> '') and (maplist[mapindex] <> '..') then begin
                clr := $AAFFFFFF;
                i := 184;
                if mapinfo.supportDOM then begin
                        powergraph.rendereffectcol(images[51],i,276,clr,4,effectSrcAlpha or EffectDiffuseAlpha);
                        dec(i, 20);
                        end;
                if mapinfo.supportCTF then begin
                        powergraph.rendereffectcol(images[51],i,276,clr,5,effectSrcAlpha or EffectDiffuseAlpha);
                        dec(i,20);
                        end;
                if mapinfo.supportTRIX then begin
                        powergraph.rendereffectcol(images[51],i,276,clr,6,effectSrcAlpha or EffectDiffuseAlpha);
                        dec(i,20);
                        end;
        end;
end;
end;

procedure FillCharEx(var Ar:array of char; S:String);
var i : byte;
begin
        for i := 0 to high(ar) do if i < length(s) then
               ar[i] := s[i+1] else ar[i] := #0;
end;

procedure NFKPLANET_PingAllServers;
var i : word;
    PingPacket : TMP_Warmupis2;
begin
        if MP_Sessions.Count = 0 then exit;
        if not mainform.Lobby.active then exit;
//        if BNET1.Active = false then BNET1.Active := true;

        for i := 0 to MP_Sessions.Count-1 do begin
                addmessage('"'+strpar_np (MP_Sessions[i],6) + '"');
                if strpar_np (MP_Sessions[i],6) = '' then begin
                        PingPacket.DATA := MMP_LOBBY_PING;
                        Mainform.BNETSendData2IP_ (strpar_np(MP_Sessions[i],5), BNET_GAMEPORT, PingPacket, sizeof(TMP_Warmupis2),0);
                        MP_Sessions[i] := MP_Sessions[i] + #0 + inttostr(gettickcount);
                        end;
        end;
end;

procedure ANSWER_FLOOD(toIP:shortstring; datasize:word);
var   msg: TMP_IpInvite;
      msgsize : byte;
begin
{        MsgSize := datasize;
        Msg.DATA := MMP_FLOOD;
        Msg.ACTION := 1;
        mainform.BNETSendData2IP (toIP, Msg, MsgSize, 0);
        addmessage('^1answered flood-SEND');}
end;

procedure BNET_FLOOOOOD(p1,p2,p3:shortstring);
var   msg: TMP_IpInvite;
      msgsize : byte;
      sz : word;
      cnt,z : word;
begin
{        if p1='' then begin addmessage('Usage: floodto xxx.xxx.xxx.xxx datasize count'); exit; end;
        sz := strtoint(p2);
        cnt := strtoint(p3);

        MsgSize := SizeOf(TMP_IpInvite) + sz;
        Msg.DATA := MMP_FLOOD;
        Msg.ACTION := 0;

        for z := 1 to cnt do
                mainform.BNETSendData2IP (p1, Msg, MsgSize, 0);
        addmessage('^5Flooded to ' + P1);}
end;

procedure BNET_IPINVITE(IP:ShortString);
var    Packet : TMP_IpInvite;
       p : byte;
begin
        IP := StripSymbols(' ',IP);
        if IP='' then begin addmessage('Usage: ipinvite xxx.xxx.xxx.xxx'); exit; end;
        if IP='xxx.xxx.xxx.xxx' then exit; // EXpeCially for Mega DUDEZ!!!
        if Length(IP)<7 then begin addmessage('Invalid IP.'); exit; end;
        if ismultip<>1 then begin addmessage('You can send invites only if you are server.'); exit; end;
        if (IP=MainForm.LocalIP) or (IP=MainForm.GlobalIP) then begin addmessage('Can''t send to local IP'); exit; end;

//        for p := 0 to 24 do SendFloodTo(IP, 0);

        SendFloodTo(IP, BNET_GAMEPORT, 0);
        SendFloodTo(IP, BNET_GAMEPORT, 0);

        Packet.DATA := MMP_INVITE;
        Packet.ACTION := 0;
        Mainform.BNETSendData2IP_ (IP, BNET_GAMEPORT, Packet, sizeof(TMP_IpInvite),0);
        if INCONSOLE then Addmessage('^2ipinvite: invite sent...');

end;

procedure NFKPLANET_PingLastServer;
var i : word;
    PingPacket : TMP_Warmupis2;
begin
        if MP_Sessions.Count = 0 then exit;
        if (not mainform.Lobby.active) and (MP_STEP <> 4) then exit;
//        if BNET1.Active = false then BNET1.Active := true;

        if strpar_np (MP_Sessions[i],5) = '' then exit;

        i := MP_Sessions.Count-1;
//      addmessage('"'+strpar_np (MP_Sessions[i],6) + '"');

        // Server is FULL. we don't ping this.
        if strpar_np (MP_Sessions[i],3) = strpar_np (MP_Sessions[i],4) then begin
                MP_Sessions[i] := MP_Sessions[i] +#0 + '0' + #0 + 'XXX';
                exit;
                end;

        if strpar_np (MP_Sessions[i],6) = '' then begin
                PingPacket.DATA := MMP_LOBBY_PING;
                Mainform.BNETSendData2IP_ (strpar_np(MP_Sessions[i],5),BNET_GAMEPORT, PingPacket, sizeof(TMP_Warmupis2),0);
                if BNET_GAMEPORT<>BNET_SERVERPORT then
                        Mainform.BNETSendData2IP_ (strpar_np(MP_Sessions[i],5),BNET_SERVERPORT, PingPacket, sizeof(TMP_Warmupis2),0);
                MP_Sessions[i] := MP_Sessions[i] + #0 + inttostr(gettickcount);
                end;
end;

procedure NFKPLANET_UpdateServerPing(IP: ShortString);
var i : word;
    prevTICK : longword;
    ping : word;
begin
//      addmessage('^2NFKPLANET_UpdateServerPing');
        if MP_Sessions.Count = 0 then exit;
        if (not mainform.Lobby.active) and (MP_STEP<>4) then exit;

        for i := 0 to MP_Sessions.Count-1 do
        if strpar_np(MP_Sessions[i],5)=IP then begin
                try prevTICK := strtoint ( strpar_np(MP_Sessions[i],6) );
                except exit; end;
                ping := (gettickcount-prevTICK) div 2;
                if strpar_np(MP_Sessions[i],7) <> '' then
                ping := (ping + strtoint ( strpar_np(MP_Sessions[i],7)));
                if ping > 999 then ping := 999;
                MP_Sessions[i] := MP_Sessions[i] +#0 + inttostr( PING );
                exit;
        end;
end;

procedure NFKPLANET_UpdateMapName(MapName_ : string);
var Command : TNFKPLANET_CMD;
begin
        if not mainform.Lobby.active then exit;

        Command._cmd := 'm'; // update map name
        FillCharEx(Command._data, MapName_);
        mainform.Lobby.Socket.SendBuf (Command, sizeof(command));
end;

procedure NFKPLANET_UpdateHostName(HostName_ : string);
var Command : TNFKPLANET_CMD;
begin
        if not mainform.Lobby.active then exit;

        Command._cmd := 'N'; // update map name
        FillCharEx(Command._data, HostName_);
        mainform.Lobby.Socket.SendBuf (Command, sizeof(command));
end;

procedure NFKPLANET_UpdateCurrentUsers(Players_ : byte);
var Command : TNFKPLANET_CMD;
begin
        if not mainform.Lobby.active then exit;
        Command._cmd := 'C'; // update current users
        FillCharEx(Command._data, inttostr(Players_) );
        mainform.Lobby.Socket.SendBuf (Command, sizeof(command));
end;

procedure NFKPLANET_UpdateMaxUsers(MaxPlayers_ : byte);
var Command : TNFKPLANET_CMD;
        MsgSize:word;
        msg:TMP_Svcommand_ex;
begin
        if ismultip=1 then begin
        MsgSize := SizeOf(TMP_Svcommand_ex);
        msg.data := MMP_SV_COMMANDEX;
        msg.maxplayers := OPT_SV_MAXPLAYERS;
        msg.net_predict := OPT_NETPREDICT;
        msg.reserved1 := 0;
        msg.powerup := OPT_SV_POWERUP;
        mainform.BNETSendData2All(Msg,MsgSize,ttGuaranteed);
        end;

        if not mainform.Lobby.active then exit;
        Command._cmd := 'M'; // update maxuzerz
        FillCharEx(Command._data, inttostr(MaxPlayers_));
        mainform.Lobby.Socket.SendBuf (Command, sizeof(command));
end;

procedure NFKPLANET_UpdateGameType(GameType_ : byte);
var Command : TNFKPLANET_CMD;
begin
        if not mainform.Lobby.active then exit;
        Command._cmd := 'P'; // update gametype
        FillCharEx(Command._data, inttostr(GameType_));
        mainform.Lobby.Socket.SendBuf (Command, sizeof(command));
end;

procedure NFKPLANET_Register(HostName_, MapName_ : string; Players_, MaxPlayers_, GameType_ : byte );
var Command : TNFKPLANET_CMD;
begin
        if not mainform.Lobby.active then begin
//                showmessage('NFKPLANET: Can''t register server. Not connected.');
                exit;
                end;

        Command._cmd := 'N'; // update host name
        FillCharEx(Command._data, HostName_);
        mainform.Lobby.Socket.SendBuf (Command, sizeof(command));

        Command._cmd := 'm'; // update map name
        FillCharEx(Command._data, MapName_);
        mainform.Lobby.Socket.SendBuf (Command, sizeof(command));

        Command._cmd := 'C'; // update current users
        FillCharEx(Command._data, inttostr(Players_) );
        mainform.Lobby.Socket.SendBuf (Command, sizeof(command));

        Command._cmd := 'M'; // update maxuzerz
        FillCharEx(Command._data, inttostr(MaxPlayers_));
        mainform.Lobby.Socket.SendBuf (Command, sizeof(command));

        Command._cmd := 'P'; // update gametype
        FillCharEx(Command._data, inttostr(GameType_));
        mainform.Lobby.Socket.SendBuf (Command, sizeof(command));

        Command._cmd := 'R'; // register server
        mainform.Lobby.Socket.SendBuf (Command, sizeof(command));
end;

// -----------------------------------------------------------------------------

type
P_rec = ^T_rec;
T_rec = packed record
  b1 : byte;
  b2 : byte;
  b3 : byte;
  b4 : byte;
end;

function IPtoDotDot(ip:Dword):string;
//Yeh, translates  3232235521 to 192.168.0.1
var
 p:P_rec;
 i:dword;
 s:string;
begin
  i:=ip;
  p:=@i;
  s:= inttostr(p^.b1)+'.'+inttostr(p^.b2)+'.'+inttostr(p^.b3)+'.'+inttostr(p^.b4);
  result:=s;
end;


// NFKPLANET_KeepAlive
procedure NFKPLANET_KeepAlive;
var Command : TNFKPLANET_CMD;
begin
        if not mainform.Lobby.active then exit;
        Command._cmd := '#';
        FillChar(Command._data,0,sizeof(Command._data));
        mainform.Lobby.Socket.SendBuf (Command, sizeof(command));
//        addmessage('NFKPLANET: Keep alive');
end;
// -------------------------------------+---------------------------------------
// NFKPLANET_CheckProxies                \
// Check If SomeBody want to connect me. /
// -------------------------------------/
procedure NFKPLANET_CheckProxies;
var Command : TNFKPLANET_CMD;
begin
        if not mainform.Lobby.active then exit;
        if ismultip <> 1 then exit;
        if GetNumberOfPlayers >= OPT_SV_MAXPLAYERS then exit;

        Command._cmd := 'x';
        FillCharEx(Command._data, MainForm.GlobalIP); // connect $ELF.
        mainform.Lobby.Socket.SendBuf (Command, sizeof(command));
//        addmessage('NFKPLANET_CheckProxies');
end;
// -----------------------------------------------------------------------------
procedure NFKPLANET_IWantJoinProxy(IP : string);
var Command : TNFKPLANET_CMD;
i : byte;
    zz : longint;
begin
        if not mainform.Lobby.active then exit;

        Command._cmd := 'X';
        for i := 0 to 14 do Command._data [i] := #0;
        zz := inet_addr(pchar(IP));
        move(zz, Command._data, 4);

        mainform.Lobby.Socket.SendBuf (Command, sizeof(command));
//        addmessage('NFKPLANET: NFKPLANET_IWantJoinProxy: '+IP);
end;


procedure NFKPLANET_proxyd;
var i : byte;
begin
        addmessage('NFKPLANET_proxyd');
        for i := 0 to random(10) do begin
                if random(3)=0 then NFKPLANET_IWantJoinProxy (MainForm.GlobalIP)
                else NFKPLANET_IWantJoinProxy(inttostr(255)+'.'+inttostr(255)+'.'+inttostr(255)+'.'+inttostr(255));
        end;

end;

// -----------------------------------------------------------------------------
procedure NFKPLANET_UpdatePlayersCount;
var Command : TNFKPLANET_CMD;
begin
        if not mainform.Lobby.active then exit;
        Command._cmd := 'S';
        FillChar(Command._data,0,sizeof(Command._data));
        mainform.Lobby.Socket.SendBuf (Command, sizeof(command));
//        addmessage('NFKPLANET: Get Players Count');
end;
// =============================================================================
function net_ReturnMask(IP:string) : string;
var i,dot : byte;
begin
        result := '';
        dot := 0;
        for i := 1 to length(IP) do begin
                result := result + IP[i];
                if IP[i]='.' then inc(dot);
                if dot >= 3 then begin
                        result := result + '255';
                        exit;
                        end;
        end;
end;
// =============================================================================

procedure LAN_BroadCast;
var mask, mask2 : string;
begin
       mask := net_ReturnMask(MainForm.GlobalIP);
       CL_AskLobbyGamestate(mask);
       mask2 := net_ReturnMask(MainForm.LocalIP);
       if mask <> mask2 then CL_AskLobbyGamestate(mask2);
end;
// =============================================================================
procedure NFKPLANET_UpdateServerList;
var Command_ : TNFKPLANET_CMD;
begin
        if MP_STEP = 4 then begin
                LAN_BroadCast;
                exit;
        end;

        if mainform.Lobby.Active= false then begin
                addmessage('NFKPLANET: Cannot execute command.. Not connected');
                exit;
        end;
        if BNET_LOBBY_STATUS <> 2 then exit;
        BRefreshEnabled := false;
        MP_Sessions.Clear; // new.
        serverofs := 0;
        Command_._cmd := 'G';
        FillChar(Command_._data,0,sizeof(Command_._data));
        mainform.Lobby.Socket.SendBuf (Command_, sizeof(TNFKPLANET_CMD));
//        addmessage('^3NFKPLANET: Requesting server list');
end;

procedure NFKPLANET_ShowNewsDeliveryScreen;
var i : byte;
begin
        if (DrawWindow(BNET_AU_Caption,'OK',BNET_AU_PosX,BNET_AU_PosY,BNET_AU_WidthX,BNET_AU_WidthY,1)=true) and (keyup_) then begin
                BNET_AUTOUPDATE := false;
                mapcansel := 10;
                playsound(SND_menu3,0,0);
                BNET_AU_ShowUpdateInfo := false;

                if BNET_AU_CanPlayWithThisVersion = false then begin
                        ShowCriticalError('Latest version is required for playing at NFK PLANET','Your NFK version ('+VERSION+')'+' is outdated. Please','visit official website for latest update ('+BNET_AU_LIST[1]+').');
                        applyHcommand('disconnect');
                        BNET_AUTOUPDATE := true;
                        exit;
                        end;

                NFKPLANET_UpdateServerList;
                exit;
        end;


        for i := 2 to BNET_AU_LIST.count-1 do
        if strpar(BNET_AU_LIST[i],0)='w' then
                ParseColorText(strpar_next(BNET_AU_LIST[i],3), strtoint(strpar(BNET_AU_LIST[i],1)), strtoint(strpar(BNET_AU_LIST[i],2)), 1);

        mapcansel := 4;
end;

function NFKPLANET_AutoUpdate() :boolean;
var CRC32 : cardinal;
begin
        result := false;
        BNET_AU_ShowUpdateInfo := false;
        if not BNET_AUTOUPDATE then exit;

        BNET_AUTOUPDATE := false;

        try
        MainForm.NMHTTP1.body := ROOTDIR+'\system\au.dat';
        MainForm.NMHTTP1.Get(BNET_UPDATEURL);
        except result:=false; exit; end;

        BNET_AU_LIST.LoadFromFile(ROOTDIR+'\system\au.dat');
        BNET_AU_LIST.SaveToFile(ROOTDIR+'\system\au.dat'); // prevent bug... CRC32

        if BNET_AU_LIST.count < 2 then exit; // kinda bug?
        if strpar(BNET_AU_LIST[0],0) <> 'IDNFK' then exit; // special header..

        CRC32 := LOADMAPCRC32(MainForm.NMHTTP1.body);

        // New File... Updating.
        if BNET_LASTUPDATESRC <> CRC32 then begin
//                addmessage('BNET_LASTUPDATESRC='+inttostr(BNET_LASTUPDATESRC)+'   CRC32='+inttostr(CRC32));
//                BNET_LASTUPDATESRC := CRC32;
                BNET_AU_ShowUpdateInfo := true;
                BNET_AU_PosX := strtoint(strpar(BNET_AU_LIST[0],1));
                BNET_AU_PosY := strtoint(strpar(BNET_AU_LIST[0],2));
                BNET_AU_WidthX := strtoint(strpar(BNET_AU_LIST[0],3));
                BNET_AU_WidthY := strtoint(strpar(BNET_AU_LIST[0],4));
                BNET_AU_Caption := strpar_next(BNET_AU_LIST[0],5);

                if VERSION <> BNET_AU_LIST[1] then begin //version rejection
                        BNET_AU_CanPlayWithThisVersion := false;
                        BNET_AUTOUPDATE := true;
                        result := false;
                        exit;
                end else begin
                        BNET_AU_CanPlayWithThisVersion := true;
//                        BNET_AUTOUPDATE := false;
                        end;

                result := true;
        end else // old news, but still version rejection...

                result := false;

                if VERSION <> BNET_AU_LIST[1] then begin
                        ShowCriticalError('Latest version is required for playing at NFK PLANET','Your NFK version is outdated. Please','visit official website for latest update.');
                        applyHcommand('disconnect');
                        BNET_AUTOUPDATE := true;
                        BNET_AU_CanPlayWithThisVersion := false;
                        exit;
                end else BNET_AU_CanPlayWithThisVersion := true;
end;

function CUSTOMSORT_PL (List: TStringList; Index1, Index2: Integer): Integer;
var num1, num2 : integer;
begin
  try  num1 := strtoint(list[index1]);
  except num1 := 0; end;

  try num2 := strtoint(list[index2]);
  except num2 := 0; end;

  if num1 = num2 then begin
        Result := 0;
        exit;
        end;
  if num1 > num2 then result := -1 else result := 1;
end;

function CUSTOMSORT_PING (List: TStringList; Index1, Index2: Integer): Integer;
var num1, num2 : integer;
begin
  if list[index1]='' then num1 := 999 else
  if list[index1]='XXX' then num1 := 999 else
  try  num1 := strtoint(list[index1]);
  except num1 := 999; end;

  if list[index2]='' then num2 := 999 else
  if list[index2]='XXX' then num2 := 999 else
  try num2 := strtoint(list[index2]);
  except num2 := 999; end;

  if num1 = num2 then begin
        Result := 0;
        exit;
        end;
  if num1 < num2 then result := -1 else result := 1;
end;

procedure NFKPLANET_SortList(ID:Byte);
var ts, ts2 : TStringList;
        i,find : word;
        STR:string;
begin
        if mapcansel>0 then exit;

        if keyup_=true then playsound(snd_menu2,0,0);
        mapcansel := 4;

        if MP_Sessions.count < 2 then exit;

        ts := TStringList.Create;
        ts2 := TStringList.Create;

        for i := 0 to MP_Sessions.count-1 do
                ts.add( strpar_np(MP_Sessions[i],ID));


        if ID=3 then  // special case in PLAYERS column
                ts.CustomSort(CUSTOMSORT_PL) else
        if ID=7 then  // special case in PING column
                ts.CustomSort(CUSTOMSORT_PING) else
        ts.sort;

//        ts.savetofile(rootdir+'\sorted.txt');

        for i := 0 to ts.count-1 do
                for find := 0 to MP_Sessions.count - 1 do
                        if strpar_np(MP_Sessions[find],ID) = ts[i] then begin
                        str := '';
                        str := str + strpar_np(MP_Sessions[find],0) +#0;
                        str := str + strpar_np(MP_Sessions[find],1) +#0;
                        str := str + strpar_np(MP_Sessions[find],2) +#0;
                        str := str + strpar_np(MP_Sessions[find],3) +#0;
                        str := str + strpar_np(MP_Sessions[find],4) +#0;
                        str := str + strpar_np(MP_Sessions[find],5) +#0;
                        if strpar_np(MP_Sessions[find],6) <> '' then str := str + strpar_np(MP_Sessions[find],6) +#0;
                        if strpar_np(MP_Sessions[find],7) <> '' then str := str + strpar_np(MP_Sessions[find],7) +#0;
                        ts2.add(str);
                        MP_Sessions.Delete(find);
//                        MP_Sessions[find] := '';
                        break;
                end;

        MP_Sessions.clear;
        MP_Sessions.Assign(Ts2);
//        MP_Sessions.SaveToFile(ROOTDIR+'\MP_Sessions.txt');
        ts.free; ts2.free;
        MP_SessionIndex := 0;
        serverofs := 0;
end;

// -----------------------------------------------------------------------------
procedure BNET_BEGINCONNECTING;
begin
        BNET_CONNECTING := TRUE;
        BNET_TIMEDOUT := gettickcount + 1200*10;
end;
// -----------------------------------------------------------------------------
function BNET_ValidIPAdress(IP:String):boolean;
var i,dot : byte;

begin
        result := false;
        if length(IP)<7 then exit;
        dot := 0;
        for i := 1 to length(IP) do begin
                if IP[i]='.' then inc(dot);
                if dot > 3 then
                        exit;
                if IP[i] >= 'A' then exit;
        end;

        if dot<3 then exit;
        result := true;
end;

procedure BNET_DirectConnect(IP: String);
var i : byte;
begin
        if Length(IP) = 0 then exit;
        if IP='127.0.0.1' then exit;
        if IP = MainForm.GlobalIP then exit;
        if IP = MainForm.LocalIP then exit;
        if not BNET_ValidIPAdress(IP) then begin
                addmessagE(IP +' is not valid IP adress.');
                exit;
                end;

        BNET_ISMULTIP := 2;
        BNET_GAMEIP := IP;
        BNET_BEGINCONNECTING;

        SPAWNCLIENT;
end;

procedure BNET_ServerStart;
begin
        bnet1.active := true;  // Start UDP
//        TCPSERV.Listen := true; // Start TCP
end;

function ClipWINDOWEx(x,y, width, height:word):byte;
var cur : TPoint;
    left : word;
begin
        GetCursorPos(cur);
        result := 0;
        left := x + width div 2 - 36-5;
        if (cur.x >= left) and (cur.x <= left+26*3) and (cur.y >= y+height - 50) and (cur.y <=  y+height - 50 + 30) then
                result := 1;

        if (cur.x >= x + width - 18) and (cur.x <= x + width-2) and (cur.y >= y+16) and (cur.y <=  y+30) then result := 2; // scroll up
        if (cur.x >= x + width - 18) and (cur.x <= x + width-2) and (cur.y >= y-18 + height) and (cur.y <=  y +height - 4) then result := 3;

end;

procedure ComboAddHistory(var Combo: TComboBoxNFK);
var i : byte;
begin
        if combo.text = '' then exit;

        if combo.ts.count>0 then
        for i := 0 to combo.ts.count-1 do
                if lowercase(combo.ts[i]) = lowercase(combo.text) then begin
                        if i > 0 then combo.ts.Exchange (i,0);
                        exit;
                end;

        combo.ts.Insert(0,combo.text);
        if combo.ts.count=7 then combo.ts.Delete (6);
end;

function DrawCombo(x,y : word; var Combo: TComboBoxNFK) : boolean;
var cur : TPoint;
    clr : TColor;
    i : byte;
    left: word;

begin
        GetCursorPos(Cur);
        MainForm.PowerGraph.FrameRect (x,y,200,20,$0000ca,0);
        mainform.Font2b.textout(combo.Text ,x+2,y+1,clwhite);
        left := mainform.Font2b.TextWidth(combo.Text ) + 2;
        if gettickcount mod 800 < 400 then mainform.PowerGraph.Line(x+left+2,y+2,x+left+2,y+17,clwhite,0);

        if (cur.x >= x + 182) and (cur.x <= x + 200) and (cur.y >= y+1) and (cur.y <=  y+19) then begin
                clr := $0000da;
                if (mapcansel=0) and (keyup_) then begin
                        combo.Opened := not combo.Opened;
                        mapcansel := 2;
                        end;
                end
        else    clr := $0000ca;

        MainForm.PowerGraph.Antialias := true;
        MainForm.PowerGraph.RenderEffectCol(mainform.Images[57],x + 182,y+1,330,clr,17,effectSrcAlpha); // UP
        MainForm.PowerGraph.Antialias := false;

        if combo.ts.Count > 0 then
        if combo.Opened then begin
                MainForm.PowerGraph.FillRect (x,y+19,200,20*combo.ts.count-1+2, $aa000000,2 or $100);
                MainForm.PowerGraph.FrameRect (x,y+19,200,20*combo.ts.count-1+2,$0000ca,0);

                if (cur.x >= x) and (cur.y <= x+200) and (cur.y >= y+19) and (cur.y <= y+20+20*combo.ts.count) then begin
                for i := 0 to combo.ts.count-1 do
                if (cur.y >= y+19+20*i+1) and (cur.y < y+19+20*i+20 ) then begin
                        mainform.PowerGraph.FillRectMap ( x +1, y+19+20*i , x+199, y+19+20*i , x+199, y+19+20*i+20, x +1 , y+19+20*i+20, (font_alpha_s shl 24)+$0000Ca, (font_alpha_s shl 24)+$0000Ca , (font_invalpha_s shl 24)+$0000Ca,(font_invalpha_s shl 24)+$0000Ca, 2 or $100);
                                if keyup_ then begin
//                                        playsound(snd_menu2,0,0);
                                        combo.Text := combo.ts[i];
                                        combo.Opened := false;
                                        end;
                        end;
                end;
                if (keyup_) and (mapcansel=0) then combo.Opened := false;

                for i := 0 to combo.ts.count - 1 do
                        mainform.Font2b.TextOut(combo.ts[i],x+2,y+20*i+20, clwhite);
        // Mouse pick
        end;

        if combo.ts.Count = 0 then
        if combo.Opened then begin
                MainForm.PowerGraph.FillRect (x,y+19,200,4, $aa000000,2 or $100);
                MainForm.PowerGraph.FrameRect (x,y+19,200,4,$0000ca,0);
                end;

        // connectin..
        if not combo.opened then if (mapcansel=0) and (iskey(VK_RETURN)) then
        if length(combo.text)>0 then begin
                ComboAddHistory(combo);
                applyHcommand('connect '+combo.text);
                mapcansel:=2;
                playsound(SND_Menu3,0,0);
                end;
end;

function DrawWINDOW(Caption, Button: shortString;x,y, width, height:word; type_: byte) :boolean;
var left : word;
    clr : TCOLOR;
    cur : TPoint;
begin
        result := false;
        MainForm.PowerGraph.RenderEffectCol(mainform.Images[57],x,y,                    $0000ca,0,effectSrcAlpha); // 7
        MainForm.PowerGraph.RenderEffectCol(mainform.Images[57],x,y+height-5,           $0000ca,8,effectSrcAlpha); // 1
        MainForm.PowerGraph.RenderEffectCol(mainform.Images[57],x+width-24,y,           $0000ca,2+type_,effectSrcAlpha); // 9
        MainForm.PowerGraph.RenderEffectCol(mainform.Images[57],x+width-24,y+height-5,  $0000ca,11,effectSrcAlpha); // 3
        MainForm.PowerGraph.TextureCol(mainform.Images[57], x+24,y,x+width-24,y,x+width-24,y+23,x+24,y+23,$0000ca,1,effectSrcAlpha); //8
        MainForm.PowerGraph.TextureCol(mainform.Images[57], x+24,y+height-5,x+width-24,y+height-5,x+width-24,y+23+height-5,x+24,y+23+height-5,$0000ca,9,2);//2
        MainForm.PowerGraph.TextureCol(mainform.Images[57], x,y+23,x+24,y+23,x+24,y+height-5,x,y+height-5,$0000ca,4,2);//4
        MainForm.PowerGraph.TextureCol(mainform.Images[57], x+width-24,y+23,x+width,y+23,x+width,y+height-5,x+width-24,y+height-5,$0000ca,6+type_,2);//6

        if type_ = 1 then
        MainForm.PowerGraph.FillRectMap (x + 4,y + 16, x + width - 18 +type_*14, y + 16, x + width - 18+type_*14, y + height - 4 , x +4, y + height - 4, $b7000000,2 or $100) else
        MainForm.PowerGraph.FillRectMap (x + 4,y + 16, x + width - 18 +type_*14, y + 16, x + width - 18+type_*14, y + height - 4 , x +4, y + height - 4, $aa000000,2 or $100);

        if Caption <> '' then
        MainForm.Font2ss.TextOut(Caption, x+4, y, CLWHITE);

        left := x + width div 2 - 36-5;
        GetCursorPos(cur);

        if Button <> '' then begin
                if (cur.x >= left) and (cur.x <= left+26*3) and (cur.y >= y+height - 50) and (cur.y <=  y+height - 50 + 30) then begin
                        result := true;
                        clr := $0000da;
                        end else clr := $0000ca;
                MainForm.PowerGraph.RenderEffectCol(mainform.Images[57], left,y+height - 50,left+60,clr,12,effectSrcAlpha); //btn
                MainForm.PowerGraph.RenderEffectCol(mainform.Images[57], left+24,y+height - 50,left+60,clr,13,effectSrcAlpha); //btn
                MainForm.PowerGraph.RenderEffectCol(mainform.Images[57], left+24*2,y+height - 50,left+60,clr,14,effectSrcAlpha); //btn
                MainForm.Font4.TextOut(Button, left + 26, y+height - 45, ClWHITE);
        end;
        if type_ =0 then begin
                if (cur.x >= x + width - 18) and (cur.x <= x + width-2) and (cur.y >= y+16) and (cur.y <=  y+30) then
                        clr := $0000da
                        else clr := $0000ca;

                MainForm.PowerGraph.RenderEffectCol(mainform.Images[57],x + width - 18,y+16,clr,16,effectSrcAlpha); // UP

                if (cur.x >= x + width - 18) and (cur.x <= x + width-2) and (cur.y >= y-18 + height) and (cur.y <=  y +height - 4) then
                        clr := $0000da
                        else clr := $0000ca;

                MainForm.PowerGraph.RenderEffectCol(mainform.Images[57],x + width - 18,y-18 + height,clr,17,effectSrcAlpha); // UP
        end;
end;



procedure DrawMenu;
CONST HG : byte = 20;
var cur : TPoint;
    i,b,a : integer;
    bb: byte;
//  color:integer;
    EACTION : boolean;
    alpha : cardinal;
    RG : word;
    BCreateEnabled : boolean;
    BFightEnabled : boolean;
    clr : TColor;
    s,s2 : string;
begin

GetCursorPos (cur);
EACTION := false;

// animate;
if MENUORDER = MENU_PAGE_DEMOS then begin
        bb := GetRValue(hiclr);
        if bb<100 then bb := 222;

        if menuhic = false then begin
//                if bb < 245 then inc(bb,round(10 - (255-bb) div (28)));
                if bb < 222 then inc(bb);
                if bb >= 222 then menuhic := true;
                end;
        if menuhic = true then begin
//                if bb >= 200 then dec(bb,round(10 - (255-bb) div (28)));
                if bb >= 200 then dec(bb);

                if bb < 200 then menuhic := false;
                end;
        hiclr := rgb(bb,0,0);
end;

       if SYS_CURSORFRAMEWAIT < 1 then inc(SYS_CURSORFRAMEWAIT) else begin
               SYS_CURSORFRAMEWAIT := 0;
               if SYS_CURSORFRAME < 10 then inc(SYS_CURSORFRAME) else SYS_CURSORFRAME := 0;
       end;

if mapcansel > 0 then dec(mapcansel);
if menutimeout > 0 then dec(menutimeout);

        if menuburn = 1 then // fade down
                if (ctgR=tgR) then begin
                        MENUTIMEOUT := 100;
                        mainform.dxtimer.FPS := 50;
                        MENUEDITMODE := 0;
                        menuburn := 2;
                        menuorder := MENUWANTORDER;
                        ctgr := 255;
                        tgr := 0;
                end;

        if menuburn = 2 then // fade up

                if (ctgR=tgR) then begin
                if menuwantorder = MENU_PAGE_GOGAME then begin
                        ctgr := 255;
                        tgr := 0;
                        mainform.dxtimer.FPS := 50;
                        inmenu := false;
                        SPAWNSERVER;

                        if OPT_AUTOSHOWNAMES then begin
                                OPT_AUTOSHOWNAMESTIME := OPT_AUTOSHOWNAMESDEFTIME+2;
                                OPT_SHOWNAMES := TRUE;
                                end;
                        end;
                        MENUTIMEOUT := 100;
                        mainform.dxtimer.FPS := 50;
                        MENUWANTORDER := 0;
                        MENUEDITMODE := 0;
                        menuburn := 0;
                end;


with mainform do begin
// PAGE MAINSCREEN;
if MENUORDER = MENU_PAGE_MAIN then begin

      for i := 0 to 2 do for b := 0 to 1 do PowerGraph.RenderEffect(Images[0], 256*i, 256*b, 0, effectNone);

//      PowerGraph.TextureMap(Images[4], 100 - menu1_alpha div 6, 15,356,15,356,143,100,143, 0, effectSrcAlpha);
//      PowerGraph.RenderEffect(Images[4], 356, 15, 1, effectSrcAlpha);


       PowerGraph.RenderEffect(Images[4], 114, 15,0, effectSrcAlpha);
       PowerGraph.RenderEffect(Images[4], 370, 15, 1, effectSrcAlpha);
       powerGraph.Antialias := true;

       PowerGraph.RotateEffect(Images[1], 330, 150, 64,350, 0, effectSrcAlpha);
       PowerGraph.RotateEffect(Images[42],330,150,64,350,(menu1_alpha shl 24)+$FFFFFF,0,effectSrcAlphaAdd or EffectDiffuseAlpha);
       PowerGraph.RotateEffect(Images[1], 330, 195, 64,350, 1, effectSrcAlpha);
       PowerGraph.RotateEffect(Images[42],330,195,64,350,(menu2_alpha shl 24)+$FFFFFF,1,effectSrcAlphaAdd or EffectDiffuseAlpha);
       PowerGraph.RotateEffect(Images[1], 330, 240, 64,350, 2, effectSrcAlpha);
       PowerGraph.RotateEffect(Images[42],330,240,64,350,(menu3_alpha shl 24)+$FFFFFF,2,effectSrcAlphaAdd or EffectDiffuseAlpha);
       PowerGraph.RotateEffect(Images[1], 330, 285, 64,350, 3, effectSrcAlpha);
       PowerGraph.RotateEffect(Images[42],330,285,64,350,(menu4_alpha shl 24)+$FFFFFF,3,effectSrcAlphaAdd or EffectDiffuseAlpha);
       PowerGraph.RotateEffect(Images[1], 330, 330, 64,350, 4, effectSrcAlpha);
       PowerGraph.RotateEffect(Images[42],330,330,64,350,(menu5_alpha shl 24)+$FFFFFF,4,effectSrcAlphaAdd or EffectDiffuseAlpha);
       PowerGraph.RotateEffect(Images[1], 330, 375, 64,350, 5, effectSrcAlpha);
       PowerGraph.RotateEffect(Images[42],330,375,64,350,(menu6_alpha shl 24)+$FFFFFF,5,effectSrcAlphaAdd or EffectDiffuseAlpha);

       // animate menu1
       if not SYS_SHOWCRITICAL then begin

       if (cur.x >= menux+170) and (cur.x <= menux+470) and (cur.y >= menuy+130)  and (cur.y <= menuy+170) then begin
                if menu1_alpha_dir = 1 then begin if menu1_alpha <$FF then inc(menu1_alpha,15) else menu1_alpha_dir := 0;
                end else if menu1_alpha_dir = 0 then begin if menu1_alpha >15 then dec(menu1_alpha,15) else menu1_alpha_dir := 1; end;
       end else if menu1_alpha >15 then dec(menu1_alpha,15);
       // animate menu2
       if (cur.x >= menux+170) and (cur.x <= menux+470) and (cur.y >= menuy+175)  and (cur.y <= menuy+215) then begin
                if menu2_alpha_dir = 1 then begin if menu2_alpha <$FF then inc(menu2_alpha,15) else menu2_alpha_dir := 0;
                end else if menu2_alpha_dir = 0 then begin if menu2_alpha >15 then dec(menu2_alpha,15) else menu2_alpha_dir := 1; end;
       end else if menu2_alpha >15 then dec(menu2_alpha,15);
       // animate menu3
       if (cur.x >= menux+170) and (cur.x <= menux+470) and (cur.y >= menuy+220)  and (cur.y <= menuy+260) then begin
                if menu3_alpha_dir = 1 then begin if menu3_alpha <$FF then inc(menu3_alpha,15) else menu3_alpha_dir := 0;
                end else if menu3_alpha_dir = 0 then begin if menu3_alpha >15 then dec(menu3_alpha,15) else menu3_alpha_dir := 1; end;
       end else if menu3_alpha >15 then dec(menu3_alpha,15);
       // animate menu4
       if (cur.x >= menux+170) and (cur.x <= menux+470) and (cur.y >= menuy+265)  and (cur.y <= menuy+305) then begin
                if menu4_alpha_dir = 1 then begin if menu4_alpha <$FF then inc(menu4_alpha,15) else menu4_alpha_dir := 0;
                end else if menu4_alpha_dir = 0 then begin if menu4_alpha >15 then dec(menu4_alpha,15) else menu4_alpha_dir := 1; end;
       end else if menu4_alpha >15 then dec(menu4_alpha,15);
       // animate menu5
       if (cur.x >= menux+170) and (cur.x <= menux+470) and (cur.y >= menuy+310)  and (cur.y <= menuy+340) then begin
                if menu5_alpha_dir = 1 then begin if menu5_alpha <$FF then inc(menu5_alpha,15) else menu5_alpha_dir := 0;
                end else if menu5_alpha_dir = 0 then begin if menu5_alpha >15 then dec(menu5_alpha,15) else menu5_alpha_dir := 1; end;
       end else if menu5_alpha >15 then dec(menu5_alpha,15);
       // animate menu6
       if (cur.x >= menux+170) and (cur.x <= menux+470) and (cur.y >= menuy+355)  and (cur.y <= menuy+395) then begin
                if menu6_alpha_dir = 1 then begin if menu6_alpha <$FF then inc(menu6_alpha,15) else menu6_alpha_dir := 0;
                end else if menu6_alpha_dir = 0 then begin if menu6_alpha >15 then dec(menu6_alpha,15) else menu6_alpha_dir := 1; end;
       end else if menu6_alpha >15 then dec(menu6_alpha,15);
       end;

       powerGraph.Antialias := false;

       if SYS_SHOWCRITICAL then begin
                DrawWindow(SYS_SHOWCRITICAL_CAPTION,'OK',120,165,400,150,1);
                Font2b.AlignedOut(SYS_SHOWCRITICAL_Text1,0,210,taCenter,TaNone,clWhite);
                Font2b.AlignedOut(SYS_SHOWCRITICAL_Text2,0,230,taCenter,TaNone,clWhite);
       end;

       if not SYS_SHOWCRITICAL then begin

        if (inconsole=false) and (menuburn=0) then begin
                if iskey(ord('H')) then begin
                                GoMenuPage(MENU_PAGE_HOTSEAT);
                                if maplist.count=0 then begin
                                        mapindex := -1;
                                        BrimMapList(MapPath);
                                end;
                                lastmap := -2;                                
                                menu_tab := 0;
                end;
                if iskey(ord('M')) then begin
                                if maplist.count=0 then begin
                                        mapindex := -1;
                                        BrimMapList(MapPath);
                                end;
                                lastmap := -2;
                                GoMenuPage(MENU_PAGE_MULTIPLAYER);
                                end;

                if iskey(ord('S')) then begin
                                GoMenuPage(MENU_PAGE_SETUP);
                                menu_tab := 0;
                end;
                if iskey(ord('C')) then
                            GoMenuPage(MENU_PAGE_CREDITS); gametime := -1111;
                if iskey(ord('D')) then begin
                        if demolist.count=0 then
                                demoindex := 0;
                        BrimDemosList(DemoPath);
                        GoMenuPage(MENU_PAGE_DEMOS);
                        if demoindex-21 >0 then demoofs := demoindex -20;

                end;
        end;

//        DrawWINDOW(0,0,640,400);

        if inconsole=false then
        if mapcansel=0 then
        if (iskey(mbutton1)) and (menuburn = 0) then begin
//
                if (cur.x >= menux+170) and (cur.x <= menux+470) and (cur.y >= menuy+130)  and (cur.y <= menuy+170) then
                        begin   // hotseat selected
                                GoMenuPage(MENU_PAGE_HOTSEAT);
                                if maplist.count=0 then begin
                                        mapindex := -1;
                                        BrimMapList(MapPath);
                                end;
                                lastmap := -2;
                                menu_tab := 0;
                        end;

                if (cur.x >= menux+170) and (cur.x <= menux+470) and (cur.y >= menuy+175)  and (cur.y <= menuy+215) then begin
                        GoMenuPage(MENU_PAGE_MULTIPLAYER);
                        if maplist.count=0 then begin
                        mapindex := -1;
                        BrimMapList(MapPath);
                        end;
                        lastmap := -2;
                end;

                if (cur.x >= menux+170) and (cur.x <= menux+470) and (cur.y >= menuy+220)  and (cur.y <= menuy+260) then GoMenuPage(MENU_PAGE_SETUP);
                if (cur.x >= menux+170) and (cur.x <= menux+470) and (cur.y >= menuy+265)  and (cur.y <= menuy+305) then begin
                                if demolist.count=0 then
                                        demoindex := 0;
                                BrimDemosList(DemoPath);
                                GoMenuPage(MENU_PAGE_DEMOS);
                                if demoindex-21 >0 then demoofs := demoindex -20;
                        end;
                if (cur.x >= menux+170) and (cur.x <= menux+470) and (cur.y >= menuy+310)  and (cur.y <= menuy+340) then begin GoMenuPage(MENU_PAGE_CREDITS); gametime := -1111; end;
                if (cur.x >= menux+170) and (cur.x <= menux+470) and (cur.y >= menuy+355)  and (cur.y <= menuy+395) then begin mainform.close; exit; end;
        end;

        end else if mapcansel=0 then begin // show critical, keys;

                if ISKEY(VK_RETURN) then begin mapcansel := 15; SYS_SHOWCRITICAL:=false; end;

                if ClipWindowEX(120,165,400,150)=1 then begin
                        if (ISKEY(mbutton1)) and (mapcansel=0) then begin
                                mapcansel := 15;
                                SYS_SHOWCRITICAL:=false;
                                end;
                end;

        end;

//              Font4.Scale := 512;
//              Font3.AlignedOut(uppercase('Pre055. For bot developers only.'), 222, 406,tacenter,tanone, clwhite);
//              Font3.AlignedOut(uppercase('do not distribute'), 222, 426,tacenter,tanone, clwhite);
//              Font4.Scale := 256;


//                Font2.AlignedOut('PUSSY version, do not distribute!!!!!', 222, 436,tacenter,tanone, clWhite);
                Font2.AlignedOut('Need For Kill (c) 2001-2004. Created by 3d[Power]. All rights preserved.', 80, 452,tacenter,tanone, $0000EE);
                Font2.AlignedOut('http://www.3dpower.org               e-mail: haz-3dpower@mail.ru', 102, 465,tacenter,tanone, $0000EE);
end else

// PAGE HOTSEAT
if MENUORDER = MENU_PAGE_HOTSEAT then begin     //HOTSEAT
        dxtimer.FPS := 50;

        for i := 0 to 2 do for b := 0 to 1 do PowerGraph.RenderEffect(Images[0], 256*i, 256*b, 0, effectNone);

 //     powerGraph.antialias := true;
        PowerGraph.RenderEffect(Images[5], 510, 410, 4, effectSrcAlpha);
        PowerGraph.RenderEffectCol(Images[5], 510, 410,  (button1_alpha shl 24)+$FFFFFF , 5, effectSrcAlpha or effectDiffuseAlpha);
        PowerGraph.RenderEffect(Images[5], 0, 410, 0, effectSrcAlpha);
        PowerGraph.RenderEffectCol(Images[5], 0, 410,  (button_alpha shl 24)+$FFFFFF , 1, effectSrcAlpha or effectDiffuseAlpha);

        powerGraph.Antialias := TRUE;
        PowerGraph.RotateEffect(Images[1], 120, 30, 64,350, 0, effectSrcAlpha);
        powerGraph.Antialias := false;

        // animate back button
        if (cur.x >= menux+10) and (cur.x <= menux+110) and (cur.y >= menuy+415)  and (cur.y <= menuy+465) then begin

                        if button_alpha_dir = 1 then begin
                                if button_alpha <$FF then inc(button_alpha,15) else button_alpha_dir := 0;
                        end else
                        if button_alpha_dir = 0 then begin
                                if button_alpha >15 then dec(button_alpha,15) else button_alpha_dir := 1;
                        end;
        end else if button_alpha >15 then dec(button_alpha,15);

        // animate fight button
        if (cur.x >= menux+520) and (cur.x <= menux+621) and (cur.y >= menuy+415)  and (cur.y <= menuy+465) then begin

                        if button1_alpha_dir = 1 then begin
                                if button1_alpha <$FF then inc(button1_alpha,15) else button1_alpha_dir := 0;
                        end else
                        if button1_alpha_dir = 0 then begin
                                if button1_alpha >15 then dec(button1_alpha,15) else button1_alpha_dir := 1;
                        end;
        end else if button1_alpha >15 then dec(button1_alpha,15);

        // check coord
        if not inconsole then
        if (iskey(mbutton1)) and (menuburn = 0) and (menueditmode = 0) and (mapcansel = 0) then begin
                if (cur.x >= menux+10) and (cur.x <= menux+110) and (cur.y >= menuy+415)  and (cur.y <= menuy+465) then GoMenuPage(MENU_PAGE_MAIN);
                if (cur.x >= menux+520) and (cur.x <= menux+621) and (cur.y >= menuy+415)  and (cur.y <= menuy+465) then begin
                                // check if we try to spawn a directory,,
                                if (extractfileext(maplist[mapindex]) = '') or (maplist[mapindex] = '..') then begin // chdir
                                                BrimMapList(MAPPath+'\'+maplist[mapindex]);
                                                mapcansel:=10;
                                                playsound(SND_menu3,0,0);
                                end else
                                GoMenuPage(MENU_PAGE_GOGAME);
                        end;
        end;

        Font3.TextOut('GAME OPTIONS:', 300, 50, clWhite);

        // nasty anim...
        if (extractfileext(maplist[mapindex]) = '') or (maplist[mapindex] = '..') then
                prevra := 81 else prevra := 0;

        if prevra < 77 then begin
                Font4.TextOut(map_name, 10, 220, clWhite);
                Font4.TextOut('BY: '+map_author,10,235, clWhite);
                Font4.TextOut('Size: '+inttostr(BRICK_X)+' X '+inttostr(BRICK_Y),10,250, clWhite);
        end;

        if menuburn=0 then begin
                if menu_tab = 0 then begin
                        Font3.TextOut('+',5,30, clWhite);
                        if menu_sl < 9 then menu_sl := 9;
                end;
                if menu_tab = 2 then begin
                        Font3.TextOut('+',540,395, clWhite);
                        if menu_sl < 9 then menu_sl := 9;
                end;
                  // menu sections
                case menu_sl of
                        0 : Font3.TextOut('+',275,100, clWhite);
                        1 : Font3.TextOut('+',275,130, clWhite);
                        2 : Font3.TextOut('+',275,180, clWhite);
                        3 : Font3.TextOut('+',275,210, clWhite);
                        4 : Font3.TextOut('+',275,240, clWhite);
                        5 : Font3.TextOut('+',275,270, clWhite);
                        6 : Font3.TextOut('+',275,320, clWhite);
                end;
            end;

                // seeking menu ENTER key
                if (inconsole = false) and (iskey(VK_RETURN)) and (menueditmode > 0) and (mapcansel = 0) then begin
                        playsound(SND_menu3,0,0);
                        if MENUEDITMODE = 3 then applyHcommand('warmup '+MENUEDITSTR);
                        if MENUEDITMODE = 4 then applyHcommand('timelimit '+MENUEDITSTR);
                        if MENUEDITMODE = 5 then applyHcommand('fraglimit '+MENUEDITSTR);
                        MENUEDITSTR :='';
                        menueditmode := 0; mapcansel := 10;
                end;

                Font3.TextOut('View p1 properties',290,100,clWhite);
                Font3.TextOut('View p2 properties',290,130,clWhite);

                if OPT_NOPLAYER=2 then
                Font3.TextOut('Disable player 2: Yes',290,180,clWhite) else
                Font3.TextOut('Disable player 2: No',290,180,clWhite);

                if menueditmode=3 then Font3.TextOut('Warmup='+MENUEDITSTR+'_',290,210,clWhite) else
                Font3.TextOut('Warmup:'+inttostr(MATCH_WARMUP),290,210,clWhite);
                if menueditmode=4 then Font3.TextOut('Timelimit='+MENUEDITSTR+'_',290,240,clWhite) else
                Font3.TextOut('Timelimit:'+inttostr(MATCH_TIMELIMIT),290,240,clWhite);
                if menueditmode=5 then Font3.TextOut('Fraglimit='+MENUEDITSTR+'_',290,270,clWhite) else
                Font3.TextOut('Fraglimit:'+inttostr(MATCH_FRAGLIMIT),290,270,clWhite);
                Font3.TextOut('Gametype: '+GAMETYPE_STR[MATCH_GAMETYPE],290,320,clWhite);

                if (inconsole = false) and (mapcansel = 0) and (menueditmode=0) and (menuburn=0) then begin

                        if (menu_tab = 2) and iskey(VK_LEFT) then begin playsound(SND_menu2,0,0); menu_sl := 0; menu_tab := 1;mapcansel := 5; end else
                        if (menu_tab = 1) and iskey(VK_LEFT) then begin playsound(SND_menu2,0,0); menu_sl := 9; menu_tab := 0;mapcansel := 5; end else
                        if (menu_tab = 0) and iskey(VK_LEFT) then begin playsound(SND_menu2,0,0); menu_sl := 9; menu_tab := 2;mapcansel := 5; end;


                        if (menu_tab = 0) and ((iskey(VK_TAB)) or (iskey(VK_RIGHT)))
                                then begin playsound(SND_menu2,0,0); menu_sl := 0; menu_tab := 1;mapcansel := 5; end else

                        if (menu_tab = 1) and((iskey(VK_TAB)) or (iskey(VK_RIGHT))) then begin
                                        playsound(SND_menu2,0,0);
                                        menu_sl := 9; menu_tab := 2;mapcansel := 5; end else

                        if (menu_tab = 2) and ((iskey(VK_TAB)) or (iskey(VK_RIGHT))) then begin
                                        playsound(SND_menu2,0,0);
                                        menu_sl := 9; menu_tab := 0;mapcansel := 5; end;


                        if (menu_tab = 1) and (iskey(VK_UP)) then begin
                                if menu_sl > 0 then dec(menu_sl) else
                                if menu_sl = 0 then menu_sl := 6;
                                playsound(SND_menu2,0,0);
                                mapcansel := 5;
                        end;
                        if (menu_tab = 1) and (iskey(VK_DOWN)) then begin
                                if menu_sl < 6 then inc(menu_sl) else
                                if menu_sl = 6 then menu_sl := 0;
                                playsound(SND_menu2,0,0);
                                mapcansel := 5;
                        end;

             // READ ENTER KEY!!!!!!
             if iskey(VK_RETURN)=true then EACTION := true;

             if (dxinput.Mouse.X <> 0) or
                (dxinput.Mouse.Y <> 0) or (iskey(mbutton1)) then
             if mapcansel=0 then
             if menueditmode = 0 then begin
                if (cur.x >= 285) and (cur.x <= 640) and (cur.y >= 100) and (cur.y <= 310) then begin
                                if iskey(mbutton1) then begin mapcansel:=4; EACTION:=true; end;
                                menu_tab := 1;
                                if menu_sl = 9 then menu_sl := 0;
                                end;

                if (cur.x >= 285) and (cur.x <= 640) and (cur.y >= 100)  and (cur.y <= 120) then begin
                                if iskey(mbutton1) then begin mapcansel:=4; EACTION:=true; end;
                                if menu_sl <> 0 then playsound(SND_menu2,0,0);
                                menu_sl := 0;
                                end;

                if (cur.x >= 285) and (cur.x <= 640) and (cur.y >= 130)  and (cur.y <= 150) then begin
                                if iskey(mbutton1) then begin mapcansel:=4; EACTION:=true; end;
                                if menu_sl <> 1 then playsound(SND_menu2,0,0);
                                menu_sl := 1;
                                end;

                if (cur.x >= 285) and (cur.x <= 640) and (cur.y >= 180)  and (cur.y <= 200) then begin // disable player
                                if iskey(mbutton1) then begin mapcansel:=4; EACTION:=true; end;
                                if menu_sl <> 2 then playsound(SND_menu2,0,0);
                                menu_sl := 2;
                                end;

                if (cur.x >= 285) and (cur.x <= 640) and (cur.y >= 210)  and (cur.y <= 230) then begin // disable player
                                if iskey(mbutton1) then begin mapcansel:=4; EACTION:=true; end;
                                if menu_sl <> 3 then playsound(SND_menu2,0,0);
                                menu_sl := 3;
                                end;

                if (cur.x >= 285) and (cur.x <= 640) and (cur.y >= 240)  and (cur.y <= 260) then begin
                                if iskey(mbutton1) then begin mapcansel:=4; EACTION:=true; end;
                                if menu_sl <> 4 then playsound(SND_menu2,0,0);
                                menu_sl := 4;
                                end;

                if (cur.x >= 285) and (cur.x <= 640) and (cur.y >= 270)  and (cur.y <= 290) then begin
                                if iskey(mbutton1) then begin mapcansel:=4; EACTION:=true; end;
                                if menu_sl <> 5 then playsound(SND_menu2,0,0);
                                menu_sl := 5;
                                end;

                if (cur.x >= 285) and (cur.x <= 640) and (cur.y >= 320) and (cur.y <= 340) then begin
                                if iskey(mbutton1) then begin mapcansel:=4; EACTION:=true; end;
                                if menu_sl <> 6 then playsound(SND_menu2,0,0);
                                menu_sl := 6;
                                end;
            end;

                        if EAction then
                        case menu_sl of
                        0: begin p1properties_backto:= false; GoMenuPage(MENU_PAGE_P1PROP); end;
                        1: GoMenuPage(MENU_PAGE_P2PROP);
                        2: begin playsound(SND_menu3,0,0); mapcansel := 10; if OPT_NOPLAYER=0 then OPT_NOPLAYER := 2 else OPT_NOPLAYER := 0; end;
                        3: begin playsound(SND_menu3,0,0);MENUEDITMODE := 3; MENUEDITMAX := 3;MENUEDITSTR := inttostr(MATCH_WARMUP); mapcansel := 10;    end;
                        4: begin playsound(SND_menu3,0,0);MENUEDITMODE := 4; MENUEDITMAX := 3;MENUEDITSTR := inttostr(MATCH_TIMELIMIT); mapcansel := 10; end;
                        5: begin playsound(SND_menu3,0,0);MENUEDITMODE := 5; MENUEDITMAX := 3;MENUEDITSTR := inttostr(MATCH_FRAGLIMIT); mapcansel := 10; end;
                        6: begin playsound(SND_menu3,0,0); mapcansel := 10;
                                if MATCH_GAMETYPE = GAMETYPE_FFA then MATCH_GAMETYPE := GAMETYPE_RAILARENA else
                                if MATCH_GAMETYPE = GAMETYPE_RAILARENA then MATCH_GAMETYPE := GAMETYPE_PRACTICE else
                                if MATCH_GAMETYPE = GAMETYPE_PRACTICE then MATCH_GAMETYPE := GAMETYPE_FFA;
                                 end;
                        end;

        end;

        //wtf?
             if prevra < 77 then begin
                     PowerGraph.FillRect (43+prevra, 272, 162-prevra*2, 122, $333333, effectMul);
                     PowerGraph.Rectangle(43+prevra, 272, 162-prevra*2, 122, $0000ca, $000000, effectadd);
             end;


             if menueditmode = 0 then begin
                if (cur.x >= 10) and (cur.x <= 270) and (cur.y >= 70)  and (cur.y <= 220) then begin
//                                if iskey(mbutton1) then begin
                                if menu_tab <> 0 then playsound(SND_menu2,0,0);
                                menu_sl := 9; menu_tab := 0 end;
             end;

             IF INCONSOLE=FALSE THEN
    if (menu_tab = 0) then begin
        if (iskey(VK_UP)) or
        (iskey(mScrollUp)) or
        (( ClipWindowEx(7,54,259,168)=2) and (iskey(mbutton1))) then

                if (mapcansel = 0) then if mapindex > 0 then begin // key up
                IF mapindex > 0 then playsound(SND_menu2,0,0);
                if mapindex > 0 then dec(mapindex);
                if mapindex < mapofs then dec(mapofs);
                mapcansel := 4;
                if iskey(mScrollUp) then mapcansel := 1;
                end;

        if (iskey(VK_NEXT)) and (mapcansel = 0) then begin// pagedown
        if mapindex+9 <= maplist.count - 1 then begin
                mapcansel := 5;
                lastmap := -1;
                playsound(SND_menu2,0,0);
                inc(mapindex,9);
                inc(mapofs,9);

                if maplist.count >= 9 then if mapofs > maplist.count-10 then begin
                        mapofs := maplist.count-9;
                        end;

                end else
        if mapindex+9 > maplist.count - 1 then begin
                mapindex := maplist.count - 1;
                mapcansel := 5;
                mapofs := mapindex-7;
                if mapofs < 0 then mapofs:=0;
                lastmap := -1;
//              playsound(SND_menu2,320);
        end;
        end;


        if (iskey(VK_HOME)) and (mapcansel = 0) then begin// home
                if mapindex > 0 then playsound(SND_menu2,0,0);
                mapindex := 0;
                mapofs := 0;
                mapcansel := 5;
                lastmap := -1;
        end;
        if (iskey(VK_END)) and (mapcansel = 0) then begin// end
                if mapindex < maplist.count-1 then playsound(SND_menu2,0,0);
                mapindex := maplist.count-1;
                if maplist.count-8 > 0 then mapofs := mapindex-7;
                mapcansel := 5;
                lastmap := -1;
        end;


        if (iskey(VK_PRIOR)) and (mapcansel = 0) then begin// pageup
        if mapindex-9 >= 0 then begin
                mapcansel := 5;
                lastmap := -1;
                playsound(SND_menu2,0,0);
                dec(mapindex,9);
                if mapofs-9 >= 0 then dec(mapofs,9) else mapofs := 0;
                end else
        if mapindex-9 < 0 then begin
                mapindex := 0;
                mapofs := 0;
                mapcansel := 5;
                lastmap := -1;
//                playsound(SND_menu2,320);
        end;
        end;

        // SCROLLER;
        if maplist.count >= 2 then
        if iskey(mbutton1) and (mapcansel=0) and (cur.x >= 250) and (cur.x <= 250+15) and (cur.y >= 85) and (cur.y <= 200) then begin
                        if cur.y > 85+ (100*mapindex div (maplist.count-1)) then if mapindex < maplist.count-1 then begin
                                inc (mapindex);
                                mapcansel := 2;
                                if mapindex-mapofs >= 8 then inc(mapofs);
                        end;

                        if cur.y < 85+ (100*mapindex div (maplist.count-1)) then if mapindex > 0 then begin
                                dec (mapindex);
                                mapcansel := 2;
                                if mapindex < mapofs then dec(mapofs);
                        end;
        end;


        if (iskey(VK_DOWN)) or
        (iskey(mScrollDn)) or
        (( ClipWindowEx(7,54,259,168)=3) and (iskey(mbutton1))) then
                if (mapcansel = 0) then begin // key down;
                IF mapindex < maplist.count - 1 then playsound(SND_menu2,0,0);
                if mapindex < maplist.count - 1 then inc(mapindex);
                if mapindex-mapofs >= 8 then inc(mapofs);
                mapcansel := 4;
                if iskey(mScrollDn) then mapcansel := 1;
//                lastmap := -1;
                end;




    end;

        // for hotseat and multi
        DrawMenu_MapMang();

        // escape key cansels editing...
        if (iskey(VK_ESCAPE)) and (mapcansel=0) and (menueditmode>0) then begin
                        menueditmode:=0;
                        mapcansel:=10;
                        playsound(SND_menu3,0,0);
                end;
        if (mapcansel=0) and (menuburn=0) and (inconsole=false) and (menueditmode=0) then begin
                if (menu_tab=0) and ((iskey(VK_RETURN)) or (iskey(mbutton2)) or (iskey(mbutton3)) ) then
                begin
                        // change directory
                        if (extractfileext(maplist[mapindex]) = '') or (maplist[mapindex] = '..') then begin // chdir
                                BrimMapList(MAPPath+'\'+maplist[mapindex]);
                                mapcansel:=10;
                                playsound(SND_menu3,0,0);
                        end;
                end;

                if (menu_tab = 2) and (iskey(VK_RETURN)) then begin // FIGHT BUTTON
                                if (extractfileext(maplist[mapindex]) = '') or (maplist[mapindex] = '..') then begin // chdir
                                                BrimMapList(MAPPath+'\'+maplist[mapindex]);
                                                mapcansel:=10;
                                                playsound(SND_menu3,0,0);
                                end else
                                GoMenuPage(MENU_PAGE_GOGAME);
                         end;
                if (iskey(VK_ESCAPE)) then GoMenuPage(MENU_PAGE_MAIN);
        end;

end else

// MENU_PAGE_MULTIPLAYER
if menuorder = MENU_PAGE_MULTIPLAYER then begin     // SETUP

//      HEHE:) Disable multiplayer :)
{       menuorder := MENU_PAGE_main;
        applyHcommand('disconnect');
}


        dxtimer.FPS := 50;
        // DRAW_BACKGROUND
        for i := 0 to 2 do for b := 0 to 1 do PowerGraph.RenderEffect(Images[0], 256*i, 256*b, 0, effectNone);

        powerGraph.Antialias := TRUE;
        if MP_STEP = 1 then
        PowerGraph.RotateEffect(Images[60], 140, 30, 64, 350, 0, effectSrcAlpha) else // nfkplanet label
        if MP_STEP = 4 then
        PowerGraph.RotateEffect(Images[60], 140, 30, 64, 350, 1, effectSrcAlpha) else // nfkplanet label
        PowerGraph.RotateEffect(Images[1], 160, 30, 64,350, 1, effectSrcAlpha);
        powerGraph.Antialias := false;

//        BRefreshEnabled := TRUE;
        BCreateEnabled := TRUE;
        BFightEnabled := TRUE;

        if ((MP_STEP=1) or (MP_STEP=4)) and (MP_Sessions.count = 0) then BFightEnabled:=false;

{        if (((Mp_ProvidersMirror[MP_ProvidersIndex]='Modem Connection For DirectPlay') or (Mp_ProvidersMirror[MP_ProvidersIndex]='Serial Connection For DirectPlay')) and (MP_Sessions.count>0)) then begin
                BRefreshEnabled := false;
                BCreateEnabled := false;
        end;
 }
        // BUTTONS
        // -----------------
        PowerGraph.RenderEffect(Images[5], 0, 410, 0, effectSrcAlpha);
        PowerGraph.RenderEffectCol(Images[5], 0, 410,  (button_alpha shl 24)+$FFFFFF , 1, effectSrcAlpha or effectDiffuseAlpha);
        // animate back button
        if (cur.x >= menux+10) and (cur.x <= menux+110) and (cur.y >= menuy+415)  and (cur.y <= menuy+465) then begin

                        if button_alpha_dir = 1 then begin
                                if button_alpha <$FF then inc(button_alpha,15) else button_alpha_dir := 0;
                        end else
                        if button_alpha_dir = 0 then begin
                                if button_alpha >15 then dec(button_alpha,15) else button_alpha_dir := 1;
                        end;
        end else if button_alpha >15 then dec(button_alpha,15);


        if (MP_STEP<=2) or (MP_STEP=4) then begin
                if MP_STEP=0 then begin
                        PowerGraph.RenderEffect(Images[46], 510, 410, 2, effectSrcAlpha);
                        PowerGraph.RenderEffectCol(Images[46], 510, 410,  (button1_alpha shl 24)+$FFFFFF , 3, effectSrcAlpha or effectDiffuseAlpha);
           end else begin
                if BFightEnabled=false then
                PowerGraph.RenderEffectCol(Images[5], 510, 410,$FF999999, 4, effectSrcAlpha or EffectDiffuseAlpha) else
                PowerGraph.RenderEffect(Images[5], 510, 410, 4, effectSrcAlpha);
                PowerGraph.RenderEffectCol(Images[5], 510, 410,  (button1_alpha shl 24)+$FFFFFF , 5, effectSrcAlpha or effectDiffuseAlpha);
        end;
        // animate fight button

        if BFightEnabled=false then button1_alpha := 0 else

        if (cur.x >= menux+520) and (cur.x <= menux+621) and (cur.y >= menuy+415)  and (cur.y <= menuy+465) then begin
                        if button1_alpha_dir = 1 then begin
                                if button1_alpha <$FF then inc(button1_alpha,15) else button1_alpha_dir := 0;
                        end else
                        if button1_alpha_dir = 0 then begin
                                if button1_alpha >15 then dec(button1_alpha,15) else button1_alpha_dir := 1;
                        end;

        end else if button1_alpha >15 then dec(button1_alpha,15);
        end;

        if (MP_STEP=1) or (MP_STEP=4) then begin
//                if Mp_ProvidersMirror[MP_ProvidersIndex]='IPX Connection For DirectPlay' then begin

                // render refresh
                if BRefreshEnabled=false then
                PowerGraph.RenderEffectCol(Images[46], 165, 410,  $FF999999, 0, effectSrcAlpha or effectDiffuseAlpha) else
                PowerGraph.RenderEffect(Images[46], 165, 410, 0, effectSrcAlpha);
                PowerGraph.RenderEffectCol(Images[46], 165, 410,  (button2_alpha shl 24)+$FFFFFF , 1, effectSrcAlpha or effectDiffuseAlpha);
                // animate back button

                if BRefreshEnabled=false then button2_alpha := 0 else
                if (cur.x >= menux+180) and (cur.x <= menux+280) and (cur.y >= menuy+415)  and (cur.y <= menuy+465) then begin

                        if button2_alpha_dir = 1 then begin
                                if button2_alpha <$FF then inc(button2_alpha,15) else button2_alpha_dir := 0;
                        end else
                        if button2_alpha_dir = 0 then begin
                                if button2_alpha >15 then dec(button2_alpha,15) else button2_alpha_dir := 1;
                        end;
                end else if button2_alpha >15 then dec(button2_alpha,15);
  //              end;

                //render create
                if MP_STEP<>4 then begin
                if BCreateEnabled=false then
                PowerGraph.RenderEffectCol(Images[5], 340, 410, $FF999999  , 2, effectSrcAlpha or effectDiffuseAlpha) else
                PowerGraph.RenderEffect(Images[5], 340, 410, 2, effectSrcAlpha);
                PowerGraph.RenderEffectCol(Images[5], 340, 410,  (button3_alpha shl 24)+$FFFFFF , 3, effectSrcAlpha or effectDiffuseAlpha);
                end;
                // animate back button

                if BCreateEnabled=false then button3_alpha := 0 else
                if (cur.x >= menux+355) and (cur.x <= menux+455) and (cur.y >= menuy+415)  and (cur.y <= menuy+465) then begin

                        if button3_alpha_dir = 1 then begin
                                if button3_alpha <$FF then inc(button3_alpha,15) else button3_alpha_dir := 0;
                        end else
                        if button3_alpha_dir = 0 then begin
                                if button3_alpha >15 then dec(button3_alpha,15) else button3_alpha_dir := 1;
                        end;
                end else if button3_alpha >15 then dec(button3_alpha,15);
        end;

        // -----------------


//        if (ctgr=255) then tgb:=0;
  //      if (ctgr=0) and (tgb=1) then begin
    //            ctgr := 255; tgr := 0;
      //          end;

      // NFKPLANET#
        if MP_STEP=0 then begin
                if BNET_LOBBY_STATUS=0 then begin

                DrawWindow('Select connection','',130,132,400,110,0);

                PowerGraph.FillRectMap ( 135 , 150+MP_ProvidersIndex*20 , 135+375, 150+MP_ProvidersIndex*20 ,
                135+375, 150+MP_ProvidersIndex*20 + 20, 135, 150+MP_ProvidersIndex*20 + 20,
                (font_alpha_s shl 24)+$0000Ca, (font_alpha_s shl 24)+$0000Ca , (font_invalpha_s shl 24)+$0000Ca,(font_invalpha_s shl 24)+$0000Ca, 2 or $100);

                if MP_Providers.count >= 2 then
                        PowerGraph.RenderEffectCol(images[57],513,163+ (42*MP_ProvidersIndex div (Mp_Providers.Count-1)),$0000da, 5,effectSrcAlpha);

                for i := 0 to Mp_Providers.count-1 do
                if i = 0 then
                Font2b.AlignedOut(Mp_Providers[i], 130, 152+i*20, tacenter,tanone,clWhite) else
                Font2b.AlignedOut(Mp_Providers[i], 130, 152+i*20, tacenter,tanone,clSilver);

                Font2b.AlignedOut(Mp_Providers[MP_ProvidersIndex],170,276,tacenter,tanone,CLWhite);


                // Mouse pick
//              getcursorpos(cur);
                if ( iskey(mbutton1) )  and (mapcansel=0) and (cur.x >= 135) and (cur.x <= 135+376) and (cur.y >= 150) and (cur.y <= 150+20*4) then
                for i := 0 to 3 do
                if (cur.y >= 150+20*i) and (cur.y < 150+20*i+20 ) then begin
                        if MP_ProvidersIndex <> i then playsound(SND_Menu2,0,0);
                        MP_ProvidersIndex := i;
                        mapcansel:=2;
                        end;

                if Mp_Providers[MP_ProvidersIndex]=BNET_STR_LOBBY then begin
                        Font2b.AlignedOut('Support up to 8 players',130,300,tacenter,tanone,CLSilver);
                        Font2b.AlignedOut('NFK PLANET is a meet point of nfk online',130,332,tacenter,tanone,CLSilver);
                        Font2b.AlignedOut('players. Any currently available servers',130,348,tacenter,tanone,CLSilver);
                        Font2b.AlignedOut('are listed there, you can create and',130,364,tacenter,tanone,CLSilver);
                        Font2b.AlignedOut('register your own game on NFK PLANET!',130,380,tacenter,tanone,CLSilver);
                end else
//
                if Mp_Providers[MP_ProvidersIndex]=BNET_STR_DIRECT then begin
                        Font2b.AlignedOut('Support up to 8 players',130,300,tacenter,tanone,CLSilver);
                        Font2b.AlignedOut('This feature will help you to host a LAN',130,332,tacenter,tanone,CLSilver);
                        Font2b.AlignedOut('or a private internet game. Players has to know',130,348,tacenter,tanone,CLSilver);
                        Font2b.AlignedOut('your IP address, if you host an internet game.',130,364,tacenter,tanone,CLSilver);
//                        Font2b.AlignedOut('',130,364,tacenter,tanone,CLSilver);
//                        Font2b.AlignedOut('You need to enter IP address manually.',130,364,tacenter,tanone,CLSilver);
                end;
                if Mp_Providers[MP_ProvidersIndex] = BNET_STR_DIRECTJOIN then begin
//                        Font2b.AlignedOut('Support up to 8 players',130,300,tacenter,tanone,CLSilver);
                        Font2b.AlignedOut('Join a LAN or a private internet game.',130,332,tacenter,tanone,CLSilver);
                        Font2b.AlignedOut('You have to know an IP address of the game server.',130,348,tacenter,tanone,CLSilver);
                end;

                if Mp_Providers[MP_ProvidersIndex] = BNET_STR_JOINLAN then begin
//                        Font2b.AlignedOut('Support up to 8 players',130,300,tacenter,tanone,CLSilver);
                        Font2b.AlignedOut('Automatic NFK servers searching',130,332,tacenter,tanone,CLSilver);
                        Font2b.AlignedOut('in your Local Area Network.',130,348,tacenter,tanone,CLSilver);
                end;

                end else //end BNET_LOBBY_STATUS = 0
                if BNET_LOBBY_STATUS=1 then begin // CONNECTING
                        DrawWindow('NFK PLANET','',320-180,240-50,360,90,1);
                        font2b.AlignedOut('Connecting to NFK PLANET...',0,0,tacenter,tacenter,clWhite);
                        mapcansel := 4;
                end else
                //
                if BNET_LOBBY_STATUS=3 then begin // CANT CONNECT;
                        if (DrawWindow('Error connecting to NFK PLANET...','OK',320-250,100,500,480-200,1)) and (keyup_) then begin
                                playsound(SND_Menu3,0,0);
                                mapcansel := 0;
                                BNET_LOBBY_STATUS := 0;
                                end;
                        font2b.TextOut('You could not connect to NFK PLANET.',90,130,clWhite);
                        font2b.TextOut('Please, check following reasons:',90,145,clWhite);
                        font2b.TextOut('1) Your computer does not have internet connection.',90,175,clWhite);
                        font2b.TextOut('2) You are behind proxy server.',90,190,clWhite);
                        font2b.TextOut('3) Your Firewall blocks connection.',90,205,clWhite);
                        font2b.TextOut('4) Your connection is really slow or server is in lag, ',90,220,clWhite);
                        font2b.TextOut('    try to connect later. ',90,235,clWhite);
                        font2b.textout('5) Your NFK ports are busy ('+inttostr(BNET_GAMEPORT)+' and '+inttostr(BNET_LOBBYPORT)+').',90,250,clWhite);
                        font2b.TextOut('6) Address of NFK PLANET Server has changed, please',90,265,clWhite);
                        font2b.TextOut('    visit the official NFK web site (www.3dpower.org)',90,280,clWhite);
                        font2b.TextOut('    to update your NFK PLANET address.',90,295,clWhite);
                        mapcansel := 4;

                end else
                if BNET_LOBBY_STATUS=4 then begin // direct connect: join
                        if not BNET_CONNECTING then begin
                                DrawWindow('Direct Connection: Join game','',320-180,260-100,360,140,1);
                                font2b.TextOut('Enter IP address:',240,200,clWhite);
                                DrawCombo (220,240,combo1);
                        end;
                end;


        end else

        // CREATE SERVER SCREEN!!!!!1

        if MP_STEP=2 then begin
                //SPAWN SERVER!!!!!!11
               if (inconsole=false) and (mapcansel=0) and (menuburn=0) and (menueditmode=0) then
               if ((cur.x >= menux+520) and (cur.x <= menux+621) and (cur.y >= menuy+415)  and (cur.y <= menuy+465) and ISKEY(mbutton1)) or ((ISKEY(ord('F'))) and (MENUEDITMODE=0)) or ((iskey(VK_RETURN)) and (MENUEDITMODE=0) and (menu_tab = 2) ) then begin
                       if (extractfileext(maplist[mapindex]) = '') or (maplist[mapindex] = '..') then begin // chdir
                                BrimMapList(MAPPath+'\'+maplist[mapindex]);
                                mapcansel:=10;
                                playsound(SND_menu3,0,0);
                       end else begin

                       EACTION := false;

                       // SERVER  CREATION..


                        if Mp_Providers[MP_ProvidersIndex] = BNET_STR_LOBBY then
                               NFKPLANET_Register(OPT_SV_HOSTNAME,
                               copy(extractfilename(map_filename_fullpath),1,length(extractfilename(map_filename_fullpath))-5),
                               GetNumberOfPlayers,OPT_SV_MAXPLAYERS, MATCH_GAMETYPE);

                               BNET_ISMULTIP := 1;
//                               BNET1.Active := true;
                               MP_WAITSNAPSHOT := FALSE;

                               GoMenuPage(MENU_PAGE_GOGAME);
                               INGAMEMENU:=false;
                               mapcansel:=0;


                       end;
               end;


        Font3.TextOut('SERVER SETTINGS:', 330, 50, clWhite);
        if (extractfileext(maplist[mapindex]) <> '') and (maplist[mapindex] <> '..') then begin
                Font4.TextOut(map_name, 10, 220, clWhite);
                Font4.TextOut('BY: '+map_author,10,235, clWhite);
                Font4.TextOut('Size: '+inttostr(BRICK_X)+' X '+inttostr(BRICK_Y),10,250, clWhite);
        end;


        if menuburn=0 then begin

                if menu_tab = 0 then begin
                        Font3.TextOut('+',5,30, clWhite);
                        if menu_sl < 9 then menu_sl := 9;
                end;
                if menu_tab = 2 then begin
                        Font3.TextOut('+',540,395, clWhite);
                        if menu_sl < 9 then menu_sl := 9;
                end;
                  // menu sections
                case menu_sl of
                        0 : Font3.TextOut('+',280,97, clWhite);
                        1 : Font3.TextOut('+',280,117, clWhite);
                        2 : Font3.TextOut('+',280,137, clWhite);
                        3 : Font3.TextOut('+',280,157, clWhite);
                        4 : Font3.TextOut('+',280,197, clWhite);
                        5 : Font3.TextOut('+',280,217, clWhite);
                        6 : Font3.TextOut('+',280,237, clWhite);
                        7 : Font3.TextOut('+',280,277, clWhite);
                        8 : Font3.TextOut('+',280,297, clWhite);
                end;
            end;

                // seeking menu ENTER key
                if (inconsole = false) and (iskey(VK_RETURN)) and (menueditmode > 0) and (mapcansel = 0) then begin
                        playsound(SND_menu3,0,0);
                        if MENUEDITMODE = 1 then applyHcommand('sv_hostname '+MENUEDITSTR);
                        if MENUEDITMODE = 3 then applyHcommand('warmup '+MENUEDITSTR);
                        if MENUEDITMODE = 4 then applyHcommand('timelimit '+MENUEDITSTR);
                        if MENUEDITMODE = 5 then begin
                                if MATCH_GAMETYPE=GAMETYPE_CTF then
                                        applyHcommand('capturelimit '+MENUEDITSTR) else
                                if MATCH_GAMETYPE=GAMETYPE_DOMINATION then
                                        applyHcommand('domlimit '+MENUEDITSTR) else
                                applyHcommand('fraglimit '+MENUEDITSTR);
                                end;
                        MENUEDITSTR :='';
                        menueditmode := 0; mapcansel := 10;
                end;


                if menueditmode=1 then Font4.TextOut('Hostname='+MENUEDITSTR+'_',300,100,clWhite) else
                Font4.TextOut('Hostname: '+OPT_SV_HOSTNAME,300,100,clWhite);

                if OPT_SV_ALLOWJOINMATCH=true then Font4.TextOut('Allow join match: Yes',300,120,clWhite) else
                Font4.TextOut('Allow join match: No',300,120,clWhite);
                if OPT_SV_DEDICATED=true then Font4.TextOut('Dedicated: Yes',300,140,clWhite) else
                Font4.TextOut('Dedicated: No',300,140,clWhite);
                if OPT_SYNC=1 then Font4.TextOut('Synchronization: heavy',300,160,clWhite);
                if OPT_SYNC=2 then Font4.TextOut('Synchronization: medium',300,160,clWhite);
                if OPT_SYNC=3 then Font4.TextOut('Synchronization: light',300,160,clWhite);

                      //  OPT_SV_DEDICATED
                if menueditmode=3 then Font4.TextOut('Warmup='+MENUEDITSTR+'_',300,200,clWhite) else
                Font4.TextOut('Warmup:'+inttostr(MATCH_WARMUP),300,200,clWhite);

                if MATCH_GAMETYPE <> GAMETYPE_DOMINATION then begin
                        if menueditmode=4 then Font4.TextOut('Timelimit='+MENUEDITSTR+'_',300,220,clWhite) else
                        Font4.TextOut('Timelimit:'+inttostr(MATCH_TIMELIMIT),300,220,clWhite);
                end;

                if (MATCH_GAMETYPE <> GAMETYPE_CTF) and (MATCH_GAMETYPE <> GAMETYPE_DOMINATION) then begin
                        if menueditmode=5 then Font4.TextOut('Fraglimit='+MENUEDITSTR+'_',300,240,clWhite) else
                        Font4.TextOut('Fraglimit:'+inttostr(MATCH_FRAGLIMIT),300,240,clWhite);
                end;

                if MATCH_GAMETYPE = GAMETYPE_CTF then begin
                        if menueditmode=5 then Font4.TextOut('Capturelimit='+MENUEDITSTR+'_',300,240,clWhite) else
                        Font4.TextOut('Capturelimit:'+inttostr(MATCH_CAPTURELIMIT),300,240,clWhite);
                end;
                if MATCH_GAMETYPE = GAMETYPE_DOMINATION then begin
                        if menueditmode=5 then Font4.TextOut('Domlimit='+MENUEDITSTR+'_',300,240,clWhite) else
                        Font4.TextOut('Domlimit:'+inttostr(MATCH_DOMLIMIT),300,240,clWhite);
                end;


                Font4.TextOut('Gametype: '+GAMETYPE_STR[MATCH_GAMETYPE],300,280,clWhite);
                Font4.TextOut('Maxplayers: '+inttostr(OPT_SV_MAXPLAYERS),300,300,clWhite);

                if menu_sl=0 then font2b.alignedout('Your server''s network name',150,435,tacenter,tanone,clSilver);
                if (menu_sl=1) and (OPT_SV_ALLOWJOINMATCH=false) then font2b.alignedout('Clients can connect only at the warmup time',150,435,tacenter,tanone,clSilver);
                if (menu_sl=1) and (OPT_SV_ALLOWJOINMATCH=true) then font2b.alignedout('Clients can connect at any time',150,435,tacenter,tanone,clSilver);
                if (menu_sl=2) and (OPT_SV_DEDICATED=true) then font2b.alignedout('Server spawns without server''s player',150,435,tacenter,tanone,clSilver);
                if (menu_sl=2) and (OPT_SV_DEDICATED=false) then font2b.alignedout('Server spawns with server''s player',150,435,tacenter,tanone,clSilver);
                if menu_sl=3 then begin
                        if mainform.lobby.Active then begin
                        font2b.alignedout('You not able to change synchronization level',0,425,tacenter,tanone,clSilver);
                        font2b.alignedout('at internet games. Light is default.',150,437,tacenter,tanone,clSilver);
                        end else
                        font2b.alignedout('Use "heavy" at the fast connections',150,435,tacenter,tanone,clSilver);
                        end;

                if menu_sl=7 then if MATCH_GAMETYPE = GAMETYPE_FFA then font2b.alignedout('DeathMatch. Standart game rules',150,435,tacenter,tanone,clSilver);
                if menu_sl=7 then if MATCH_GAMETYPE = GAMETYPE_TEAM then font2b.alignedout('TeamPlay. DeathMatch between two teams.',150,435,tacenter,tanone,clSilver);
                if menu_sl=7 then if MATCH_GAMETYPE = GAMETYPE_RAILARENA then font2b.alignedout('RailArena. No items, railgun only',150,435,tacenter,tanone,clSilver);
                if menu_sl=7 then if MATCH_GAMETYPE = GAMETYPE_PRACTICE then font2b.alignedout('Practice. No items,all weapons,200 health\armor ',0,435,tacenter,tanone,clSilver);
                if menu_sl=7 then if MATCH_GAMETYPE = GAMETYPE_CTF then begin
                        font2b.alignedout('Capture The Flag. Take enemy flag',0,435,tacenter,tanone,clSilver);
                        font2b.alignedout('and bring it back to your base.',150,447,tacenter,tanone,clSilver);
                        end;
                if menu_sl=7 then if MATCH_GAMETYPE=GAMETYPE_DOMINATION then begin
                        font2b.alignedout('Domination. While you have a control of a',0,423,tacenter,tanone,clSilver);
                        font2b.alignedout('dompoint your team gains points. The first',0,435,tacenter,tanone,clSilver);
                        font2b.alignedout('team to reach "domlimit" points wins the match',0,447,tacenter,tanone,clSilver);
                        font2b.alignedout('',150,447,tacenter,tanone,clSilver);
                        end;

                if (inconsole = false) and (mapcansel = 0) and (menueditmode=0) and (menuburn=0) then begin
                        if (menu_tab=0)  and ((iskey(VK_RETURN)) or (iskey(mbutton2)) or (iskey(mbutton3)) )then
                        begin
                                if (extractfileext(maplist[mapindex]) = '') or (maplist[mapindex] = '..') then begin // chdir
                                        BrimMapList(MAPPath+'\'+maplist[mapindex]);
                                        mapcansel:=10;
                                        playsound(SND_menu3,0,0);
                                end;
                        end;

                        if (menu_tab = 2) and iskey(VK_LEFT) then begin playsound(SND_menu2,0,0); menu_sl := 0; menu_tab := 1;mapcansel := 5; end else
                        if (menu_tab = 1) and iskey(VK_LEFT) then begin playsound(SND_menu2,0,0); menu_sl := 9; menu_tab := 0;mapcansel := 5; end else
                        if (menu_tab = 0) and iskey(VK_LEFT) then begin playsound(SND_menu2,0,0); menu_sl := 9; menu_tab := 2;mapcansel := 5; end;
                        if (menu_tab = 0) and ((iskey(VK_TAB)) or (iskey(VK_RIGHT)))
                                then begin playsound(SND_menu2,0,0); menu_sl := 0; menu_tab := 1;mapcansel := 5; end else
                        if (menu_tab = 1) and((iskey(VK_TAB)) or (iskey(VK_RIGHT))) then begin
                                        playsound(SND_menu2,0,0);
                                        menu_sl := 9; menu_tab := 2;mapcansel := 5; end else
                        if (menu_tab = 2) and ((iskey(VK_TAB)) or (iskey(VK_RIGHT))) then begin
                                        playsound(SND_menu2,0,0);
                                        menu_sl := 9; menu_tab := 0;mapcansel := 5; end;
                        if (menu_tab = 1) and (iskey(VK_UP)) then begin
                                if menu_sl > 0 then dec(menu_sl) else
                                if menu_sl = 0 then menu_sl := 8;
                        if (MATCH_GAMETYPE=GAMETYPE_DOMINATION) and (menu_sl=5) then menu_sl :=4;
                                playsound(SND_menu2,0,0);
                                mapcansel := 5;
                        end;
                        if (menu_tab = 1) and (iskey(VK_DOWN)) then begin
                                if menu_sl < 8 then inc(menu_sl) else
                                if menu_sl = 8 then menu_sl := 0;
                                if (MATCH_GAMETYPE=GAMETYPE_DOMINATION) and (menu_sl=5) then menu_sl :=6;
                                playsound(SND_menu2,0,0);
                                mapcansel := 5;
                        end;

             // READ ENTER KEY!!!!!!
             if iskey(VK_RETURN)=true then EACTION := true;


//           if dxinput.Mouse.Z <> 0 then
//           addmessagE(inttostR(dxinput.Mouse.Z));

             if (dxinput.Mouse.X <> 0) or
                (dxinput.Mouse.Y <> 0) or (iskey(mbutton1)) then
             if mapcansel=0 then
//             if iskey(mbutton1) then
             if menueditmode = 0 then begin
                if (cur.x >= 275) and (cur.x <= 640) and (cur.y >= 100) and (cur.y <= 310) then begin
                                if iskey(mbutton1) then begin mapcansel:=4; EACTION:=true; end;
                                menu_tab := 1;
                                if menu_sl = 9 then menu_sl := 0;
                        end;
                if (cur.x >= 275) and (cur.x <= 640) and (cur.y > 100)  and (cur.y < 120) then begin
                                if iskey(mbutton1) then begin mapcansel:=4; EACTION:=true; end;
                                if menu_sl <> 0 then playsound(SND_menu2,0,0);
                                menu_sl := 0;
                        end;
                if (cur.x >= 275) and (cur.x <= 640) and (cur.y > 120)  and (cur.y < 140) then begin
                                if iskey(mbutton1) then begin mapcansel:=4; EACTION:=true; end;
                                if menu_sl <> 1 then playsound(SND_menu2,0,0);
                                menu_sl := 1;
                        end;
                if (cur.x >= 275) and (cur.x <= 640) and (cur.y > 140)  and (cur.y < 160) then begin
                                if iskey(mbutton1) then begin mapcansel:=4; EACTION:=true; end;
                                if menu_sl <> 2 then playsound(SND_menu2,0,0);
                                menu_sl := 2;
                        end;
                if (cur.x >= 275) and (cur.x <= 640) and (cur.y > 160)  and (cur.y < 180) then begin
                                if iskey(mbutton1) then begin mapcansel:=4; EACTION:=true; end;
                                if menu_sl <> 3 then playsound(SND_menu2,0,0);
                                menu_sl := 3;
                        end;

                if (cur.x >= 275) and (cur.x <= 640) and (cur.y > 200)  and (cur.y < 220) then begin
                                if iskey(mbutton1) then begin mapcansel:=4; EACTION:=true; end;
                                if menu_sl <> 4 then playsound(SND_menu2,0,0);
                                menu_sl := 4;
                        end;

                if MATCH_GAMETYPE<>GAMETYPE_DOMINATION then //timelimit disabled in DOM
                if (cur.x >= 275) and (cur.x <= 640) and (cur.y > 220) and (cur.y < 240) then begin
                                if iskey(mbutton1) then begin mapcansel:=4; EACTION:=true; end;
                                if menu_sl <> 5 then playsound(SND_menu2,0,0);
                                menu_sl := 5;
                        end;

                if (cur.x >= 275) and (cur.x <= 640) and (cur.y > 240) and (cur.y < 260) then begin
                                if iskey(mbutton1) then begin mapcansel:=4; EACTION:=true; end;
                                if menu_sl <> 6 then playsound(SND_menu2,0,0);
                                menu_sl := 6;
                        end;

                if (cur.x >= 275) and (cur.x <= 640) and (cur.y > 280) and (cur.y < 300) then begin
                                if iskey(mbutton1) then begin mapcansel:=4; EACTION:=true; end;
                                if menu_sl <> 7 then playsound(SND_menu2,0,0);
                                menu_sl := 7;
                                end;

                if (cur.x >= 275) and (cur.x <= 640) and (cur.y > 300) and (cur.y < 320) then begin
                                if iskey(mbutton1) then begin mapcansel:=4; EACTION:=true; end;
                                if menu_sl <> 8 then playsound(SND_menu2,0,0);
                                menu_sl := 8;
                                end;

            end;

                        if EAction then
                        case menu_sl of
                        0: begin playsound(SND_menu3,0,0);MENUEDITMODE := 1; MENUEDITMAX := 50;MENUEDITSTR := OPT_SV_HOSTNAME; mapcansel := 10; end;
                        1: begin playsound(SND_menu3,0,0); mapcansel := 10; OPT_SV_ALLOWJOINMATCH:=not OPT_SV_ALLOWJOINMATCH; end;
                        2: begin playsound(SND_menu3,0,0); mapcansel := 10; OPT_SV_DEDICATED:=not OPT_SV_DEDICATED; end;
                        3: begin
                        if not mainform.lobby.Active then begin
                                playsound(SND_menu3,0,0); mapcansel := 10; if OPT_SYNC < 3 then INC(OPT_SYNC) else OPT_SYNC := 1; end;
                                end;
                        4: begin playsound(SND_menu3,0,0);MENUEDITMODE := 3; MENUEDITMAX := 3;MENUEDITSTR := inttostr(MATCH_WARMUP); mapcansel := 10;    end;
                        5: begin playsound(SND_menu3,0,0);MENUEDITMODE := 4; MENUEDITMAX := 3;MENUEDITSTR := inttostr(MATCH_TIMELIMIT); mapcansel := 10; end;
                        6: begin playsound(SND_menu3,0,0);MENUEDITMODE := 5; MENUEDITMAX := 3;

                                        if MATCH_GAMETYPE=GAMETYPE_CTF then
                                                MENUEDITSTR := inttostr(MATCH_CAPTURELIMIT) else
                                        if MATCH_GAMETYPE=GAMETYPE_DOMINATION then
                                                MENUEDITSTR := inttostr(MATCH_DOMLIMIT) else
                                        MENUEDITSTR := inttostr(MATCH_FRAGLIMIT);
                                        mapcansel := 10;
                                end;


                        7: begin playsound(SND_menu3,0,0); mapcansel := 10;
                                if MATCH_GAMETYPE = GAMETYPE_FFA then MATCH_GAMETYPE := GAMETYPE_TEAM else
                                if MATCH_GAMETYPE = GAMETYPE_TEAM then MATCH_GAMETYPE := GAMETYPE_CTF else
                                if MATCH_GAMETYPE = GAMETYPE_CTF then MATCH_GAMETYPE := GAMETYPE_DOMINATION else
                                if MATCH_GAMETYPE = GAMETYPE_DOMINATION then MATCH_GAMETYPE := GAMETYPE_RAILARENA else
                                if MATCH_GAMETYPE = GAMETYPE_RAILARENA then MATCH_GAMETYPE := GAMETYPE_PRACTICE else
                                if MATCH_GAMETYPE = GAMETYPE_PRACTICE then MATCH_GAMETYPE := GAMETYPE_FFA;
                                 end;
                        8: begin
                                 playsound(SND_menu3,0,0); mapcansel := 10;
                                 if OPT_SV_MAXPLAYERS > 2 then dec(OPT_SV_MAXPLAYERS) else OPT_SV_MAXPLAYERS := 8;
                                 end;
                        end;
        end;

             if menueditmode = 0 then begin
                if (cur.x >= 10) and (cur.x <= 270) and (cur.y >= 70)  and (cur.y <= 220) then begin
//                                if iskey(mbutton1) then begin
                                if menu_tab <> 0 then playsound(SND_menu2,0,0);
                                menu_sl := 9; menu_tab := 0 end;
             end;

             IF INCONSOLE=FALSE THEN
    if (menu_tab = 0) then begin
        if (iskey(VK_UP))
        or (iskey(mScrollUp)) or
        (( ClipWindowEx(7,54,259,168)=2) and (iskey(mbutton1))) then

                if (mapcansel = 0) then if mapindex > 0 then begin // key up
                IF mapindex > 0 then playsound(SND_menu2,0,0);
                if mapindex > 0 then dec(mapindex);
                if mapindex < mapofs then dec(mapofs);
                mapcansel := 4;
                if iskey(mScrollUp) then mapcansel := 1;

                lastmap := -1;
                end;

        if (iskey(VK_NEXT)) and (mapcansel = 0) then begin// pagedown
        if mapindex+9 <= maplist.count - 1 then begin
                mapcansel := 5;
                lastmap := -1;
                playsound(SND_menu2,0,0);
                inc(mapindex,9);
                inc(mapofs,9);

                if maplist.count >= 9 then if mapofs > maplist.count-10 then begin
                        mapofs := maplist.count-9;
                        end;

                end else
        if mapindex+9 > maplist.count - 1 then begin
                mapindex := maplist.count - 1;
                mapcansel := 5;
                mapofs := mapindex-7;
                if mapofs < 0 then mapofs:=0;
                lastmap := -1;
//              playsound(SND_menu2,320);
        end;
        end;


        if (iskey(VK_HOME)) and (mapcansel = 0) then begin// home
                if mapindex > 0 then playsound(SND_menu2,0,0);
                mapindex := 0;
                mapofs := 0;
                mapcansel := 5;
                lastmap := -1;
        end;
        if (iskey(VK_END)) and (mapcansel = 0) then begin// end
                if mapindex < maplist.count-1 then playsound(SND_menu2,0,0);
                mapindex := maplist.count-1;
                if maplist.count-8 > 0 then mapofs := mapindex-7;
                mapcansel := 5;
                lastmap := -1;
        end;

        // SCROLLER;
        if maplist.count >= 2 then
        if iskey(mbutton1) and (mapcansel=0) and (cur.x >= 250) and (cur.x <= 250+15) and (cur.y >= 85) and (cur.y <= 200) then begin
                        if cur.y > 85+ (100*mapindex div (maplist.count-1)) then if mapindex < maplist.count-1 then begin
                                inc (mapindex);
                                mapcansel := 2;
                                if mapindex-mapofs >= 8 then inc(mapofs);
                        end;

                        if cur.y < 85+ (100*mapindex div (maplist.count-1)) then if mapindex > 0 then begin
                                dec (mapindex);
                                mapcansel := 2;
                                if mapindex < mapofs then dec(mapofs);
                        end;
        end;

        if (iskey(VK_PRIOR)) and (mapcansel = 0) then begin// pageup
                if mapindex-9 >= 0 then begin
                        mapcansel := 5;
                        lastmap := -1;
                        playsound(SND_menu2,0,0);
                        dec(mapindex,9);
                        if mapofs-9 >= 0 then dec(mapofs,9) else mapofs := 0;
                end else
                if mapindex-9 < 0 then begin
                        mapindex := 0;
                        mapofs := 0;
                        mapcansel := 5;
                        lastmap := -1;
        //                playsound(SND_menu2,320);
                end;
        end;

        if (iskey(VK_DOWN))
        or (iskey(mScrollDn)) or
        (( ClipWindowEx(7,54,259,168)=3) and (iskey(mbutton1))) then
                if (mapcansel = 0) then begin // key down;
                IF mapindex < maplist.count - 1 then playsound(SND_menu2,0,0);
                if mapindex < maplist.count - 1 then inc(mapindex);
                if mapindex-mapofs >= 8 then inc(mapofs);
                mapcansel := 4;
                if iskey(mScrollDn) then mapcansel := 1;
                lastmap := -1;
                end;
    end;

        DrawMenu_MapMang;
        end else


        // -=======---------------=-=============--------=--------=======--=-=-=------------


        if BNET_AU_ShowUpdateInfo = false then
        if (MP_STEP=1) or (MP_STEP=4) then begin


                if MP_STEP = 4 then
                if (ISKEY (32)) or (Sys_lan_refresh_time < gettickcount) then begin
                        Sys_lan_refresh_time := 0;
                        BRefreshEnabled := true;
                end;
{
                PowerGraph.Antialias := true;
                PowerGraph.RotateEffect (Images[56],320,240,64,1280, $550000ca,planet_frame,efsa or efda);
                PowerGraph.Antialias := false;
}

                DrawWINDOW('Hostname                          Map                                   Type      Load   Address                       Ping','',10,86,620,280,0);


                if (cur.y>=86) and (cur.y <= 98) then begin
                        if (cur.x>=14) and (cur.x <= 74) then begin
                                MainForm.Font2ss.TextOut('Hostname', 14, 86, $02BBFF);
                                if keyup_ then NFKPLANET_SortList(0);
                        end else
                        if (cur.x>=176) and (cur.x <= 200) then begin
                                MainForm.Font2ss.TextOut('Map', 176, 86, $02BBFF);
                                if keyup_ then NFKPLANET_SortList(1);
                        end else
                        if (cur.x>=339) and (cur.x <= 368) then begin
                                MainForm.Font2ss.TextOut('Type', 339, 86, $02BBFF);
                                if keyup_ then NFKPLANET_SortList(2);
                        end else
                        if (cur.x>=391) and (cur.x <= 420) then begin
                                MainForm.Font2ss.TextOut('Load', 391, 86, $02BBFF);
                                if keyup_ then NFKPLANET_SortList(3);
                        end else
                        if (cur.x>=431) and (cur.x <= 480) then begin
                                MainForm.Font2ss.TextOut('Address', 431, 86, $02BBFF);
                                if keyup_ then NFKPLANET_SortList(5);
                        end else
                        if (cur.x>=570) and (cur.x <= 600) then begin
                                MainForm.Font2ss.TextOut('Ping', 570, 86, $02BBFF);
                                if keyup_ then NFKPLANET_SortList(7);
                        end;
                end;

//              PowerGraph.Rectangle(10,100,620,206,$FF0000FF,$DD000000,effectSrcAlpha or EffectDiffuseAlpha);
                Font3.TextOut('Need For Kill Servers:', 15, 50, ClWhite);

                if MP_STEP=4 then if sys_lan_refresh_time > gettickcount then begin
                        Font2b.TextOut('Scanning for servers.', 310, 422, clWhite);
                        Font2b.TextOut('Press SPACE to stop.', 315, 438, clSilver);
                        end;

                if MP_STEP=1 then if SYS_BANNER then PowerGraph.RenderEffect(images[56],500,10,0,0);

//              if MP_Sessions.count>0 then PowerGraph.FillRect(14,104+18*MP_SessionIndex,620,18,$FF0000AA,EffectNone);
                if MP_Sessions.count=0 then
                Font2b.AlignedOut(inttostr(MP_Sessions.count)+ ' server(s) found.',450,380,tanone,tanone,CLSilver) else
                Font2b.AlignedOut(inttostr(MP_Sessions.count)+ ' server(s) found.',450,380,tanone,tanone,CLWhite);
//                Font2b.AlignedOut(inttostr(BNET_LOBBY_PLAYERSPLAYING)+ ' players online',10,380,tanone,tanone,CLSilver);

                if Mp_Providers[MP_ProvidersIndex] = BNET_STR_DIRECT then begin
                        Font2b.AlignedOut(MainForm.LocalIP,530,0,taFinal,taBeginning,$FFFFFFFF);
                        Font2b.AlignedOut(MainForm.GlobalIP,530,20,taFinal,tanone,$FFFFFFFF);
                        if MP_Sessions.count=0 then begin
                        Font2b.AlignedOut('Press REFRESH button to scan for servers at the specified IP adress.',0,350,tacenter,tanone,CLSilver);
                        Font2b.AlignedOut('Press CREATE button to create a game',0,365,tacenter,tanone,CLSilver);
                        end else begin
                                Font2b.AlignedOut('Press REFRESH button to scan for servers at the specified IP adress.',0,350,tacenter,tanone,CLSilver);
                                Font2b.AlignedOut('Press CREATE button to create a game',0,365,tacenter,tanone,CLSilver);
                                Font2b.AlignedOut('Press FIGHT to join game',0,380,tacenter,tanone,CLSilver);
                        end;
                end;
{                if Mp_Providers[MP_ProvidersIndex]='Modem Connection For DirectPlay' then begin
                        if MP_Sessions.count=0 then begin
                        Font2b.AlignedOut('Press REFRESH button to scan for servers at the specified phone number.',0,350,tacenter,tanone,CLSilver);
                        Font2b.AlignedOut('Press CREATE button to create a game',0,365,tacenter,tanone,CLSilver);
                        end else begin
                                Font2b.AlignedOut('Press FIGHT to join game',0,380,tacenter,tanone,CLSilver);
                        end;
                end;
                }

                // server list viewer.
                for i := 0 to 13 do
                if i+serverofs <= MP_Sessions.Count -1 then begin
                        if i+serverofs = MP_SessionIndex then

                        PowerGraph.FillRectMap ( 15 , 104+18*i , 15 + 595, 104+18*i ,  15  + 595, 104+18*i + 18, 15 , 104+18*i + 18, (font_alpha_s shl 24)+$0000ba, (font_alpha_s shl 24)+$0000ba , (font_invalpha_s shl 24)+$0000ba,(font_invalpha_s shl 24)+$0000ba, 2 or $100);
//                      PowerGraph.FillRect(15, 104+18*i, 595, 18, $0000ca, effectNone);
//                      clr := clgray;
//                      if strpar_np(MP_Sessions[i+serverofs],7) <> '' then clr :=
                        ParseColorTextLimited(strpar_np(MP_Sessions[i+serverofs],0),15,104+i*18,1,150);
                        ParseColorTextLimited(strpar_np(MP_Sessions[i+serverofs],1),175,104+i*18,1,150);
                        Font2b.TextOut (GAMETYPE_STR_NP[strtoint(strpar_np(MP_Sessions[i+serverofs],2))], 340, 104+i*18, clWhite);
                        Font2b.TextOut (strpar_np(MP_Sessions[i+serverofs],3)+'/'+strpar_np(MP_Sessions[i+serverofs],4), 390, 104+i*18, clWhite);
                        Font2b.TextOut (strpar_np(MP_Sessions[i+serverofs],5), 430, 104+i*18, clWhite);
                        Font2b.TextOut (strpar_np(MP_Sessions[i+serverofs],7), 570, 104+i*18, clWhite);
                        end;

                // scroll bar.
                if MP_Sessions.count >= 2 then
                        PowerGraph.RenderEffectCol(images[57],613,117+ (212*MP_SessionIndex div (MP_Sessions.count-1)),$0000da, 5,effectSrcAlpha);

                // Refresh Button
                if (inconsole=false) and (mapcansel=0) then
                if ((cur.x >= 180) and (cur.x <= 280) and (cur.y > 415)  and (cur.y < 465) and ISKEY(mbutton1)) or (ISKEY(ord('R'))) then
                if BRefreshEnabled then
                         begin
                                MP_Sessions.clear;

                                if MP_STEP=4 then sys_lan_refresh_time := gettickcount + 10000;
                                BRefreshEnabled := false;
                                // refresh serverz.
                                mapcansel := 5;
                                playsound(SND_menu3,0,0);

                                EACTION:=false;
                                if (Mp_Providers[MP_ProvidersIndex] = BNET_STR_LOBBY) or (Mp_Providers[MP_ProvidersIndex] = BNET_STR_JOINLAN) then
                                        NFKPLANET_UpdateServerList;
                        end;
                end;

                // Create button
                if (MP_step=1) and (inconsole=false) and (mapcansel=0) then
                if ((cur.x >= 355) and (cur.x <= 455) and (cur.y > 415)  and (cur.y < 465) and ISKEY(mbutton1)) or (ISKEY(ord('C')) and (MENUEDITMODE=0)) then
                if BCreateEnabled then
//                if not (((Mp_ProvidersMirror[MP_ProvidersIndex]='Modem Connection For DirectPlay') or (Mp_ProvidersMirror[MP_ProvidersIndex]='Serial Connection For DirectPlay')) and (MP_Sessions.count>0)) then
                begin
                        if Mp_Providers[MP_ProvidersIndex]=BNET_STR_LOBBY then
                                applyHcommand('sync 3'); // for mega dudes, who dont know what is sync!
                        MP_STEP:=2;
                        playsound(SND_menu3,0,0);
                        mapcansel := 10;
                end;

               //Connect (Fight) Button
               if (inconsole=false) and (mapcansel=0) then
               if ((cur.x >= menux+520) and (cur.x <= menux+621) and (cur.y >= menuy+415)  and (cur.y <= menuy+465) and ISKEY(mbutton1)) or (ISKEY(ord('F')) and (MENUEDITMODE=0)) then
               if MP_Sessions.count > 0 then
               if BFightEnabled then
               if (MP_STEP=1) or (MP_STEP=4) then begin
                        mapcansel := 10;
                        applyHcommand('connect '+strpar_np(MP_Sessions[MP_SessionIndex],5));

                        if (mainform.lobby.Active) and (strpar_np(MP_Sessions[MP_SessionIndex],7) = '') then
//                                Addmessage('joining proxy "'+strpar_np(MP_Sessions[MP_SessionIndex],7)+'"');
                                NFKPLANET_IWantJoinProxy(strpar_np(MP_Sessions[MP_SessionIndex], 5));

                        if ismultip=2 then MP_WAITSNAPSHOT := true;
               end;


                if (inconsole=false) then
                if mapcansel=0 then
                if menuburn=0 then begin

                        // NEXT Button.
                     if (MP_STEP=0) then begin  //Select The Communication Method KEYZ>

//                                exit;

                             if BNET_LOBBY_STATUS=0 then
                             if ISKEY(VK_UP) or (iskey(mscrollup)) or
                             ( (ClipWindowEx(130,132,400,110) = 2) and (iskey(MBUTTON1)))
                              then begin if MP_ProvidersIndex>0 then begin
                                playsound(SND_menu2,0,0);
                                dec(MP_ProvidersIndex);
                                mapcansel := 4;
                                if iskey(mscrollup) then mapcansel := 1;
                                end; end else

                             if BNET_LOBBY_STATUS=0 then
                             if ISKEY(VK_DOWN) or (iskey(mscrollDN)) or
                             ( (ClipWindowEx(130,132,400,110) = 3) and (iskey(MBUTTON1)))
                             then if MP_ProvidersIndex<Mp_Providers.count-1 then begin playsound(SND_menu2,0,0);  inc(MP_ProvidersIndex); mapcansel := 4;if iskey(mscrolldn) then mapcansel := 1; end;


                             if BNET_LOBBY_STATUS=4 then
                             if mapcansel=0 then
                             if combo1.Text = '' then
                             if combo1.TS.Count > 0 then
                             if ISKEY(18) then begin
                                combo1.Text := combo1.TS[0];
                                mapcansel := 2;
                                playsound(SND_Menu2,0,0);
                             end;

                             if ((cur.x >= menux+520) and (cur.x <= menux+621) and (cur.y >= menuy+415)  and (cur.y <= menuy+465) and ISKEY(mbutton1)) then
                             if BNET_LOBBY_STATUS=4 then
                                     if (length(combo1.text)>0) and (BNET_ValidIPAdress(combo1.text)) then begin
                                        ComboAddHistory(combo1);
                                        applyHcommand('connect '+combo1.text);
                                        mapcansel:=2;
                                        combo1.opened := false;
                                        playsound(SND_Menu3,0,0);
                                end;


                             if BNET_LOBBY_STATUS = 0 then
                             if (ISKEY(VK_RETURN)) or (iskey(mbutton2)) or (iskey(mbutton3)) or

                                ((cur.x >= menux+520) and (cur.x <= menux+621) and (cur.y >= menuy+415)  and (cur.y <= menuy+465) and ISKEY(mbutton1)) then begin


                                button3_alpha := 0;
                                button2_alpha := 0;
                                button1_alpha := 0;
                                button_alpha := 0;
                                mapcansel:=10;
                                playsound(SND_menu3,0,0);
                                if ISKEY(mbutton1) then setcursorpos(510,400); // a little hack :)

                                MP_Sessions.clear;
                                serverofs := 0;
                                MP_SessionIndex := 0;
                                mapcansel:=10;
                                MP_STEP:=0;

                                if Mp_Providers[MP_ProvidersIndex]=BNET_STR_LOBBY then
                                if BNET_LOBBY_STATUS=0 then
                                if mainform.lobby.Active = false then begin
                                        {
                                        ShowCriticalError('Cancelled','No NFK PLANET in this test version.','');
                                        ApplyCommand('disconnect');
                                        exit;
                                        }
                                        BNET_LOBBY_STATUS := 1;
                                        BNET_LOBBY_PLAYERSPLAYING := 0;
                                        mainform.lobby.Active := true;
                                end;

                                if Mp_Providers[MP_ProvidersIndex]=BNET_STR_DIRECTJOIN then
                                        BNET_LOBBY_STATUS:=4 else

                                if Mp_Providers[MP_ProvidersIndex]=BNET_STR_DIRECT then
                                        MP_STEP:=2 else

                                if Mp_Providers[MP_ProvidersIndex]=BNET_STR_JOINLAN then begin
                                        MP_STEP:=4;
                                        sys_lan_refresh_time := gettickcount+10000;
                                        BRefreshEnabled := false;
                                        MP_Sessions.clear;
                                        NFKPLANET_UpdateServerList;
                                        end;


                             end;
                     end;


                     if (inconsole=false) then
                     if (MP_STEP=1) or (MP_STEP=4) then
                     if MP_Sessions.count > 0 then begin

                                // scroll mp_sessions up
                                if (ISKEY(VK_UP)) or (iskey(mScrollUp)) or ((ClipWindowEx(10,86,620,280)=2)  and (iskey(mbutton1))) then if MP_SessionIndex>0 then begin
                                        dec(MP_SessionIndex);
                                        mapcansel := 4;
                                        playsound(SND_Menu2,0,0);
                                        if (iskey(mScrollUp)) then mapcansel := 1;
                                        if MP_SessionIndex < ServerOFS then dec(ServerOFS);

                                end;
                                if ISKEY(VK_DOWN) or (iskey(mScrollDn)) or ((ClipWindowEx(10,86,620,280)=3)  and (iskey(mbutton1)))  then if MP_SessionIndex<MP_Sessions.count-1 then begin
                                        inc(MP_SessionIndex); mapcansel := 4;
                                        playsound(SND_Menu2,0,0);
                                        if (iskey(mScrollDn)) then mapcansel := 1;
                                        if MP_SessionIndex-ServerOFS >= 13 then inc(ServerOFS);
                                end;


                                // SCROLLER:
                                if MP_Sessions.count >= 2 then
                                if iskey(mbutton1) and (mapcansel=0) and (cur.x >= 613) and (cur.x <= 613+18) and (cur.y >= 117) and (cur.y <= 104+242) then begin
                                        if cur.y > 117+ (212*MP_SessionIndex div (MP_Sessions.count-1)) then if MP_SessionIndex < MP_Sessions.count-1 then begin
                                                inc (MP_SessionIndex);
                                                mapcansel := 2;
                                                if MP_SessionIndex-ServerOFS >= 13 then inc(ServerOFS);
                                                end;

                                        if cur.y < 117+ (212*MP_SessionIndex div (MP_Sessions.count-1)) then if MP_SessionIndex > 0 then begin
                                                dec (MP_SessionIndex);
                                                mapcansel := 2;
                                                if MP_SessionIndex < ServerOFS then dec(ServerOFS);
                                                end;
                                end;

                                // Mouse pick
                                if iskey(mbutton1) and (mapcansel=0) and (cur.x >= 15) and (cur.x <= 610) and (cur.y >= 104) and (cur.y <= 104+280) then
                                for i := 0 to 13 do
                                        if (cur.y >= 104+18*i) and (cur.y < 104+18*i+18 ) then
                                        if i + ServerOFS <= MP_Sessions.count-1 then
                                                if MP_SessionIndex <> i + ServerOFS then begin
                                                MP_SessionIndex := i + ServerOFS;
                                                playsound(SND_Menu2,0,0);
                                                mapcansel:=2;
                                                if abs(cur.y-104+18*i) > 30 then
                                                mapcansel:=1;
                                        end;

                     end;

        end;

        if BNET_AU_ShowUpdateInfo = true then NFKPLANET_ShowNewsDeliveryScreen;

        // escape key cansels editing...
        if (iskey(VK_ESCAPE)) and (MP_STEP=2) and (mapcansel=0) and (menueditmode>0) then begin
                        menueditmode:=0;
                        mapcansel:=10;
                        playsound(SND_menu3,0,0);
                end;

        //back.
        if (inconsole=false) then
        if mapcansel=0 then
        if menuburn=0 then
                if (iskey(VK_ESCAPE)) or ((cur.x >= menux+10) and (cur.x <= menux+110) and (cur.y >= menuy+415)  and (cur.y <= menuy+465) and (keyup_) and (MENUEDITMODE=0)) then begin
                        button1_alpha := 0;
                        button_alpha := 0;
                        mapcansel:=10;
                        menueditmode:=0;
                        if MP_STEP>0 then playsound(SND_menu3,0,0);
                        iF MP_STEP=0 then
                                 if BNET_LOBBY_STATUS=4 then begin
                                        BNET_LOBBY_STATUS:=0;
                                        playsound(SND_Menu3,0,0);
                                        end
                                        else
                                 GoMenuPage(MENU_PAGE_MAIN) else



                        if MP_STEP=1 then begin// LOBBYSCREEN BACK;
                                if Mp_Providers[MP_ProvidersIndex]=BNET_STR_LOBBY then begin

//                                        if bnet1.active then bnet1.active := false;

                                        if BNET_LOBBY_STATUS = 1 then begin
                                                BNET_LOBBY_STATUS := 0;
                                                MP_STEP:=0;
                                        end;

                                        if BNET_LOBBY_STATUS = 2 then begin
                                                BNET_LOBBY_STATUS := 0;
                                                MP_STEP:=0;
                                                end;

                                        if MainForm.LOBBY.Active = true then
                                                MainForm.LOBBY.Active := false;

                                        mapcansel:=10;
                                end;
                        end else
                        // -------------------
                        if MP_STEP=4 then Begin
                                mapcansel := 10;
                                MP_STEP := 0;
                        end else
                        // -------------------
                        if MP_STEP=2 then Begin
                                mapcansel:=10;
                                if Mp_Providers[MP_ProvidersIndex]=BNET_STR_DIRECT then
                                        MP_STEP:=0 else
                                if Mp_Providers[MP_ProvidersIndex]=BNET_STR_LOBBY then
                                        MP_STEP := 1;

                        end;
        end;

end else
//===================================================================================
// PAGE SETUP
if menuorder = MENU_PAGE_SETUP then begin     // SETUP
        dxtimer.FPS := 50;
        // DRAW_BACKGROUND
        for i := 0 to 2 do for b := 0 to 1 do PowerGraph.RenderEffect(Images[0], 256*i, 256*b, 0, effectNone);

        powerGraph.Antialias := TRUE;
        PowerGraph.RotateEffect(Images[1], 90, 30, 64,350, 2, effectSrcAlpha);
        powerGraph.Antialias := false;

        PowerGraph.RenderEffect(Images[5], 0, 410, 0, effectSrcAlpha);
        PowerGraph.RenderEffectCol(Images[5], 0, 410,  (button_alpha shl 24)+$FFFFFF , 1, effectSrcAlpha or effectDiffuseAlpha);

        // animate back button
        if (cur.x >= menux+10) and (cur.x <= menux+110) and (cur.y >= menuy+415)  and (cur.y <= menuy+465) then begin

                        if button_alpha_dir = 1 then begin
                                if button_alpha <$FF then inc(button_alpha,15) else button_alpha_dir := 0;
                        end else
                        if button_alpha_dir = 0 then begin
                                if button_alpha >15 then dec(button_alpha,15) else button_alpha_dir := 1;
                        end;
        end else if button_alpha >15 then dec(button_alpha,15);

        PowerGraph.antialias := true;


        Font3.TextOut('+ Change player properties', 20, 80, clWhite);

        if (menuburn=0) and (mapcansel=0) and (inconsole=false) then
        if (iskey(VK_RETURN)) or (((cur.x >= 20) and (cur.y >= 80) and (cur.x <= 400) and (cur.y <= 100)) and (keyup_)) then begin
                p1properties_backto := true;
                GoMenuPage(MENU_PAGE_P1PROP);
                mapcansel := 8;
        end;

//        p1properties_backto
        Font1.TextOut('Setup screen in not finished yet.', 20, 140, clWhite);
        Font1.TextOut('Please read help file, section "Console Commands"', 20, 160, clWhite);
        PowerGraph.antialias := false;

//        Mainform.DXPlay.

        if menuburn=0 then begin
        if (iskey(VK_ESCAPE)) then GoMenuPage(MENU_PAGE_MAIN);
                if (cur.x >= menux+10) and (cur.x <= menux+110) and (cur.y >= menuy+415)  and (cur.y <= menuy+465) then
                if keyup_ then GoMenuPage(MENU_PAGE_MAIN);
        end;
end else

// PAGE MENU_REDEFINEP1 or MENU_REDEFINEP2
if (menuorder = MENU_REDEFINEP1) or (menuorder = MENU_REDEFINEP2) then begin     // MENU_REDEFINEP1

        dxtimer.FPS := 50;
        // DRAW_BACKGROUND
        for i := 0 to 2 do for b := 0 to 1 do PowerGraph.RenderEffect(Images[0], 256*i, 256*b, 0, effectNone);

        if menuorder=MENU_REDEFINEP1 then
        Font3.TextOut('PLAYER 1 CONTROLS:', 15, 15, clWhite) else
        Font3.TextOut('PLAYER 2 CONTROLS:', 15, 15, clWhite);

        PowerGraph.RenderEffect(Images[5], 0, 410, 0, effectSrcAlpha);
        PowerGraph.RenderEffectCol(Images[5], 0, 410,  (button_alpha shl 24)+$FFFFFF , 1, effectSrcAlpha or effectDiffuseAlpha);

        // animate back button
        if (cur.x >= menux+10) and (cur.x <= menux+110) and (cur.y >= menuy+415)  and (cur.y <= menuy+465) then begin

                        if button_alpha_dir = 1 then begin
                                if button_alpha <$FF then inc(button_alpha,15) else button_alpha_dir := 0;
                        end else
                        if button_alpha_dir = 0 then begin
                                if button_alpha >15 then dec(button_alpha,15) else button_alpha_dir := 1;
                        end;
        end else if button_alpha >15 then dec(button_alpha,15);

        if menuorder=MENU_REDEFINEP1 then
        if menuburn=0 then begin
                if MENUEDITMODE>0 then begin
                        Font4.TextOut('=',180,60+menu_sl*16,clwhite);
                        Font4.AlignedOut('Waiting for new key... ESCAPE to clear',0,450,TaCenter,taNone,clwhite);
                end else begin
                if (menu_sl=19) then Font4.AlignedOut('For Multiplayer only',0,430,TaCenter,taNone,clwhite);
                if (menu_sl=8) or (menu_sl=9) then begin
                        Font4.TextOut('This bind is useless, if you use mouse look',170,430,clwhite);
                        Font4.AlignedOut('Press ENTER to change',0,450,TaCenter,taNone,clwhite);
                end else if menuorder=MENU_REDEFINEP1 then begin
                                if menu_sl=20 then
                                Font4.AlignedOut('It will reset controls to default values',0,450,TaCenter,taNone,clwhite) else
                                Font4.AlignedOut('Press ENTER to change',0,450,TaCenter,taNone,clwhite);
                        end;
                if menu_sl < 20 then
                        Font4.TextOut('+',180,60+menu_sl*16,clwhite) else
                        Font4.TextOut('+',180,76+menu_sl*16,clwhite);
                end;
        end;

        if menuorder=MENU_REDEFINEP2 then
        if menuburn=0 then begin
                if MENUEDITMODE>0 then begin
                        Font4.TextOut('=',180,60+menu_sl*16,clwhite);
                        Font4.AlignedOut('Waiting for new key... ESCAPE to clear',0,450,TaCenter,taNone,clwhite);
                end ELSE begin

                if menu_sl=19 then Font4.AlignedOut('It will reset controls to default values',0,450,TaCenter,taNone,clwhite) else
                Font4.AlignedOut('Press ENTER to change',0,450,TaCenter,taNone,clwhite);

                if menu_sl < 19 then
                        Font4.TextOut('+',180,60+menu_sl*16,clwhite) else
                        Font4.TextOut('+',180,76+menu_sl*16,clwhite);
                end;
        end;


                RG := 60;
                Font4.TextOut('Jump',200,RG,clwhite);inc(RG,16);
                Font4.TextOut('Left',200,RG,clwhite);inc(RG,16);
                Font4.TextOut('Right',200,RG,clwhite);inc(RG,16);
                Font4.TextOut('Crouch',200,RG,clwhite);inc(RG,16);
                Font4.TextOut('Fire',200,RG,clwhite);inc(RG,16);
                Font4.TextOut('Nextweapon',200,RG,clwhite);inc(RG,16);
                Font4.TextOut('Prevweapon',200,RG,clwhite);inc(RG,16);
                Font4.TextOut('Center',200,RG,clwhite);inc(RG,16);
                Font4.TextOut('Lookup',200,RG,clwhite);inc(RG,16);
                Font4.TextOut('Lookdown',200,RG,clwhite);inc(RG,16);
                Font4.TextOut('Gauntlet',200,RG,clwhite);inc(RG,16);
                Font4.TextOut('Machine gun',200,RG,clwhite);inc(RG,16);
                Font4.TextOut('Shotgun',200,RG,clwhite);inc(RG,16);
                Font4.TextOut('Grenade L.',200,RG,clwhite);inc(RG,16);
                Font4.TextOut('Rocket L.',200,RG,clwhite);inc(RG,16);
                Font4.TextOut('Shaft',200,RG,clwhite);inc(RG,16);
                Font4.TextOut('Railgun',200,RG,clwhite);inc(RG,16);
                Font4.TextOut('Plasma gun',200,RG,clwhite);inc(RG,16);
                Font4.TextOut('BFG',200,RG,clwhite);inc(RG,16);
        if menuorder=MENU_REDEFINEP1 then begin
                Font4.TextOut('Scoreboard',200,RG,clwhite);inc(RG,32);
                Font4.TextOut('Reset to defaults',200,RG,clwhite);//inc(RG,16);

        end else begin
                inc(RG,16);
                Font4.TextOut('Reset to defaults',200,RG,clwhite);
                end;


        if menuorder=MENU_REDEFINEP1 then begin
        RG := 60;
        Font4.TextOut(KEYSTR[ord(CTRL_MOVEUP)],400,RG,clwhite);inc(RG,16);
        Font4.TextOut(KEYSTR[ord(CTRL_MOVELEFT)],400,RG,clwhite);inc(RG,16);
        Font4.TextOut(KEYSTR[ord(CTRL_MOVERIGHT)],400,RG,clwhite);inc(RG,16);
        Font4.TextOut(KEYSTR[ord(CTRL_MOVEDOWN)],400,RG,clwhite);inc(RG,16);
        Font4.TextOut(KEYSTR[ord(CTRL_FIRE)],400,RG,clwhite);inc(RG,16);
        Font4.TextOut(KEYSTR[ord(CTRL_NEXTWEAPON)],400,RG,clwhite);inc(RG,16);
        Font4.TextOut(KEYSTR[ord(CTRL_PREVWEAPON)],400,RG,clwhite);inc(RG,16);
        Font4.TextOut(KEYSTR[ord(CTRL_CENTER)],400,RG,clwhite);inc(RG,16);
        Font4.TextOut(KEYSTR[ord(CTRL_LOOKUP)],400,RG,clwhite);inc(RG,16);
        Font4.TextOut(KEYSTR[ord(CTRL_LOOKDOWN)],400,RG,clwhite);inc(RG,16);
        Font4.TextOut(KEYSTR[ord(CTRL_WEAPON0)],400,RG,clwhite);inc(RG,16);
        Font4.TextOut(KEYSTR[ord(CTRL_WEAPON1)],400,RG,clwhite);inc(RG,16);
        Font4.TextOut(KEYSTR[ord(CTRL_WEAPON2)],400,RG,clwhite);inc(RG,16);
        Font4.TextOut(KEYSTR[ord(CTRL_WEAPON3)],400,RG,clwhite);inc(RG,16);
        Font4.TextOut(KEYSTR[ord(CTRL_WEAPON4)],400,RG,clwhite);inc(RG,16);
        Font4.TextOut(KEYSTR[ord(CTRL_WEAPON5)],400,RG,clwhite);inc(RG,16);
        Font4.TextOut(KEYSTR[ord(CTRL_WEAPON6)],400,RG,clwhite);inc(RG,16);
        Font4.TextOut(KEYSTR[ord(CTRL_WEAPON7)],400,RG,clwhite);inc(RG,16);
        Font4.TextOut(KEYSTR[ord(CTRL_WEAPON8)],400,RG,clwhite);inc(RG,16);
        Font4.TextOut(KEYSTR[ord(CTRL_SCOREBOARD)],400,RG,clwhite);//inc(RG,16);

        end else begin
        RG := 60;
        Font4.TextOut(KEYSTR[ord(CTRL_P2MOVEUP)],400,RG,clwhite);inc(RG,16);
        Font4.TextOut(KEYSTR[ord(CTRL_P2MOVELEFT)],400,RG,clwhite);inc(RG,16);
        Font4.TextOut(KEYSTR[ord(CTRL_P2MOVERIGHT)],400,RG,clwhite);inc(RG,16);
        Font4.TextOut(KEYSTR[ord(CTRL_P2MOVEDOWN)],400,RG,clwhite);inc(RG,16);
        Font4.TextOut(KEYSTR[ord(CTRL_P2FIRE)],400,RG,clwhite);inc(RG,16);
        Font4.TextOut(KEYSTR[ord(CTRL_P2NEXTWEAPON)],400,RG,clwhite);inc(RG,16);
        Font4.TextOut(KEYSTR[ord(CTRL_P2PREVWEAPON)],400,RG,clwhite);inc(RG,16);
        Font4.TextOut(KEYSTR[ord(CTRL_P2CENTER)],400,RG,clwhite);inc(RG,16);
        Font4.TextOut(KEYSTR[ord(CTRL_P2LOOKUP)],400,RG,clwhite);inc(RG,16);
        Font4.TextOut(KEYSTR[ord(CTRL_P2LOOKDOWN)],400,RG,clwhite);inc(RG,16);
        Font4.TextOut(KEYSTR[ord(CTRL_P2WEAPON0)],400,RG,clwhite);inc(RG,16);
        Font4.TextOut(KEYSTR[ord(CTRL_P2WEAPON1)],400,RG,clwhite);inc(RG,16);
        Font4.TextOut(KEYSTR[ord(CTRL_P2WEAPON2)],400,RG,clwhite);inc(RG,16);
        Font4.TextOut(KEYSTR[ord(CTRL_P2WEAPON3)],400,RG,clwhite);inc(RG,16);
        Font4.TextOut(KEYSTR[ord(CTRL_P2WEAPON4)],400,RG,clwhite);inc(RG,16);
        Font4.TextOut(KEYSTR[ord(CTRL_P2WEAPON5)],400,RG,clwhite);inc(RG,16);
        Font4.TextOut(KEYSTR[ord(CTRL_P2WEAPON6)],400,RG,clwhite);inc(RG,16);
        Font4.TextOut(KEYSTR[ord(CTRL_P2WEAPON7)],400,RG,clwhite);inc(RG,16);
        Font4.TextOut(KEYSTR[ord(CTRL_P2WEAPON8)],400,RG,clwhite);//inc(RG,16);
        end;

        // mouse select.
        if menueditmode = 0 then if (dxinput.Mouse.X <> 0) or (dxinput.Mouse.Y <> 0) or (iskey(mbutton1)) then
        if (cur.x >= 200) and (cur.x <= 600) and (cur.y >= 60) and (cur.y <= RG+16) then begin
                        for i := 0 to 1+(RG-60) div 16 do if (cur.y >= 64+16*i) and (cur.y <= 64+16+16*i) then menu_sl := i;
                        if last_menu_sl <> menu_sl then playsound(SND_menu2,0,0);
                        last_menu_sl := menu_sl;
                        if mapcansel = 0 then
                        if iskey(mButton1) then begin
                                 EACTION := true;
                                 mapcansel := 0;
                                 end else
                        mapcansel := 1;
                        if menu_sl > 1+(RG-60) div 16 then menu_sl := 1+(RG-60) div 16;
        end;

        if inconsole then mapcansel := 1;

        if (mapcansel = 0) and (MENUEDITMODE=0) then begin
                if menuorder=MENU_REDEFINEP1 then begin
                        if iskey(VK_UP) then begin
                        if menu_sl = 0 then menu_sl := 20 else dec(menu_sl);
                        playsound(SND_menu2,0,0); mapcansel := 5; end;
                        if iskey(VK_DOWN) then begin
                        if menu_sl = 20 then menu_sl := 0 else inc(menu_sl);
                        playsound(SND_menu2,0,0); mapcansel := 5; end;
                end;
                if menuorder=MENU_REDEFINEP2 then begin
                        if iskey(VK_UP) then begin
                        if menu_sl = 0 then menu_sl := 19 else dec(menu_sl);
                        playsound(SND_menu2,0,0); mapcansel := 5; end;
                        if iskey(VK_DOWN) then begin
                        if menu_sl = 19 then menu_sl := 0 else inc(menu_sl);
                        playsound(SND_menu2,0,0); mapcansel := 5; end;
                end;

                if iskey(VK_RETURN) then EACTION := true;
                // start read any key
                if EACTION then begin

                        if menuorder=MENU_REDEFINEP1 then begin
                                if menu_sl=20 then begin
                                        if menuorder=MENU_REDEFINEP1 then p1defaults else p2defaults;
                                        mapcansel := 10;
                                        playsound(SND_menu3,0,0);
                                end else begin
                                        MENUEDITMODE :=1;
                                        mapcansel := 10;
                                end;
                        end;
                        if menuorder=MENU_REDEFINEP2 then begin
                                if menu_sl=19 then begin
                                        if menuorder=MENU_REDEFINEP1 then p1defaults else p2defaults;
                                        mapcansel := 10;
                                        playsound(SND_menu3,0,0);
                                end else begin
                                        MENUEDITMODE :=1;
                                        mapcansel := 10;
                                end;
                        end;
                end;
        end;

        // wait for anykey;
        if (MENUEDITMODE=1) and (mapcansel=0) then
                for i:=0 to $FF do if ISKEY(ord(i)) then begin
                        mapcansel := 10;
                        MENUEDITMODE := 0;

                        IF (KEYSTR[i]='unbinded') or (KEYSTR[i]='') then
                        a:=0 else a := i;

                        if ord(a) <>0 then unbindkey(a);

                        if menuorder=MENU_REDEFINEP1 then
                        case menu_sl of
                        0 : CTRL_MOVEUP := ord(a);
                        1 : CTRL_MOVELEFT := ord(a);
                        2 : CTRL_MOVERIGHT := ord(a);
                        3 : CTRL_MOVEDOWN := ord(a);
                        4 : CTRL_FIRE := ord(a);
                        5 : CTRL_NEXTWEAPON := ord(a);
                        6 : CTRL_PREVWEAPON := ord(a);
                        7 : CTRL_CENTER := ord(a);
                        8 : CTRL_LOOKUP := ord(a);
                        9 : CTRL_LOOKDOWN := ord(a);
                        10 : CTRL_WEAPON0 := ord(a);
                        11 : CTRL_WEAPON1 := ord(a);
                        12 : CTRL_WEAPON2 := ord(a);
                        13 : CTRL_WEAPON3 := ord(a);
                        14 : CTRL_WEAPON4 := ord(a);
                        15 : CTRL_WEAPON5 := ord(a);
                        16 : CTRL_WEAPON6 := ord(a);
                        17 : CTRL_WEAPON7 := ord(a);
                        18 : CTRL_WEAPON8 := ord(a);
                        19 : CTRL_SCOREBOARD := ord(a);
                        end;

                        if menuorder=MENU_REDEFINEP2 then
                        case menu_sl of
                        0 : CTRL_P2MOVEUP := ord(a);
                        1 : CTRL_P2MOVELEFT := ord(a);
                        2 : CTRL_P2MOVERIGHT := ord(a);
                        3 : CTRL_P2MOVEDOWN := ord(a);
                        4 : CTRL_P2FIRE := ord(a);
                        5 : CTRL_P2NEXTWEAPON := ord(a);
                        6 : CTRL_P2PREVWEAPON := ord(a);
                        7 : CTRL_P2CENTER := ord(a);
                        8 : CTRL_P2LOOKUP := ord(a);
                        9 : CTRL_P2LOOKDOWN := ord(a);
                        10 : CTRL_P2WEAPON0 := ord(a);
                        11 : CTRL_P2WEAPON1 := ord(a);
                        12 : CTRL_P2WEAPON2 := ord(a);
                        13 : CTRL_P2WEAPON3 := ord(a);
                        14 : CTRL_P2WEAPON4 := ord(a);
                        15 : CTRL_P2WEAPON5 := ord(a);
                        16 : CTRL_P2WEAPON6 := ord(a);
                        17 : CTRL_P2WEAPON7 := ord(a);
                        18 : CTRL_P2WEAPON8 := ord(a);
                        end;

                        playsound(SND_menu3,0,0);
                        break;
                end;

        //  BACK button
        if (menuburn=0) and (mapcansel=0) then begin
        if menuorder=MENU_REDEFINEP1 then begin
                if iskey(VK_ESCAPE) then begin
                GoMenuPage(MENU_PAGE_P1PROP);
                menu_sl:=9;end;
                if (cur.x >= menux+10) and (cur.x <= menux+110) and (cur.y >= menuy+415)  and (cur.y <= menuy+465) then
                if iskey(mbutton1) then begin
                GoMenuPage(MENU_PAGE_P1PROP);
                menu_sl:=9;end;
        end else
        if menuorder=MENU_REDEFINEP2 then begin
                if iskey(VK_ESCAPE) then begin
                GoMenuPage(MENU_PAGE_P2PROP);menu_sl:=8;end;
                if (cur.x >= menux+10) and (cur.x <= menux+110) and (cur.y >= menuy+415)  and (cur.y <= menuy+465) then
                if iskey(mbutton1) then begin GoMenuPage(MENU_PAGE_P2PROP);menu_sl:=8;end;
        end; end;
end else

if menuorder = MENU_PAGE_DEMOS then begin     //DEMOS
        dxtimer.FPS := 50;

        // DRAW_BACKGROUND
        for i := 0 to 2 do for b := 0 to 1 do PowerGraph.RenderEffect(Images[0], 256*i, 256*b, 0, effectNone);

        powerGraph.Antialias := TRUE;
        PowerGraph.RotateEffect(Images[1], 90, 30, 64,350, 3, effectSrcAlpha);
        powerGraph.Antialias := false;

        PowerGraph.RenderEffect(Images[5], 0, 410, 0, effectSrcAlpha);
        PowerGraph.RenderEffectCol(Images[5], 0, 410,  (button_alpha shl 24)+$FFFFFF , 1, effectSrcAlpha or effectDiffuseAlpha);

        // animate back button
        if (cur.x >= menux+10) and (cur.x <= menux+110) and (cur.y >= menuy+415)  and (cur.y <= menuy+465) then begin

                        if button_alpha_dir = 1 then begin
                                if button_alpha <$FF then inc(button_alpha,15) else button_alpha_dir := 0;
                        end else
                        if button_alpha_dir = 0 then begin
                                if button_alpha >15 then dec(button_alpha,15) else button_alpha_dir := 1;
                        end;
        end else if button_alpha >15 then dec(button_alpha,15);

        PowerGraph.RenderEffect(Images[5], 510, 410, 6, effectSrcAlpha);
        PowerGraph.RenderEffectCol(Images[5], 510, 410,  (button1_alpha shl 24)+$FFFFFF , 7, effectSrcAlpha or effectDiffuseAlpha);

        // animate fight button
        if (cur.x >= menux+520) and (cur.x <= menux+621) and (cur.y >= menuy+415)  and (cur.y <= menuy+465) then begin

                        if button1_alpha_dir = 1 then begin
                                if button1_alpha <$FF then inc(button1_alpha,15) else button1_alpha_dir := 0;
                        end else
                        if button1_alpha_dir = 0 then begin
                                if button1_alpha >15 then dec(button1_alpha,15) else button1_alpha_dir := 1;
                        end;
        end else if button1_alpha >15 then dec(button1_alpha,15);


//        ImageList.Items.Find('playbtn').Draw(DXDraw.Surface, menux+535,menuy+420, 0);           // playdemo

       PowerGraph.Antialias := true;
       PowerGraph.RenderEffect(Images[43], 570, 120, 0, effectSrcAlpha);
       PowerGraph.RenderEffect(Images[43], 570, 184, 2, effectSrcAlpha);
       PowerGraph.RenderEffectCol(Images[43], 570, 120,  (menu1_alpha shl 24)+$FFFFFF , 1, effectSrcAlpha or effectDiffuseAlpha);
       PowerGraph.RenderEffectCol(Images[43], 570, 184,  (menu2_alpha shl 24)+$FFFFFF , 3, effectSrcAlpha or effectDiffuseAlpha);
       PowerGraph.Antialias := false;



       // animate menu1
       if (cur.x >= menux+570) and (cur.x <= menux+615) and (cur.y >= menuy+120)  and (cur.y <= menuy+184) then begin
                if menu1_alpha_dir = 1 then begin if menu1_alpha <$FF then inc(menu1_alpha,15) else menu1_alpha_dir := 0;
                end else if menu1_alpha_dir = 0 then begin if menu1_alpha >15 then dec(menu1_alpha,15) else menu1_alpha_dir := 1; end;
       end else if menu1_alpha >15 then dec(menu1_alpha,15);
       // animate menu2
       if (cur.x >= menux+570) and (cur.x <= menux+615) and (cur.y >= menuy+185)  and (cur.y <= menuy+248) then begin
                if menu2_alpha_dir = 1 then begin if menu2_alpha <$FF then inc(menu2_alpha,15) else menu2_alpha_dir := 0;
                end else if menu2_alpha_dir = 0 then begin if menu2_alpha >15 then dec(menu2_alpha,15) else menu2_alpha_dir := 1; end;
       end else if menu2_alpha >15 then dec(menu2_alpha,15);


    if not INCONSOLE then
    if (mapcansel = 0) then begin       // selection demo!

        if iskey(VK_HOME) then begin
                IF demoindex > 0 then playsound(SND_menu2,0,0);
                demoindex:=0;
                demoofs :=0;
                mapcansel := 4;
                end;

        if iskey(VK_END) then begin
                if demoindex < demolist.count-1 then playsound(SND_menu2,0,0);
                demoindex := demolist.count-1;
                if demolist.count-21 > 0 then demoofs := demoindex-20;
                mapcansel := 5;
        end;


        if ((iskey(VK_UP)) or
           (iskey(mScrollUp)) or
           (((cur.x >= 570) and (cur.x <= 615) and (cur.y >= 120)  and (cur.y <= 184))
           and (iskey(mbutton1)))) then begin
           if demoindex > 0 then begin
                IF demoindex > 0 then playsound(SND_menu2,0,0);
                if demoindex > 0 then dec(demoindex);
                if demoindex < demoofs then dec(demoofs);
                if iskey(VK_TAB) then mapcansel := 1 else
                mapcansel := 4;
                if iskey(mScrollUp) then mapcansel := 1;
                end;
        end else
        if ((iskey(VK_DOWN)) or
           (iskey(mScrollDn)) or
           (((cur.x >= 570) and (cur.x <= 615) and (cur.y >= 185)  and (cur.y <= 248))
           and (iskey(mbutton1)))) then begin
                if demoindex < demolist.count - 1 then playsound(SND_menu2,0,0);
                if demoindex < demolist.count - 1 then inc(demoindex);
                if demoindex-demoofs >= 21 then inc(demoofs);
                if iskey(VK_TAB) then mapcansel := 1 else
                mapcansel := 4;
                if iskey(mScrollDn) then mapcansel := 1;
                end;

        if mapcansel=0 then
        if demolist.count > 0 then
//        if ((iskey(VK_RETURN)) or
          if ((iskey(VK_RETURN)) or (iskey(mbutton2)) or (iskey(mbutton3))  or

           (((cur.x >= menux+520) and (cur.x <= menux+621) and (cur.y >= menuy+415)  and (cur.y <= menuy+465))
            and (iskey(mbutton1)))) then begin /// rock 'n roll


            if (extractfileext(demolist[demoindex]) = '') or (demolist[demoindex] = '..') then begin // chdir
                        if extractfileext(demolist[demoindex]) = '' then BCreateEnabled := true else BCreateEnabled := false;
                        BrimDemoSList(DEMOPath+'\'+demolist[demoindex]);
                        if BCreateEnabled then demoindex := 0;


                        //a bug fix :)
                        if (extractfileext(demolist[demoindex]) <> '') and (demolist[demoindex] <> '..') then demoindex := 0;
                        mapcansel:=10;
                        playsound(SND_menu3,0,0);
            end else begin
                // Okay, now play demo
                i := 1;
                s := ROOTDIR+'\demos\?';
                s2 := DEMOPath+'\'+demolist[demoindex];
                while lowercase(s[i])=lowercase(s2[i]) do inc(i);
                applyHcommand('demo '+copy(s2,i,length(s2)-i-3));
                playsound(SND_menu3,0,0);
                exit;
                end;

           end;


        // Mouse pick
        getcursorpos(cur);
        if iskey(mbutton1) and (mapcansel=0) and (cur.x >= 15) and (cur.x <= 540) and (cur.y >= 54) and (cur.y <= 54+336+16) then
        for i := 0 to 21 do
        if (cur.y >= 54+16*i) and (cur.y < 54+16*i+16 ) then
        if i + demoofs <= demolist.count-1 then
        if demoindex <> i + demoofs then begin
        demoindex := i + demoofs;
        playsound(SND_Menu2,0,0);
        mapcansel:=2;
        if abs(cur.y-54+16*i) > 30 then
        mapcansel:=1;
        end;



    end;

                PowerGraph.SetClipRect(rect(0,0,549,480));

                if demolist.count=0 then Font2b.TextOut('No demos found.',20,54+16,clWhite);

                for i := 0 to 21 do begin
                        if i+demoofs <= demolist.Count -1 then begin
                        if i+demoofs = demoindex then begin
                                PowerGraph.FillRectMap(10,menuy+54+16*i,549,menuy+54+16*i,549,menuy+52+16*i+20,10,menuy+72+16*i,
                                $990000EE,$990000EE,$990000EE,$990000EE,effectSrcAlpha);

//                                PowerGraph.f

        //                          PowerGraph.FillRect(12, 70+16*i+2, 234, (70+16*i+16+3)-(70+16*i+2), $0000ca, effectNone);
                                  if (extractfileext(demolist[i+demoofs]) = '') or (demolist[i+demoofs] = '..') then begin
                                  if demolist[i+demoofs] = '..' then // render .. icon.
                                          PowerGraph.RenderEffect (Images[35],14,56+16*i,10,effectSrcAlpha) else
                                          begin // render folder icon
                                               PowerGraph.RenderEffectCol(Images[35],14,55+16*i,$0000ea,11,effectSrcAlpha);
                                               Font2b.TextOut(demolist[i+demoofs],30,54+16*i,clWhite);
                                          end;
                                  end  else
                                  Font2b.TextOut(demolist[i+demoofs],12,54+16*i,clWhite);
                                end else
                                if (extractfileext(demolist[i+demoofs]) = '') or (demolist[i+demoofs] = '..') then begin
                                  if demolist[i+demoofs] = '..' then // render .. icon.
                                          PowerGraph.RenderEffect (Images[35],14,56+16*i,10,effectSrcAlpha) else
                                          begin // render folder icon
                                               PowerGraph.RenderEffectCol (Images[35],14,55+16*i,$0000ea,11,effectSrcAlpha);
                                               Font2b.TextOut(demolist[i+demoofs],30,54+16*i,clWhite);
                                          end;
                                  end  else
                                Font2b.TextOut(demolist[i+demoofs],12,54+16*i,clWhite);
                        end;
                end;

                PowerGraph.SetClipRect(rect(0,0,640,480));

{               for i := 0 to 21 do begin          // $AA0000EE
                        if i+demoofs <= demolist.count -1 then
                        if i+demoofs = demoindex then begin
                                PowerGraph.FillRect(10,menuy+52+16*i+2,539,18,$990000EE,effectSrcAlpha);
                                Font2b.TextOut(demolist[i+demoofs],12,54+16*i,clWhite);
                                 end else
                        Font2b.TextOut(demolist[i+demoofs],12,54+16*i,clWhite);
                end;
 }


                PowerGraph.Rectangle(549, 53, 12, 340, $000044, $000000, effectadd);
                if demolist.count >= 2 then
                        PowerGraph.FillRect(550, 54+ (320*demoindex div (demolist.count-1)), 10, 18, $990000EE, effectSrcAlpha);

        if mapcansel=0 then
        if menuburn=0 then begin
        if (dxinput.keyboard.Keys[27]) or ( (keyup_) and
                ( (cur.x >= menux+10) and (cur.x <= menux+110) and (cur.y >= menuy+415)  and (cur.y <= menuy+465) ))then
                begin
                        if demolist.count >0 then
                        if (demolist[0] = '..') then begin // chdir
                                BrimDemoSList(DEMOPath+'\..');
                                mapcansel:=10;
                                playsound(SND_menu3,0,0);
                        end else
                        GoMenuPage(MENU_PAGE_MAIN);

                        if demolist.count=0 then GoMenuPage(MENU_PAGE_MAIN);
                end;
        end;
end else

// PAGE PLAYER1PROPERTIES
if MENUORDER = MENU_PAGE_P1PROP then begin
        dxtimer.FPS := 50;
        // DRAW_BACKGROUND
        for i := 0 to 2 do for b := 0 to 1 do PowerGraph.RenderEffect(Images[0], 256*i, 256*b, 0, effectNone);

        PowerGraph.RenderEffect(Images[5], 0, 410, 0, effectSrcAlpha);
        PowerGraph.RenderEffectCol(Images[5], 0, 410,  (button_alpha shl 24)+$FFFFFF , 1, effectSrcAlpha or effectDiffuseAlpha);

        // animate back button
        if (cur.x >= menux+10) and (cur.x <= menux+110) and (cur.y >= menuy+415)  and (cur.y <= menuy+465) then begin

                        if button_alpha_dir = 1 then begin
                                if button_alpha <$FF then inc(button_alpha,15) else button_alpha_dir := 0;
                        end else
                        if button_alpha_dir = 0 then begin
                                if button_alpha >15 then dec(button_alpha,15) else button_alpha_dir := 1;
                        end;
        end else if button_alpha >15 then dec(button_alpha,15);


        Font3.textout('PLAYER 1 PROPERTIES:',20,20,clWhite);
        if menuburn=0 then Font1.textout('+',30,70+HG*menu_sl,clWhite);

        if menueditmode = 0 then begin

                ParseColorText('Name: '+P1NAME,50,70,4);

//                Font4.textout('Name: '+P1NAME,50,70,clWhite);
                Font4.textout('Crosshair type: '+inttostr(OPT_P1CROSHT),50,70+HG*1,clWhite);
                Font4.textout('Crosshair color: '+inttostr(OPT_P1CROSH),50,70+HG*2,clWhite);
                Font4.textout('Mouse sensitivity: '+inttostr(OPT_SENS),50,70+HG*3,clWhite);
                Font4.textout('Rail color: '+inttostr(OPT_RAILCOLOR1),50,70+HG*4,clWhite);
                Font4.textout('Player model: '+OPT_NFKMODEL1,50,70+HG*5,clWhite);

                if OPT_P1MOUSELOOK=true then begin
                        Font4.textout('Mouse Look: Yes',50,70+HG*6,clWhite);
                        Font4.textout('Keylook accelerate: not required',50,70+HG*7,clWhite);
                end else begin
                        Font4.textout('Mouse Look: No',50,70+HG*6,clWhite);
                        Font4.textout('Keylook accelerate: '+inttostr(OPT_P1KEYBACCELDELIM),50,70+HG*7,clWhite);
                end;

                if OPT_WEAPONSWITCH_END = 0 then Font4.textout('Auto weapon switch: no',50,70+HG*8,clWhite);
                if OPT_WEAPONSWITCH_END = 1 then Font4.textout('Auto weapon switch: to best (no explosive)',50,70+HG*8,clWhite);
                if OPT_WEAPONSWITCH_END = 2 then Font4.textout('Auto weapon switch: to best',50,70+HG*8,clWhite);
                Font4.textout('Customize controls',50,70+HG*9,clWhite);
        end else begin
                if menu_sl = 0 then Font4.textout('Name ='+MENUEDITSTR+'_',50,70+HG*0,clWhite) else
                if menu_sl = 3 then Font4.textout('Mouse sensitivity ='+MENUEDITSTR+'_',50,70+HG*3,clWhite) else
                if menu_sl = 7 then Font4.textout('Keylook accelerate ='+MENUEDITSTR+'_',50,70+HG*7,clWhite);
        end;
        /// KEYZ
        alpha:=$FF;

        // Crosshair preview
        if OPT_P1CROSHT > 0 then begin
                PowerGraph.Rectangle(309,99,17,17,$FFAAAAAA,$77000000,EffectSrcAlpha or EffectDiffuseAlpha);
                PowerGraph.RenderEffectCol(Images[27], 315, 105,(alpha shl 24) +ACOLOR[OPT_P1CROSH],OPT_P1CROSHT-1, effectSrcAlpha);
        end;

        // Rail Color Preview.
                PowerGraph.Rectangle(309,150,17,17,$FFAAAAAA,(alpha shl 24) +ACOLOR[OPT_RAILCOLOR1],EffectSrcAlpha or EffectDiffuseAlpha);

        EACTION := false;

        // Model Preview
        PowerGraph.Rectangle(340,100,60,60,$FFAAAAAA,$77CCCCCC,EffectSrcAlpha or EffectDiffuseAlpha);
        for i := 0 to NUM_MODELS do
                if (eee[i].classname +'+'+ eee[i].skinname) = lowercase(OPT_NFKMODEL1) then begin
                        PowerGraph.RenderEffect(Images[eee[i].walk_index], 370 - eee[i].modelsizex div 2, 105,0, effectSrcAlpha);
                        break;
                end;

        Font4.textout(inttostr(i+1)+ ' of '+inttostr(NUM_MODELS),410,140,clWhite);

        if (mapcansel = 0) and (inconsole = false) then begin

                eaction := ISKEY(VK_RETURN);
                if (EACTION) and (menueditmode > 0) then begin
                        MSG_DISABLE := TRUE;
        //                HIST_DISABLE := TRUE;
                        playsound(SND_menu3,0,0);
                        if MENUEDITMODE = 1 then applycommand('name '+MENUEDITSTR);
                        if MENUEDITMODE = 4 then applycommand('sensitivity '+MENUEDITSTR);
                        if MENUEDITMODE = 8 then applycommand('keybaccelerate '+MENUEDITSTR);
                        MSG_DISABLE := FALSE; HIST_DISABLE := FALSE; MENUEDITSTR :='';
                        menueditmode := 0; mapcansel := 10;
                end else
        if menueditmode = 0 then begin
                // mouse select.
             if (dxinput.Mouse.X <> 0) or
                (dxinput.Mouse.Y <> 0) or (iskey(mbutton1)) then
                if (cur.x >= 50) and (cur.x <= 320) and (cur.y >= 70) and (cur.y <= 270) then begin
//                if iskey(mbutton1) then begin
                        //select p1prop items by mouse

                        for i := 0 to 9 do if (cur.y >= 70+20*i) and (cur.y <= 90+20*i)
                        then menu_sl := i;
                        if last_menu_sl <> menu_sl then
                                playsound(SND_menu2,0,0);
                        last_menu_sl := menu_sl;
                        mapcansel := 1;
                        if menu_sl > 9 then menu_sl := 9;
                        if iskey(mButton1) then begin
                                 EACTION := true;
                                 mapcansel := 0;
                                 end;

                end;



       // back button
       if iskey(VK_ESCAPE) then begin
                        if p1properties_backto=false then GoMenuPage(MENU_PAGE_HOTSEAT)
                        else GoMenuPage(MENU_PAGE_SETUP);
                        menu_tab := 1; menu_sl := 0;
                        end;

       // back mouse press
       if (cur.x >= menux+10) and (cur.x <= menux+110) and (cur.y >= menuy+415)  and (cur.y <= menuy+465) then
       if keyup_ then begin

                        if p1properties_backto=false then GoMenuPage(MENU_PAGE_HOTSEAT)
                        else GoMenuPage(MENU_PAGE_SETUP);
                        menu_tab := 1; menu_sl := 0;
                        end;

        if iskey(VK_UP) then begin
                if menu_sl = 0 then menu_sl := 9 else dec(menu_sl);
                playsound(SND_menu2,0,0); mapcansel := 5; end;

        if iskey(VK_DOWN) and (mapcansel = 0) then begin
                if menu_sl = 9 then menu_sl := 0 else inc(menu_sl);
                playsound(SND_menu2,0,0); mapcansel := 5; end;

        end;

        // enter key;
        if mapcansel=0 then
        if EACTION then begin
                MENUEDITMAX := 1;
                if menu_sl = 0 then MENUEDITSTR := P1NAME;
                if menu_sl = 0 then MENUEDITMAX := 30;
                if menu_sl = 1 then if OPT_P1CROSHT < 9 then inc(OPT_P1CROSHT) else OPT_P1CROSHT := 0;
                if menu_sl = 2 then if OPT_P1CROSH < 8 then inc(OPT_P1CROSH) else OPT_P1CROSH := 1;
                if menu_sl = 3 then MENUEDITSTR := inttostr(OPT_SENS);
                if menu_sl = 4 then if OPT_RAILCOLOR1 < 8 then inc(OPT_RAILCOLOR1) else OPT_RAILCOLOR1 := 1;
                if menu_sl = 6 then OPT_P1MOUSELOOK := not OPT_P1MOUSELOOK;
                if menu_sl = 5 then begin
                                for i := 0 to NUM_MODELS-1 do
                                if (eee[i].classname+'+'+eee[i].skinname) = OPT_NFKMODEL1 then begin
                                if i = NUM_MODELS-1 then OPT_NFKMODEL1 := eee[0].classname+'+'+eee[0].skinname else
                                OPT_NFKMODEL1 := eee[i+1].classname+'+'+eee[i+1].skinname;
                                break;
                                end;
                        end;
                if menu_sl = 7 then MENUEDITSTR := inttostr(OPT_P1KEYBACCELDELIM);
                if menu_sl = 8 then if OPT_WEAPONSWITCH_END < 2 then inc(OPT_WEAPONSWITCH_END) else OPT_WEAPONSWITCH_END := 0;
                if (menu_sl=0) or (menu_sl=3) or (menu_sl=7) then
                menueditmode := menu_sl+1 else menueditmode := 0;
                mapcansel:=10;
                if menu_sl<> 9 then playsound(SND_menu3,0,0);
                if menu_sl = 9 then begin mapcansel:=10; GOMenuPage(MENU_REDEFINEP1); menu_sl := 0; end;
        end;
    end;
end;

// PAGE PLAYER2PROPERTIES
if MENUORDER = MENU_PAGE_P2PROP then begin

        for i := 0 to 2 do for b := 0 to 1 do PowerGraph.RenderEffect(Images[0], 256*i, 256*b, 0, effectNone);

        PowerGraph.RenderEffect(Images[5], 0, 410, 0, effectSrcAlpha);
        PowerGraph.RenderEffectCol(Images[5], 0, 410,  (button_alpha shl 24)+$FFFFFF , 1, effectSrcAlpha or effectDiffuseAlpha);

        // animate back button
        if (cur.x >= menux+10) and (cur.x <= menux+110) and (cur.y >= menuy+415)  and (cur.y <= menuy+465) then begin
                        if button_alpha_dir = 1 then begin
                                if button_alpha <$FF then inc(button_alpha,15) else button_alpha_dir := 0;
                        end else
                        if button_alpha_dir = 0 then begin
                                if button_alpha >15 then dec(button_alpha,15) else button_alpha_dir := 1;
                        end;
        end else if button_alpha >15 then dec(button_alpha,15);

        Font3.textout('PLAYER 2 PROPERTIES:',20,20,clWhite);
        if menuburn=0 then Font4.textout('+',30,70+HG*menu_sl,clWhite);

   if menueditmode = 0 then begin
        ParseColorText('Name: '+P2NAME,50,70,4);
        Font4.textout('Crosshair type: '+inttostr(OPT_P2CROSHT),50,70+HG*1,clWhite);
        Font4.textout('Crosshair color: '+inttostr(OPT_P2CROSH),50,70+HG*2,clWhite);
        Font4.textout('Keylook speed: '+inttostr(OPT_KSENS),50,70+HG*3,clWhite);
        Font4.textout('Keylook accelerate: '+inttostr(OPT_KEYBACCELDELIM),50,70+HG*4,clWhite);
        Font4.textout('Rail color: '+inttostr(OPT_RAILCOLOR2),50,70+HG*5,clWhite);
        Font4.textout('Player model: '+OPT_NFKMODEL2,50,70+HG*6,clWhite);
        if OPT_P2WEAPONSWITCH_END = 0 then Font4.textout('Auto weapon switch: no',50,70+HG*7,clWhite);
        if OPT_P2WEAPONSWITCH_END = 1 then Font4.textout('Auto weapon switch: to best (no explosive)',50,70+HG*7,clWhite);
        if OPT_P2WEAPONSWITCH_END = 2 then Font4.textout('Auto weapon switch: to best',50,70+HG*7,clWhite);
        Font4.textout('Customize controls',50,70+HG*8,clWhite);

    end else begin
        if menu_sl = 0 then Font4.textout('Name ='+MENUEDITSTR+'_',50,70+HG*0,clWhite) else
        if menu_sl = 3 then Font4.textout('Keylook speed ='+MENUEDITSTR+'_',50,70+HG*3,clWhite) else
        if menu_sl = 4 then Font4.textout('Keylook accelerate ='+MENUEDITSTR+'_',50,70+HG*4,clWhite);// else
    end;
        /// KEYZ

        alpha := $FF;

        // Crosshair preview
        if OPT_P1CROSHT > 0 then begin
                PowerGraph.Rectangle(309,99,17,17,$FFAAAAAA,$77000000,EffectSrcAlpha or EffectDiffuseAlpha);
                PowerGraph.RenderEffectCol(Images[27], 315, 105,(alpha shl 24) +ACOLOR[OPT_P2CROSH],OPT_P2CROSHT-1, effectSrcAlpha);
        end;

        // Rail Color Preview.
        PowerGraph.Rectangle(309,150,17,17,$FFAAAAAA,(alpha shl 24) +ACOLOR[OPT_RAILCOLOR2],EffectSrcAlpha or EffectDiffuseAlpha);

        // Model Preview
        PowerGraph.Rectangle(340,100,60,60,$FFAAAAAA,$77CCCCCC,EffectSrcAlpha or EffectDiffuseAlpha);
        for i := 0 to NUM_MODELS do
                if (eee[i].classname +'+'+ eee[i].skinname) = lowercase(OPT_NFKMODEL2) then begin
                        PowerGraph.RenderEffect(Images[eee[i].walk_index], 370 - eee[i].modelsizex div 2, 105,0, effectSrcAlpha);
                        break;
                end;

        Font4.textout(inttostr(i+1)+ ' of '+inttostr(NUM_MODELS),410,140,clWhite);

        if (mapcansel = 0) and (inconsole = false) then
        if (dxinput.keyboard.Keys[$0D]) and (menueditmode > 0) then begin
                playsound(SND_menu3,0,0);
                if MENUEDITMODE = 1 then applyhcommand('p2name '+MENUEDITSTR);
                if MENUEDITMODE = 4 then applyhcommand('keybsensitivity '+MENUEDITSTR);
                if MENUEDITMODE = 5 then applyhcommand('p2keybaccelerate '+MENUEDITSTR);
                MENUEDITSTR :='';
                menueditmode := 0; mapcansel := 10;
        end;

        // mouse select.
        if mapcansel = 0 then
        if menueditmode = 0 then if (dxinput.Mouse.X <> 0) or (dxinput.Mouse.Y <> 0) or (iskey(mbutton1)) then
        if (cur.x >= 50) and (cur.x <= 320) and (cur.y >= 70) and (cur.y <= 250) then begin
                        for i := 0 to 8 do if (cur.y >= 70+20*i) and (cur.y <= 90+20*i) then menu_sl := i;
                        if last_menu_sl <> menu_sl then playsound(SND_menu2,0,0);
                        last_menu_sl := menu_sl;
                        mapcansel := 1;
                        if menu_sl > 8 then menu_sl := 8;
                        if iskey(mButton1) then begin
                                 EACTION := true;
                                 mapcansel := 0;
                                 end;
        end;

       if menueditmode = 0 then begin
       if mapcansel = 0 then begin

        // back btn
       if (cur.x >= menux+10) and (cur.x <= menux+110) and (cur.y >= menuy+415)  and (cur.y <= menuy+465) then
       if isbutton1 in dxinput.mouse.States then begin
                GoMenuPage(MENU_PAGE_HOTSEAT);
                menu_sl := 1;
       end;

       // back
       if (dxinput.keyboard.Keys[VK_ESCAPE]) then begin
                GoMenuPage(MENU_PAGE_HOTSEAT);
                menu_sl := 1;
       end;


        if iskey(VK_UP) then begin
                if menu_sl = 0 then menu_sl := 8 else dec(menu_sl);
                playsound(SND_menu2,0,0); mapcansel := 5; end;

        if iskey(VK_DOWN) and (mapcansel = 0) then begin
                if menu_sl = 8 then menu_sl := 0 else inc(menu_sl);
                playsound(SND_menu2,0,0); mapcansel := 5; end;
       end;
       if dxinput.keyboard.Keys[VK_RETURN] then EACTION := true;


        if (mapcansel=0) and (EACTION) then begin
                if menu_sl <> 8 then playsound(SND_menu3,0,0);
                MENUEDITMAX := 1;
                menueditmode := menu_sl+1;
                if menu_sl = 0 then MENUEDITSTR := P2NAME;
                if menu_sl = 0 then MENUEDITMAX := 30;
                if menu_sl = 1 then if OPT_P2CROSHT < 9 then inc(OPT_P2CROSHT) else OPT_P2CROSHT := 0;
                if menu_sl = 2 then if OPT_P2CROSH < 8 then inc(OPT_P2CROSH) else OPT_P2CROSH := 1;
                if menu_sl = 3 then MENUEDITSTR := inttostr(OPT_KSENS);
                if menu_sl = 4 then MENUEDITSTR := inttostr(OPT_KEYBACCELDELIM);
                if menu_sl = 5 then if OPT_RAILCOLOR2 < 8 then inc(OPT_RAILCOLOR2) else OPT_RAILCOLOR2 := 1;
                if menu_sl = 6 then begin for i := 0 to NUM_MODELS-1 do
                        if (eee[i].classname+'+'+eee[i].skinname) = OPT_NFKMODEL2 then begin
                        if i = NUM_MODELS-1 then OPT_NFKMODEL2 := eee[0].classname+'+'+eee[0].skinname else
                        OPT_NFKMODEL2 := eee[i+1].classname+'+'+eee[i+1].skinname;
                        break;
                        end;
                end;
                if menu_sl = 7 then if OPT_P2WEAPONSWITCH_END < 2 then inc(OPT_P2WEAPONSWITCH_END) else OPT_P2WEAPONSWITCH_END := 0;
                if menu_sl = 8 then begin GOMenuPage(MENU_REDEFINEP2); menu_sl := 0; end;
                if (menu_sl = 1) or (menu_sl = 2) or (menu_sl >= 5) then MENUEDITMODE := 0;
                mapcansel := 10;
        end;
      end;// $$$if menueditmode = 0 then
//    end;
end;

// PAGE CREDITS
if menuorder = MENU_PAGE_CREDITS then begin     // CREDITS

      for i := 0 to 2 do for b := 0 to 1 do PowerGraph.RenderEffect(Images[0], 256*i, 256*b, 0, effectNone);

      powerGraph.Antialias := TRUE;
      PowerGraph.RotateEffect(Images[1], 105, 30, 64,350, 4, effectSrcAlpha);
      powerGraph.Antialias := false;

      PowerGraph.RenderEffect(Images[5], 0, 410, 0, effectSrcAlpha);
      PowerGraph.RenderEffectCol(Images[5], 0, 410,  (button_alpha shl 24)+$FFFFFF , 1, effectSrcAlpha or effectDiffuseAlpha);

      // animate back button
      if (cur.x >= menux+10) and (cur.x <= menux+110) and (cur.y >= menuy+415)  and (cur.y <= menuy+465) then begin
                             if button_alpha_dir = 1 then begin
                                if button_alpha <$FF then inc(button_alpha,15) else button_alpha_dir := 0;
                        end else
                        if button_alpha_dir = 0 then begin
                                if button_alpha >15 then dec(button_alpha,15) else button_alpha_dir := 1;
                        end;
        end else if button_alpha >15 then dec(button_alpha,15);


//        ImageList.Items.Find('logo').Draw(DXDraw.Surface, 100,20+i*20-trunc(gametime/2)-160, 0);       // logo NEED FOR KILL (red)

       PowerGraph.RenderEffect(Images[4], 114, 80-trunc(gametime/2)-160,0, effectSrcAlpha);
       PowerGraph.RenderEffect(Images[4], 370, 80-trunc(gametime/2)-160, 1, effectSrcAlpha);


        for i := 0 to credlist.count-1 do
                if copy(Credlist[i],1,1) = '=' then begin
//                        PowerGraph.antialias := true;
                        Font2.scale := 512;
                        Font2.AlignedOutEx(copy(Credlist[i],2,Length(Credlist[i])-1),0,20+i*16-trunc(gametime/2),taCenter,taNone,$DD0000FF, EffectSrcAlpha or EffectDiffuseAlpha);
                        Font2.scale := 256;
//                        PowerGraph.antialias := false;
                end else
              Font2b.AlignedOut(Credlist[i],0,20+i*16-trunc(gametime/2),taCenter,taNone,CLWhite);

        if gametime < (credlist.count*16)*2+40 then
        inc(gametime);// else



//        DXTimer.interval := 100;
  //      ImageList.Items.Find('nutrit').Draw(DXDraw.Surface,445,10, 0);       // angeline jolie tattoo :)}

        if menuburn=0 then begin
                if (dxinput.keyboard.Keys[32]) then if gametime < (credlist.count*20+480)*2 then inc(gametime,3);
                if (dxinput.keyboard.Keys[27]) then GoMenuPage(MENU_PAGE_MAIN);
                if (cur.x >= menux+10) and (cur.x <= menux+110) and (cur.y >= menuy+415)  and (cur.y <= menuy+465) then
                if isbutton1 in dxinput.mouse.States then GoMenuPage(MENU_PAGE_MAIN);
        end;
end;

 // BNETCONNECTING;
 if BNET_CONNECTING then begin
        DrawWindow('Establishing connection','',310-140,240-50,300,100,1);
        font2b.AlignedOut(' Connecting to '+BNET_GAMEIP,0,0,tacenter,tacenter,clWhite);
        MAPCANSEL := 4;
        if GetTickCount > BNET_TIMEDOUT then begin
                BNET_CONNECTING := false;
                BNET_ISMULTIP:=0;
                end;
 end;

// OTHER STUFF \ dont touch
if MENUEDITMODE = 0 then begin
        powergraph.antialias := true;
        PowerGraph.RenderEffectCol(Images[44],  cur.x,  cur.y,256,$EE1111FF,SYS_CURSORFRAME,effectSrcAlpha or EffectDiffuseAlpha);
        powergraph.antialias := false;
        DRAWConsole;
end;







 GammaAnimation;
// Font2b.TextOut('queues:'+inttostr( QueueBuf.count ),0,368,$00FF00);

 // finish the rendering
 PowerGraph.EndScene();
 // present the render on the screen
 PowerGraph.Present();

 keyup_ := false;

end;

end;

function player_region_touch (x,y,x1,y1 : word; f : tplayer) : boolean;
begin
        result := false;
        if f = nil then exit;
        if (f.x + 9 >= x*32) and (f.x-8 <= x1*32+32) then
        if (f.y + 23 >= y * 16) and (f.y - 23 <= y1*16+16) then
        result := true;
end;


function object_region_touch (x,y,x1,y1 : word; f : tmonosprite) : boolean;
begin
        result := false;
        if f = nil then exit;

        // HERE IS OPTIMIZA FOr gib. mayb

        if (f.x + 3 >= x*32) and (f.x-3 <= x1*32+32) then
        if (f.y + 3 >= y * 16) and (f.y - 3 <= y1*16+16) then
        result := true;
end;

// thiz pr0cedure calls "Suck My Dick"
procedure ActivateOBJ(p : byte);
var z,o,i : word;
rzlt : boolean;
    Msg: TMP_ObjChangeState;
    MsgSize: word;

begin
  // open door
  if ddd[p].objtype = 6 then begin // area_pain.
        ddd[p].target := 1;
        ddd[p].lenght := 100;
        exit;
  end;

  if ddd[p].orient > 1 then begin
        for z := 0 to 7 do begin
                if ddd[p].orient  = 2 then rzlt := player_region_touch (ddd[p].x,ddd[p].y,ddd[p].x+ddd[p].lenght,ddd[p].y, players[z]);
                if ddd[p].orient  = 3 then rzlt := player_region_touch (ddd[p].x,ddd[p].y,ddd[p].x,ddd[p].y+ddd[p].lenght, players[z]);
                if rzlt = true then break;
                end;

        if rzlt = true then begin // failed to close, so open back.
                ddd[p].target := 0;

                        // send data to clients.
                        if ismultip=1 then begin
                                MsgSize := SizeOf(TMP_ObjChangeState);
                                Msg.Data := MMP_OBJCHANGESTATE;
                                Msg.objindex := p;
                                Msg.state := 0;
                                mainform.BNETSendData2All (Msg, MsgSize, 1);
                        end;

                        if MATCH_DRECORD then begin
                                // change obj state!
                                ddata.gametic := gametic;
                                ddata.gametime := gametime;
                                ddata.type0 := DDEMO_OBJCHANGESTATE;
                                DemoStream.Write( DData, Sizeof(DData));
                                DObjChangeState.objindex := p;
                                DObjChangeState.state := 0;     // closed
                                DemoStream.Write( DObjChangeState, Sizeof(DObjChangeState));
                        end;

        end
        else begin
                if ddd[p].target = 1 then ddd[p].nowanim := 0 else ddd[p].nowanim := 6;
                ddd[p].target := 1; // ReMoVe ObJeCtS heRe.
                for z := 0 to 1000 do if aaa[z].dead = 0 then begin
                        if ddd[p].orient  = 0 then rzlt := object_region_touch (ddd[p].x,ddd[p].y,ddd[p].x+ddd[p].lenght,ddd[p].y, aaa[z]);
                        if ddd[p].orient  = 1 then rzlt := object_region_touch (ddd[p].x,ddd[p].y,ddd[p].x,ddd[p].y+ddd[p].lenght, aaa[z]);
                        if rzlt = true then begin
                                if aaa[z].objname = 'blood' then aaa[z].dead := 2;
                                if aaa[z].objname = 'gib'  then aaa[z].dead := 2;
                                if aaa[z].objname = 'rocket' then begin
                                        aaa[z].dead := 1;
                                        aaa[z].weapon := 0;
                                        aaa[z].frame := 0;
                                end;
                                if aaa[o].objname = 'grenade' then begin
                                        aaa[z].objname := 'rocket';
                                        aaa[z].dead := 1;
                                        aaa[z].weapon := 0;
                                        aaa[z].frame := 0;
                                end;
                                if MATCH_DRECORD then begin
                                        DData.type0 := 5;    // kill this object in demo
                                        DData.gametic := gametic;
                                        DData.gametime := gametime;
                                        DDXIDKill.x := round(aaa[z].x);
                                        DDXIDKill.y := round(aaa[z].y);
                                        DDXIDKill.DXID := aaa[z].DXID;
                                        DemoStream.Write( DData, Sizeof(DData));
                                        DemoStream.Write( DDXIDKill, Sizeof(DDXIDKill));
                                end;

                                for i := 0 to NUM_OBJECTS do if (ddd[i].active = true) and (ddd[p].targetname=ddd[i].target) and (ddd[i].objtype=9) then
                                        ddd[i].targetname := ddd[p].wait;

                        end;
                end;

                if ddd[p].dir = 0 then
                        if OPT_DOORSOUNDS then playsound(SND_dr1_end,ddd[p].x*32,ddd[p].y*16);

                        // send data to clients.
                        if ismultip=1 then begin
                                MsgSize := SizeOf(TMP_ObjChangeState);
                                        Msg.Data := MMP_OBJCHANGESTATE;
                                        Msg.objindex := p;
                                        Msg.state := 1;
                                        mainform.BNETSendData2All (Msg, MsgSize, 1);
                        end;

                        if MATCH_DRECORD then begin
                                // change obj state!
                                ddata.gametic := gametic;
                                ddata.gametime := gametime;
                                ddata.type0 := DDEMO_OBJCHANGESTATE;
                                DemoStream.Write( DData, Sizeof(DData));
                                DObjChangeState.objindex := p;
                                DObjChangeState.state := 1;     // closed
                                DemoStream.Write( DObjChangeState, Sizeof(DObjChangeState));
                        end;
        end;
  end // ENDOF: if ddd[p].orient > 1 then
        else begin // opened doorz;
                if ddd[p].target = 0 then ddd[p].nowanim := 0 else ddd[p].nowanim := 6;
                ddd[p].target := 0;
                if ddd[p].dir = 0 then begin
                        for i := 0 to NUM_OBJECTS do if (ddd[i].active = true) and (ddd[p].targetname=ddd[i].target) and (ddd[i].objtype=9) then
                                ddd[i].targetname := ddd[p].wait;

                        if OPT_DOORSOUNDS then playsound(SND_dr1_strt,ddd[p].x*32,ddd[p].y*16);

                        // send data to clients.
                       if ismultip=1 then begin
                                MsgSize := SizeOf(TMP_ObjChangeState);
                                        Msg.Data := MMP_OBJCHANGESTATE;
                                        Msg.objindex := p;
                                        Msg.state := 0;
                                        mainform.BNETSendData2All (Msg, MsgSize, 1);
                        end;

                        if MATCH_DRECORD then begin
                                // change obj state!
                                ddata.gametic := gametic;
                                ddata.gametime := gametime;
                                ddata.type0 := DDEMO_OBJCHANGESTATE;
                                DemoStream.Write( DData, Sizeof(DData));
                                DObjChangeState.objindex := p;
                                DObjChangeState.state := 0;     // closed
                                DemoStream.Write( DObjChangeState, Sizeof(DObjChangeState));
                        end;
                end;

        end;

        ddd[p].dir := ddd[p].wait;
end;

// thiz procedure calls "Eat My Shit"
procedure MAPOBJ_think(i : word);
var
    a,xx,yy,p,xxx,yyy : byte;
    o,z : word;
    rzlt : boolean;
    str,str2 : string[255];
    alpha : cardinal;
    Msg: TMP_ObjChangeState;
    Msg2: TMP_cl_ObjDestroy;
    Msg3: TMP_TeleportPlayer;
    Msg4: TMP_TrixArenaWin;
    MsgSize: word;
begin
//      if MATCH_GAMEEND Then exit;
//      exit;
        rzlt := false;
        // ---------------------------------------
//              addmessage('drawing '+inttostr(ddd[i].objtype));
                if ddd[i].objtype = 1 then begin        // teleporter
//              addmessage('draw teleport #'+inttostr(i));
                        if inscreen(ddd[i].x*32,ddd[i].y*16,48) then

                        mainform.PowerGraph.RenderEffect(mainform.Images[30], ddd[i].x*32-16+GX, ddd[i].y*16-30+GY,0, effectSrcAlpha);
                        if ddd[i].wait < 15 then inc(ddd[i].wait) else ddd[i].wait := 0;
                        if inscreen(ddd[i].x*32,ddd[i].y*16,48) then
                        mainform.PowerGraph.RenderEffectCol(mainform.Images[31], ddd[i].x*32+6+GX, ddd[i].y*16-25+GY,$AAFFFFFF,ddd[i].wait div 4, effectSrcAlpha);
                        if MATCH_DDEMOPLAY then exit;

                        for a := 0 to 7 do if players[a] <> nil then if (players[a].dead = 0) and (players[a].health > 0) and ((players[a].netobject=false)) then begin
                                xx := trunc(players[a].x) div 32;
                                yy := trunc(players[a].y+13) div 16;
                                if (xx = ddd[i].x) and (yy = ddd[i].y) then begin
                                        players[a].x := ddd[i].lenght  * 32 +16;
                                        players[a].y := ddd[i].dir * 16 - 8;
                                        if players[a].inertiax > 1 then players[a].inertiax := players[a].inertiax / 2;
                                        RespawnFlash(xx*32,yy*16);
                                        RespawnFlash(ddd[i].lenght * 32,ddd[i].dir * 16);

                                        if ismultip>0 then begin
                                               MsgSize := SizeOf(TMP_TeleportPlayer);
                                               Msg3.Data := MMP_TELEPORTPLAYER;
                                               Msg3.x1 := xx*32;
                                               Msg3.y1 := yy*16;
                                               Msg3.x2 := ddd[i].lenght * 32;
                                               Msg3.y2 := ddd[i].dir * 16;
                                               if ismultip=1 then
                                               mainform.BNETSendData2All (Msg3, MsgSize, 0) else
                                               mainform.BNETSendData2HOST (Msg3, MsgSize, 0);
                                        end;
                                     end;
                        end;
                end;
                // ---------------------------------------
                if ddd[i].objtype = 2 then begin        // BUTTON

                //        if gametic<=5 then exit;

                        if ddd[i].targetname = 0 then if ddd[i].nowanim > 0 then dec(ddd[i].nowanim,15);
                        if ddd[i].targetname = 1 then if ddd[i].nowanim < $ff then inc(ddd[i].nowanim,15);

                        alpha := ddd[i].nowanim;
                        if inscreen(ddd[i].x*32,ddd[i].y*16,48) then begin
                                          mainform.PowerGraph.RenderEffectCol(mainform.Images[34], ddd[i].x*32+4+GX, ddd[i].y*16-4+GY,(($FF-Alpha ) shl 24) + $FFFFFF,6, effectSrcAlpha or EffectDiffuseAlpha);
                                          mainform.PowerGraph.RenderEffectCol(mainform.Images[34], ddd[i].x*32+4+GX, ddd[i].y*16-4+GY,(Alpha shl 24) + $FFFFFF,7+ddd[i].orient, effectSrcAlpha or EffectDiffuseAlpha);
                        end;
                        if MATCH_DDEMOPLAY THEN EXIT;
                        if ismultip=2 then exit;

                        if ddd[i].targetname > 0 then begin
                                if ddd[i].lenght > 0 then dec(ddd[i].lenght) else begin
                                        ddd[i].targetname := 0;

                                        // send button off data to clients.
                                        if ismultip=1 then begin
                                                MsgSize := SizeOf(TMP_ObjChangeState);
                                                Msg.Data := MMP_OBJCHANGESTATE;
                                                Msg.objindex := i;
                                                Msg.state := 0;
                                                mainform.BNETSendData2All (Msg, MsgSize, 1);
                                        end;


                                        if MATCH_DRECORD then begin
                                                // change obj state!
                                                ddata.gametic := gametic;
                                                ddata.gametime := gametime;
                                                ddata.type0 := DDEMO_OBJCHANGESTATE;
                                                DemoStream.Write( DData, Sizeof(DData));
                                                DObjChangeState.objindex := i;
                                                DObjChangeState.state := 0;     // dizactive
                                                DemoStream.Write( DObjChangeState, Sizeof(DObjChangeState));
                                        end;
                                end;
                        end else
                        for z := 0 to 7 do if players[z] <> nil then if players[z].dead = 0 then begin
                                xx := trunc(players[z].x) div 32;
                                for o := 0 to 2 do begin
                                case o of
                                        0 : yy := trunc(players[z].y+23) div 16;
                                        1 : yy := trunc(players[z].y-23) div 16;
                                        2 : yy := trunc(players[z].y) div 16;
                                end;
                                if (xx = ddd[i].x) and (yy = ddd[i].y) then begin
                                        ddd[i].targetname := 1;         //0\1=normal\activated
                                        ddd[i].lenght := ddd[i].wait;   // time of gametic to wait.

                                        // send button on data to clients.
                                        if ismultip=1 then begin
                                                MsgSize := SizeOf(TMP_ObjChangeState);
                                                Msg.Data := MMP_OBJCHANGESTATE;
                                                Msg.objindex := i;
                                                Msg.state := 1;
                                                mainform.BNETSendData2All (Msg, MsgSize, 1);
                                        end;

                                        if MATCH_DRECORD then begin
                                                // change obj state!
                                                ddata.gametic := gametic;
                                                ddata.gametime := gametime;
                                                ddata.type0 := DDEMO_OBJCHANGESTATE;
                                                DemoStream.Write( DData, Sizeof(DData));
                                                DObjChangeState.objindex := i;
                                                DObjChangeState.state := 1;     // active
                                                DemoStream.Write( DObjChangeState, Sizeof(DObjChangeState));
                                        end;
                                        playsound(SND_button,ddd[i].x*32,ddd[i].y*16);
                                        //ddd[i].nowanim := 0;
                                        for p := 0 to NUM_OBJECTS do
                                        if (ddd[p].active = true) and (ddd[p].targetname = ddd[i].target) and ((ddd[p].objtype = 3) or (ddd[p].objtype = 6)) then ACTIVATEOBJ(p);
                                end;
                                end;
                        end;
                end;
                // ---------------------------------------
                if (MATCH_DDEMOPLAY) or (ismultip=2) then // NOT REAL DOOOOORRRRRRR
                if ddd[i].objtype = 3 then begin        // simple ! door (!)
                        if ddd[i].nowanim > 0 then dec(ddd[i].nowanim) else ddd[i].nowanim := 0;    // animate door
                        // !DOOR ANIMATION!
                        if (ddd[i].orient = 1) or (ddd[i].orient = 3) then begin //vertical anim
                                if ddd[i].target = 1 then a := ddd[i].nowanim;
                                if ddd[i].target = 0 then a := 6-ddd[i].nowanim;
                                if ddd[i].nowanim = 0 then if ddd[i].target = 0 then a := 11 else a:= 0;
                        end else
                        if (ddd[i].orient = 0) or (ddd[i].orient = 2) then begin //horz anim
                                if ddd[i].target = 1 then a := 6+ddd[i].nowanim;
                                if ddd[i].target = 0 then a := 12-ddd[i].nowanim;
                                if ddd[i].nowanim = 0 then if ddd[i].target = 0 then a := 11 else a:= 6;
                        end;
                        // end DOOR ANIM.

                        for o := 0 to ddd[i].lenght-1 do begin
                                if (ddd[i].orient = 0) or (ddd[i].orient = 2) then begin// horizon closed door
                                        xxx := o;
                                        yyy := 0;
                                        end;
                                if (ddd[i].orient = 1) or (ddd[i].orient = 3) then begin// vert closed door
                                        xxx := 0;
                                        yyy := o;
                                        end;
                                if inscreen(ddd[i].x*32+xxx*32,ddd[i].y*16+yyy*16,32) then
                                mainform.PowerGraph.RenderEffect(mainform.Images[21], ddd[i].x*32+xxx*32+GX, ddd[i].y*16+yyy*16+GY,73+a, effectSrcAlpha);
                                if ddd[i].target = 1 then bbb[ddd[i].x+xxx, ddd[i].y+yyy].block := true;
                                if ddd[i].target = 0 then if bbb[ddd[i].x+xxx, ddd[i].y+yyy].image < 54 then bbb[ddd[i].x+xxx, ddd[i].y+yyy].block := false;
                        end;
                end;
                // ---------------------------------------
                if (MATCH_DDEMOPLAY=false) and (ismultip<2) then
                if ddd[i].objtype = 3 then begin        // door (!)
                        if ddd[i].dir > 0 then dec(ddd[i].dir) else ddd[i].dir := 0;    // wait in toggled status
//                        addmessage(inttostr(ddd[i].dir));

                if ddd[i].nowanim > 0 then dec(ddd[i].nowanim) else ddd[i].nowanim := 0;    // animate door

                // !DOOR ANIMATION!
                if (ddd[i].orient = 1) or (ddd[i].orient = 3) then begin //vertical anim
                        if ddd[i].target = 1 then a := ddd[i].nowanim;
                        if ddd[i].target = 0 then a := 6-ddd[i].nowanim;
                        if ddd[i].nowanim = 0 then if ddd[i].target = 0 then a := 11 else a:= 0;
                end else
                if (ddd[i].orient = 0) or (ddd[i].orient = 2) then begin //horz_anim
                        if ddd[i].target = 1 then a := 6+ddd[i].nowanim;
                        if ddd[i].target = 0 then a := 12-ddd[i].nowanim;
                        if ddd[i].nowanim = 0 then if ddd[i].target = 0 then a := 11 else a:= 6;
                end;
                // end DOOR ANIM.

                        if (ddd[i].orient = 0) or (ddd[i].orient = 1) then
                        if (ddd[i].dir = 1) and (ddd[i].target = 0) then begin // so, CLOSE!
                                rzlt := false;
                                for o := 0 to 7 do begin
                                        if ddd[i].orient  = 0 then rzlt := player_region_touch (ddd[i].x,ddd[i].y,ddd[i].x+ddd[i].lenght,ddd[i].y, players[o]);
                                        if ddd[i].orient  = 1 then rzlt := player_region_touch (ddd[i].x,ddd[i].y,ddd[i].x,ddd[i].y+ddd[i].lenght, players[o]);
                                        if rzlt = true then break;
                                        end;
                                if rzlt = true then begin


                                        // shut up doortriggerz
                                        for o := 0 to NUM_OBJECTS do if (ddd[o].active = true) and (ddd[i].targetname=ddd[o].target) and (ddd[o].objtype=9) then
                                                begin
                                                    ddd[o].targetname := ddd[i].wait;
//                                                    addmessage('doortrigger time give|'+inttostr(ddd[i].targetname));
                                                 end;

                                        ddd[i].target := 0;
                                        if (ddd[i].special = 1) then
                                        ddd[i].dir := 6 else ddd[i].dir := ddd[i].wait;
                                end else begin
                                        ddd[i].target := 1; // ReMoVe ObJeCtS heRe.
                                        for o := 0 to 1000 do if aaa[o].dead = 0 then begin
                                                if ddd[i].orient  = 0 then rzlt := object_region_touch(ddd[i].x,ddd[i].y-1,ddd[i].x+ddd[i].lenght+1,ddd[i].y, aaa[o]);
                                                if ddd[i].orient  = 1 then rzlt := object_region_touch(ddd[i].x,ddd[i].y-1,ddd[i].x,ddd[i].y+ddd[i].lenght+1, aaa[o]);
                                                if rzlt = true then begin
                                                        if aaa[o].objname = 'corpse' then aaa[o].dead := 2;
                                                end;
                                        end;


                                        for o := 0 to 1000 do if aaa[o].dead = 0 then begin
                                                if ddd[i].orient  = 0 then rzlt := object_region_touch(ddd[i].x,ddd[i].y,ddd[i].x+ddd[i].lenght,ddd[i].y, aaa[o]);
                                                if ddd[i].orient  = 1 then rzlt := object_region_touch(ddd[i].x,ddd[i].y,ddd[i].x,ddd[i].y+ddd[i].lenght, aaa[o]);
                                                if rzlt = true then begin
                                                        if aaa[o].objname = 'corpse' then aaa[o].dead := 2;
                                                        if aaa[o].objname = 'blood' then aaa[o].dead := 2;
                                                        if aaa[o].objname = 'plasma' then aaa[o].dead := 2;
                                                        if aaa[o].objname = 'gib'  then aaa[o].dead := 2;
                                                        if aaa[o].objname = 'rocket' then begin
                                                                aaa[o].dead := 1;
                                                                aaa[o].weapon := 0;
                                                                aaa[o].frame := 0;
                                                        end;
                                                        if aaa[o].objname = 'grenade' then begin
                                                                aaa[o].objname := 'rocket';
                                                                aaa[o].dead := 1;
                                                                aaa[o].weapon := 0;
                                                                aaa[o].frame := 0;
                                                        end;

                        // send explosion to client;
//                        if aaa[o].dead = 0 then
                        if (aaa[o].objname = 'weapon') or (aaa[o].objname = 'flag') then
                                aaa[o].health := 0; // weapon will kill himself 
                        if (aaa[o].objname = 'grenade') or (aaa[o].objname = 'rocket') or (aaa[o].objname = 'plasma') then
                        if ismultip=1 then begin
                                MsgSize := SizeOf(TMP_cl_ObjDestroy);
                                    Msg2.Data := MMP_CL_OBJDESTROY;
                                    Msg2.killDXID := aaa[o].DXID;
//                                  addmessage('sending killing packet: '+inttostr(aaa[o].DXID));
                                    MSG2.index := 0;
                                    Msg2.x := round(aaa[o].x);
                                    Msg2.y := round(aaa[o].y);
                                    mainform.BNETSendData2All (Msg2, MsgSize, 1);
                        end;
                        // & send explosion to client;


                                                if aaa[o].dxid > 0 then
//                                                if (aaa[o].objname = 'grenade') or (aaa[o].objname = 'rocket') or (aaa[o].objname = 'plasma') then
                                                if MATCH_DRECORD then begin
                                                        DData.type0 := 5;    // kill this object in demo
                                                        DData.gametic := gametic;
                                                        DData.gametime := gametime;
                                                        DDXIDKill.x := round(aaa[o].x);
                                                        DDXIDKill.y := round(aaa[o].y);
                                                        DDXIDKill.DXID := aaa[o].DXID;
                                                        DemoStream.Write( DData, Sizeof(DData));
                                                        DemoStream.Write( DDXIDKill, Sizeof(DDXIDKill));
                                                end;


                                                end;
                                        end;


                                        // send door data to clients.
                                        if ismultip=1 then begin
                                                MsgSize := SizeOf(TMP_ObjChangeState);
                                                Msg.Data := MMP_OBJCHANGESTATE;
                                                Msg.objindex := i;
                                                Msg.state := 1;
                                                mainform.BNETSendData2All (Msg, MsgSize, 1);
                                        end;


                                        if MATCH_DRECORD then begin
                                                // change obj state!
                                                ddata.gametic := gametic;
                                                ddata.gametime := gametime;
                                                ddata.type0 := DDEMO_OBJCHANGESTATE;
                                                DemoStream.Write( DData, Sizeof(DData));
                                                DObjChangeState.objindex := i;
                                                DObjChangeState.state := 1;     // closed
                                                DemoStream.Write( DObjChangeState, Sizeof(DObjChangeState));
                                        end;

                                        if OPT_DOORSOUNDS then playsound(SND_dr1_end,ddd[i].x*32,ddd[i].y*16);
                                        ddd[i].nowanim := 6;
                                end;
                        end;
                        if (ddd[i].orient = 2) or (ddd[i].orient = 3) then
                        if (ddd[i].dir = 1) and (ddd[i].target = 1) then begin // so, OPEN!
                                ddd[i].target := 0;
                                if OPT_DOORSOUNDS then playsound(SND_dr1_strt,ddd[i].x*32,ddd[i].y*16);
                                        // send door data to clients.
                                        if ismultip=1 then begin
                                                MsgSize := SizeOf(TMP_ObjChangeState);
                                                Msg.Data := MMP_OBJCHANGESTATE;
                                                Msg.objindex := i;
                                                Msg.state := 0;
                                                mainform.BNETSendData2All (Msg, MsgSize, 1);
                                        end;

                                        if MATCH_DRECORD then begin
                                                // change obj state!
                                                ddata.gametic := gametic;
                                                ddata.gametime := gametime;
                                                ddata.type0 := DDEMO_OBJCHANGESTATE;
                                                DemoStream.Write( DData, Sizeof(DData));
                                                DObjChangeState.objindex := i;
                                                DObjChangeState.state := 0;     // open
                                                DemoStream.Write( DObjChangeState, Sizeof(DObjChangeState));
                                        end;
                                ddd[i].nowanim := 6;
                                end;
                        for o := 0 to ddd[i].lenght-1 do begin
                                if (ddd[i].orient = 0) or (ddd[i].orient = 2) then begin// horizon closed door
                                        xxx := o;
                                        yyy := 0;
                                        end;
                                if (ddd[i].orient = 1) or (ddd[i].orient = 3) then begin// vert closed door
                                        xxx := 0;
                                        yyy := o;
                                        end;
                                if inscreen(ddd[i].x*32+xxx*32,ddd[i].y*16+yyy*16,32) then

                                mainform.PowerGraph.RenderEffect(mainform.Images[21], ddd[i].x*32+xxx*32+GX, ddd[i].y*16+yyy*16+GY,73+a, effectSrcAlpha);

                                if ddd[i].target = 1 then bbb[ddd[i].x+xxx, ddd[i].y+yyy].block := true;
                                if ddd[i].target = 0 then if bbb[ddd[i].x+xxx, ddd[i].y+yyy].image < 54 then bbb[ddd[i].x+xxx, ddd[i].y+yyy].block := false;
                        end;
                end;
                // ---------------------------------------
                if ddd[i].objtype = 4 then begin        // trigger
                        if MATCH_DDEMOPLAY then exit;
                        if ismultip=2 then exit;
    //                    if gametic<=5 then exit;
                        if ddd[i].targetname > 0 then dec(ddd[i].targetname);
                        if ddd[i].targetname > 0 then exit;
                        ddd[i].targetname := ddd[i].wait;
                        for o := 0 to 7 do begin
                                if players[o] <> nil then if players[o].dead = 0 then
                                        rzlt := player_region_touch (ddd[i].x,ddd[i].y,ddd[i].x+ddd[i].lenght-1,ddd[i].y+ddd[i].dir-1, players[o]);
                                if rzlt = true then break;
                                end;
                        if rzlt = true then begin
                                //shit
                                for p := 0 to NUM_OBJECTS do
                                        if (ddd[p].active = true) and (ddd[p].targetname = ddd[i].target) and ((ddd[p].objtype = 3) or (ddd[p].objtype = 6)) then ACTIVATEOBJ(p);
                        end;
                end;
                // ---------------------------------------
                if ddd[i].objtype = 5 then begin        // area_push
                        if ddd[i].targetname > 0 then dec(ddd[i].targetname);
                        if ddd[i].targetname > 0 then exit;
  //                      if gametic<=5 then exit;
                        ddd[i].targetname := ddd[i].wait;
                        if not MATCH_DDEMOPLAY then
                        for o := 0 to 7 do begin
                                if players[o] <> nil then if (players[o].dead = 0) then begin
                                rzlt := player_region_touch (ddd[i].x,ddd[i].y,ddd[i].x+ddd[i].lenght-1,ddd[i].y+ddd[i].dir-1, players[o]);
                                if rzlt = true then begin
                                        if (players[o].netobject=false) then begin
                                                if ddd[i].orient = 0 then players[o].InertiaX := -ddd[i].special/10;
                                                if ddd[i].orient = 1 then players[o].InertiaY := -ddd[i].special/10;
                                                if ddd[i].orient = 2 then players[o].InertiaX := ddd[i].special/10;
                                                if ddd[i].orient = 3 then players[o].InertiaY := ddd[i].special/10;
                                        end;

                                        if (rzlt = true) and (ismultip<=1) then begin
                                                // if have target. fire it.
                                                if ddd[i].target > 0 then for p := 0 to NUM_OBJECTS do
                                                if (ddd[p].active = true) and (ddd[p].targetname = ddd[i].target) and ((ddd[p].objtype = 3)  or (ddd[p].objtype = 6)) then ACTIVATEOBJ(p);
                                                end;
                                end;
                                end;
                        end;

                        for o := 0 to 1000 do if (aaa[o].objname = 'gib')then
                                if object_region_touch (ddd[i].x,ddd[i].y,ddd[i].x+ddd[i].lenght-1,ddd[i].y+ddd[i].dir-1, aaa[o]) then
                                begin
                                        if ddd[i].orient = 0 then aaa[o].InertiaX := -ddd[i].special/10;
                                        if ddd[i].orient = 1 then aaa[o].InertiaY := -ddd[i].special/10;
                                        if ddd[i].orient = 2 then aaa[o].InertiaX := ddd[i].special/10;
                                        if ddd[i].orient = 3 then aaa[o].InertiaY := ddd[i].special/10;
                                end;
                end;
                // ---------------------------------------
                if ddd[i].objtype = 6 then begin        // area_pain
                if MATCH_DDEMOPLAY then exit;
//                if gametic<=5 then exit;
                if ismultip=2 then exit;

                    //------------
                    if ddd[i].targetname = 0 then begin // JUST INSTANT PAIN!
                        if ddd[i].target > 0 then dec(ddd[i].target);
                        if ddd[i].target > 0 then exit;
                        ddd[i].target := ddd[i].nowanim;
                        for o := 0 to 7 do begin
                                if players[o] <> nil then if players[o].dead = 0 then begin
                                rzlt := player_region_touch (ddd[i].x,ddd[i].y,ddd[i].x+ddd[i].special-1,ddd[i].y+ddd[i].orient-1, players[o]);
                                if rzlt = true then if players[o].health > 0 then begin
                                        ApplyDamage(players[o],ddd[i].dir ,aaa[0],DIE_INPAIN);
                                        SpawnBlood(players[o]);
                                        end;
                                end;
                                end;
                    end;
                    //------------
                    if ddd[i].targetname > 0 then begin
                        if ddd[i].lenght > 0 then begin // waittime.
                        if ddd[i].target > 0 then begin // active. burn em burn em burn em.
                                dec(ddd[i].target);
                                if ddd[i].target=0 then begin   // active wait time finished, so, do something,,,
                                        ddd[i].target := ddd[i].nowanim;   // ddd[i].wait itsa DMG INTERVAL.

                                        for o := 0 to 7 do begin
                                                rzlt := player_region_touch (ddd[i].x,ddd[i].y,ddd[i].x+ddd[i].special-1,ddd[i].y+ddd[i].orient-1, players[o]);
                                                if rzlt = true then if players[o].health > 0 then begin
                                                        ApplyDamage(players[o],ddd[i].dir ,aaa[0],DIE_INPAIN);
                                                        SpawnBlood(players[o]);
                                                        end;
                                                end;
                                end;
                        end;
                        dec(ddd[i].lenght);
                        end;
                    end;
                    //------------
                end;
                // ---------------------------------------
                if ddd[i].objtype = 7 then begin        // area_trickarena_end;
                        if MATCH_GAMETYPE <> GAMETYPE_TRIXARENA then exit;
                        if ismultip > 1 then exit;
                        if MATCH_DDEMOPLAY then exit;
                        if MATCH_GAMEEND = true then exit;
                        for o := 0 to 7 do begin
                                if players[o] <> nil then if players[o].dead = 0 then
                                        rzlt := player_region_touch (ddd[i].x,ddd[i].y,ddd[i].x+ddd[i].special-1,ddd[i].y+ddd[i].orient-1, players[o]);
                                if rzlt = true then if players[o].health > 0 then begin
                                        str := '';
                                        if trunc(gametime / 60) < 10 then str := '0';
                                        str := str + inttostr(trunc(gametime/60))+':';
                                        if gametime - trunc(gametime / 60)*60 < 10 then str := str + '0';
                                        str := str + inttostr(gametime - trunc(gametime / 60)*60);
                                        if MATCH_STARTSIN = 0 then begin
                                                addmessage(players[o].netname + ' ^7^nfinished the level. Time: '+str+'.'+inttostr(gametic));

                                        if ismultip=1 then begin
                                                MsgSize := SizeOf(TMP_TrixArenaWin);
                                                Msg4.Data := MMP_MULTITRIX_WIN;
                                                Msg4.DXID := players[o].DXID;
                                                Msg4.gametic := gametic;
                                                Msg4.gametime := gametime;
                                                mainform.BNETSendData2All (Msg4, MsgSize, 1);
                                        end;

                                        IF MATCH_DRECORD then begin
                                                ddata.gametic := gametic;
                                                ddata.gametime := gametime;
                                                ddata.type0 := DDEMO_TRIXARENAEND;
                                                DemoStream.Write( DData, Sizeof(DData));
                                                DTrixArenaEnd.DXID := players[o].dxid;
                                                DemoStream.Write( DTrixArenaEnd, Sizeof(DTrixArenaEnd));
                                        end;
                                        GameEnd(END_JUSTEND);

                                        if (OPT_TRIXMASTA) then begin
                                                if fileexists(ROOTDIR+'\demos\temp.ndm') then begin
                                                        str2 := 'myrecords_'+map_filename+'_'+toValidFilename(str)+'_'+inttostr(gametic)+'s_';
                                                        for i := 0 to 7 do begin if players[i] <> nil then
                                                                str2:= str2+toValidFilename(StripColorName(players[i].netname))+'.ndm';
                                                                break;
                                                        end;
                                                        Renamefile(ROOTDIR+'\demos\temp.ndm',ROOTDIR+'\demos\'+lowercase(str2));
                                                        addmessage('demo saved as "'+lowercase(str2)+'"');
                                                end;
                                        end;

                                        end else begin
                                                addmessage('Trix arena doesnt works in warmup.');
                                                ApplyDamage(players[o],10,aaa[0],DIE_WRONGPLACE);
                                                end;
                                        break;
                                end;
                        end;
                end;
                // ---------------------------------------
                if ddd[i].objtype =  8 then begin        // area_teleport;
                        if MATCH_DDEMOPLAY then exit;
//                        if gametime<=1 then exit;
                        if MATCH_GAMEEND = true then exit;
                        for o := 0 to 7 do begin
                                rzlt := player_region_touch (ddd[i].x,ddd[i].y,ddd[i].x+ddd[i].special-1,ddd[i].y+ddd[i].orient-1, players[o]);
                                if rzlt = true then if (players[o].dead = 0) and (players[o].health > 0) and (players[o].netobject=false) then begin
                                        RespawnFlash(players[o].x-16, players[o].y);
                                        players[o].x := ddd[i].dir  * 32 +16;
                                        players[o].y := ddd[i].wait * 16 - 8;
                                        if players[o].inertiax > 1 then players[o].inertiax := players[o].inertiax / 2;
                                        RespawnFlash(ddd[i].dir * 32,ddd[i].wait * 16);

                                        MsgSize := SizeOf(TMP_TeleportPlayer);
                                        Msg3.Data := MMP_TELEPORTPLAYER;
                                        Msg3.x1 := round(players[o].x-16);
                                        Msg3.y1 := round(players[o].y);
                                        Msg3.x2 := ddd[i].dir * 32;
                                        Msg3.y2 := ddd[i].wait * 16;
                                        mainform.BNETSendData2All (Msg3, MsgSize, 0);

                                end;
                        end;
                end;
                // ---------------------------------------
                if ddd[i].objtype =  9 then begin        // doortrigger;
                        // nothing to do... so, we just sit here, and make our selves looks DUDE
                        if ddd[i].targetname > 0 then dec(ddd[i].targetname);
                end;

end;

procedure FlashStatusBar(pl : byte);
begin
if pl = 1 then begin
if DRAW_BARFLASH = FALSE then begin p1flashbar := 0; exit; end;
if p1flashbar >= 1 then inc(p1flashbar);
if p1flashbar > 15 then p1flashbar := 0;
end ELSE
if pl = 2 then begin
if DRAW_BARFLASH = FALSE then begin p2flashbar := 0; exit; end;
if p2flashbar >= 1 then inc(p2flashbar);
if p2flashbar > 15 then p2flashbar := 0;
end;
end;

procedure resetmap;
var i,a : integer;
begin


//        addmessage('^5map reset');
        if (MATCH_GAMETYPE = GAMETYPE_RAILARENA) or (MATCH_GAMETYPE = GAMETYPE_PRACTICE) then begin
                for i := 0 to BRICK_X-1 do      // remove itemz.
                for a := 0 to BRICK_Y-1 do begin
                        if bbb[i,a].image > 0 then
                                if bbb[i,a].respawnable = TRUE then begin
                                        bbb[i,a].respawntime := 0;
                                        bbb[i,a].respawnable := false;
                                        bbb[i,a].scale := 255;
                                end;
                end;
        end else begin

                for i := 0 to BRICK_X-1 do      // brickz
                for a := 0 to BRICK_Y-1 do begin
                        if bbb[i,a].image > 0 then if bbb[i,a].respawntime > 0 then bbb[i,a].respawntime := 0;

                        if (bbb[i,a].image >= 40) and (bbb[i,a].image <= 42) then // reset ctf, dom.
                                bbb[i,a].dir := 0;

                        if MATCH_GAMETYPE <> GAMETYPE_TRIXARENA then
                        if (bbb[i,a].image >= 23) and (bbb[i,a].image <= 28) then
                                bbb[i,a].respawntime := 1500 + random(150)*10;

                end;
        end;

        // domination
        if MATCH_GAMETYPE = GAMETYPE_DOMINATION then DOM_Reset();

        for i := 0 to 1000 do aaa[i].dead := 2; // clear objects

        // reset special objects
        for i := 0 to NUM_OBJECTS do if ddd[i].active = true then begin
                        if ddd[i].objtype = 2 then begin
                                ddd[i].targetname := 0;
                                ddd[i].lenght := 0;
                        end;
                        if ddd[i].objtype = 3 then begin
                                if (ddd[i].orient = 1) or (ddd[i].orient = 0) then ddd[i].target := 1 else ddd[i].target := 0;
                                ddd[i].nowanim := 0;
                                ddd[i].dir := 0;
                        end;
                        if ddd[i].objtype = 4 then ddd[i].targetname := 0;
        end;

        if ismultip=1 then SV_Remember_Score_Clear;
end;

procedure HUD_ShowStats;
var
 stx,sty : word;
 stp,sti : byte;

begin
with mainform do begin
// ------------------------
        stx := 420;
        sty := 120;


        if (SYS_P1STATSX > 400) or (SYS_P2STATSX < 240) then exit;

        for sti := 0 to 1 do begin

                if sti = 0 then begin
                stx := mainform.powergraph.width - 220;
                stp := OPT_1BARTRAX;
                end else begin
                        stx := 20;
                        stp := OPT_2BARTRAX;
                        if not SYS_BAR2AVAILABLE then break;
                end;

        if players[stp] <> nil then begin
                Font2.TextOut('Stats for ',stx,sty, clWhite);
                ParseColorText(players[stp].netname,stx+60,sty,5);
                Font2.TextOut('kills   deaths   suicides    frags',stx,sty+20,clWhite);
                Font2.TextOut(inttostr(players[stp].stats.stat_kills),stx+5,sty+35,clAqua);
                Font2.TextOut(inttostr(players[stp].stats.stat_deaths ),stx+50,sty+35,clAqua);
                Font2.TextOut(inttostr(players[stp].stats.stat_suicide ), stx+110,sty+35,clAqua);
                Font2.TextOut(inttostr(players[stp].frags), stx+170,sty+35, clAqua);
                Font2.TextOut('Accuracy info:',stx,sty+55,clwhite);

                if (players[stp].stats.stat_impressives > 0) or
                (players[stp].stats.stat_excellents > 0) or
                (players[stp].stats.stat_humiliations > 0) then
                Font2.TextOut('Rewards:',stx,sty+250,clwhite);


                if players[stp].stats.gaun_hits > 0 then Font2.TextOut('Gauntlet:',stx,sty+75,clYellow);
                if mapweapondata.machine = true then Font2.TextOut('Machine:',stx,sty+90,clYellow);
                if mapweapondata.shotgun = true then Font2.TextOut('Shotgun:',stx,sty+105,clYellow);
                if mapweapondata.grenade = true then Font2.TextOut('Grenade:',stx,sty+120,clYellow);
                if mapweapondata.rocket  = true then Font2.TextOut('Rocket:',stx,sty+135,clYellow);
                if mapweapondata.shaft = true then Font2.TextOut('Shaft:',stx,sty+150,clYellow);
                if mapweapondata.rail = true then Font2.TextOut('Rail:',stx,sty+165,clYellow);
                if mapweapondata.plasma = true then Font2.TextOut('Plazma:',stx,sty+180,clYellow);
                if mapweapondata.bfg = true then Font2.TextOut('BFG:',stx,sty+195,clYellow);
                if players[stp].stats.gaun_hits > 0 then Font2.TextOut(inttostr(players[stp].stats.gaun_hits),stx+80,sty+75,clwhite);

                if mapweapondata.machine = true then begin
                Font2.TextOut(inttostr(players[stp].stats.mach_hits)+'/'+inttostr(players[stp].stats.mach_fire),stx+80,sty+90, clwhite);
                if players[stp].stats.mach_fire > 0 then Font2.TextOut(inttostr(round((players[stp].stats.mach_hits * 100) / players[stp].stats.mach_fire))+'%',stx+160,sty+90,claqua)
                else Font2.TextOut('0%',stx+160,sty+90,claqua);
                end;

                if mapweapondata.shotgun = true then begin
                Font2.TextOut(inttostr(players[stp].stats.shot_hits)+'/'+inttostr(players[stp].stats.shot_fire),stx+80,sty+105,clwhite);
                if players[stp].stats.shot_fire > 0 then Font2.TextOut(inttostr(round((players[stp].stats.shot_hits * 100) / players[stp].stats.shot_fire))+'%',stx+160,sty+105,claqua)
                else Font2.TextOut('0%',stx+160,sty+105,claqua);
                end;

                if mapweapondata.grenade = true then begin
                Font2.TextOut( inttostr(players[stp].stats.gren_hits )+'/'+inttostr(players[stp].stats.gren_fire ),stx+80,sty+120,clwhite);
                if players[stp].stats.gren_fire > 0 then Font2.TextOut(inttostr(round((players[stp].stats.gren_hits * 100) / players[stp].stats.gren_fire ))+'%',stx+160,sty+120,claqua)
                else Font2.TextOut('0%',stx+160,sty+120,claqua);
                end;

                if mapweapondata.rocket = true then begin
                Font2.TextOut(inttostr(players[stp].stats.rocket_hits )+'/'+inttostr(players[stp].stats.rocket_fire ),stx+80,sty+135, clwhite);
                if players[stp].stats.rocket_fire > 0 then Font2.TextOut(inttostr(round((players[stp].stats.rocket_hits * 100) / players[stp].stats.rocket_fire ))+'%',stx+160,sty+135, claqua)
                else Font2.TextOut('0%',stx+160,sty+135, claqua);
                end;

                if mapweapondata.shaft = true then begin
                Font2.TextOut(inttostr(players[stp].stats.shaft_hits)+'/'+inttostr(players[stp].stats.shaft_fire ),stx+80,sty+150,clwhite);
                if players[stp].stats.shaft_fire > 0 then Font2.TextOut(inttostr(round((players[stp].stats.shaft_hits * 100) / players[stp].stats.shaft_fire ))+'%',stx+160,sty+150,claqua)
                else Font2.TextOut('0%',stx+160,sty+150,claqua);
                end;

                if mapweapondata.rail = true then begin
                Font2.TextOut(inttostr(players[stp].stats.rail_hits)+'/'+inttostr(players[stp].stats.rail_fire ),stx+80,sty+165, clwhite);
                if players[stp].stats.rail_fire > 0 then Font2.TextOut(inttostr(round((players[stp].stats.rail_hits * 100) / players[stp].stats.rail_fire ))+'%',stx+160,sty+165, claqua)
                else Font2.TextOut('0%',stx+160,sty+165,claqua);
                end;

                if mapweapondata.plasma = true then begin
                Font2.TextOut(inttostr(players[stp].stats.plasma_hits)+'/'+inttostr(players[stp].stats.plasma_fire ),stx+80,sty+180, clwhite);
                if players[stp].stats.plasma_fire > 0 then Font2.TextOut(inttostr(round((players[stp].stats.plasma_hits * 100) / players[stp].stats.plasma_fire ))+'%',stx+160,sty+180, claqua)
                else Font2.TextOut('0%',stx+160,sty+180,claqua);
                end;

                if mapweapondata.bfg = true then begin
                Font2.TextOut(inttostr(players[stp].stats.bfg_hits)+'/'+inttostr(players[stp].stats.bfg_fire ),stx+80,sty+195,clwhite);
                if players[stp].stats.bfg_fire > 0 then Font2.TextOut(inttostr(round((players[stp].stats.bfg_hits * 100) / players[stp].stats.bfg_fire ))+'%',stx+160,sty+195,claqua)
                else Font2.TextOut('0%',stx+160,sty+195,claqua);
                end;

                Font2.TextOut('dmggiven: ',stx+0,sty+215,cllime);
                Font2.TextOut('dmgrecvd: ',stx+0,sty+230,clred);
                Font2.TextOut(inttostr(players[stp].stats.stat_dmggiven),stx+80,sty+215,claqua);
                Font2.TextOut(inttostr(players[stp].stats.stat_dmgrecvd),stx+80,sty+230,claqua);

                if players[stp].stats.stat_impressives  > 0 then Font2.TextOut(inttostr(players[stp].stats.stat_impressives),stx+30,sty+275, claqua);
                if players[stp].stats.stat_excellents > 0 then Font2.TextOut(inttostr(players[stp].stats.stat_excellents),stx+110,sty+275, claqua);
                if players[stp].stats.stat_humiliations > 0 then Font2.TextOut(inttostr(players[stp].stats.stat_humiliations),stx+190,sty+275, claqua);

         end; //
        end;



        if SYS_BAR2AVAILABLE then
        if OPT_SHOWSTATS then
        if (players[OPT_2BARTRAX] <> nil) then begin
                sty := 120;
                if  players[OPT_2BARTRAX].stats.stat_impressives > 0 then         PowerGraph.RenderEffect(Images[34],20,sty+270,0, effectSrcAlpha or effectDiffuseAlpha);
                if  players[OPT_2BARTRAX].stats.stat_excellents > 0 then          PowerGraph.RenderEffect(Images[34],100,sty+270,1, effectSrcAlpha or effectDiffuseAlpha);
                if  players[OPT_2BARTRAX].stats.stat_humiliations > 0 then        PowerGraph.RenderEffect(Images[34],180,sty+270,2, effectSrcAlpha or effectDiffuseAlpha);
        end;

        if OPT_1BARTRAX < $FF then
        if OPT_SHOWSTATS then
        if (players[OPT_1BARTRAX] <> nil) then begin
                sty := 120;
                if  players[OPT_1BARTRAX].stats.stat_impressives > 0 then PowerGraph.RenderEffect(Images[34],420,sty+270,0, effectSrcAlpha or effectDiffuseAlpha);
                if  players[OPT_1BARTRAX].stats.stat_excellents > 0 then PowerGraph.RenderEffect(Images[34],500,sty+270,1, effectSrcAlpha or effectDiffuseAlpha);
                if  players[OPT_1BARTRAX].stats.stat_humiliations > 0 then PowerGraph.RenderEffect(Images[34],580,sty+270,2, effectSrcAlpha or effectDiffuseAlpha);
        end;



// ------------------------
end;
end;

procedure HUD_DOMBAR;
var i : integer;
    colo,YYB : dword;

    colr,colb,coln:dword;
    rs,bs,ns:word;
begin

if OPT_DOMBARSTYLE = 0 then exit;

YYB := OPT_DOMBARPOS;
if OPT_DOMBARSTYLE=1 then if YYB>300 then YYB := 300;

colr := $BB0303A1;
colb := $EEAB3604;
coln := $bbffffff;

if OPT_DOMBARSTYLE = 2 then begin
        rs :=0;
        bs :=0;
        if dompoint1=C_TEAMRED then inc(rs);
        if dompoint2=C_TEAMRED then inc(rs);
        if dompoint3=C_TEAMRED then inc(rs);
        if dompoint1=C_TEAMBLU then inc(bs);
        if dompoint2=C_TEAMBLU then inc(bs);
        if dompoint3=C_TEAMBLU then inc(bs);
        if (dompoint1=dompoint2) and (dompoint2=dompoint3) and (dompoint3=C_TEAMNON) then rs := 256;
        if rs > bs then colo := colr;
        if rs < bs then colo := colb;
        if rs = 256 then colo := coln;
        MainForm.PowerGraph.RenderEffectCol(MainForm.images[51], 16, 16+ YYB, 256, colo, 3, EffectSrcAlpha or effectDiffusealpha);
        exit;
end;

if OPT_DOMBARSTYLE=3 then begin
colr := $FF0000FF;
colb := $FFFF0000;
coln := $FFffffff;
end;

with MainForm do begin
        for i := 0 to 2 do begin
                case i of
                0 : begin
                        if dompoint1=C_TEAMRED then colo := colr;
                        if dompoint1=C_TEAMBLU then colo := colb;
                        if dompoint1=C_TEAMNON then colo := coln;
                        if OPT_DOMBARSTYLE=1 then if MATCH_STARTSIN>0 then Font2s.textout('alpha', 32 - Font2s.TextWidth('alpha') div 2,20 +i*48 + YYB,clWhite);
                        if OPT_DOMBARSTYLE=3 then Font4.textout('alpha', 32 - Font4.TextWidth('alpha') div 2,20 +i*24 + YYB,colo);
                    end;
                1 : begin
                        if dompoint2=C_TEAMRED then colo := colr;
                        if dompoint2=C_TEAMBLU then colo := colb;
                        if dompoint2=C_TEAMNON then colo := coln;
                        if OPT_DOMBARSTYLE=1 then if MATCH_STARTSIN>0 then Font2s.textout('beta', 32 - Font2s.TextWidth('beta') div 2,20 +i*48 + YYB,clWhite);
                        if OPT_DOMBARSTYLE=3 then Font4.textout('beta', 32 - Font4.TextWidth('beta') div 2,20 +i*24 + YYB,colo);
                    end;
                2 : begin
                        if dompoint3=C_TEAMRED then colo := colr;
                        if dompoint3=C_TEAMBLU then colo := colb;
                        if dompoint3=C_TEAMNON then colo := coln;
                        if OPT_DOMBARSTYLE=1 then if MATCH_STARTSIN >0 then Font2s.textout('gamma', 32 - Font2s.TextWidth('gamma') div 2,20 +i*48 + YYB,clWhite);
                        if OPT_DOMBARSTYLE=3 then Font4.textout('gamma', 32 - Font4.TextWidth('gamma') div 2,20 +i*24 + YYB,colo);
                    end;
                end;

                if OPT_DOMBARSTYLE=1 then PowerGraph.RenderEffectCol(images[51], 16, 32+i*48 + YYB, 256, colo, 3, EffectSrcAlpha or effectDiffusealpha)
        end;
end;
end;

procedure HUD_CTFBAR;
const SIZEX = 32;
      SIZEY = 32;
var x,y:word;
begin
with MainForm do begin
        if OPT_DRAWFRAGBARY > SIZEY then Y := OPT_DRAWFRAGBARY-SIZEY else
        Y := OPT_DRAWFRAGBARY+16;
        PowerGraph.Antialias := true;
        if OPT_DRAWFRAGBARMYFRAG >= OPT_DRAWFRAGBAROTHERFRAG then X := OPT_DRAWFRAGBARX+32 else X := OPT_DRAWFRAGBARX;
        PowerGraph.TextureCol(Images[51],X,Y,X+SIZEX,Y,X+SIZEX,Y+SIZEY,X,Y+SIZEY,$EE0303A1,CTF_BLUEFLAGSTATUS,EffectSrcAlpha or effectdiffusealpha);
        if OPT_DRAWFRAGBARMYFRAG < OPT_DRAWFRAGBAROTHERFRAG then X := OPT_DRAWFRAGBARX+32 else X := OPT_DRAWFRAGBARX;
        PowerGraph.TextureCol(Images[51],X,Y,X+SIZEX,Y,X+SIZEX,Y+SIZEY,X,Y+SIZEY,$EEAB3604,CTF_REDFLAGSTATUS,EffectSrcAlpha or effectdiffusealpha);
        PowerGraph.Antialias := false;
end;
end;

function HUD_TeamBar:integer;
type ppposs = record
        x,y : Smallint;
        end;

var i, myteam,maxtextwidth, plcount, locs,FONTINDEX : byte;
    y,x,xadd,yadd,barwidth,barheight,ammmo : word;
    s : string;

    pos1 : array [1..6] of ppposs;
    pos2 : array [1..6] of ppposs;
    pos3 : array [1..6] of ppposs;
    pos4 : array [1..6] of ppposs;
    pos5 : array [1..6] of ppposs;
    pos6 : array [1..6] of ppposs;
    pos_barend : array [1..6] of ppposs;
    pos8 : array [1..6] of ppposs;


begin
        result := 0;
        if OPT_TB_STYLE=0 then exit;
        if myteamis = C_TEAMNON then exit;
        if MATCH_GAMEEND then exit;
with mainform do begin
//  mainform.Font2s.TextOut (players[OPT_1BARTRAX].location, 10,200,$8800FF00);
        x := 100;
        y := 400;
        maxtextwidth := 0;
        plcount := 0;

        FONTINDEX := OPT_TB_STYLE;
        for i := 0 to 7 do if players[i] <> nil then if players[i].team = MyTeamIs then
                if ((OPT_TB_SHOWMYSELF=true) or (players[i].dxid <> mydxidis)) then
                begin
//                        if (OPT_TB_SHOWMYSELF=false) and (players[i].dxid <> mydxidis) then continue;

                        myteam := GetColorTextWidth(players[i].netname,FONTINDEX);
                        if myteam > maxtextwidth then
                                maxtextwidth := myteam;
                        inc(plcount);
                end;

        if plcount=0 then exit;
        xadd:=0;yadd :=0;

        case OPT_TB_STYLE of
        1 : begin
                        pos1[OPT_TB_STYLE].x := 6; // | after nickname
                        pos2[OPT_TB_STYLE].x := 6; // hels
                        pos3[OPT_TB_STYLE].x := 12;
                        pos4[OPT_TB_STYLE].x := 12;
                        pos5[OPT_TB_STYLE].x := 16; //image
                        pos5[OPT_TB_STYLE].y := 3;  //image
                        pos6[OPT_TB_STYLE].x := 16; //loc
                        pos_barend[OPT_TB_STYLE].x := 18;
                        pos_barend[OPT_TB_STYLE].y := 4;
                        yadd := 2;
                end;
        2 : begin
                        pos1[OPT_TB_STYLE].x := 0;
                        pos2[OPT_TB_STYLE].x := 0;
                        pos3[OPT_TB_STYLE].x := 0;
                        pos4[OPT_TB_STYLE].x := 0;
                        pos5[OPT_TB_STYLE].x := 0;
                        pos5[OPT_TB_STYLE].y := 0;
                        pos6[OPT_TB_STYLE].x := 2;
                        pos_barend[OPT_TB_STYLE].x := 4;
                        pos_barend[OPT_TB_STYLE].y := 0;
                        yadd := 0;
                end;
        3 : begin
                        pos1[OPT_TB_STYLE].x := 0;
                        pos2[OPT_TB_STYLE].x := -3;
                        pos3[OPT_TB_STYLE].x := -3;
                        pos4[OPT_TB_STYLE].x := -6;

                        pos5[OPT_TB_STYLE].x := -4;
                        pos5[OPT_TB_STYLE].y := 2;

                        pos6[OPT_TB_STYLE].x := -3;
                        pos_barend[OPT_TB_STYLE].x := 0;
                        pos_barend[OPT_TB_STYLE].y := 2;
                        yadd := 0;
                end;
        else xadd:=0;
        end;

        barwidth := maxtextwidth + 85 + 170 + pos_barend[OPT_TB_STYLE].x;

        locs := GetLocationsCount;
        if locs=0 then barwidth := maxtextwidth+85+22 + pos_barend[OPT_TB_STYLE].x;
        barheight := plcount*15 + 4 + pos_barend[OPT_TB_STYLE].y;

        x := mainform.powergraph.width div 2 -barwidth div 2;
        y := mainform.powergraph.height-barheight;

        MyTeam := MyTeamIs;

        if OPT_TB_COLOR=14 then begin
                if MyTeam=C_TEAMRED then PowerGraph.FillRect(320-barwidth div 2,y,barwidth,barheight,COLORARRAY[8],2 or $100) else
                if MyTeam=C_TEAMBLU then PowerGraph.FillRect(320-barwidth div 2,y,barwidth,barheight,COLORARRAY[11],2 or $100) else
                PowerGraph.FillRect(320-barwidth div 2,y,barwidth,barheight,$000000,effectMul);
        end else
                PowerGraph.FillRect(320-barwidth div 2,y,barwidth,barheight,COLORARRAY[OPT_TB_COLOR],effectMul);

        for i := 0 to 7 do if players[i] <> nil then if players[i].team = MyTeam then
                if (OPT_TB_SHOWMYSELF=true) or (players[i].dxid <> mydxidis) then
                begin

                ParseColorText(players[i].netname,x+3,y+2,FONTINDEX);
                ParseColorText('| ',x+maxtextwidth+15,y+2,FONTINDEX);

                if (players[i].health > 0) and (players[i].dead = 0) then
                        ParseColorText(inttostr(players[i].health) , pos1[FONTINDEX].x + x+maxtextwidth+34  -  GetColorTextWidth(inttostr(players[i].health), FONTINDEX) div 2,y+2,FONTINDEX) else
                ParseColorText('^1RIP' ,pos1[FONTINDEX].x+x+maxtextwidth+34-GetColorTextWidth('^1RIP', FONTINDEX) div 2  ,y+2,FONTINDEX);

                ParseColorText('|',pos2[FONTINDEX].x+x+maxtextwidth+50,y+2,FONTINDEX);
                ParseColorText(inttostr(players[i].armor),pos3[FONTINDEX].x+xadd+x+maxtextwidth+69  -  GetColorTextWidth(inttostr(players[i].armor), FONTINDEX) div 2 ,y+2,FONTINDEX);

                ParseColorText('|',pos4[FONTINDEX].x+x+maxtextwidth+85,y+2,FONTINDEX);
                if (players[i].health > 0) and (players[i].dead = 0) then
                        PowerGraph.RenderEffect (images[50],pos5[FONTINDEX].x+x+maxtextwidth+90,y+pos5[FONTINDEX].y,players[i].weapon,2) else
                PowerGraph.RenderEffect (images[50],pos5[FONTINDEX].x+x+maxtextwidth+90,y+pos5[FONTINDEX].y,9,2);
                if locs>0 then
                        ParseColorTextLimited('| ' +players[i].location, pos6[FONTINDEX].x+x+maxtextwidth+105, y+2, FONTINDEX, 145);


                inc(y,15+yadd);
                inc(result,15+yadd);
        end;

end; end;
//------------------------------------------------------------------------------
function HUD_BigHudAvail : boolean;
begin
        result := ((OPT_HUD_VISIBLE=2) or ((OPT_HUD_VISIBLE=1)and((ishotseatmap=false) or (OPT_CAMERATYPE<>0))));
end;
//------------------------------------------------------------------------------
procedure HUD_PowerIcons;
var c,tmp,stp,ammmo:word;
    alias : boolean;
    teambarhei : integer;

begin
with mainform do begin
//------------------------------------

        teambarhei := 0;
        if TeamGame then teambarhei := HUD_TeamBar-5;
        //fragbar. mp only.
        if OPT_DRAWFRAGBAR then
        if {(ismultip>0) or }({(MATCH_DDEMOPLAY=) and} (SYS_BAR2AVAILABLE=false)) then
        if getnumberofplayers>1 then begin

              stp := 0;
              if SYS_BAR2AVAILABLE then if players[OPT_2BARTRAX] <> nil then begin
                stp := 56;
                if players[OPT_2BARTRAX].item_quad > 0 then inc(stp,16);
                if players[OPT_2BARTRAX].item_regen > 0 then inc(stp,16);
                if players[OPT_2BARTRAX].item_battle > 0 then inc(stp,16);
                if players[OPT_2BARTRAX].item_flight > 0 then inc(stp,16);
                if players[OPT_2BARTRAX].item_haste > 0 then inc(stp,16);
                if players[OPT_2BARTRAX].item_invis > 0 then inc(stp,16);
              end;

             if OPT_DRAWFRAGBARMYFRAG >= OPT_DRAWFRAGBAROTHERFRAG then begin

                     c := font4.textwidth(inttostr(OPT_DRAWFRAGBARMYFRAG));
                     powergraph.Rectangle (OPT_DRAWFRAGBARX,OPT_DRAWFRAGBARY-stp, c*2+1,16,$88DDDDDD,$88FF0000,effectSrcAlpha or EffectDiffuseAlpha);
                     Font4.TextOut (inttostr(OPT_DRAWFRAGBARMYFRAG),OPT_DRAWFRAGBARX+c div 2,OPT_DRAWFRAGBARY-2-stp,$88EEEEEE);
                     tmp := font4.textwidth(inttostr(OPT_DRAWFRAGBAROTHERFRAG));
                     powergraph.Rectangle (OPT_DRAWFRAGBARX+c*2,OPT_DRAWFRAGBARY-stp, tmp*2+1,16,$88DDDDDD,$880000CC,effectSrcAlpha or EffectDiffuseAlpha);
                     Font4.TextOut (inttostr(OPT_DRAWFRAGBAROTHERFRAG),OPT_DRAWFRAGBARX+c*2+tmp div 2,OPT_DRAWFRAGBARY-2-stp,$88DDDDDD);
             end else begin
                     c := font4.textwidth(inttostr(OPT_DRAWFRAGBAROTHERFRAG));
                     powergraph.Rectangle (OPT_DRAWFRAGBARX,OPT_DRAWFRAGBARY-stp, c*2+1,16,$88DDDDDD,$880000CC,effectSrcAlpha or EffectDiffuseAlpha);
                     Font4.TextOut (inttostr(OPT_DRAWFRAGBAROTHERFRAG),OPT_DRAWFRAGBARX+c div 2,OPT_DRAWFRAGBARY-2-stp,$88EEEEEE);
                     tmp := font4.textwidth(inttostr(OPT_DRAWFRAGBARMYFRAG));
                     powergraph.Rectangle (OPT_DRAWFRAGBARX+c*2,OPT_DRAWFRAGBARY-stp, tmp*2+1,16,$88DDDDDD,$88FF0000,effectSrcAlpha or EffectDiffuseAlpha);
                     Font4.TextOut (inttostr(OPT_DRAWFRAGBARMYFRAG),OPT_DRAWFRAGBARX+c*2+tmp div 2,OPT_DRAWFRAGBARY-2-stp,$88DDDDDD);
             end;

        end;

        if MATCH_GAMETYPE = GAMETYPE_CTF then HUD_CTFBAR;
        if MATCH_GAMETYPE = GAMETYPE_DOMINATION then HUD_DOMBAR;
//------------------------------------

                if players[OPT_1BARTRAX] <> nil then begin
                        if players[OPT_1BARTRAX].weapon = 0 then ammmo := 0;
                        if players[OPT_1BARTRAX].weapon = 1 then ammmo := players[OPT_1BARTRAX].ammo_mg;
                        if players[OPT_1BARTRAX].weapon = 2 then ammmo := players[OPT_1BARTRAX].ammo_sg;
                        if players[OPT_1BARTRAX].weapon = 3 then ammmo := players[OPT_1BARTRAX].ammo_gl;
                        if players[OPT_1BARTRAX].weapon = 4 then ammmo := players[OPT_1BARTRAX].ammo_rl;
                        if players[OPT_1BARTRAX].weapon = 5 then ammmo := players[OPT_1BARTRAX].ammo_sh;
                        if players[OPT_1BARTRAX].weapon = 6 then ammmo := players[OPT_1BARTRAX].ammo_rg;
                        if players[OPT_1BARTRAX].weapon = 7 then ammmo := players[OPT_1BARTRAX].ammo_pl;
                        if players[OPT_1BARTRAX].weapon = 8 then ammmo := players[OPT_1BARTRAX].ammo_bfg;

                        // Enchanced HUD
                        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if HUD_BigHudAvail then begin
                            if (players[OPT_1BARTRAX].health > 0) then begin
                                alias := mainform.PowerGraph.Antialias;
                                mainform.PowerGraph.Antialias := true;

                                if TeamGame then if OPT_HUD_Y + OPT_HUD_HEIGTH < PowerGraph.Height - teambarhei then teambarhei := 0;

                                if OPT_HUD_ICONS then begin
                                        if OPT_HUD_SHADOWED then // ammo ico.
                                        powergraph.TextureMapRect (images[63], 2+OPT_HUD_X + 640 div OPT_HUD_DIVISOR - OPT_HUD_HEIGTH - OPT_HUD_HEIGTH div 2 - OPT_HUD_WIDTH div 2, 3+OPT_HUD_Y-teambarhei,OPT_HUD_HEIGTH,OPT_HUD_HEIGTH, players[OPT_1BARTRAX].weapon, (OPT_HUD_ALPHA div 2) shl 24+$0, 2 or $100);
                                        powergraph.TextureMapRect (images[63], OPT_HUD_X + 640 div OPT_HUD_DIVISOR - OPT_HUD_HEIGTH - OPT_HUD_HEIGTH div 2 - OPT_HUD_WIDTH div 2, OPT_HUD_Y-teambarhei,OPT_HUD_HEIGTH,OPT_HUD_HEIGTH, players[OPT_1BARTRAX].weapon, OPT_HUD_ALPHA shl 24+$FFFFFF, 2 or $100);
                                        if OPT_HUD_SHADOWED then // health ico
                                        powergraph.TextureMapRect (images[63], 2+OPT_HUD_X - 640 div OPT_HUD_DIVISOR  - (OPT_HUD_HEIGTH) - OPT_HUD_HEIGTH div 2 - OPT_HUD_WIDTH div 2, 3+OPT_HUD_Y-teambarhei,OPT_HUD_HEIGTH,OPT_HUD_HEIGTH,10,(OPT_HUD_ALPHA div 2) shl 24+$0, 2 or $100);
                                        powergraph.TextureMapRect (images[63], OPT_HUD_X - 640 div OPT_HUD_DIVISOR  - (OPT_HUD_HEIGTH) - OPT_HUD_HEIGTH div 2 - OPT_HUD_WIDTH div 2, OPT_HUD_Y-teambarhei,OPT_HUD_HEIGTH,OPT_HUD_HEIGTH,10,OPT_HUD_ALPHA shl 24+$FFFFFF, 2 or $100);
                                        if OPT_HUD_SHADOWED then // armor ico
                                        powergraph.TextureMapRect (images[63], 2+OPT_HUD_X  - (OPT_HUD_HEIGTH) - OPT_HUD_HEIGTH div 2 - OPT_HUD_WIDTH div 2, 3+OPT_HUD_Y-teambarhei,OPT_HUD_HEIGTH,OPT_HUD_HEIGTH,11,(OPT_HUD_ALPHA div 2) shl 24+$0, 2 or $100);
                                        powergraph.TextureMapRect (images[63], OPT_HUD_X  - (OPT_HUD_HEIGTH) - OPT_HUD_HEIGTH div 2 - OPT_HUD_WIDTH div 2, OPT_HUD_Y-teambarhei,OPT_HUD_HEIGTH,OPT_HUD_HEIGTH,11,OPT_HUD_ALPHA shl 24+$FFFFFF, 2 or $100);
                                end;

                                if  players[OPT_1BARTRAX].refire > 0 then
                                TexturedNumbersOut(ammmo, OPT_HUD_X + 640 div OPT_HUD_DIVISOR, OPT_HUD_Y-teambarhei, OPT_HUD_WIDTH,OPT_HUD_HEIGTH, OPT_HUD_ALPHA shl 24+$eeeecc) else
                                TexturedNumbersOut(ammmo, OPT_HUD_X + 640 div OPT_HUD_DIVISOR, OPT_HUD_Y-teambarhei, OPT_HUD_WIDTH,OPT_HUD_HEIGTH, OPT_HUD_ALPHA shl 24+$FFFF00);

                                if (cos(STIME/200) < 0) and (players[OPT_1BARTRAX].health <= 25) then
                                        TexturedNumbersOut(players[OPT_1BARTRAX].health, OPT_HUD_X - 640 div OPT_HUD_DIVISOR, OPT_HUD_Y-teambarhei, OPT_HUD_WIDTH,OPT_HUD_HEIGTH,OPT_HUD_ALPHA shl 24+$ff2222)
                                else if players[OPT_1BARTRAX].health >= 100 then
                                        TexturedNumbersOut(players[OPT_1BARTRAX].health, OPT_HUD_X - 640 div OPT_HUD_DIVISOR, OPT_HUD_Y-teambarhei, OPT_HUD_WIDTH,OPT_HUD_HEIGTH,OPT_HUD_ALPHA shl 24+$FFFFFF) else
                                        TexturedNumbersOut(players[OPT_1BARTRAX].health, OPT_HUD_X - 640 div OPT_HUD_DIVISOR, OPT_HUD_Y-teambarhei, OPT_HUD_WIDTH,OPT_HUD_HEIGTH,OPT_HUD_ALPHA shl 24+$FFFF00);
                                if players[OPT_1BARTRAX].armor >= 100 then
                                TexturedNumbersOut(players[OPT_1BARTRAX].armor,  OPT_HUD_X, OPT_HUD_Y-teambarhei, OPT_HUD_WIDTH,OPT_HUD_HEIGTH,OPT_HUD_ALPHA shl 24+$FFFFFF) else
                                TexturedNumbersOut(players[OPT_1BARTRAX].armor,  OPT_HUD_X, OPT_HUD_Y-teambarhei, OPT_HUD_WIDTH,OPT_HUD_HEIGTH,OPT_HUD_ALPHA shl 24+$FFFF00);
                                mainform.PowerGraph.Antialias := alias;
                            end;
                        end else
                        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        // HUD. STATUS BAR 1;  Standart
                        if(players[OPT_1BARTRAX] <> nil) then begin
                                c := mainform.powergraph.width - 22;
                                if players[OPT_1BARTRAX].health <= 0 then Font2s.TextOut('RIP',c+2, P1BARORIENT+1,clRed) else
                                if players[OPT_1BARTRAX].health <= 25 then
                                Font2s.TextOut(inttostr(players[OPT_1BARTRAX].health),c, P1BARORIENT+1,clRed) else
                                Font2s.TextOut(inttostr(players[OPT_1BARTRAX].health),c, P1BARORIENT+1,clAqua);
                                Font2s.TextOut(inttostr(players[OPT_1BARTRAX].armor) ,c, P1BARORIENT+14, clAqua); // armor
                                Font2s.TextOut(inttostr(ammmo), c, P1BARORIENT+27, clAqua);
                                Font2s.TextOut(inttostr(players[OPT_1BARTRAX].frags), c, P1BARORIENT+39,clAqua);
                        end;
                end;
                
                // HUD. STATUS BAR 2;
                if SYS_BAR2AVAILABLE then
                if players[OPT_2BARTRAX] <> nil then begin
                if players[OPT_2BARTRAX].health <= 0 then Font2s.TextOut('RIP',15, P1BARORIENT+1,clRed) else
                if players[OPT_2BARTRAX].health <= 25 then Font2s.TextOut(inttostr(players[OPT_2BARTRAX].health),15, P1BARORIENT+1,clRed) ELSE
                Font2s.TextOut(inttostr(players[OPT_2BARTRAX].health),15, P1BARORIENT+1,clAqua);
                Font2s.TextOut(inttostr(players[OPT_2BARTRAX].armor),15, P1BARORIENT+14, clAqua); // armor
                if players[OPT_2BARTRAX].weapon = 1 then Font2s.TextOut(inttostr(players[OPT_2BARTRAX].ammo_mg), 15, P1BARORIENT+27, clAqua);
                if players[OPT_2BARTRAX].weapon = 2 then Font2s.TextOut(inttostr(players[OPT_2BARTRAX].ammo_sg), 15, P1BARORIENT+27, clAqua);
                if players[OPT_2BARTRAX].weapon = 3 then Font2s.TextOut(inttostr(players[OPT_2BARTRAX].ammo_gl), 15, P1BARORIENT+27, clAqua);
                if players[OPT_2BARTRAX].weapon = 4 then Font2s.TextOut(inttostr(players[OPT_2BARTRAX].ammo_rl), 15, P1BARORIENT+27, clAqua);
                if players[OPT_2BARTRAX].weapon = 5 then Font2s.TextOut(inttostr(players[OPT_2BARTRAX].ammo_sh), 15, P1BARORIENT+27, clAqua);
                if players[OPT_2BARTRAX].weapon = 6 then Font2s.TextOut(inttostr(players[OPT_2BARTRAX].ammo_rg), 15, P1BARORIENT+27, clAqua);
                if players[OPT_2BARTRAX].weapon = 7 then Font2s.TextOut(inttostr(players[OPT_2BARTRAX].ammo_pl), 15, P1BARORIENT+27, clAqua);
                if players[OPT_2BARTRAX].weapon = 8 then Font2s.TextOut(inttostr(players[OPT_2BARTRAX].ammo_bfg),15, P1BARORIENT+27, clAqua);
                Font2s.TextOut(inttostr(players[OPT_2BARTRAX].frags), 15, P1BARORIENT+39,clAqua);
                end;

// ==================== POWERUPS ===================== \\
     if players[OPT_1BARTRAX] <> nil then
     if players[OPT_1BARTRAX].dead = 0 then
     begin
        c := 603;
        tmp := 17;
        if players[OPT_1BARTRAX].item_regen > 0 then begin
                tmp := 17;
                PowerGraph.RenderEffectCol(Images[40],c,P1BARORIENT-17,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,0,EffectSrcAlpha or EffectDiffuseAlpha);
                Font2s.TextOut(inttostr(players[OPT_1BARTRAX].item_regen-1), 625, P1BARORIENT-15, clAqua);
                inc(tmp,16);
        end;

        if players[OPT_1BARTRAX].item_quad > 0 then begin
                tmp := 17;
                if players[OPT_1BARTRAX].item_regen > 0 then inc(tmp,16);
                PowerGraph.RenderEffectCol(Images[40],c,P1BARORIENT-tmp,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,1,EffectSrcAlpha or EffectDiffuseAlpha);
                Font2s.TextOut(inttostr(players[OPT_1BARTRAX].item_quad-1), 625, P1BARORIENT-tmp+3, clAqua);
                inc(tmp,16);

        end;
        if players[OPT_1BARTRAX].item_battle > 0 then begin
                tmp := 17;
                if (players[OPT_1BARTRAX].item_quad > 0) then inc(tmp,16);
                if (players[OPT_1BARTRAX].item_regen > 0) then inc(tmp,16);
                PowerGraph.RenderEffectCol(Images[40],c,P1BARORIENT-tmp,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,2,EffectSrcAlpha or EffectDiffuseAlpha);
                Font2s.TextOut(inttostr(players[OPT_1BARTRAX].item_battle-1), 625, P1BARORIENT-tmp+3, clAqua);
                inc(tmp,16);
        end;
        if players[OPT_1BARTRAX].item_flight > 0 then begin
                tmp := 17;
                if (players[OPT_1BARTRAX].item_quad > 0) then inc(tmp,16);
                if (players[OPT_1BARTRAX].item_regen > 0) then inc(tmp,16);
                if (players[OPT_1BARTRAX].item_battle > 0) then inc(tmp,16);
                PowerGraph.RenderEffectCol(Images[40],c,P1BARORIENT-tmp,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,3,EffectSrcAlpha or EffectDiffuseAlpha);
                Font2s.TextOut(inttostr(players[OPT_1BARTRAX].item_flight-1), 625, P1BARORIENT-tmp+3, clAqua);
                inc(tmp,16);
        end;
        if players[OPT_1BARTRAX].item_haste > 0 then begin
                tmp := 17;
                if (players[OPT_1BARTRAX].item_quad > 0) then inc(tmp,16);
                if (players[OPT_1BARTRAX].item_regen > 0) then inc(tmp,16);
                if (players[OPT_1BARTRAX].item_battle > 0) then inc(tmp,16);
                if (players[OPT_1BARTRAX].item_flight > 0) then inc(tmp,16);
                PowerGraph.RenderEffectCol(Images[40],c,P1BARORIENT-tmp,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,4,EffectSrcAlpha or EffectDiffuseAlpha);
                Font2s.TextOut(inttostr(players[OPT_1BARTRAX].item_haste-1), 625, P1BARORIENT-tmp+3, clAqua);
                inc(tmp,16);
        end;
        if players[OPT_1BARTRAX].item_invis > 0 then begin
                tmp := 17;
                if (players[OPT_1BARTRAX].item_quad > 0) then inc(tmp,16);
                if (players[OPT_1BARTRAX].item_regen > 0) then inc(tmp,16);
                if (players[OPT_1BARTRAX].item_battle > 0) then inc(tmp,16);
                if (players[OPT_1BARTRAX].item_flight > 0) then inc(tmp,16);
                if (players[OPT_1BARTRAX].item_haste > 0) then inc(tmp,16);
                PowerGraph.RenderEffectCol(Images[40],c,P1BARORIENT-tmp,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,5,EffectSrcAlpha or EffectDiffuseAlpha);
                Font2s.TextOut(inttostr(players[OPT_1BARTRAX].item_invis-1), 625, P1BARORIENT-tmp+3, clAqua);
                inc(tmp,16);
        end;

     end;

     if not OPT_SHOWSTATS then
     if (OPT_SHOWNICKATSB) or ((OPT_AUTOSHOWNAMESTIME > 0) and (OPT_AUTOSHOWNAMES) and (MATCH_DDEMOPLAY) and (SYS_BAR2AVAILABLE=true)) then
     if players[OPT_1BARTRAX] <> nil then begin
                if players[OPT_1BARTRAX].dead > 0 then tmp := 17;
                PowerGraph.FillRect(634-GetColorTextWidth(players[OPT_1BARTRAX].netname,3)+2,P1BARORIENT-tmp,GetColorTextWidth(players[OPT_1BARTRAX].netname,3)+3,16,(OPT_R_STATUSBARALPHA shl 24)+ $000000,EffectSrcAlpha or EffectDiffuseAlpha);
                ParseColorText(players[OPT_1BARTRAX].netname,638-GetColorTextWidth(players[OPT_1BARTRAX].netname,3),P1BARORIENT-tmp,3);
                end;

// ==================== p2POWERUPS ===================== \\
     if SYS_BAR2AVAILABLE then
     if players[OPT_2BARTRAX] <> nil then
     if players[OPT_2BARTRAX].dead = 0 then
     begin
        c := 0;
        tmp := 17;
        if players[OPT_2BARTRAX].item_regen > 0 then begin
                PowerGraph.RenderEffectCol(Images[40],c,P1BARORIENT-17,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,0,EffectSrcAlpha or EffectDiffuseAlpha);
                Font2s.Textout(inttostr(players[OPT_2BARTRAX].item_regen-1), 22, P1BARORIENT-15,clAqua);
                inc(tmp,16);
        end;

        if players[OPT_2BARTRAX].item_quad > 0 then begin
                tmp := 17;
                if players[OPT_2BARTRAX].item_regen > 0 then inc(tmp,16);
                PowerGraph.RenderEffectCol(Images[40],c,P1BARORIENT-tmp,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,1,EffectSrcAlpha or EffectDiffuseAlpha);
                Font2s.Textout(inttostr(players[OPT_2BARTRAX].item_quad-1), 22, P1BARORIENT-tmp+3,clAqua);
                inc(tmp,16);
        end;
        if players[OPT_2BARTRAX].item_battle > 0 then begin
                tmp := 17;
                if (players[OPT_2BARTRAX].item_quad > 0) then inc(tmp,16);
                if (players[OPT_2BARTRAX].item_regen > 0) then inc(tmp,16);
                PowerGraph.RenderEffectCol(Images[40],c,P1BARORIENT-tmp,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,2,EffectSrcAlpha or EffectDiffuseAlpha);
                Font2s.Textout(inttostr(players[OPT_2BARTRAX].item_battle-1), 22, P1BARORIENT-tmp+3,clAqua);
                inc(tmp,16);
        end;
        if players[OPT_2BARTRAX].item_flight > 0 then begin
                tmp := 17;
                if (players[OPT_2BARTRAX].item_quad > 0) then inc(tmp,16);
                if (players[OPT_2BARTRAX].item_regen > 0) then inc(tmp,16);
                if (players[OPT_2BARTRAX].item_battle > 0) then inc(tmp,16);
                PowerGraph.RenderEffectCol(Images[40],c,P1BARORIENT-tmp,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,3,EffectSrcAlpha or EffectDiffuseAlpha);
                Font2s.Textout(inttostr(players[OPT_2BARTRAX].item_flight-1), 22, P1BARORIENT-tmp+3,clAqua);
                inc(tmp,16);
        end;
        if players[OPT_2BARTRAX].item_haste > 0 then begin
                tmp := 17;
                if (players[OPT_2BARTRAX].item_quad > 0) then inc(tmp,16);
                if (players[OPT_2BARTRAX].item_regen > 0) then inc(tmp,16);
                if (players[OPT_2BARTRAX].item_battle > 0) then inc(tmp,16);
                if (players[OPT_2BARTRAX].item_flight > 0) then inc(tmp,16);
                PowerGraph.RenderEffectCol(Images[40],c,P1BARORIENT-tmp,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,4,EffectSrcAlpha or EffectDiffuseAlpha);
                Font2s.Textout(inttostr(players[OPT_2BARTRAX].item_haste-1), 22, P1BARORIENT-tmp+3,clAqua);
                inc(tmp,16);
        end;
        if players[OPT_2BARTRAX].item_invis > 0 then begin
                tmp := 17;
                if (players[OPT_2BARTRAX].item_quad > 0) then inc(tmp,16);
                if (players[OPT_2BARTRAX].item_regen > 0) then inc(tmp,16);
                if (players[OPT_2BARTRAX].item_battle > 0) then inc(tmp,16);
                if (players[OPT_2BARTRAX].item_flight > 0) then inc(tmp,16);
                if (players[OPT_2BARTRAX].item_haste > 0) then inc(tmp,16);
                PowerGraph.RenderEffectCol(Images[40],c,P1BARORIENT-tmp,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,5,EffectSrcAlpha or EffectDiffuseAlpha);
                Font2s.Textout(inttostr(players[OPT_2BARTRAX].item_invis-1), 22, P1BARORIENT-tmp+3,clAqua);
                inc(tmp,16);
        end;

     end;
//------------------------------------
     if (OPT_SHOWNICKATSB) or ((OPT_AUTOSHOWNAMESTIME > 0) and (OPT_AUTOSHOWNAMES) and (MATCH_DDEMOPLAY) and (SYS_BAR2AVAILABLE=true)) then
     if not OPT_SHOWSTATS then
     if SYS_BAR2AVAILABLE then
     if players[OPT_2BARTRAX] <> nil then begin
             if players[OPT_2BARTRAX].dead > 0 then tmp := 17;
             PowerGraph.FillRect(0,P1BARORIENT-tmp,GetColorTextWidth(players[OPT_2BARTRAX].netname,3)+6,16,(OPT_R_STATUSBARALPHA shl 24)+ $000000,EffectSrcAlpha or EffectDiffuseAlpha);
             ParseColorText(players[OPT_2BARTRAX].netname,3,P1BARORIENT-tmp,3);
             end;
//------------------------------------

        // WEAPBAR!
        if p1weapbar > 0 then
        if players[OPT_1BARTRAX] <> nil then
        if players[OPT_1BARTRAX].dead = 0 then begin
                      stp := 0;

                        if players[OPT_1BARTRAX].have_bfg = true then begin
                                PowerGraph.RenderEffectCol(Images[39],587-stp,P1BARORIENT+37,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,8,EffectSrcAlpha or EffectDiffuseAlpha);
                                if players[OPT_1BARTRAX].ammo_bfg = 0 then
                                PowerGraph.RenderEffectCol(Images[39],587-stp,P1BARORIENT+37,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,10,EffectSrcAlpha or EffectDiffuseAlpha);
                                if players[OPT_1BARTRAX].threadweapon = 8 then
                                PowerGraph.RenderEffectCol(Images[39],587-stp,P1BARORIENT+37,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,9,EffectSrcAlpha or EffectDiffuseAlpha);
                                inc (stp, 16);
                        end;

                        if players[OPT_1BARTRAX].have_pl = true then begin
                                PowerGraph.RenderEffectCol(Images[39],587-stp,P1BARORIENT+37,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,7,EffectSrcAlpha or EffectDiffuseAlpha);
                                if players[OPT_1BARTRAX].ammo_pl = 0 then
                                PowerGraph.RenderEffectCol(Images[39],587-stp,P1BARORIENT+37,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,10,EffectSrcAlpha or EffectDiffuseAlpha);
                                if players[OPT_1BARTRAX].threadweapon = 7 then
                                PowerGraph.RenderEffectCol(Images[39],587-stp,P1BARORIENT+37,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,9,EffectSrcAlpha or EffectDiffuseAlpha);
                                inc (stp, 16);

                        end;
                        if players[OPT_1BARTRAX].have_rg = true then begin
                                PowerGraph.RenderEffectCol(Images[39],587-stp,P1BARORIENT+37,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,6,EffectSrcAlpha or EffectDiffuseAlpha);
                                if players[OPT_1BARTRAX].ammo_rg = 0 then
                                PowerGraph.RenderEffectCol(Images[39],587-stp,P1BARORIENT+37,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,10,EffectSrcAlpha or EffectDiffuseAlpha);
                                if players[OPT_1BARTRAX].threadweapon = 6 then
                                PowerGraph.RenderEffectCol(Images[39],587-stp,P1BARORIENT+37,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,9,EffectSrcAlpha or EffectDiffuseAlpha);

                                inc (stp, 16);
                        end;
                        if players[OPT_1BARTRAX].have_sh = true then begin
                                PowerGraph.RenderEffectCol(Images[39],587-stp,P1BARORIENT+37,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,5,EffectSrcAlpha or EffectDiffuseAlpha);
                                if players[OPT_1BARTRAX].ammo_sh = 0 then
                                PowerGraph.RenderEffectCol(Images[39],587-stp,P1BARORIENT+37,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,10,EffectSrcAlpha or EffectDiffuseAlpha);
                                if players[OPT_1BARTRAX].threadweapon = 5 then
                                PowerGraph.RenderEffectCol(Images[39],587-stp,P1BARORIENT+37,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,9,EffectSrcAlpha or EffectDiffuseAlpha);
                                inc (stp, 16);
                        end;
                        if players[OPT_1BARTRAX].have_rl = true then begin
                                PowerGraph.RenderEffectCol(Images[39],587-stp,P1BARORIENT+37,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,4,EffectSrcAlpha or EffectDiffuseAlpha);
                                if players[OPT_1BARTRAX].ammo_rl = 0 then
                                PowerGraph.RenderEffectCol(Images[39],587-stp,P1BARORIENT+37,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,10,EffectSrcAlpha or EffectDiffuseAlpha);
                                if players[OPT_1BARTRAX].threadweapon = 4 then
                                PowerGraph.RenderEffectCol(Images[39],587-stp,P1BARORIENT+37,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,9,EffectSrcAlpha or EffectDiffuseAlpha);
                                inc (stp, 16);
                        end;
                        if players[OPT_1BARTRAX].have_gl = true then begin
                                PowerGraph.RenderEffectCol(Images[39],587-stp,P1BARORIENT+37,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,3,EffectSrcAlpha or EffectDiffuseAlpha);
                                if players[OPT_1BARTRAX].ammo_gl = 0 then
                                PowerGraph.RenderEffectCol(Images[39],587-stp,P1BARORIENT+37,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,10,EffectSrcAlpha or EffectDiffuseAlpha);
                                if players[OPT_1BARTRAX].threadweapon = 3 then
                                PowerGraph.RenderEffectCol(Images[39],587-stp,P1BARORIENT+37,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,9,EffectSrcAlpha or EffectDiffuseAlpha);
                                inc (stp, 16);
                        end;
                        if players[OPT_1BARTRAX].have_sg = true then begin
                                PowerGraph.RenderEffectCol(Images[39],587-stp,P1BARORIENT+37,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,2,EffectSrcAlpha or EffectDiffuseAlpha);
                                if players[OPT_1BARTRAX].ammo_sg = 0 then
                                PowerGraph.RenderEffectCol(Images[39],587-stp,P1BARORIENT+37,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,10,EffectSrcAlpha or EffectDiffuseAlpha);
                                if players[OPT_1BARTRAX].threadweapon = 2 then
                                PowerGraph.RenderEffectCol(Images[39],587-stp,P1BARORIENT+37,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,9,EffectSrcAlpha or EffectDiffuseAlpha);
                                inc (stp, 16);
                        end;
                        if players[OPT_1BARTRAX].have_mg = true then begin
                                PowerGraph.RenderEffectCol(Images[39],587-stp,P1BARORIENT+37,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,1,EffectSrcAlpha or EffectDiffuseAlpha);
                                if players[OPT_1BARTRAX].ammo_mg = 0 then
                                PowerGraph.RenderEffectCol(Images[39],587-stp,P1BARORIENT+37,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,10,EffectSrcAlpha or EffectDiffuseAlpha);
                                if players[OPT_1BARTRAX].threadweapon = 1 then
                                PowerGraph.RenderEffectCol(Images[39],587-stp,P1BARORIENT+37,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,9,EffectSrcAlpha or EffectDiffuseAlpha);
                                inc (stp, 16);
                        end;
                        PowerGraph.RenderEffectCol(Images[39],587-stp,P1BARORIENT+37,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,0,EffectSrcAlpha or EffectDiffuseAlpha);
                        if players[OPT_1BARTRAX].threadweapon = 0 then
                        PowerGraph.RenderEffectCol(Images[39],587-stp,P1BARORIENT+37,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,9,EffectSrcAlpha or EffectDiffuseAlpha);

        end;

        // WEAPBAR!
        if SYS_BAR2AVAILABLE then
        if p2weapbar > 0 then
        if players[OPT_2BARTRAX] <> nil then
        if players[OPT_2BARTRAX].dead = 0 then begin
                        stp := 0;

                        PowerGraph.RenderEffectCol(Images[39],37+stp,P1BARORIENT+37,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,0,EffectSrcAlpha or EffectDiffuseAlpha);
                        if players[OPT_2BARTRAX].threadweapon = 0 then
                        PowerGraph.RenderEffectCol(Images[39],37+stp,P1BARORIENT+37,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,9,EffectSrcAlpha or EffectDiffuseAlpha);
                        inc (stp, 16);

                        if players[OPT_2BARTRAX].have_mg = true then begin
                                PowerGraph.RenderEffectCol(Images[39],37+stp,P1BARORIENT+37,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,1,EffectSrcAlpha or EffectDiffuseAlpha);
                                if players[OPT_2BARTRAX].ammo_mg = 0 then
                                PowerGraph.RenderEffectCol(Images[39],37+stp,P1BARORIENT+37,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,10,EffectSrcAlpha or EffectDiffuseAlpha);
                                if players[OPT_2BARTRAX].threadweapon = 1 then
                                PowerGraph.RenderEffectCol(Images[39],37+stp,P1BARORIENT+37,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,9,EffectSrcAlpha or EffectDiffuseAlpha);
                                inc (stp, 16);
                        end;
                        if players[OPT_2BARTRAX].have_sg = true then begin
                                PowerGraph.RenderEffectCol(Images[39],37+stp,P1BARORIENT+37,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,2,EffectSrcAlpha or EffectDiffuseAlpha);
                                if players[OPT_2BARTRAX].ammo_sg = 0 then
                                PowerGraph.RenderEffectCol(Images[39],37+stp,P1BARORIENT+37,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,10,EffectSrcAlpha or EffectDiffuseAlpha);
                                if players[OPT_2BARTRAX].threadweapon = 2 then
                                PowerGraph.RenderEffectCol(Images[39],37+stp,P1BARORIENT+37,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,9,EffectSrcAlpha or EffectDiffuseAlpha);
                                inc (stp, 16);
                        end;
                        if players[OPT_2BARTRAX].have_gl = true then begin
                                PowerGraph.RenderEffectCol(Images[39],37+stp,P1BARORIENT+37,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,3,EffectSrcAlpha or EffectDiffuseAlpha);
                                if players[OPT_2BARTRAX].ammo_gl = 0 then
                                PowerGraph.RenderEffectCol(Images[39],37+stp,P1BARORIENT+37,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,10,EffectSrcAlpha or EffectDiffuseAlpha);
                                if players[OPT_2BARTRAX].threadweapon = 3 then
                                PowerGraph.RenderEffectCol(Images[39],37+stp,P1BARORIENT+37,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,9,EffectSrcAlpha or EffectDiffuseAlpha);
                                inc (stp, 16);
                        end;
                        if players[OPT_2BARTRAX].have_rl = true then begin
                                PowerGraph.RenderEffectCol(Images[39],37+stp,P1BARORIENT+37,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,4,EffectSrcAlpha or EffectDiffuseAlpha);
                                if players[OPT_2BARTRAX].ammo_rl = 0 then
                                PowerGraph.RenderEffectCol(Images[39],37+stp,P1BARORIENT+37,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,10,EffectSrcAlpha or EffectDiffuseAlpha);
                                if players[OPT_2BARTRAX].threadweapon = 4 then
                                PowerGraph.RenderEffectCol(Images[39],37+stp,P1BARORIENT+37,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,9,EffectSrcAlpha or EffectDiffuseAlpha);
                                inc (stp, 16);
                        end;
                        if players[OPT_2BARTRAX].have_sh = true then begin
                                PowerGraph.RenderEffectCol(Images[39],37+stp,P1BARORIENT+37,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,5,EffectSrcAlpha or EffectDiffuseAlpha);
                                if players[OPT_2BARTRAX].ammo_sh = 0 then
                                PowerGraph.RenderEffectCol(Images[39],37+stp,P1BARORIENT+37,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,10,EffectSrcAlpha or EffectDiffuseAlpha);
                                if players[OPT_2BARTRAX].threadweapon = 5 then
                                PowerGraph.RenderEffectCol(Images[39],37+stp,P1BARORIENT+37,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,9,EffectSrcAlpha or EffectDiffuseAlpha);
                                inc (stp, 16);
                        end;
                        if players[OPT_2BARTRAX].have_rg = true then begin
                                PowerGraph.RenderEffectCol(Images[39],37+stp,P1BARORIENT+37,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,6,EffectSrcAlpha or EffectDiffuseAlpha);
                                if players[OPT_2BARTRAX].ammo_rg = 0 then
                                PowerGraph.RenderEffectCol(Images[39],37+stp,P1BARORIENT+37,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,10,EffectSrcAlpha or EffectDiffuseAlpha);
                                if players[OPT_2BARTRAX].threadweapon = 6 then
                                PowerGraph.RenderEffectCol(Images[39],37+stp,P1BARORIENT+37,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,9,EffectSrcAlpha or EffectDiffuseAlpha);
                                inc (stp, 16);
                        end;

                        if players[OPT_2BARTRAX].have_pl = true then begin
                                PowerGraph.RenderEffectCol(Images[39],37+stp,P1BARORIENT+37,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,7,EffectSrcAlpha or EffectDiffuseAlpha);
                                if players[OPT_2BARTRAX].ammo_pl = 0 then
                                PowerGraph.RenderEffectCol(Images[39],37+stp,P1BARORIENT+37,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,10,EffectSrcAlpha or EffectDiffuseAlpha);
                                if players[OPT_2BARTRAX].threadweapon = 7 then
                                PowerGraph.RenderEffectCol(Images[39],37+stp,P1BARORIENT+37,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,9,EffectSrcAlpha or EffectDiffuseAlpha);
                                inc (stp, 16);
                        end;
                        if players[OPT_2BARTRAX].have_bfg = true then begin
                                PowerGraph.RenderEffectCol(Images[39],37+stp,P1BARORIENT+37,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,8,EffectSrcAlpha or EffectDiffuseAlpha);
                                if players[OPT_2BARTRAX].ammo_bfg = 0 then
                                PowerGraph.RenderEffectCol(Images[39],37+stp,P1BARORIENT+37,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,10,EffectSrcAlpha or EffectDiffuseAlpha);
                                if players[OPT_2BARTRAX].threadweapon = 8 then
                                PowerGraph.RenderEffectCol(Images[39],37+stp,P1BARORIENT+37,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,9,EffectSrcAlpha or EffectDiffuseAlpha);
                        end;
//}
       end;


end;
end;

procedure MAP_RESTART;
var i,a : integer;
    msg5 : TMP_SV_PlayerRespawn;
    MsgSize : word;
begin

        resetmap;

        for i := 0 to 7 do if players[i] <> nil then begin
                resetplayer(players[i]);
                if ismultip <= 1 then FindRespawnPoint(players[i],false);
                resetplayerstats(players[i]);
                players[i].frags := 0;
                if ismultip=1 then begin
                MsgSize := SizeOf(TMP_SV_PlayerRespawn);
                        Msg5.Data := MMP_PLAYERRESPAWN;
                        Msg5.DXID := players[i].dxid;
//                        FindRespawnPointV2(players[i]);
                        Msg5.x := SPAWNX;
                        Msg5.y := SPAWNY;
                        mainform.BNETSendData2All (Msg5, MsgSize, 1);
                end;
        end;

        INSCOREBOARD := false;

        addmessage('Map reborned ('+map_name+')');

        gametic := 0;
        gametime := 0;
        gamesudden := 0;

        MATCH_OVERTIME := 0;
        MATCH_REDTEAMSCORE := 0;
        MATCH_BLUETEAMSCORE := 0;

        SYS_ANNOUNCER := 3; // tied..

        if MATCH_DRECORD then begin
                // REMEMBER THE TIME!
                ddata.gametic := gametic;
                ddata.gametime := gametime;
                ddata.type0 := 3;
                DemoStream.Write( DData, Sizeof(DData));
                DImmediateTimeSet.newgametic := gametic;
                DImmediateTimeSet.newgametime  := gametime;
                DImmediateTimeSet.warmup := 0;
                DemoStream.Write( DImmediateTimeSet, Sizeof(DImmediateTimeSet));
        end;

        if MATCH_STARTSIN > 1 then
        if OPT_AUTOSHOWNAMES then begin
                OPT_AUTOSHOWNAMESTIME := OPT_AUTOSHOWNAMESDEFTIME;
                OPT_SHOWNAMES := TRUE;
        end;

        MSG_DISABLE := false;
        MATCH_SUDDEN := false;
        OPT_SHOWSTATS := false;
        map_info := 5;
        match_gameend := false;
        draworder := random(2);

        if ismultip=0 then
        if (MATCH_GAMETYPE=GAMETYPE_TRIXARENA) and (OPT_TRIXMASTA) and (MATCH_STARTSIN>1) then begin
                  applyhcommand('record temp');
        end;


        if MATCH_STARTSIN <= 1 then begin
                map_info:=0;
                end;

        if BD_Avail then DLL_EVENT_ResetGame; // bot.dll
end;

// ==================== DEMO ENGINE ===========
function ISHotSeatMap:boolean;
begin
        result := (BRICK_X = 20) and (BRICK_Y = 30);
end;

procedure DEMO_AutoBarTrax;
begin
        if OPT_1BARTRAX=0 then OPT_2BARTRAX := 1;
        if OPT_1BARTRAX=1 then OPT_2BARTRAX := 0;

        IF GetNumberOfPlayers>=3 then begin
                SYS_BAR2AVAILABLE := false;
                exit;
                end;

        IF GetNumberOfPlayers=1 then begin
                SYS_BAR2AVAILABLE := false;
                if players[OPT_1BARTRAX]=nil then OPT_1BARTRAX:=1;
                exit;
        end;

        IF GetNumberOfPlayers=2 then
                if ISHotSeatMap then begin
                        SYS_BAR2AVAILABLE := TRUE;
                        OPT_2BARTRAX := 1;

                        if OPT_1BARTRAX = OPT_2BARTRAX then begin
                                OPT_1BARTRAX := 0;
                                OPT_2BARTRAX := 1;
                                end;

//                        if players[OPT_1BARTRAX]=nil then inc(OPT_2BARTRAX);
//                        if players[OPT_2BARTRAX]=nil then if OPT_1BARTRAX <> 0 then OPT_2BARTRAX:=0 else OPT_1BARTRAX := 1;


                        exit;
                end else SYS_BAR2AVAILABLE := false;
end;

procedure DEMOPLAREC;
var a : TPlayer;
    stp : word;
    d : byte;
    i,b : word;
    str : string[10];
    str2 : string[30];
    UPDATESPEED : shortint;
    rzlt : boolean;
    chatstr : string;
    buf: array[0..$FF] of char;
begin
        UPDATESPEED := 3; // der
        // =================================================== \\
        // Playing demo
        // =================================================== \\
        if MATCH_DDEMOPLAY then
                if DemoStream.Position < demostream.Size then
                while (gametime >= ddata.gametime) and ((gametic >= DData.gametic) or (gametime > DData.gametime)) do begin
                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if DData.type0 = DDEMO_PLAYERPOSV3 then // VERSION3: player position
                        for d := 0 to 7 do if players[d] <> nil then if players[d].dxid = DPlayerUpdateV3.DXID then begin
                                players[d].x := DPlayerUpdateV3.x;
                                players[d].y := DPlayerUpdateV3.y;
                                if (DPlayerUpdateV3.PUV3 and PUV3_DIR0)=PUV3_DIR0 then players[d].dir := 0;
                                if (DPlayerUpdateV3.PUV3 and PUV3_DIR1)=PUV3_DIR1 then players[d].dir := 1;
                                if (DPlayerUpdateV3.PUV3 and PUV3_DIR2)=PUV3_DIR2 then players[d].dir := 2;
                                if (DPlayerUpdateV3.PUV3 and PUV3_DIR3)=PUV3_DIR3 then players[d].dir := 3;
                                if (DPlayerUpdateV3.PUV3 and PUV3_DEAD0)=PUV3_DEAD0 then players[d].dead := 0;
                                if (DPlayerUpdateV3.PUV3 and PUV3_DEAD1)=PUV3_DEAD1 then players[d].dead := 1;
                                if (DPlayerUpdateV3.PUV3 and PUV3_DEAD2)=PUV3_DEAD2 then players[d].dead := 2;
                                if (DPlayerUpdateV3.PUV3 and PUV3_WPN0)=PUV3_WPN0 then players[d].weapon := 0;
                                if (DPlayerUpdateV3.PUV3 and PUV3_WPN1)=PUV3_WPN1 then players[d].weapon := 1;
                                if (DPlayerUpdateV3.PUV3 and PUV3_WPN2)=PUV3_WPN2 then players[d].weapon := 2;
                                if (DPlayerUpdateV3.PUV3 and PUV3_WPN3)=PUV3_WPN3 then players[d].weapon := 3;
                                if (DPlayerUpdateV3.PUV3 and PUV3_WPN4)=PUV3_WPN4 then players[d].weapon := 4;
                                if (DPlayerUpdateV3.PUV3 and PUV3_WPN5)=PUV3_WPN5 then players[d].weapon := 5;
                                if (DPlayerUpdateV3.PUV3 and PUV3_WPN6)=PUV3_WPN6 then players[d].weapon := 6;
                                if (DPlayerUpdateV3.PUV3 and PUV3_WPN7)=PUV3_WPN7 then players[d].weapon := 7;
                                if (DPlayerUpdateV3.PUV3B and PUV3B_WPN8)=PUV3B_WPN8 then players[d].weapon := 8;
                                if (DPlayerUpdateV3.PUV3B and PUV3B_CROUCH)=PUV3B_CROUCH then players[d].crouch := true else players[d].crouch := false;
                                if (DPlayerUpdateV3.PUV3B and PUV3B_BALLOON)=PUV3B_BALLOON then players[d].BALLOON := true else players[d].BALLOON := false;

                                if (players[d].dead = 0) and ((DPlayerUpdateV3.PUV3 and PUV3_DEAD1)=PUV3_DEAD1) then players[d].frame := 0;
                                players[d].InertiaX := DPlayerUpdateV3.InertiaX;
                                players[d].InertiaY := DPlayerUpdateV3.Inertiay;
                                if (players[d].dead > 0) and ((DPlayerUpdateV3.PUV3 and PUV3_DEAD0)=PUV3_DEAD0) and (players[d].rewardtime>0) then players[d].rewardtime := 0;
                                players[d].fangle := DPlayerUpdateV3.wpnang;

                                // fixangle
                                if (players[d].dir=1) or (players[d].dir=3) then begin
                                if (players[d].fangle > $7F) then players[d].fangle:= $FF - players[d].fangle;
                                end else
                                if (players[d].fangle <= $7F) then players[d].fangle:= $FF - players[d].fangle;

                                players[d].ammo_mg := DPlayerUpdateV3.currammo;
                                players[d].ammo_sg := DPlayerUpdateV3.currammo;
                                players[d].ammo_gl := DPlayerUpdateV3.currammo;
                                players[d].ammo_rl := DPlayerUpdateV3.currammo;
                                players[d].ammo_sh := DPlayerUpdateV3.currammo;
                                players[d].ammo_rg := DPlayerUpdateV3.currammo;
                                players[d].ammo_pl := DPlayerUpdateV3.currammo;
                                players[d].ammo_bfg := DPlayerUpdateV3.currammo;
                        end;
                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

                        if Ddata.type0 = DDEMO_TIMESET then begin // set new gametic, gametime
                                gametic := DImmediateTimeSet.newgametic ;
                                gametime := DImmediateTimeSet.newgametime;
                                MATCH_STARTSIN := DImmediateTimeSet.warmup;

                                if (DImmediateTimeSet.warmup = 0) and (gametime=0) and (gametic=0) then begin      // map_restart
                                        resetmap;

                                        for i := 0 to 7 do if players[i] <> nil then begin
                                                        resetplayerstats(players[i]);
                                                        players[i].item_quad := 0;
                                                        players[i].item_regen := 0;
                                                        players[i].item_haste := 0;
                                                        players[i].item_battle := 0;
                                                        players[i].item_flight := 0;
                                                        players[i].item_invis := 0;
                                                end;
                                        //playsound('fight.wav',320);
                                        for i := 0 to 1000 do if aaa[i].objname <> 'flash' then aaa[i].dead := 2; // clear objects
                                         // items
//                                        for i := 0 to BRICK_X-1 do for b := 0 to BRICK_Y-1 do
  //                                      if bbb[i,b].image > 0 then if bbb[i,b].respawntime > 0 then bbb[i,b].respawntime := 0;

                                        // reset special objects
                                        for i := 0 to NUM_OBJECTS do if ddd[i].active = true then begin
                                        if ddd[i].objtype = 2 then begin
                                                ddd[i].targetname := 0;
                                                ddd[i].lenght := 0;
                                        end;
                                        if ddd[i].objtype = 3 then begin
                                        if (ddd[i].orient = 1) or (ddd[i].orient = 0) then ddd[i].target := 1 else ddd[i].target := 0;
                                                ddd[i].nowanim := 0;
                                                ddd[i].dir := 0;
                                        end;
                                        if ddd[i].objtype = 4 then ddd[i].targetname := 0;
                                        end;
                                end;
                        end;

                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if DData.type0 = DDEMO_CREATEPLAYER then begin // create new player
                                a := TPlayer.Create;
                                with a do begin
                                x := DSpawnPlayer.x;
                                y := DSpawnPlayer.y;
                                objname := 'player';
                                idd := 0;
                                control := 0;   //no control
                                health := 125;
                                armor := 0;
                                netname := DSpawnPlayer.netname;
                                nfkmodel := DSpawnPlayer.modelname;
                                netobject := TRUE; // not local player
                                soundmodel := OPT_SOUNDMODEL1;
                                frame := DSpawnPlayer.frame;
                                dead := DSpawnPlayer.dead;
                                weapon := 1;
                                netupdated := true;
                                flagcarrier := false;
                                TESTPREDICT_X := x;
                                TESTPREDICT_Y := y;
                                DXID := DSpawnPlayer.dxid;
                                assignmodel(a);
                                dir := DSpawnPlayer.dir;
                                addplayer(a);
                                resetplayer(a);
                                resetplayerstats(a);
                                playsound(SND_respawn,x,y);
                                if MATCH_DDEMOMPPLAY>0 then
                                        addmessage(a.netname+' ^7^njoin the game');

                                end;

                                // automatic bar2assign
                                DEMO_AutoBarTrax;
                        end;
                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

                        if DData.type0 = DDEMO_CREATEPLAYERV2 then begin // create new playerV2
                                a := TPlayer.Create;
                                with a do begin
                                x := DSpawnPlayerV2.x;
                                y := DSpawnPlayerV2.y;
                                objname := 'player';
                                idd := 0;
                                control := 0;   //no control
                                health := 125;
                                armor := 0;
                                netname := DSpawnPlayerV2.netname;
                                nfkmodel := DSpawnPlayerV2.modelname;
                                netobject := TRUE; // not local player
                                soundmodel := OPT_SOUNDMODEL1;
                                frame := 0;
                                dead := DSpawnPlayerV2.dead;
                                weapon := 1;
                                netupdated := true;
                                TESTPREDICT_X := x;
                                TESTPREDICT_Y := y;
                                DXID := DSpawnPlayerV2.dxid;
                                assignmodel(a);
                                dir := DSpawnPlayerV2.dir;
                                team := DSpawnPlayerV2.team;
                                flagcarrier := false;
//                                addmessage('spawned with team: '+inttostr(team));
                                addplayer(a);
                                resetplayer(a);
                                resetplayerstats(a);
                                playsound(SND_respawn,x,y);

                                if MATCH_DDEMOMPPLAY>0 then
                                        addmessage(a.netname+' ^7^njoin the game');

                                assignmodel(a);

                                end;

                                // automatic bar2assign
                                DEMO_AutoBarTrax;
                        end;
                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

                        if DData.type0 = DDEMO_KILLOBJECT then begin // kill object with defined dxid.
                                for stp := 0 to 1000 do
                                        if aaa[stp].dead < 2 then
                                        if aaa[stp].DXID = DDXIDKill.DXID then begin
//                                                addmessage('KILLING DXID#'+inttostr(demodata.dxid)+' '+aaa[stp].objname);
                                                                aaa[stp].dead := 1;
                                                                aaa[stp].weapon := 0;
                                                                aaa[stp].frame := 0;

                                                                aaa[stp].x := DDXIDKill.x;
                                                                aaa[stp].y := DDXIDKill.y;

                                                        if aaa[stp].objname = 'rocket' then begin
                                                                PopupGIBZ(aaa[stp],60,100);
                                                                aaa[stp].fangle := random(256);
                                                                end;

                                                        if (aaa[stp].objname = 'grenade') then begin
                                                                PopupGIBZ(aaa[stp],60,100);
                                                                aaa[stp].weapon := 1;
                                                                aaa[stp].fangle := random(256);
                                                                aaa[stp].speed := random(8);
                                                                aaa[stp].objname := 'rocket';
                                                                aaa[stp].topdraw := 2;  // explosion to the top animaton
//                                                                addmessage('killin #'+inttostr(aaa[stp].DXID));
                                                        end;
                                                if (aaa[stp].objname = 'plasma') then aaa[stp].dead := 2; // plazma-just remove
                                                break;
                                        end;
                        end;
                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if DData.type0 = DDEMO_FIREROCKET then begin // fire rocket
                                for d := 0 to 7 do if players[d] <> nil then if players[d].dxid = DMissileV2.spawnerDxid then begin FireRocket(players[d],0,0,0); break; end;
                        end;
                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if DData.type0 = DDEMO_FIREBFG  then begin // fire BFG
                                for d := 0 to 7 do if players[d] <> nil then if players[d].dxid = DMissileV2.spawnerDxid then begin FireBFG(players[d],0,0,0); break; end;
                        end;
                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if DData.type0 = DDEMO_FIREPLASMA then begin // fire PLAZMA
                                for d := 0 to 7 do if players[d] <> nil then if players[d].dxid = DMissile.spawnerDxid then begin FirePlasma(players[d],0,0,0); break; end;
                        end;
                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if DData.type0 = DDEMO_FIREPLASMAV2 then begin // fire PLAZMA
                                for d := 0 to 7 do if players[d] <> nil then if players[d].dxid = DMissileV2.spawnerDxid then begin FirePlasma(players[d],0,0,0); break; end;
                        end;
                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if DData.type0 = 8 then begin // fire old GREN
                                for d := 0 to 7 do if players[d] <> nil then if players[d].dxid = DVectorMissile.spawnerDxid then begin FireGren(players[d],0,0,0); break; end;
                        end;
                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if DData.type0 = DDEMO_FIREGRENV2 then begin // fire GREN
                                for d := 0 to 7 do if players[d] <> nil then if players[d].dxid = DGrenadeFireV2.spawnerDxid then begin FireGren(players[d],0,0,0); break; end; end;

                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if DData.type0 = 9 then begin // fire RAIL
                               for d := 0 to 7 do if players[d] <> nil then if players[d].dxid = DVectorMissile.spawnerDxid then begin FireRail(players[d],0,0,0,0); break; end;
                        end;
                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if DData.type0 = 10 then begin // fire SHAFT
                                for d := 0 to 7 do if players[d] <> nil then if players[d].dxid = DVectorMissile.spawnerDxid then begin FireShaft(players[d],0,0,0); break; end;
                        end;
                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if DData.type0 = 11 then begin // fire ShotGN
                                for d := 0 to 7 do if players[d] <> nil then if players[d].dxid = DVectorMissile.spawnerDxid then begin FireShotGun(players[d],0,0,0); break; end;
                        end;
                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if DData.type0 = 12 then begin // fire Mach
                                for d := 0 to 7 do if players[d] <> nil then if players[d].dxid = DVectorMissile.spawnerDxid then begin FireMachine(players[d],0,0,0); break; end;
                        end;
                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if DData.type0 = DDEMO_ITEMDISSAPEAR then begin // DDEMO_ITEMDISSAPEAR
                                Item_Dissapear(DItemDissapear.x,DItemDissapear.y,DItemDissapear.i,players[0]);
                                bbb[DItemDissapear.x,DItemDissapear.y].respawntime := 2;        // remove item;
                        end;
                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if DData.type0 = DDEMO_ITEMAPEAR then begin // DDEMO_ITEMDISSAPEAR
                                bbb[DItemDissapear.x,DItemDissapear.y].respawntime := 0;        // add item;

                                if OPT_R_ALPHAITEMSRESPAWN then
                                      bbb[DItemDissapear.x,DItemDissapear.y].scale := 0
                                      else bbb[DItemDissapear.x,DItemDissapear.y].scale := $FF;
                        end;

                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if DDAta.type0 = DDEMO_DAMAGEPLAYER then begin
                        for d := 0 to 7 do if players[d] <> nil then if players[d].dxid = DDamagePlayer.DXID then begin
                                        if players[d].item_battle > 0 then
                                        if players[d].item_battle_time = 0 then begin
                                                playsound(SND_protect3,players[d].x,players[d].y);
                                                players[d].item_battle_time := 50;
                                        end;

                                        players[d].health := DDamagePlayer.health;
                                        players[d].armor := DDamagePlayer.armor;

                                        if players[d].health <= GIB_DEATH then begin
                                                players[d].rewardtime := 0;

                                        if OPT_MEATLEVEL > 0 then begin
                                        if random(2) = 0 then
                                                PLAYSOUND(SND_gib1,players[d].x,players[d].y) else
                                                PLAYSOUND(SND_gib2,players[d].x,players[d].y);
                                        if OPT_MEATLEVEL >= 2 then begin     // WOW. YOURE WIN A BONUS MEAT!
                                                ThrowGib(Players[d],1);
                                                ThrowGib(Players[d],1);
                                                ThrowGib(Players[d],0);
                                        end;
                                        if OPT_MEATLEVEL = 3 then begin
                                                ThrowGib(Players[d],1);
                                                ThrowGib(Players[d],1);
                                                ThrowGib(Players[d],0);
                                        end;
                                                ThrowGib(Players[d],1);
                                                ThrowGib(Players[d],1);
                                                ThrowGib(Players[d],1);
                                                ThrowGib(Players[d],0);
                                        end;
                                        end;

                                        if players[d].health <= 0 then begin
                                                        players[d].gantl_state := 0;
                                                        players[d].gantl_s := 0;

                                                        inc(players[d].stats.stat_deaths);
                                                        if DDamagePlayer.ext > 0 then
                                                        inc(players[d].stats.stat_suicide);
                                                        players[d].item_quad := 0;
                                                        players[d].item_regen := 0;
                                                        players[d].item_haste := 0;
                                                        players[d].item_battle := 0;
                                                        players[d].item_flight := 0;
                                                        players[d].item_invis := 0;
                                                        players[d].flagcarrier := false; // no flag anyway


                                                        if DDamagePlayer.ext > 0 then   // suicide :}
                                                                SimpleDeathMessage(players[d],'',0,DDamagePlayer.ext) else
                                                        for stp := 0 to 7 do if players[stp] <> nil then if players[stp].dxid = DDamagePlayer.ATTDXID then begin
                                                                SimpleDeathMessage(players[d],players[stp].netname,DDamagePlayer.attwpn,0);
                                                                break;
                                                        end;

                                        end;

                                        // player hit player. bloodspawn.
                                        if (DDamagePlayer.ext = 0) then begin
                                                if DDamagePlayer.attwpn = 1 then SpawnBlood(players[d]) else
                                                if (DDamagePlayer.attwpn = 2) then begin // shotgun
                                                        SpawnBlood(players[d]);
                                                        SpawnBlood(players[d]);
                                                        SpawnBlood(players[d]);
                                                        SpawnBlood(players[d]);
                                                end else
                                                if (DDamagePlayer.attwpn = 5) then begin        // shaft
                                                        SpawnBlood(players[d]);
                                                end else
                                                if (DDamagePlayer.attwpn = 6) then begin // rail
                                                        SpawnBlood(players[d]);
                                                        SpawnBlood(players[d]);
                                                        SpawnBlood(players[d]);
                                                        SpawnBlood(players[d]);
                                                        end else

                                                if (DDamagePlayer.attwpn = 0) then playsound(SND_gauntl_a,players[d].x,players[d].y);

                                                if (DDamagePlayer.attwpn = 7) then begin
                                                        SpawnBlood(players[d]);
                                                        SpawnBlood(players[d]);
                                                end;

                                                if (DDamagePlayer.attwpn = 3) or (DDamagePlayer.attwpn = 4) or (DDamagePlayer.attwpn = 8) or (DDamagePlayer.attwpn = 0) then begin
                                                        SpawnBlood(players[d]);
                                                        SpawnBlood(players[d]);
                                                        SpawnBlood(players[d]);
                                                        SpawnBlood(players[d]);
                                                        end;
                                        end;

                                        // hitsound
                                        if (DDamagePlayer.ext = 0) then // fire $t@Tzzz
                                        for stp:=0 to 7 do if players[stp] <> nil then if
                                        players[stp].dxid = DDamagePlayer.ATTDXID then begin
                                                case DDamagePlayer.attwpn of
                                                1 : inc(players[stp].stats.mach_hits);
                                                2 : inc(players[stp].stats.shot_hits);
                                                3 : inc(players[stp].stats.gren_hits);
                                                4 : inc(players[stp].stats.rocket_hits);
                                                5 : inc(players[stp].stats.shaft_hits);
                                                6 : inc(players[stp].stats.rail_hits);
                                                7 : inc(players[stp].stats.plasma_hits);
                                                8 : inc(players[stp].stats.bfg_hits);
                                                end;
                                        end;


                                        // FIXME: in demo, blood sometimes spawns in strange places.
                                        if DDamagePlayer.ext = DIE_INPAIN then SpawnBlood(players[d]);

                                        if (OPT_HITSND = true) and (DDamagePlayer.ext = 0) then begin



                                        if players[OPT_1BARTRAX]=nil then OPT_1BARTRAX := 0;



                                                // hitsound
                                                for stp:=0 to 7 do if players[stp] <> nil then
                                                if players[stp].dxid = DDamagePlayer.ATTDXID then begin

                                                        rzlt := false;

                                                        if OPT_1BARTRAX = stp then
                                                        if players[OPT_1BARTRAX] <> nil then
                                                        if (players[stp].DXID = players[OPT_1BARTRAX].DXID) then
                                                                rzlt := true;

                                                        if SYS_BAR2AVAILABLE then
                                                        if OPT_2BARTRAX = stp then
                                                        if players[OPT_2BARTRAX] <> nil then
                                                        if (players[stp].DXID = players[OPT_2BARTRAX].DXID) then
                                                                rzlt := true;

                                                        if rzlt = true then
                                                        if players[stp].hitsnd = 0 then begin
                                                                playsound(SND_hit,players[stp].x,players[stp].y);
                                                                players[stp].hitsnd := 5;
                                                                break;
                                                        end;
                                                end;

                                        end;

                                        if ((Players[d].health > GIB_DEATH) or (OPT_MEATLEVEL = 0))  and (Players[d].health <= 0) then begin
                                        stp := random(3);
                                        if stp = 0 then playsound(Players[d].SND_death1,Players[d].x,Players[d].y);
                                        if stp = 1 then playsound(Players[d].SND_death2,Players[d].x,Players[d].y);
                                        if stp = 2 then playsound(Players[d].SND_death3,Players[d].x,Players[d].y);
                                        end else
                                        if Players[d].paintime = 0 then begin
                                        if Players[d].health >= 76 then playsound(Players[d].SND_Pain100,Players[d].x,Players[d].y) else
                                        if Players[d].health >= 51 then playsound(Players[d].SND_Pain75,Players[d].x,Players[d].y) else
                                        if Players[d].health >= 26 then playsound(Players[d].SND_Pain50,Players[d].x,Players[d].y) else
                                        if Players[d].health >= 1 then playsound(Players[d].SND_Pain25,Players[d].x,Players[d].y);
                                        Players[d].paintime := 25;
                                        end;

                                        break;
                                end;
                        end;

                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if DData.type0 = DDEMO_JUMPSOUND then begin // fire Mach
                                for d := 0 to 7 do if players[d] <> nil then if players[d].dxid = DPlayerJump.Dxid then begin playsound(players[d].SND_Jump,players[d].x,players[d].y); break; end;
                        end;

                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if DData.type0 = DDEMO_HAUPDATE then begin
                        for d := 0 to 7 do if players[d] <> nil then if players[d].dxid = DPlayerHAUpdate.DXID then begin
                                players[d].health := DPlayerHAUpdate.health;
                                players[d].armor  := DPlayerHAUpdate.armor;
                                players[d].frags  := DPlayerHAUpdate.frags;
                                end;
                        end;

                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if DData.type0 = DDEMO_FLASH then begin // spawn Respawn Flash
                                RespawnFlash(DRespawnFlash.x,DRespawnFlash.y);
                        end;

                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if DData.type0 = DDEMO_GAMEEND then begin
                                try
                                GameEnd(DGameEnd.EndType);
                                except addmessage('Error DDEMO_GAMEEND'); end;

                                case DGameEnd.EndType of
                                        END_SUDDEN : addmessage('^3Sudden death hit.');
                                        END_TIMELIMIT : addmessage('^3Timelimit hit.');
                                        END_FRAGLIMIT : addmessage('^3Fraglimit hit.');
                                        END_CAPTURELIMIT : addmessage('^3Capturelimit hit.');
                                        END_DOMLIMIT : addmessage('^3Domlimit hit.');
                                end;

                                for i := 0 to 1000 do if (aaa[i].objname <> 'flash')
                                and (aaa[i].objname <> 'gib')
                                and (aaa[i].objname <> 'blood')
                                and (aaa[i].objname <> 'shots')
                                and (aaa[i].objname <> 'shots2')
                                and (aaa[i].objname <> 'smoke')
                                and (aaa[i].objname <> 'machine')
                                and (aaa[i].objname <> 'rail')
                                then aaa[i].dead := 2; // clear objects

                                for d := 0 to 7 do if players[d] <> nil then if players[d].gantl_state > 0 then
                                        players[d].gantl_state := 0;
                        end;
                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if DData.type0 = DDEMO_NOAMMOSOUND then playsound(SND_Noammo, DNoAmmoSound.x,DNoAmmoSound.y);
                        if DData.type0 = DDEMO_JUMPPADSOUND then playsound(SND_jumppad,DJumppadSound.x,DJumppadSound.y);
                        if DData.type0 = DDEMO_RESPAWNSOUND then playsound(SND_respawn,DRespawnSound.x,DRespawnSound.y);
                        if DData.type0 = DDEMO_LAVASOUND then playsound(SND_lava,DLavaSound.x,DLavaSound.y);
                        if DData.type0 = DDEMO_POWERUPSOUND then playsound(SND_poweruprespawn,DPowerUpSound.x,DPowerUpSound.y);
                        if DData.type0 = DDEMO_FLIGHTSOUND then playsound(SND_flight,DFlightSound.x,DFlightSound.y);
                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if DData.type0 = DDEMO_EARNPOWERUP then
                        for d := 0 to 7 do if players[d] <> nil then if players[d].dxid = DEarnPowerup.DXID then begin
                                case DEarnPowerup.type1 of
                                1 : players[d].item_regen := DEarnPowerup.time;
                                2 : players[d].item_flight := DEarnPowerup.time;
                                3 : players[d].item_battle := DEarnPowerup.time;
                                4 : players[d].item_haste := DEarnPowerup.time;
                                5 : players[d].item_quad := DEarnPowerup.time;
                                6 : players[d].item_invis := DEarnPowerup.time;
                                end;
                        end;
                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if DData.type0 = DDEMO_EARNREWARD then
                        for d := 0 to 7 do if players[d] <> nil then if players[d].dxid = DEarnReward.DXID then begin
                                players[d].rewardtype := DEarnReward.type1;
                                if players[d].rewardtime <= 170 then case DEarnReward.type1 of
                                1 : playsound(SND_impressive,players[d].x,players[d].y);      // no double sound.
                                2 : playsound(SND_excellent,players[d].x,players[d].y);
                                3 : playsound(SND_humiliation,players[d].x,players[d].y);
                                end;
                                players[d].rewardtime := 200;
                                break;
                        end;
                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if DData.type0 = DDEMO_READYPRESS then MATCH_STARTSIN := DReadyPress.newmatch_statsin;
                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if DData.type0 = DDEMO_BUBBLE then
                        for d := 0 to 7 do if players[d] <> nil then if players[d].dxid = DBubble.DXID then begin
                                SpawnBubble(players[d]);
                                break;
                        end;
                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
{                        if DData.type0 = DDEMO_STATS then       // oldversion. not used anymore...
                        for d := 0 to 7 do if players[d] <> nil then if players[d].dxid = DStats.DXID then begin
                                 players[d].stats.stat_kills := DStats.stat_kills;
                                 players[d].stats.stat_dmggiven := DStats.stat_dmggiven;
                                 players[d].stats.stat_dmgrecvd := DStats.stat_dmgrecvd;
                                 players[d].stats.mach_hits := DStats.mach_hits;
                                 players[d].stats.shot_hits := DStats.shot_hits;
                                 players[d].stats.gren_hits := DStats.gren_hits ;
                                 players[d].stats.rocket_hits := DStats.rocket_hits ;
                                 players[d].stats.shaft_hits := DStats.shaft_hits ;
                                 players[d].stats.plasma_hits := DStats.plasma_hits ;
                                 players[d].stats.rail_hits := DStats.rail_hits ;
                                 players[d].stats.bfg_hits := DStats.bfg_hits;
                                 break;
                        end;

                        if DData.type0 = DDEMO_STATS2 then    // oldversion. not used anymore...
                        for d := 0 to 7 do if players[d] <> nil then if players[d].dxid = DStats2.DXID then begin
                                 players[d].stats.stat_kills := DStats2.stat_kills;
                                 players[d].stats.stat_suicide := DStats2.stat_suicide;
                                 players[d].stats.stat_deaths := DStats2.stat_deaths;
                                 players[d].frags := DStats2.frags;
                                 players[d].stats.stat_dmggiven := DStats2.stat_dmggiven;
                                 players[d].stats.stat_dmgrecvd := DStats2.stat_dmgrecvd;
                                 players[d].stats.mach_hits := DStats2.mach_hits;
                                 players[d].stats.shot_hits := DStats2.shot_hits;
                                 players[d].stats.gren_hits := DStats2.gren_hits ;
                                 players[d].stats.rocket_hits := DStats2.rocket_hits ;
                                 players[d].stats.shaft_hits := DStats2.shaft_hits ;
                                 players[d].stats.plasma_hits := DStats2.plasma_hits ;
                                 players[d].stats.rail_hits := DStats2.rail_hits ;
                                 players[d].stats.bfg_hits := DStats2.bfg_hits;
                                 players[d].stats.mach_fire := DStats2.mach_fire;
                                 players[d].stats.shot_fire := DStats2.shot_fire;
                                 players[d].stats.gren_fire := DStats2.gren_fire;
                                 players[d].stats.rocket_fire := DStats2.rocket_fire;
                                 players[d].stats.shaft_fire := DStats2.shaft_fire;
                                 players[d].stats.plasma_fire := DStats2.plasma_fire;
                                 players[d].stats.rail_fire := DStats2.rail_fire;
                                 players[d].stats.bfg_fire := DStats2.bfg_fire;
                                 break;
                        end;           }

                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if DData.type0 = DDEMO_STATS3 then
                        for d := 0 to 7 do if players[d] <> nil then if players[d].dxid = DStats3.DXID then begin
                                 players[d].stats.stat_kills := DStats3.stat_kills;
                                 players[d].stats.stat_suicide := DStats3.stat_suicide;
                                 players[d].stats.stat_deaths := DStats3.stat_deaths;
                                 players[d].frags := DStats3.frags;
                                 players[d].stats.stat_dmggiven := DStats3.stat_dmggiven;
                                 players[d].stats.stat_dmgrecvd := DStats3.stat_dmgrecvd;
                                 players[d].stats.gaun_hits := DStats3.gaun_hits;
                                 players[d].stats.mach_hits := DStats3.mach_hits;
                                 players[d].stats.shot_hits := DStats3.shot_hits;
                                 players[d].stats.gren_hits := DStats3.gren_hits ;
                                 players[d].stats.rocket_hits := DStats3.rocket_hits ;
                                 players[d].stats.shaft_hits := DStats3.shaft_hits ;
                                 players[d].stats.plasma_hits := DStats3.plasma_hits ;
                                 players[d].stats.rail_hits := DStats3.rail_hits ;
                                 players[d].stats.bfg_hits := DStats3.bfg_hits;
                                 players[d].stats.mach_fire := DStats3.mach_fire;
                                 players[d].stats.shot_fire := DStats3.shot_fire;
                                 players[d].stats.gren_fire := DStats3.gren_fire;
                                 players[d].stats.rocket_fire := DStats3.rocket_fire;
                                 players[d].stats.shaft_fire := DStats3.shaft_fire;
                                 players[d].stats.plasma_fire := DStats3.plasma_fire;
                                 players[d].stats.rail_fire := DStats3.rail_fire;
                                 players[d].stats.bfg_fire := DStats3.bfg_fire;
                                 players[d].stats.stat_impressives := DStats3.bonus_impressive;
                                 players[d].stats.stat_excellents := DStats3.bonus_excellent;
                                 players[d].stats.stat_humiliations := DStats3.bonus_humiliation;
                                 break;
                        end;

                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if DData.type0 = DDEMO_GAMESTATE then begin
                                if DGameState.type1 = 1 then playsound(SND_5_min,0,0);
                                if DGameState.type1 = 2 then playsound(SND_1_min,0,0);
                                if DGameState.type1 = 3 then begin
                                        playsound(SND_sudden_death,0,0);
                                        gamesudden := 200;
                                end;
                        end;
                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if DData.type0 = DDEMO_TRIXARENAEND then
                        for d := 0 to 7 do if players[d] <> nil then if players[d].dxid = DTrixArenaEnd.DXID then begin
                                str := '';
                                if trunc(gametime / 60) < 10 then str := '0';
                                str := str + inttostr(trunc(gametime/60))+':';
                                if gametime - trunc(gametime / 60)*60 < 10 then str := str + '0';
                                str := str + inttostr(gametime - trunc(gametime / 60)*60);
                                addmessage(players[d].netname + ' ^7^nfinished the level. Time: '+str+'.'+inttostr(gametic));
                                break;
                        end;

                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if DData.type0 = DDEMO_OBJCHANGESTATE then begin
                                if ddd[DObjChangeState.objindex].active =false then begin addmessage('error: DDEMO_OBJCHANGESTATE for null object'); end;

                                if ddd[DObjChangeState.objindex].objtype = 2 then // btn
                                if ddd[DObjChangeState.objindex].targetname <> DObjChangeState.state then begin
                                        ddd[DObjChangeState.objindex].targetname := DObjChangeState.state;
                                        if DObjChangeState.state = 1 then playsound(SND_button,ddd[DObjChangeState.objindex].x*32,ddd[DObjChangeState.objindex].y*16);
                                end;

                                if ddd[DObjChangeState.objindex].objtype = 3 then // dooR
                                if ddd[DObjChangeState.objindex].target <> DObjChangeState.state then begin
                                        ddd[DObjChangeState.objindex].nowanim := 6;
                                        ddd[DObjChangeState.objindex].target := DObjChangeState.state;
                                        if DObjChangeState.state = 1 then begin
                                                for i := 0 to 1000 do if aaa[i].dead = 0 then begin
                                                        rzlt := false;

                                                        if aaa[i].dead < 2 then begin
                                                        if ddd[DObjChangeState.objindex].orient  = 0 then rzlt := object_region_touch(ddd[DObjChangeState.objindex].x,ddd[DObjChangeState.objindex].y-1,ddd[DObjChangeState.objindex].x+ddd[DObjChangeState.objindex].lenght+1,ddd[DObjChangeState.objindex].y, aaa[i]);
                                                        if ddd[DObjChangeState.objindex].orient  = 1 then rzlt := object_region_touch(ddd[DObjChangeState.objindex].x,ddd[DObjChangeState.objindex].y,ddd[DObjChangeState.objindex].x, ddd[DObjChangeState.objindex].y+ddd[DObjChangeState.objindex].lenght+1, aaa[i]);
                                                        if rzlt = true then if aaa[i].objname = 'corpse' then begin
                                                                aaa[i].dead := 2;
                                                                end;
                                                        end;
                                                end;
                                        end;
                                        if DObjChangeState.state = 1 then playsound(SND_dr1_end,ddd[DObjChangeState.objindex].x*32,ddd[DObjChangeState.objindex].y*16);
                                        if DObjChangeState.state = 0 then playsound(SND_dr1_strt,ddd[DObjChangeState.objindex].x*32,ddd[DObjChangeState.objindex].y*16);
                                end;
                        end;
                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if DData.type0 = DDEMO_CORPSESPAWN then
                        for d := 0 to 7 do if players[d] <> nil then if players[d].dxid = DCorpseSpawn.DXID then begin
                                SpawnCorpse(players[d]);
                                break;
                        end;

                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        // outdated
                        if DData.type0 = DDEMO_GRENADESYNC then begin // sync grenade with defined dxid.
                                for stp := 0 to 1000 do
                                        if aaa[stp].dead < 2 then
                                        if aaa[stp].objname = 'grenade' then
                                        if aaa[stp].DXID = DGrenadeSync.DXID then begin
                                        //        addmessage('syncing #'+inttostr(DGrenadeSync.DXID));
                                                aaa[stp].x := DGrenadeSync.x;
                                                aaa[stp].y := DGrenadeSync.y;
                                                aaa[stp].InertiaX := DGrenadeSync.InertiaX;
                                                aaa[stp].InertiaY := DGrenadeSync.InertiaY;
                                                break;
                                        end;
                        end;
                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if DData.type0 = DDEMO_GAUNTLETSTATE then begin
                                for d := 0 to 7 do if players[d] <> nil then if players[d].dxid = DGauntletState.DXID then begin
                                        players[d].gantl_state := DGauntletState.State;

                                end;
                        end;

                        //--------------------------------------------
                        // MP.
                        if DData.type0 = DDEMO_MPSTATE then begin
                                MATCH_DDEMOMPPLAY := DMultiplayer.y;
                                OPT_1BARTRAX := DMultiplayer.pov;

                                if players[OPT_1BARTRAX] = nil then
                                for d := 0 to 7 do if (players[d] <> nil) then begin
                                        OPT_1BARTRAX := d;
                                        break;
                                        end;
//                                SYS_BAR2AVAILABLE := false;

                                // client demos bugfix
                                if (ISHotSeatMap) and (GetNumberOfPlayers = 2) then
                                        if OPT_1BARTRAX = OPT_2BARTRAX then begin
                                                OPT_1BARTRAX := 0;
                                                OPT_2BARTRAX := 1;
                                        end;
                        end;

                        //--------------------------------------------
                        if DData.type0 = DDEMO_NETRAIL then begin
                                playsound(SND_rail,DNetRail.x1,DNetRail.y1);
                                for i := 0 to 1000 do if aaa[i].dead = 2 then begin
                                        aaa[i].objname := 'rail';
                                        aaa[i].dude := false;
                                        aaa[i].dead := 1;
                                        aaa[i].topdraw := 1;
                                        aaa[i].frame := 0;
                                        aaa[i].DXID := 0;
                                        aaa[i].x := DNetRail.x;
                                        aaa[i].y := DNetRail.y;
                                        aaa[i].cx := DNetRail.endx;
                                        aaa[i].cy := DNetRail.endy;
                                        aaa[i].fallt := DNetRail.color;
                                        break;
                                end;
                        end;
                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if DData.type0 = DDEMO_NETPARTICLE then begin
                                if DNetShotParticle.index = 1 then begin
                                  SpawnNetShots1(trunc(DNetShotParticle.x), trunc(DNetShotParticle.y));
                                  playsound(SND_machine,trunc(DNetShotParticle.x1),trunc(DNetShotParticle.y1));
                                end;
                                if DNetShotParticle.index = 2 then begin
                                  SpawnNetShots(trunc(DNetShotParticle.x), trunc(DNetShotParticle.y));
                                  playsound(SND_shotgun,trunc(DNetShotParticle.x1),trunc(DNetShotParticle.y1));
                                end;
                        end;

                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        // client side recorded demoz...
                        if DData.type0 = DDEMO_NETTIMEUPDATE then begin
                                if DNETTimeUpdate.WARMUP = true then begin
                                        if DNETTimeUpdate.Min < 1 then MATCH_FAKESTARTSIN:=1 else
                                        MATCH_FAKESTARTSIN := DNETTimeUpdate.Min;

                                        case MATCH_FAKESTARTSIN of
                                                1 : playsound(SND_one,0,0);
                                                2 : playsound(SND_two,0,0);
                                                3 : playsound(SND_three,0,0);
                                        end;
                                end else begin
                                        MATCH_FAKESTARTSIN := 0;
                                        MATCH_FAKEMIN := DNETTimeUpdate.Min;
                                end;
                        end;
                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if DData.type0 = DDEMO_NETSVMATCHSTART then begin
                                playsound(SND_fight,0,0);
                                MATCH_STARTSIN:=0;      // GAME!
                                MATCH_FAKESTARTSIN:=0;

                                for d := 0 to 7 do if players[d] <> nil then begin
                                        resetplayer(players[d]);
                                        resetplayerstats(players[d]);
                                        end;

                                resetmap;
                        end;
                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if DData.type0 = DDEMO_DROPPLAYER then begin
                                for d := 0 to 7 do if players[d] <> nil then if players[d].dxid = DNETKickDropPlayer.DXID then begin
                                        addmessage(players[d].netname +' ^7^nhas left the game.');
//                                        RespawnFlash(players[d].x-16, players[d].y);
                                        if SYS_BOT then DLL_SYSTEM_RemovePlayer(players[d].DXID);
                                        players[d] := nil;
                                        break;
                                end;
                        end;
                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if DData.type0 = DDEMO_SPECTATORCONNECT    then addmessage(DNETSpectator.netname +' ^7^njoined as spectator.');
                        if DData.type0 = DDEMO_SPECTATORDISCONNECT then addmessage(DNETSpectator.netname +' ^7^ndisconnected.');
                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if DData.type0 = DDEMO_GENERICSOUNDDATA then
                                for d := 0 to 7 do if players[d] <> nil then if players[d].dxid = DNETSoundData.DXID then begin
                                        case DNETSoundData.SoundType of
                                        0:playsound(players[d].SND_Jump,players[d].x,players[d].y);
                                        1:playsound(SND_flight,players[d].x,players[d].y);
                                        2:playsound(SND_jumppad,players[d].x,players[d].y);
                                        3:playsound(SND_damage3,players[d].x,players[d].y);
                                        4:playsound(SND_noammo,players[d].x,players[d].y);
                                       end;
                                break;
                        end;
                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if DData.type0 = DDEMO_GENERICSOUNDSTATDATA then
                                case DNETSoundStatData.SoundType of
                                        0:playsound(SND_5_min,0,0);
                                        1:playsound(SND_1_min,0,0);
                                        2:begin
                                                playsound(SND_sudden_death,0,0);
                                                MATCH_SUDDEN := TRUE;
                                                gamesudden := 200;
                                        end;
                                end;
                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if DData.type0 = DDEMO_CHATMESSAGE then begin
                                DemoStream.read(buf, DNETCHATMessage.messagelenght);
                                if DNETCHATMessage.DXID=0 then addmessage('^%Dedicated^7: ^5'+ StrPas(buf));
                                playsound(SND_talk,0,0);
                                for d := 0 to 7 do if players[d] <> nil then if (players[d].dxid = DNETCHATMessage.DXID) then begin
                                        addmessage(players[d].netname+'^7^n: ^5'+StrPas(buf));
                                        break;
                                end;
                        end;
                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if DData.type0 = DDEMO_PLAYERRENAME then
                                for d := 0 to 7 do if players[d] <> nil then if players[d].dxid = DNETNameModelChange.DXID then begin
                                        str2 := players[d].netname;
                                        players[d].netname := DNETNameModelChange.newstr;
                                        addmessage(str2+'^7^n renamed to '+players[d].netname);
                                        break;
                                end;
                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if DData.type0 = DDEMO_PLAYERMODELCHANGE then
                                for d := 0 to 7 do if players[d] <> nil then if players[d].dxid = DNETNameModelChange.DXID then begin
                                addmessage(players[d].netname +' ^7^nchanged his model to '+ DNETNameModelChange.newstr);
                                players[d].nfkmodel := DNETNameModelChange.newstr;
                                ASSIGNMODEL(players[d]);
                                break;
                                end;
                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if DData.type0 = DDEMO_TEAMSELECT then
                                for d := 0 to 7 do if players[d] <> nil then if players[d].dxid = DNETTeamSelect.DXID then begin

                                if DNETTeamSelect.team = 1 then addmessage(players[d].netname+ ' ^7^njoined ^1RED ^7team') else
                                addmessage(players[d].netname + ' ^7^njoined ^4BLUE ^7team');

                                players[d].team := DNETTeamSelect.team;
                                ASSIGNMODEL(players[d]);
                                break;
                        end;
                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        // CTF
                        if DData.type0 = DDEMO_CTF_EVENT_FLAGTAKEN then
                        for d := 0 to 7 do if players[d] <> nil then if players[d].dxid = DCTF_FlagTaken.DXID then begin
                                players[d].flagcarrier := true;
                                playsound(SND_flagtk,0,0);
                                bbb[DCTF_FlagTaken.x,DCTF_FlagTaken.y].dir := 1; // not at base.
                                CTF_Event_Message(players[d].dxid,'taken');
                                break;
                        end;
                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if DData.type0 = DDEMO_CTF_EVENT_FLAGCAPTURE then // flag capture.
                        for d := 0 to 7 do if players[d] <> nil then if players[d].dxid = DCTF_FlagCapture.DXID then begin
                                players[d].flagcarrier := false;
                                playsound(SND_flagcap,0,0);
                                if players[d].team=0 then i := 1 else i := 0;
                                CTF_ReturnFlag(i);
                                CTF_Event_Message(players[d].dxid,'captu');
                                break;
                        end;
                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if (DData.type0 = DDEMO_CTF_EVENT_FLAGDROP) or (DData.type0 = DDEMO_CTF_EVENT_FLAGDROPGAMESTATE) then
                                CTF_DEMO_DropFlag();
                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if DData.type0 = DDEMO_CTF_EVENT_FLAGDROP_APPLY then
                        for stp := 0 to 1000 do if (aaa[stp].dead =0) and (aaa[stp].objname = 'flag') and (aaa[stp].DXID = DCTF_DropFlagApply.DXID) then begin
                                aaa[stp].x := DCTF_DropFlagApply.x;
                                aaa[stp].y := DCTF_DropFlagApply.y;
                                aaa[stp].InertiaX := 0;
                                aaa[stp].InertiaY := 0;
                                break;
                        end;
                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if DData.type0 = DDEMO_CTF_EVENT_FLAGPICKUP then
                        for d := 0 to 7 do if players[d] <> nil then if players[d].dxid = DCTF_FlagPickUp.PlayerDXID then begin
                                for stp := 0 to 1000 do if (aaa[stp].dead =0) and (aaa[stp].objname = 'flag') and (aaa[stp].DXID = DCTF_FlagPickUp.FlagDXID) then begin
                                        players[d].flagcarrier := true;
                                        CTF_Event_Message(players[d].dxid,'taken');
                                        aaa[stp].dead := 2;
                                        playsound(SND_flagtk,0,0);
                                        break;
                                end;
                                break;
                        end;
                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if DData.type0 = DDEMO_CTF_EVENT_FLAGRETURN then
                        for stp := 0 to 1000 do if (aaa[stp].dead =0) and (aaa[stp].objname = 'flag') and (aaa[stp].DXID = DCTF_FlagReturnFlag.FlagDXID) then begin
                                aaa[stp].dead := 2;
                                CTF_ReturnFlag(DCTF_FlagReturnFlag.team);
                                CTF_Event_Message(DCTF_FlagReturnFlag.team,'retur');
                                playsound(SND_Flagret,0,0);
                                break;
                        end;
                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if DData.type0 = DDEMO_CTF_GAMESTATE then begin
                                CTF_RedFlagAssign(DCTF_GameState.RedFlagAtBase);
                                CTF_BlueFlagAssign(DCTF_GameState.BlueFlagAtBase);
                                MATCH_REDTEAMSCORE := DCTF_GameState.RedScore;
                                MATCH_BLUETEAMSCORE := DCTF_GameState.BlueScore;
                        end;
                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if DData.type0 = DDEMO_CTF_GAMESTATESCORE then begin
                                MATCH_REDTEAMSCORE := DCTF_GameStateScore.RedScore;
                                MATCH_BLUETEAMSCORE := DCTF_GameStateScore.BlueScore;
                        end;
                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if DData.type0 = DDEMO_CTF_FLAGCARRIER then
                        for d := 0 to 7 do if players[d] <> nil then if players[d].dxid = DCTF_FlagCarrier.DXID then begin
                                players[d].flagcarrier := true;
                                break;
                        end;
                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if DData.type0 = DDEMO_DOM_CAPTURE then
                                DOM_Capture(DDOM_Capture.x, DDOM_Capture.y, DDOM_Capture.team, MMP_DOM_CAPTURE);
                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if DData.type0 = DDEMO_DOM_CAPTUREGAMESTATE then
                                DOM_Capture(DDOM_Capture.x, DDOM_Capture.y, DDOM_Capture.team, MMP_DOM_CAPTUREGAMESTATE);
                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if DData.type0 = DDEMO_DOM_SCORECHANGED then begin
                                MATCH_REDTEAMSCORE := DDOM_ScoreChanges.RedScore;
                                MATCH_BLUETEAMSCORE := DDOM_ScoreChanges.BlueScore;
                        end;
                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if (DData.type0 = DDEMO_WPN_EVENT_WEAPONDROP) or (DData.type0 = DDEMO_WPN_EVENT_WEAPONDROPGAMESTATE) then
                                WPN_DEMO_DropWeapon();
                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if DData.type0 = DDEMO_WPN_EVENT_WEAPONDROP_APPLY then
                        for stp := 0 to 1000 do if (aaa[stp].dead =0) and (aaa[stp].objname = 'weapon') and (aaa[stp].DXID = DCTF_DropFlagApply.DXID) then begin
                                aaa[stp].x := DCTF_DropFlagApply.x;
                                aaa[stp].y := DCTF_DropFlagApply.y;
                                aaa[stp].InertiaX := 0;
                                aaa[stp].InertiaY := 0;
                                break;
                        end;
                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if DData.type0 = DDEMO_WPN_EVENT_PICKUP then
                        for d := 0 to 7 do if players[d] <> nil then if players[d].dxid = DCTF_FlagPickUp.PlayerDXID then begin
                                for stp := 0 to 1000 do if (aaa[stp].dead =0) and (aaa[stp].objname = 'weapon') and (aaa[stp].DXID = DCTF_FlagPickUp.FlagDXID) then begin
                                        WPN_GainWeapon(players[d], aaa[stp].imageindex);
                                        aaa[stp].dead := 2;
                                        playsound(SND_wpkup,players[d].x,players[d].y);
                                        break;
                                end;
                                break;
                        end;
                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if DData.type0 = DDEMO_NEW_SHAFTBEGIN then
                        for d := 0 to 7 do if players[d] <> nil then if players[d].dxid = D_049t4_ShaftBegin.DXID then begin
                                players[d].weapon := C_WPN_SHAFT;
                                players[d].have_sh := true;
                                players[d].ammo_sh := D_049t4_ShaftBegin.ammo;
                                players[d].shaft_state := 0;
                                FireShaftEx(players[d], false);
                                players[d].shaft_state := 1;
                                break;
                        end;
                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if DData.type0 = DDEMO_NEW_SHAFTEND then
                        for d := 0 to 7 do if players[d] <> nil then if players[d].dxid = D_049t4_ShaftEnd.DXID then begin
                                players[d].shaft_state := 0;
//                                addmessage('DDEMO_NEW_SHAFTEND');
                                break;
                        end;
                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if (DData.type0 = DDEMO_POWERUP_EVENT_POWERUPDROP) or (DData.type0 = DDEMO_POWERUP_EVENT_POWERUPDROPGAMESTATE) then begin
                                POWERUP_DEMO_DropPowerup();
                        end;
                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        if DData.type0 = DDEMO_POWERUP_EVENT_PICKUP then
                        for d := 0 to 7 do if players[d] <> nil then if players[d].dxid = DCTF_FlagPickUp.PlayerDXID then begin
                                for stp := 0 to 1000 do if (aaa[stp].dead =0) and (aaa[stp].objname = 'powerup') and (aaa[stp].DXID = DCTF_FlagPickUp.FlagDXID) then begin
                                        POWERUP_GainPowerup(players[d], aaa[stp].dir, aaa[stp].imageindex);
                                        aaa[stp].dead := 2;
                                        POWERUP_Event_Pickup(aaa[stp], players[d]);
                                        break;
                                end;
                                break;
                        end;
                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                        // eof.
                        if DemoStream.Position >= demostream.Size then begin
//                                DemoStream.position := 0;
                                Addmessage('Finished playing demo.');
//                                MATCH_DDEMOPLAY := false;
                                MATCH_GAMEEND := TRUE;
                                Exit;
                                end;
                        //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

                        //read data!
                        DemoStream.read(DData,sizeof(DData));
                        if DData.type0 = DDEMO_FIREROCKET then DemoStream.read(DMissileV2,sizeof(DMissileV2));
//                        if DData.type0 = 2 then DemoStream.read(DPlayerUpdate,sizeof(DPlayerUpdate));
                        if DData.type0 = DDEMO_PLAYERPOSV3 then DemoStream.read(DPlayerUpdateV3,sizeof(DPlayerUpdateV3));
//                        if DData.type0 = DDEMO_PLAYERPOSV2 then DemoStream.read(DPlayerUpdateV2,sizeof(DPlayerUpdateV2));
                        if DData.type0 = DDEMO_FIREGRENV2 then DemoStream.read(DGrenadeFireV2,sizeof(DGrenadeFireV2));
                        if DData.type0 = 3 then DemoStream.read(DImmediateTimeSet,sizeof(DImmediateTimeSet));
                        if DData.type0 = DDEMO_CREATEPLAYER then DemoStream.read(DSpawnPlayer,sizeof(DSpawnPlayer));
                        if DData.type0 = DDEMO_CREATEPLAYERV2 then DemoStream.read(DSpawnPlayerV2,sizeof(DSpawnPlayerV2));
                        if DData.type0 = 5 then DemoStream.read(DDXIDKill,sizeof(DDXIDKill));
                        if DData.type0 = DDEMO_FIREBFG then DemoStream.read(DMissileV2,sizeof(DMissileV2));
                        if DData.type0 = 7 then DemoStream.read(DMissile,sizeof(DMissile));
                        if DData.type0 = DDEMO_FIREPLASMAV2 then DemoStream.read(DMissileV2,sizeof(DMissileV2));
                        if(DData.type0 >= 8) and (DData.type0 <= 12) then DemoStream.read(DVectorMissile,sizeof(DVectorMissile));
                        if(DData.type0 >= DDEMO_ITEMDISSAPEAR) and (DData.type0 <= DDEMO_ITEMAPEAR) then DemoStream.read(DItemDissapear,sizeof(DItemDissapear));
                        if DData.type0 = DDEMO_DAMAGEPLAYER then DemoStream.read(DDamagePlayer,sizeof(DDamagePlayer));
                        if DData.type0 = DDEMO_HAUPDATE then DemoStream.read(DPlayerHAUpdate,sizeof(DPlayerHAUpdate));
                        if DData.type0 = DDEMO_JUMPSOUND then DemoStream.read(DPlayerJump,sizeof(DPlayerJump));
                        if DData.type0 = DDEMO_FLASH then DemoStream.read(DRespawnFlash,sizeof(DRespawnFlash));
                        if DData.type0 = DDEMO_GAMEEND then DemoStream.read(DGameEnd,sizeof(DGameEnd));
                        if DData.type0 = DDEMO_RESPAWNSOUND then DemoStream.read(DRespawnSound,sizeof(DRespawnSound));
                        if DData.type0 = DDEMO_LAVASOUND then DemoStream.read(DLavaSound,sizeof(DLavaSound));
                        if DData.type0 = DDEMO_POWERUPSOUND then DemoStream.read(DPowerUpSound,sizeof(DPowerUpSound));
                        if DData.type0 = DDEMO_JUMPPADSOUND then DemoStream.read(DJumppadSound,sizeof(DJumppadSound));
                        if DData.type0 = DDEMO_EARNPOWERUP then DemoStream.read(DEarnPowerup,sizeof(DEarnPowerup));
                        if DData.type0 = DDEMO_FLIGHTSOUND then DemoStream.read(DFlightSound,sizeof(DFlightSound));
                        if DData.type0 = DDEMO_NOAMMOSOUND then DemoStream.read(DNoAmmoSound,sizeof(DNoAmmoSound));
                        if DData.type0 = DDEMO_EARNREWARD then DemoStream.read(DEarnReward,sizeof(DEarnReward));
                        if DData.type0 = DDEMO_READYPRESS then DemoStream.read(DReadyPress,sizeof(DReadyPress));
//                        if DData.type0 = DDEMO_STATS then DemoStream.read(DStats,sizeof(DStats));
  //                      if DData.type0 = DDEMO_STATS2 then DemoStream.read(DStats2,sizeof(DStats2));
                        if DData.type0 = DDEMO_STATS3 then DemoStream.read(DStats3,sizeof(DStats3));
                        if DData.type0 = DDEMO_GAMESTATE then DemoStream.read(DGameState,sizeof(DGameState));
                        if DData.type0 = DDEMO_TRIXARENAEND then DemoStream.read(DTrixArenaEnd,sizeof(DTrixArenaEnd));
                        if DData.type0 = DDEMO_OBJCHANGESTATE then DemoStream.read(DObjChangeState,sizeof(DObjChangeState));
                        if DData.type0 = DDEMO_CORPSESPAWN then DemoStream.read(DCorpseSpawn,sizeof(DCorpseSpawn));
                        if DData.type0 = DDEMO_GRENADESYNC then DemoStream.read(DGrenadeSync,sizeof(DGrenadeSync));
                        if DData.type0 = DDEMO_GAUNTLETSTATE then DemoStream.read(DGauntletState,sizeof(DGauntletState));
                        if DData.type0 = DDEMO_BUBBLE then DemoStream.read(DBubble,sizeof(DBubble));

                        // multiplayer addons.
                        if DData.type0 = DDEMO_MPSTATE then DemoStream.read(DMultiplayer,sizeof(DMultiplayer));
                        if DData.type0 = DDEMO_NETRAIL then DemoStream.read(DNetRail,sizeof(DNetRail));
                        if DData.type0 = DDEMO_NETPARTICLE then DemoStream.read(DNetShotParticle,sizeof(DNetShotParticle));
                        if DData.type0 = DDEMO_NETTIMEUPDATE then DemoStream.read(DNETTimeUpdate,sizeof(DNETTimeUpdate));
                        if DData.type0 = DDEMO_NETSVMATCHSTART then DemoStream.read(DNETSV_MatchStart,sizeof(DNETSV_MatchStart));
                        if DData.type0 = DDEMO_DROPPLAYER then DemoStream.read(DNETKickDropPlayer,sizeof(DNETKickDropPlayer));
                        if DData.type0 = DDEMO_SPECTATORDISCONNECT then DemoStream.read(DNETSpectator,sizeof(DNETSpectator));
                        if DData.type0 = DDEMO_SPECTATORCONNECT then DemoStream.read(DNETSpectator,sizeof(DNETSpectator));
                        if DData.type0 = DDEMO_GENERICSOUNDDATA then DemoStream.read(DNETSoundData,sizeof(DNETSoundData));
                        if DData.type0 = DDEMO_GENERICSOUNDSTATDATA then DemoStream.read(DNETSoundStatData,sizeof(DNETSoundStatData));
                        if DData.type0 = DDEMO_CHATMESSAGE then DemoStream.read(DNETCHATMessage,sizeof(DNETCHATMessage));
                        if DData.type0 = DDEMO_PLAYERRENAME then DemoStream.read(DNETNameModelChange,sizeof(DNETNameModelChange));
                        if DData.type0 = DDEMO_PLAYERMODELCHANGE then DemoStream.read(DNETNameModelChange,sizeof(DNETNameModelChange));
                        if DData.type0 = DDEMO_TEAMSELECT then DemoStream.read(DNETTeamSelect,sizeof(DNETTeamSelect));
                        if DData.type0 = DDEMO_CTF_EVENT_FLAGTAKEN then DemoStream.read(DCTF_FlagTaken,sizeof(DCTF_FlagTaken));
                        if DData.type0 = DDEMO_CTF_EVENT_FLAGCAPTURE then DemoStream.read(DCTF_FlagCapture,sizeof(DCTF_FlagCapture));
                        if DData.type0 = DDEMO_CTF_EVENT_FLAGDROP then DemoStream.read(DCTF_DropFlag,sizeof(DCTF_DropFlag));
                        if DData.type0 = DDEMO_CTF_EVENT_FLAGDROPGAMESTATE then DemoStream.read(DCTF_DropFlag,sizeof(DCTF_DropFlag));
                        if DData.type0 = DDEMO_CTF_EVENT_FLAGDROP_APPLY then DemoStream.read(DCTF_DropFlagApply,sizeof(DCTF_DropFlagApply));
                        if DData.type0 = DDEMO_CTF_EVENT_FLAGPICKUP then DemoStream.read(DCTF_FlagPickUp,sizeof(DCTF_FlagPickUp));
                        if DData.type0 = DDEMO_CTF_EVENT_FLAGRETURN then DemoStream.read(DCTF_FlagReturnFlag,sizeof(DCTF_FlagReturnFlag));
                        if DData.type0 = DDEMO_CTF_GAMESTATE then DemoStream.read(DCTF_GameState,sizeof(DCTF_GameState));
                        if DData.type0 = DDEMO_CTF_GAMESTATESCORE then DemoStream.read(DCTF_GameStateScore,sizeof(DCTF_GameStateScore));
                        if DData.type0 = DDEMO_CTF_FLAGCARRIER then DemoStream.read(DCTF_FlagCarrier,sizeof(DCTF_FlagCarrier));
                        if DData.type0 = DDEMO_DOM_CAPTURE then DemoStream.read(DDOM_Capture,sizeof(DDOM_Capture));
                        if DData.type0 = DDEMO_DOM_CAPTUREGAMESTATE then DemoStream.read(DDOM_Capture,sizeof(DDOM_Capture));
                        if DData.type0 = DDEMO_DOM_SCORECHANGED then DemoStream.read(DDOM_ScoreChanges,sizeof(DDOM_ScoreChanges));
                        if DData.type0 = DDEMO_WPN_EVENT_WEAPONDROP then DemoStream.read(DWPN_DropWeapon,sizeof(DWPN_DropWeapon));
                        if DData.type0 = DDEMO_WPN_EVENT_WEAPONDROPGAMESTATE then DemoStream.read(DWPN_DropWeapon,sizeof(DWPN_DropWeapon));
                        if DData.type0 = DDEMO_WPN_EVENT_WEAPONDROP_APPLY then DemoStream.read(DCTF_DropFlagApply,sizeof(DCTF_DropFlagApply));
                        if DData.type0 = DDEMO_WPN_EVENT_PICKUP then DemoStream.read(DCTF_FlagPickUp,sizeof(DCTF_FlagPickUp));
                        if DData.type0 = DDEMO_NEW_SHAFTBEGIN then DemoStream.read(D_049t4_ShaftBegin,sizeof(D_049t4_ShaftBegin));
                        if DData.type0 = DDEMO_NEW_SHAFTEND then DemoStream.read(D_049t4_ShaftEnd,sizeof(D_049t4_ShaftEnd));

                        if DData.type0 = DDEMO_POWERUP_EVENT_POWERUPDROP then DemoStream.read(DPOWERUP_DropPowerup,sizeof(DPOWERUP_DropPowerup));
                        if DData.type0 = DDEMO_POWERUP_EVENT_POWERUPDROPGAMESTATE then DemoStream.read(DPOWERUP_DropPowerup,sizeof(DPOWERUP_DropPowerup));
                        if DData.type0 = DDEMO_POWERUP_EVENT_PICKUP then DemoStream.read(DCTF_FlagPickUp,sizeof(DCTF_FlagPickUp));
//                        addmessage('DemoEngine type0='+inttostr(DData.type0));

        end;

// =================================================== \\
// Recording
// =================================================== \\
         if MATCH_DRECORD then                          // health \ armor update.
         if (gametic div SYS_DEMOUPDATESPEED = gametic / SYS_DEMOUPDATESPEED) then
         for stp := 0 to 7 do if players[stp] <> nil then begin
         if (players[stp].LHealth <> round(players[stp].health)) or
            (players[stp].LFrags <> round(players[stp].frags)) or
            (players[stp].Larmor <> round(players[stp].armor)) then begin
                DData.type0 := DDEMO_HAUPDATE;
                DData.gametic := gametic;
                DData.gametime := gametime;
                DemoStream.Write( DData, Sizeof(DData));
                DPlayerHAUpdate.DXID := players[stp].DXID;
                DPlayerHAUpdate.health := players[stp].health;
                DPlayerHAUpdate.armor := players[stp].armor;
                DPlayerHAUpdate.frags := players[stp].frags;
                DemoStream.Write( DPlayerHAUpdate, Sizeof(DPlayerHAUpdate));
                players[stp].LHealth := players[stp].health;
                players[stp].LArmor := players[stp].armor;
                players[stp].LFrags := players[stp].frags;
         end;
         end;

        if MATCH_DRECORD then
        for stp := 0 to 7 do begin
        if players[stp] <> nil then
         if (gametic div 2 = gametic / 2) then
         if     (players[stp].Lx <> round(players[stp].x)) or
                (players[stp].Ly <> round(players[stp].y)) or
                (players[stp].LInertiaX <> round(players[stp].InertiaX)) or
                (players[stp].LInertiaY <> round(players[stp].InertiaY)) or
                (players[stp].Ldir <> players[stp].dir) or
//                (players[stp].Lframe <> players[stp].frame) or
                (players[stp].Ldead  <> players[stp].dead) or
                (players[stp].Lwpn  <> players[stp].weapon) or
                (players[stp].LCrouch <> players[stp].Crouch) or
                (players[stp].Lballoon <> players[stp].Balloon) or
                (players[stp].Lwpnang <> trunc(players[stp].fangle)) then begin

//              DDEMO NEW FORMAT!
                DData.type0 := DDEMO_PLAYERPOSV3;
                DData.gametic := gametic;
                DData.gametime := gametime;
                DPlayerUpdateV3.DXID := round(players[stp].dxid);
                DPlayerUpdateV3.x := players[stp].x;
                DPlayerUpdateV3.y := players[stp].y;
                DPlayerUpdateV3.inertiax  := players[stp].inertiax;
                DPlayerUpdateV3.Inertiay := players[stp].inertiay;
                DPlayerUpdateV3.PUV3 := 0;
                DPlayerUpdateV3.PUV3B := 0;
                if players[stp].dir=0 then DPlayerUpdateV3.PUV3 := DPlayerUpdateV3.PUV3 + PUV3_DIR0;
                if players[stp].dir=1 then DPlayerUpdateV3.PUV3 := DPlayerUpdateV3.PUV3 + PUV3_DIR1;
                if players[stp].dir=2 then DPlayerUpdateV3.PUV3 := DPlayerUpdateV3.PUV3 + PUV3_DIR2;
                if players[stp].dir=3 then DPlayerUpdateV3.PUV3 := DPlayerUpdateV3.PUV3 + PUV3_DIR3;
                if players[stp].dead=0 then DPlayerUpdateV3.PUV3 := DPlayerUpdateV3.PUV3 + PUV3_DEAD0;
                if players[stp].dead=1 then DPlayerUpdateV3.PUV3 := DPlayerUpdateV3.PUV3 + PUV3_DEAD1;
                if players[stp].dead=2 then DPlayerUpdateV3.PUV3 := DPlayerUpdateV3.PUV3 + PUV3_DEAD2;
                if players[stp].weapon=0 then DPlayerUpdateV3.PUV3 := DPlayerUpdateV3.PUV3 + PUV3_WPN0;
                if players[stp].weapon=1 then DPlayerUpdateV3.PUV3 := DPlayerUpdateV3.PUV3 + PUV3_WPN1;
                if players[stp].weapon=2 then DPlayerUpdateV3.PUV3 := DPlayerUpdateV3.PUV3 + PUV3_WPN2;
                if players[stp].weapon=3 then DPlayerUpdateV3.PUV3 := DPlayerUpdateV3.PUV3 + PUV3_WPN3;
                if players[stp].weapon=4 then DPlayerUpdateV3.PUV3 := DPlayerUpdateV3.PUV3 + PUV3_WPN4;
                if players[stp].weapon=5 then DPlayerUpdateV3.PUV3 := DPlayerUpdateV3.PUV3 + PUV3_WPN5;
                if players[stp].weapon=6 then DPlayerUpdateV3.PUV3 := DPlayerUpdateV3.PUV3 + PUV3_WPN6;
                if players[stp].weapon=7 then DPlayerUpdateV3.PUV3 := DPlayerUpdateV3.PUV3 + PUV3_WPN7;
                if players[stp].weapon=8 then DPlayerUpdateV3.PUV3B := DPlayerUpdateV3.PUV3B + PUV3B_WPN8;
                if players[stp].crouch then DPlayerUpdateV3.PUV3B := DPlayerUpdateV3.PUV3B + PUV3B_CROUCH;
                if players[stp].balloon then DPlayerUpdateV3.PUV3B := DPlayerUpdateV3.PUV3B + PUV3B_BALLOON;

                DPlayerUpdateV3.wpnang := trunc(players[stp].fangle);
                        case players[stp].weapon of
                        1 : DplayerUpdateV3.currammo := players[stp].ammo_mg;
                        2 : DplayerUpdateV3.currammo := players[stp].ammo_sg;
                        3 : DplayerUpdateV3.currammo := players[stp].ammo_gl;
                        4 : DplayerUpdateV3.currammo := players[stp].ammo_rl;
                        5 : DplayerUpdateV3.currammo := players[stp].ammo_sh;
                        6 : DplayerUpdateV3.currammo := players[stp].ammo_rg;
                        7 : DplayerUpdateV3.currammo := players[stp].ammo_pl;
                        8 : DplayerUpdateV3.currammo := players[stp].ammo_bfg;
                        else DplayerUpdateV3.currammo := 0;
                        end;
                DemoStream.Write( DData, Sizeof(DData));
                DemoStream.Write( DPlayerUpdateV3, Sizeof(DPlayerUpdateV3));

                players[stp].Lx := round(players[stp].x);
                players[stp].Ly := round(players[stp].y);
                players[stp].LInertiaX := round(players[stp].InertiaX);
                players[stp].LInertiaY := round(players[stp].InertiaY);
                players[stp].Ldir := players[stp].dir;
                players[stp].Ldead := players[stp].dead;
                players[stp].Lwpn := players[stp].weapon;
                players[stp].LCrouch := players[stp].crouch;
                players[stp].Lballoon := players[stp].balloon;
                players[stp].Lwpnang := trunc(players[stp].fangle);
        end;
        end;
end;

Function IsItemRespawned(i,a : byte) : boolean;
var
    msg: TMP_ItemAppear;
    msg2: TMP_XYSoundData;
    msgsize: word;
begin

  if (bbb[i,a].image >= 23) and (bbb[i,a].image <= 28) and (ismultip<2) and (OPT_SV_POWERUP=false) then begin result := false; exit; end;


  if bbb[i,a].respawntime = 1 then bbb[i,a].scale := 0;

  if bbb[i,a].respawntime = 1 then
  if ismultip = 1 then begin    // send data: item appear;
                MsgSize := SizeOf(TMP_ItemAppear);
                Msg.DATA := MMP_ITEMAPPEAR;
                Msg.x := i; Msg.y := a;
                mainform.BNETSendData2All (Msg, MsgSize, 1);
  end;

  if MATCH_DRECORD then begin
          if bbb[i,a].respawntime = 1 then begin
                DData.type0 := DDEMO_ITEMAPEAR;
                DData.gametic := gametic;
                DData.gametime := gametime;
                DItemDissapear.x := i;
                DItemDissapear.y := a;
                DItemDissapear.i := bbb[i,a].image;
                DemoStream.Write( DData, Sizeof(DData));
                DemoStream.Write( DItemDissapear, Sizeof(DItemDissapear));
          end;
  end;

  if ismultip =2 then begin
        if (bbb[i,a].respawntime > 0) then begin result := false; exit; end;
        result := true; exit;
  end;


  if MATCH_DDEMOPLAY then begin
        if (bbb[i,a].respawntime > 0) then begin result := false; exit; end;
        result := true; exit;
  end;


  if bbb[i,a].respawntime > 0 then begin
        dec(bbb[i,a].respawntime);
        if (bbb[i,a].respawntime = 50) then begin
                if (bbb[i,a].image >= 23) and (bbb[i,a].image <= 28) then begin
                       playsound(SND_poweruprespawn,i*32,a*16);

                       if ismultip=1 then begin
                                MsgSize := SizeOf(TMP_XYSoundData);
                                Msg2.Data := MMP_XYSOUND;
                                Msg2.SoundType := 0;
                                Msg2.x := i;
                                Msg2.y := a;
                                mainform.BNETSendData2All (Msg2, MsgSize, 0);
                       end;


                       if MATCH_DRECORD then begin
                              DData.type0 := DDEMO_POWERUPSOUND;
                              DData.gametic := gametic;
                              DData.gametime := gametime;
                              DPowerUpSound.x := round(i*32);
                              DPowerUpSound.y := round(a*16);
                              DemoStream.Write( DData, Sizeof(DData));
                              DemoStream.Write( DPowerUpSound, Sizeof(DPowerUpSound));
                       end;

                end;
        end;
        result := false;
        exit;
  end;
        result := true;
end;


procedure SV_MatchStart;
var  msg: TMP_SV_MatchStart;
  msgsize: word;
  var i : byte;
begin
        MsgSize := SizeOf(TMP_SV_MatchStart);
        Msg.DATA := MMP_MATCHSTART;
        Msg.gameend :=false;
        mainform.BNETSendData2All (Msg, MsgSize, 1);
        for i := 0 to 7 do if players[i] <> nil then if
        players[i].netobject then players[i].justrespawned := 25; // avoiding post respawn items pickup bug.
end;


procedure SV_PrepareToMatch;
VAR
  msg: TMP_Warmupis2;
  msgsize: word;
  i : byte;
//  i, a : word;
begin
        for i := 0 to 7 do if players[i] <> nil then if (players[i].team >= 2) and (players[i].netobject = false) then begin
             HIST_DISABLE := TRUE;
             APPLYHCommand('join auto #auto');
             HIST_DISABLE := false;
             break;
        end;

        MsgSize := SizeOf(TMP_Warmupis2);
        Msg.DATA := MMP_WARMUPIS2;
        mainform.BNETSendData2All (Msg, MsgSize, 1);
end;

function LinearInterPolation(one, two : real; smooth: byte) : word;
begin
if one=two then begin
        result := round(two);
        exit;
        end;

if (round(two - one)) div smooth=0 then begin
        result := round(two);
        exit;
        end;


result := round(one + (round(two - one)) div smooth);

end;

procedure ScreenShot();
var counter:integer;
   filename: string;
   avidemoz:TBitmap;
   DC:HDC;
   JPG:TJpegImage;
   WH,HH:word;
   ext:string[4];
begin

if OPT_CL_AVIMODE=false then begin// jpeg output.
        JPG := TJpegimage.create;
        ext := '.jpg';
        end else ext := '.bmp';
avidemoz := TBitmap.create;
if mainform.PowerGraph.FullScreen = true then begin
        WH := 640;
        HH := 480;
        end else begin
                WH:= mainform.Width;
                HH:= mainform.Height;
        end;
avidemoz.Width := WH;
avidemoz.Height := HH;
DC := GetDC( GetDesktopWindow );
BitBlt( avidemoz.Canvas.Handle, 0, 0, WH, HH, DC, 0, 0, SRCCOPY);
ReleaseDC( GetDesktopWindow, DC );

repeat
filename := inttostr(OPT_AVIDEMOC);
if OPT_AVIDEMOC < 10 then filename := '0'+filename;
if OPT_AVIDEMOC < 100 then filename := '0'+filename;
if OPT_AVIDEMOC < 1000 then filename := '0'+filename;
inc(OPT_AVIDEMOC);
until not fileexists(ROOTDIR+'\'+filename+ext);
if OPT_CL_AVIMODE=false then // jpeg output
        jpg.assign(avidemoz);
try
        if OPT_CL_AVIMODE=false then
        jpg.SaveToFile(ROOTDIR+'\'+filename+ext) else //jpg
        avidemoz.SaveToFile(ROOTDIR+'\'+filename+ext);//bmp
except addmessage('cl_avidemo error: cant save image... may be out of disk space...');
        OPT_AVIDEMO := false;
        OPT_AVIDEMOC := 0;
        end;
//addmessage('recording...'+ROOTDIR+'\'+filename+'.bmp');
avidemoz.Free;
if OPT_CL_AVIMODE=false then jpg.free;
end;

// -----------------------------------------------------------------------------
function BNETWORK_Players_collective: byte;
var i, z : byte;
begin
        result := 0;
//        exit;


        for i := 0 to high(players) do if (players[i] <> nil) and (players[i].netobject = true) then
        for z := 0 to high(players) do if (players[z] <> nil) and (i <> z) then inc(result);
end;
// -----------------------------------------------------------------------------
function BNETWORK_TMP_PlayerPosUpdate_copy_fill(i : byte) : TMP_PlayerPosUpdate_copy;
begin
        Result.Data := MMP_PLAYERPOSUPDATE_COPY;
        Result.x := players[i].x;
        if players[i].InertiaX< -5 then players[i].InertiaX := -5;
        if players[i].InertiaX> 5 then players[i].InertiaX := 5;
        Result.inertiax := trunc((players[i].inertiax + 5) * 6553.5); // optimiza :)
        Result.DXID := players[i].dxid;
        if players[i].fangle < 0 then players[i].fangle := 360+players[i].fangle;
        Result.wpnang := trunc(players[i].fangle);
        Result.PUV3 := 0;
        Result.PUV3B := 0;
        // NEW PUV3 indefication.
        if players[i].dir=0 then Result.PUV3 := Result.PUV3 + PUV3_DIR0;
        if players[i].dir=1 then Result.PUV3 := Result.PUV3 + PUV3_DIR1;
        if players[i].dir=2 then Result.PUV3 := Result.PUV3 + PUV3_DIR2;
        if players[i].dir=3 then Result.PUV3 := Result.PUV3 + PUV3_DIR3;
        if players[i].dead=0 then Result.PUV3 := Result.PUV3 + PUV3_DEAD0;
        if players[i].dead=1 then Result.PUV3 := Result.PUV3 + PUV3_DEAD1;
        if players[i].dead=2 then Result.PUV3 := Result.PUV3 + PUV3_DEAD2;
        if players[i].weapon=0 then Result.PUV3 := Result.PUV3 + PUV3_WPN0;
        if players[i].weapon=1 then Result.PUV3 := Result.PUV3 + PUV3_WPN1;
        if players[i].weapon=2 then Result.PUV3 := Result.PUV3 + PUV3_WPN2;
        if players[i].weapon=3 then Result.PUV3 := Result.PUV3 + PUV3_WPN3;
        if players[i].weapon=4 then Result.PUV3 := Result.PUV3 + PUV3_WPN4;
        if players[i].weapon=5 then Result.PUV3 := Result.PUV3 + PUV3_WPN5;
        if players[i].weapon=6 then Result.PUV3 := Result.PUV3 + PUV3_WPN6;
        if players[i].weapon=7 then Result.PUV3 := Result.PUV3 + PUV3_WPN7;
        if players[i].weapon=8 then Result.PUV3B := Result.PUV3B + PUV3B_WPN8;
        if players[i].crouch then  Result.PUV3B := Result.PUV3B + PUV3B_CROUCH;
        if players[i].balloon=true then Result.PUV3B := Result.PUV3B + PUV3B_BALLOON;

end;
// -----------------------------------------------------------------------------
function BNETWORK_TMP_PlayerPosUpdate_fill(i : byte) : TMP_PlayerPosUpdate;
begin
        Result.Data := MMP_PLAYERPOSUPDATE;
        Result.x := players[i].x;
        Result.y := players[i].y;

        // bug fix.
        if players[i].InertiaY< -5 then players[i].InertiaY := -5;
        if players[i].InertiaY> 5 then players[i].InertiaY := 5;
        if players[i].InertiaX< -5 then players[i].InertiaX := -5;
        if players[i].InertiaX> 5 then players[i].InertiaX := 5;

        Result.inertiax := trunc((players[i].inertiax + 5) * 6553.5); // optimiza :)
        Result.inertiay := trunc((players[i].inertiay + 5) * 6553.5);
        Result.DXID := players[i].dxid;
        if players[i].fangle < 0 then players[i].fangle := 360+players[i].fangle;
        Result.wpnang := trunc(players[i].fangle);
        Result.PUV3 := 0;
        Result.PUV3B := 0;
        // NEW PUV3 indefication.
        if players[i].dir=0 then Result.PUV3 := Result.PUV3 + PUV3_DIR0;
        if players[i].dir=1 then Result.PUV3 := Result.PUV3 + PUV3_DIR1;
        if players[i].dir=2 then Result.PUV3 := Result.PUV3 + PUV3_DIR2;
        if players[i].dir=3 then Result.PUV3 := Result.PUV3 + PUV3_DIR3;
        if players[i].dead=0 then Result.PUV3 := Result.PUV3 + PUV3_DEAD0;
        if players[i].dead=1 then Result.PUV3 := Result.PUV3 + PUV3_DEAD1;
        if players[i].dead=2 then Result.PUV3 := Result.PUV3 + PUV3_DEAD2;
        if players[i].weapon=0 then Result.PUV3 := Result.PUV3 + PUV3_WPN0;
        if players[i].weapon=1 then Result.PUV3 := Result.PUV3 + PUV3_WPN1;
        if players[i].weapon=2 then Result.PUV3 := Result.PUV3 + PUV3_WPN2;
        if players[i].weapon=3 then Result.PUV3 := Result.PUV3 + PUV3_WPN3;
        if players[i].weapon=4 then Result.PUV3 := Result.PUV3 + PUV3_WPN4;
        if players[i].weapon=5 then Result.PUV3 := Result.PUV3 + PUV3_WPN5;
        if players[i].weapon=6 then Result.PUV3 := Result.PUV3 + PUV3_WPN6;
        if players[i].weapon=7 then Result.PUV3 := Result.PUV3 + PUV3_WPN7;
        if players[i].weapon=8 then Result.PUV3B := Result.PUV3B + PUV3B_WPN8;
        if players[i].crouch then  Result.PUV3B := Result.PUV3B + PUV3B_CROUCH;
        if players[i].balloon=true then Result.PUV3B := Result.PUV3B + PUV3B_BALLOON;
end;
// -----------------------------------------------------------------------------
procedure BNETWORK_Sv_PlayerPosUpdate_packed();
var     Header : TPlayerPosUpdate_Packed;
        i , z : byte;
        totalsize, MsgSize : byte;
        dat, _dat : ^byte;
        Msg : TMP_PlayerPosUpdate;
        Msg2 : TMP_PlayerPosUpdate_copy;
begin
        totalsize := 0;
        Header.DATA := MMP_PLAYERPOSUPDATE_PACKED;
        Header.Count := BNETWORK_Players_collective;
        Getmem(Dat, Header.Count * sizeof(TMP_PlayerPosUpdate) + sizeof(TPlayerPosUpdate_Packed));
        _dat:=dat;
        CopyMemory(_dat, @Header, sizeof(header));
        inc(_dat, sizeof(Header));
        inc(totalsize, sizeof(Header));

        for i := 0 to high(players) do if (players[i] <> nil) and (players[i].netobject = true) then begin

                // combine packed for selected network user.
                for z := 0 to high(players) do if (players[z] <> nil) and (i <> z) then begin
                        if (players[z].inertiaY = players[z].NET_LastInertiaY) and (players[z].Y = players[z].NET_LastPosY) then begin
                                MsgSize := SizeOf(TMP_PlayerPosUpdate_copy);
                                Msg2 := BNETWORK_TMP_PlayerPosUpdate_copy_fill(z);
                                CopyMemory(_dat, @Msg2, MsgSize);
                                inc(_dat, MsgSize);
                                inc(totalsize, MsgSize);
                        end else begin
                                Msg := BNETWORK_TMP_PlayerPosUpdate_fill(z);
                                MsgSize := SizeOf(TMP_PlayerPosUpdate);
                                CopyMemory(_dat, @Msg, MsgSize);
                                inc(_dat, MsgSize);
                                inc(totalsize, MsgSize);
                                players[z].NET_LastInertiaY := players[z].InertiaY;
                                players[z].NET_LastPosY := players[z].Y;
                        end;
                end;
                mainform.BNETSendData2IP_ (players[i].IPAddress, players[i].Port, dat^, totalsize, 0);
        end;
        FreeMem(dat);
end;
// -----------------------------------------------------------------------------
procedure BNETWORK_Approve_MMP_PLAYERPOSUPDATE(var Data : pointer);
var i : byte;
begin
//        if TMP_PlayerPosUpdate(Data^).DATA <> MMP_PLAYERPOSUPDATE then begin
  //              AddMessage('WARNING: incorrect MMP_PLAYERPOSUPDATE');
    //    end;
    for i := 0 to 7 do if (players[i] <> nil) and (players[i].netobject = true) and (players[i].DXID = TMP_PlayerPosUpdate(Data^).DXID) then begin
        players[i].x := TMP_PlayerPosUpdate(Data^).X;
        players[i].y := TMP_PlayerPosUpdate(Data^).Y;
        players[i].inertiax := (TMP_PlayerPosUpdate(Data^).inertiax / 6553.5) - 5;
        players[i].inertiay := (TMP_PlayerPosUpdate(Data^).inertiay / 6553.5) - 5;

        if players[i].health > 0 then begin
                players[i].fangle := TMP_PlayerPosUpdate(Data^).wpnang;
                players[i].netupdated := true;
                players[i].netnosignal := 0;

                if (TMP_PlayerPosUpdate(Data^).PUV3 and PUV3_DIR0)=PUV3_DIR0 then players[i].dir := 0;
                if (TMP_PlayerPosUpdate(Data^).PUV3 and PUV3_DIR1)=PUV3_DIR1 then players[i].dir := 1;
                if (TMP_PlayerPosUpdate(Data^).PUV3 and PUV3_DIR2)=PUV3_DIR2 then players[i].dir := 2;
                if (TMP_PlayerPosUpdate(Data^).PUV3 and PUV3_DIR3)=PUV3_DIR3 then players[i].dir := 3;
                if (TMP_PlayerPosUpdate(Data^).PUV3 and PUV3_DEAD0)=PUV3_DEAD0 then players[i].dead := 0;
                if (TMP_PlayerPosUpdate(Data^).PUV3 and PUV3_DEAD1)=PUV3_DEAD1 then players[i].dead := 1;
                if (TMP_PlayerPosUpdate(Data^).PUV3 and PUV3_DEAD2)=PUV3_DEAD2 then players[i].dead := 2;
                if (TMP_PlayerPosUpdate(Data^).PUV3 and PUV3_WPN0)=PUV3_WPN0 then players[i].weapon := 0;
                if (TMP_PlayerPosUpdate(Data^).PUV3 and PUV3_WPN1)=PUV3_WPN1 then players[i].weapon := 1;
                if (TMP_PlayerPosUpdate(Data^).PUV3 and PUV3_WPN2)=PUV3_WPN2 then players[i].weapon := 2;
                if (TMP_PlayerPosUpdate(Data^).PUV3 and PUV3_WPN3)=PUV3_WPN3 then players[i].weapon := 3;
                if (TMP_PlayerPosUpdate(Data^).PUV3 and PUV3_WPN4)=PUV3_WPN4 then players[i].weapon := 4;
                if (TMP_PlayerPosUpdate(Data^).PUV3 and PUV3_WPN5)=PUV3_WPN5 then players[i].weapon := 5;
                if (TMP_PlayerPosUpdate(Data^).PUV3 and PUV3_WPN6)=PUV3_WPN6 then players[i].weapon := 6;
                if (TMP_PlayerPosUpdate(Data^).PUV3 and PUV3_WPN7)=PUV3_WPN7 then players[i].weapon := 7;
                if (TMP_PlayerPosUpdate(Data^).PUV3B and PUV3B_WPN8)=PUV3B_WPN8 then players[i].weapon := 8;
                if (TMP_PlayerPosUpdate(Data^).PUV3B and PUV3B_CROUCH)=PUV3B_CROUCH then players[i].crouch := true else players[i].crouch := false;
                if (TMP_PlayerPosUpdate(Data^).PUV3B and PUV3B_BALLOON)=PUV3B_BALLOON then players[i].balloon := true else players[i].balloon := false;
        end;

        PredictNetworkPlayerPos(i);
        TestPlayerDead(i);
    exit;
    end;

end;
// -----------------------------------------------------------------------------
procedure BNETWORK_Approve_MMP_PLAYERPOSUPDATE_COPY(Data : pointer);
var i : byte;
begin
    for i := 0 to 7 do if (players[i] <> nil) and (players[i].netobject = true) and (players[i].DXID = TMP_PlayerPosUpdate_copy(Data^).DXID) then begin
        players[i].x := TMP_PlayerPosUpdate_copy(Data^).X;
        players[i].inertiax := (TMP_PlayerPosUpdate_copy(Data^).inertiax / 6553.5) - 5;

        if players[i].health > 0 then begin
                players[i].fangle := TMP_PlayerPosUpdate_copy(Data^).wpnang;
                players[i].netupdated := true;
                players[i].netnosignal := 0;

                if (TMP_PlayerPosUpdate_copy(Data^).PUV3 and PUV3_DIR0)=PUV3_DIR0 then players[i].dir := 0;
                if (TMP_PlayerPosUpdate_copy(Data^).PUV3 and PUV3_DIR1)=PUV3_DIR1 then players[i].dir := 1;
                if (TMP_PlayerPosUpdate_copy(Data^).PUV3 and PUV3_DIR2)=PUV3_DIR2 then players[i].dir := 2;
                if (TMP_PlayerPosUpdate_copy(Data^).PUV3 and PUV3_DIR3)=PUV3_DIR3 then players[i].dir := 3;
                if (TMP_PlayerPosUpdate_copy(Data^).PUV3 and PUV3_DEAD0)=PUV3_DEAD0 then players[i].dead := 0;
                if (TMP_PlayerPosUpdate_copy(Data^).PUV3 and PUV3_DEAD1)=PUV3_DEAD1 then players[i].dead := 1;
                if (TMP_PlayerPosUpdate_copy(Data^).PUV3 and PUV3_DEAD2)=PUV3_DEAD2 then players[i].dead := 2;
                if (TMP_PlayerPosUpdate_copy(Data^).PUV3 and PUV3_WPN0)=PUV3_WPN0 then players[i].weapon := 0;
                if (TMP_PlayerPosUpdate_copy(Data^).PUV3 and PUV3_WPN1)=PUV3_WPN1 then players[i].weapon := 1;
                if (TMP_PlayerPosUpdate_copy(Data^).PUV3 and PUV3_WPN2)=PUV3_WPN2 then players[i].weapon := 2;
                if (TMP_PlayerPosUpdate_copy(Data^).PUV3 and PUV3_WPN3)=PUV3_WPN3 then players[i].weapon := 3;
                if (TMP_PlayerPosUpdate_copy(Data^).PUV3 and PUV3_WPN4)=PUV3_WPN4 then players[i].weapon := 4;
                if (TMP_PlayerPosUpdate_copy(Data^).PUV3 and PUV3_WPN5)=PUV3_WPN5 then players[i].weapon := 5;
                if (TMP_PlayerPosUpdate_copy(Data^).PUV3 and PUV3_WPN6)=PUV3_WPN6 then players[i].weapon := 6;
                if (TMP_PlayerPosUpdate_copy(Data^).PUV3 and PUV3_WPN7)=PUV3_WPN7 then players[i].weapon := 7;
                if (TMP_PlayerPosUpdate_copy(Data^).PUV3B and PUV3B_WPN8)=PUV3B_WPN8 then players[i].weapon := 8;
                if (TMP_PlayerPosUpdate_copy(Data^).PUV3B and PUV3B_CROUCH)=PUV3B_CROUCH then players[i].crouch := true else players[i].crouch := false;
                if (TMP_PlayerPosUpdate_copy(Data^).PUV3B and PUV3B_BALLOON)=PUV3B_BALLOON then players[i].balloon := true else players[i].balloon := false;
        end;

        PredictNetworkPlayerPos(i);
        TestPlayerDead(i);
    exit;
    end;
end;
// -----------------------------------------------------------------------------
// Client parse packeD packeT
procedure BNETWORK_CL_ParsePacked(Data : pointer);
var count, i : byte;
begin
//        AddMessage('BNETWORK_CL_ParsePacked');
        inc(integer(data), 1); // skip DATA
        count := byte(Data^);
        inc(integer(data), 1); // skip COUNT
        for i := 0 to count-1 do
        case byte(Data^) of
        // -------------------------------------------------------------
        MMP_PLAYERPOSUPDATE : begin
                BNETWORK_Approve_MMP_PLAYERPOSUPDATE(Data);
                inc( integer(data), sizeof(TMP_PlayerPosUpdate) );
        end;
        // -------------------------------------------------------------
        MMP_PLAYERPOSUPDATE_COPY : begin
                BNETWORK_Approve_MMP_PLAYERPOSUPDATE_COPY(Data);
                inc( integer(data), sizeof(TMP_PlayerPosUpdate_copy) );
        end;
        // -------------------------------------------------------------
        end;

end;
// -----------------------------------------------------------------------------

procedure BNETWORK_PlayerPosUpdate();
 var i : byte;
 MsgSize: word;
 Msg: TMP_PlayerPosUpdate;
 Msg2: TMP_PlayerPosUpdate_copy;

begin
// exit;

if ismultip=0 then exit;
if ismultip>0 then if netsync > 1 then dec(netsync) else netsync := OPT_SYNC;
if (netsync <> 1) then exit;

        // packed glue. 060
        if (ismultip=1) and (BNETWORK_Players_collective >= 2) then begin
                BNETWORK_Sv_PlayerPosUpdate_packed;
                exit;
        end;


//addmessage('BNETWORK_PlayerPosUpdate');

// 13107
// MMP_PLAYERPOSUPDATE
//        exit;
        for i := 0 to 7 do if (players[i] <> nil) and (players[i].netobject = false) and
        ( (players[i].dead=0) or (players[i].InertiaX<>0) or (players[i].InertiaY<>0) ) then begin
                // Send Self Update.
                if (players[i].inertiaY = players[i].NET_LastInertiaY) and (players[i].Y = players[i].NET_LastPosY) then begin
                        MsgSize := SizeOf(TMP_PlayerPosUpdate_copy);
                        Msg2 := BNETWORK_TMP_PlayerPosUpdate_copy_fill(i);
                        if ismultip=1 then
                        mainform.BNETSendData2All (Msg2, MsgSize, 0) else
                        mainform.BNETSendData2HOST  (Msg2, MsgSize, 0);
                end else begin
                        Msg := BNETWORK_TMP_PlayerPosUpdate_fill(i);
                        MsgSize := SizeOf(TMP_PlayerPosUpdate);
                        if ismultip=1 then
                        mainform.BNETSendData2All (Msg, MsgSize, 0) else
                        mainform.BNETSendData2HOST (Msg, MsgSize, 0);
                        players[i].NET_LastInertiaY := players[i].InertiaY;
                        players[i].NET_LastPosY := players[i].Y;
                end;
        end;
end;
// -------------------------------------------------------------------------
function CanSpectate:boolean;
var i : byte;
begin
        result:=false;
        if not iskey(CTRL_FIRE) then exit;

        for i := 0 to 7 do if players[i] <> nil then
        if (players[i].netobject = false) and (OPT_SV_DEDICATED=false) then exit;

        if ((OPT_NETSPECTATOR) or (OPT_SV_DEDICATED)) or (MATCH_DDEMOMPPLAY > 0) THEN
        if ((SYS_BAR2AVAILABLE=false) or (GetNumberOfPlayers>2) or (opt_cameratype=1) ) and (mapcansel=0) then
        result := true;
end;

// =================== VOTING =======================

function VOTE_Valid(VoteText:String):boolean;
var        s : array[0..2] of string;
begin
        result := false;
        s[0] := strpar(VoteText,0);
        s[1] := strpar(VoteText,1);
        if s[0] = 'restart' then result := true;
        if s[0] = 'ready' then result := true;
        if (s[0] = 'fraglimit') and (s[1] <> '') then result := true;
        if (s[0] = 'timelimit') and (s[1] <> '') then result := true;
        if (s[0] = 'capturelimit') and (s[1] <> '') then result := true;
        if (s[0] = 'domlimit') and (s[1] <> '') then result := true;
        if (s[0] = 'warmup') and (s[1] <> '') then result := true;
        if (s[0] = 'warmuparmor') and (s[1] <> '') then result := true;
        if (s[0] = 'forcerespawn') and (s[1] <> '') then result := true;
        if (s[0] = 'sync') and (s[1] <> '') then result := true;
        if (s[0] = 'sv_teamdamage') and (s[1] <> '') then result := true;
        if (s[0] = 'net_predict') and (s[1] <> '') then result := true;
        if (s[0] = 'sv_maxplayers') and (s[1] <> '') then result := true;
        if (s[0] = 'sv_powerup') and (s[1] <> '') then result := true;
        if (s[0] = 'map') and (s[1] <> '') then result := true;
end;

procedure VOTE_ShowVotesList;
begin
        addmessage('Available ^5VOTES^7:');
        addmessage('^5restart, ready, map, fraglimit, timelimit, capturelimit, domlimit, warmup, sv_powerup,');
        addmessage('^5warmuparmor, forcerespawn, sync, sv_teamdamage, net_predict, sv_maxplayers.');
end;

function VOTE_SV_ValidVote(IP:string; ToPort: word; VoteText : string): boolean;
var     MsgSize : word;
        Msg : TMP_VoteResult;
        s : array[0..2] of string;
begin
        result := false;
        if ismultip<>1 then exit;
        VoteText := lowercase(VoteText);

        s[0] := strpar(VoteText,0);
        s[1] := strpar(VoteText,1);
        s[2] := strpar(VoteText,2);

        if (s[0] = 'restart') and (OPT_SV_ALLOWVOTE_RESTART) then result := true;
        if (s[0] = 'ready') and (OPT_SV_ALLOWVOTE_READY) then result := true;
        if (s[0] = 'fraglimit') and (OPT_SV_ALLOWVOTE_FRAGLIMIT) then result := true;
        if (s[0] = 'timelimit') and (OPT_SV_ALLOWVOTE_TIMELIMIT) then result := true;
        if (s[0] = 'capturelimit') and (OPT_SV_ALLOWVOTE_CAPTURELIMIT) then result := true;
        if (s[0] = 'domlimit') and (OPT_SV_ALLOWVOTE_DOMLIMIT) then result := true;
        if (s[0] = 'warmup') and (OPT_SV_ALLOWVOTE_WARMUP) then result := true;
        if (s[0] = 'warmuparmor') and (OPT_SV_ALLOWVOTE_WARMUPARMOR) then result := true;
        if (s[0] = 'forcerespawn') and (OPT_SV_ALLOWVOTE_FORCERESPAWN) then result := true;
        if (s[0] = 'sync') and (OPT_SV_ALLOWVOTE_SYNC) then result := true;
        if (s[0] = 'sv_teamdamage') and (OPT_SV_ALLOWVOTE_SV_TEAMDAMAGE) then result := true;
        if (s[0] = 'net_predict') and (OPT_SV_ALLOWVOTE_NET_PREDICT) then result := true;
        if (s[0] = 'sv_maxplayers') and (OPT_SV_ALLOWVOTE_SV_MAXPLAYERS) then result :=true;
        if (s[0] = 'sv_powerup') and (OPT_SV_ALLOWVOTE_SV_POWERUP) then result := true;
        if (s[0] = 'map') and (OPT_SV_ALLOWVOTE_MAP) then begin
                if MAPExists(s[1], 0) then
                result := true;
                end;

        if not OPT_SV_ALLOWVOTE then result := false;
        if SVVOTE.voteActive then result := false;

        if result = false then begin
                MsgSize := SizeOf(TMP_VoteResult);
                Msg.Data := MMP_VOTERESULT;
                Msg.Result := 1; // you vote not accepted
                mainform.BNETSendData2IP_ (IP, ToPort, Msg, MsgSize, 1);
        end;

end;

procedure VOTE_SV_Start_ClientVote(VoterDXID:word;VoteText:string);
var     i : byte;
begin
        SVVOTE.voteActive := true;
        SVVOTE.voteString := VoteText;
        SVVOTE.voteTimedOut := GetTickCount+1000*30; // vote time
        SVVOTE.voted := false;
        SVVOTE.votesPERCENT := OPT_SV_VOTE_PERCENT;

        for i := 0 to 7 do if players[i] <> nil then
        if players[i].DXID = VoterDXID then
        if players[i].netobject=false then SVVOTE.voted := true;

        if ismultip=1 then
        for i := 0 to 7 do if players[i] <> nil then begin
                players[i].Vote := 0; // not voted yet.
                if players[i].DXID = VoterDXID then
                        players[i].Vote := 1; // VOTE YES
        end;
        playsound(SND_vote,0,0);
end;

procedure VOTE_Start(VoteText:String;VoterDXID:word);
var     i : byte;
        MsgSize : word;
        Msg : TMP_StartVote;
begin
        if (ismultip=0) or (MATCH_DDEMOPLAY) then begin
                addmessage('^5VOTE ^7aborted: voting ability only for multiplayer.');
                exit;
        end;
        if GetNumberOfPlayers=0 then begin
                addmessage('^5VOTE ^7aborted: Not enough players for voting.');
                exit;
        end;

        if not VOTE_Valid(VoteText) then begin
                addmessage('^5VOTE ^7aborted: ^5'+VoteText+' ^7is not a valid vote.');
                VOTE_ShowVotesList;
                exit;
        end;
        if VoterDXID=0 then begin
                addmessage('^5VOTE ^7aborted: You can''t call a vote');
                exit;
        end;

        // server calls a vote
        if ismultip=1 then begin
                SVVOTE.voteActive := true;
                SVVOTE.voteString := VoteText;
                SVVOTE.voteTimedOut := GetTickCount+1000*30; // vote time
                SVVOTE.voted := true;
                SVVOTE.votesPERCENT := OPT_SV_VOTE_PERCENT;

                for i := 0 to 7 do if players[i] <> nil then begin
                        players[i].Vote := 0; // not voted yet.
                        if players[i].DXID = VoterDXID then players[i].Vote := 1; // VOTE YES
                        if players[i].idd = 2 then players[i].Vote := 1; // BOT VOTE YES
                end;

                MsgSize := SizeOf(TMP_StartVote);
                Msg.Data := MMP_STARTVOTE;
                Msg.DXID := MYDXIDIS;
                Msg.VoteText := VoteText;
                mainform.BNETSendData2All (Msg, MsgSize, 1);

        end else begin // client call a vote;
                MsgSize := SizeOf(TMP_StartVote);
                Msg.Data := MMP_STARTVOTE;
                Msg.DXID := MYDXIDIS;
                Msg.VoteText := VoteText;
                SVVOTE.voted := true;
                mainform.BNETSendData2HOST (Msg, MsgSize, 1);
        end;
        if ismultip=1 then addmessage(MyNameIS+' ^7^ncalled a ^5VOTE^7: ^5'+VoteText);
        if ismultip=1 then playsound(SND_vote,0,0);
end;

procedure VOTE_ClearVote;
var i : byte;
begin
        SVVOTE.voteActive := false;
        SVVOTE.voteString := '';
        SVVOTE.voteTimedOut := 0;
        SVVOTE.voted := false;
        SVVOTE.votesPERCENT := 0;
        for i := 0 to 7 do if players[i] <> nil then
                players[i].Vote := 0; // nobody vote.

end;

procedure VOTE_CancelVote;
var
        MsgSize : word;
        Msg : TMP_VoteResult;
begin
        if ismultip<>1 then exit;
        VOTE_ClearVote;
        if inmenu=false then addmessage('^5VOTE ^7Cancelled...');

        MsgSize := SizeOf(TMP_VoteResult);
        Msg.Data := MMP_VOTERESULT;
        Msg.Result := 2; // you vote not accepted
        mainform.BNETSendData2All (Msg, MsgSize, 1);
        // SEND NETWORK PACKET HERE
end;

procedure VOTE_ApplyVote;
var     MsgSize : word;
        Msg : TMP_VoteResult;
begin
        if inmenu=false then addmessage('^5VOTE ^7Passed (^5'+SVVOTE.voteString+'^7)');
        ApplyHCommand(SVVOTE.voteString);

        SVVOTE.voteActive := false;
        SVVOTE.voteString := '';
        SVVOTE.voteTimedOut := 0;

        MsgSize := SizeOf(TMP_VoteResult);
        Msg.Data := MMP_VOTERESULT;
        Msg.Result := 3; // vote passed
        mainform.BNETSendData2All (Msg, MsgSize, 1);
end;

procedure VOTE_TestVote;
var YES,NO,PL,i : byte;
begin
        YES:=0;
        NO:=0;
        PL := GetNumberOfPlayers;

        if pl=0 then begin
                VOTE_CancelVote;
                exit;
        end;

        for i := 0 to 7 do if players[i] <> nil then begin
                if players[i].Vote = 1 then inc(YES) else
                if players[i].Vote = 2 then inc(NO);
        end;

//        addmessage('YES:'+inttostr(YES)+'  NO:'+inttostr(NO) + ' %'+inttostr((YES*100) div pl));

        if SVVOTE.votesPERCENT <= ((YES*100) div pl) then VOTE_ApplyVote else
        if ((NO*100) div pl) >= (((PL-NO)*100) div pl) then VOTE_CancelVote else
        if (YES+NO=PL) then VOTE_CancelVote; // everybody voted..


end;

procedure VOTE_VOTE(vote_:byte);
var     MsgSize : word;
        Msg : TMP_Vote;
        i : byte;
begin
        if SVVOTE.voteActive = false then exit;
        if inmenu then exit;
        if ismultip=0 then exit;
        if SVVOTE.voted = true then begin
                addmessage('You already voted..');
                exit;
                end;

        SVVOTE.voted := true;
        if ismultip=1 then
        for i := 0 to 7 do if players[i] <> nil then begin
                if players[i].netobject = false then
                        players[i].Vote := vote_;
                // Bots are vote vote_, as server.
                end;

        MsgSize := SizeOf(TMP_Vote);
        Msg.Data := MMP_VOTE;
        Msg.VOTE := vote_;
        Msg.DXID := MYDXIDIS;
        if ismultip=2 then mainform.BNETSendData2HOST (Msg, MsgSize, 1) else
        if ismultip=1 then mainform.BNETSendData2All (Msg, MsgSize, 1);

        if vote_=1 then addmessage(MyNameIS + ' ^7^nvoted ^5YES');
        if vote_=2 then addmessage(MyNameIS + ' ^7^nvoted ^5NO');
end;

// =============================================================================

procedure RCON_Send(text:string);
var buf : array [0..$FE] of byte;
    p : pointer;
    str : string;
    msgsize : integer;
begin
        if ismultip<2 then begin
                addmessage('Only clients can use rcon');
                exit;
        end;
        if OPT_RCON_PASSWORD='' then begin
                addmessage('No rcon password set');
                exit;
        end;

        p := @buf;
        AddByte(p, MMP_RCON_MESSAGE);
        AddByte(p, 0); // TRY
        str := OPT_RCON_PASSWORD+#13+text;
        AddString(p, str);
        msgsize := Length(str)+3;
        mainform.BNETSendData2HOST (buf, MsgSize, 1);
//        addmessage('send '+str);
end;

// =============================================================================
procedure RCON_Answer(cmd, ip:string; port:word);
var buf : array [0..$FE] of byte;
    p : pointer;
begin
        p := @buf;
        AddByte(p, MMP_RCON_ANSWER);
        AddByte(p, 0); // TRY
        AddString(p, cmd);
        mainform.BNETSendData2IP_(ip,port,buf, Length(cmd)+3, 1);
end;
// =============================================================================
procedure RCON_Recv(Typ : byte; cmd, FromIP : string; FromPort : word);
var ps, cm : string;
        poss, i : byte;
        ts : TStringList;
        curpos : word;
begin
        poss := pos(#13, cmd);

        // Rcon not accepted
        if lowercase(copy(cmd,1, poss-1)) <> lowercase(OPT_RCON_PASSWORD) then begin
                RCON_Answer('Invalid rcon password or server''s rcon is not set.',FromIp, FromPort);
                exit;
        end;

        // Rcon accepted
        cm := copy(cmd,poss+1, length(cmd)-poss+1);
        curpos := conmsg.count;
        ApplyCommand(cm);

        if conmsg.count < curpos then exit; // list becomes less!!?

        ts := TStringList.Create;
        cm:=lowercase(cm);


        if curpos <= conmsg.count then begin
                if conmsg.count-curpos-2 <= 0 then begin
                        exit;
                        ts.Free;
                end;

                for i := 0 to conmsg.count-curpos-2 do begin   // error
//                if lowercase(conmsg[i]) = cm then break;
                ts.add(conmsg[i]);
                end;
        end;

        if ts.count <> conmsg.count then
        if ts.count > 0 then
        for i := ts.count-1 downto 0 do RCON_Answer(ts[i],FromIp, FromPort);

        ts.Free;
end;
// =============================================================================

procedure ReSortScoreBoard;
var ts : TStringList;
    i, find : byte;
    str : string;
begin
        ts := TStringList.Create;
        scoreboard_ts.clear;

        for i := 0 to 7 do
        if players[i] <> nil then begin
                ts.add(inttostr(players[i].frags));
                players[i].loadframe := 0; // not sorted yet
                end;

        if ts.count=0 then exit; // :) i found this bug, when i was playing with some guy, with ping around 3000, but its does not matter :)

        ts.CustomSort(CUSTOMSORT_PL);

        for i := 0 to ts.count-1 do
        for find := 0 to 7 do
                if players[find] <> nil then
                if (inttostr(players[find].frags) = ts[i]) and (players[find].loadframe = 0) then begin
                        scoreboard_ts.add(inttostr(players[find].DXID));
                        ts[i] := '-999';
                        players[find].loadframe := 1;
                        break;
                end;
        ts.free;
end;

// ================================
procedure DrawQWScoreBoard;
var     i,b,z, spectadd:byte;
        maxnickname_length  : word;
        tmp : word;
        time_ :cardinal;
        sz : array[0..3] of word; // positions. ping, frags, name, TOP, LEFT
        aph : cardinal;
begin
        // Detect ScoreBoardSizes;
        maxnickname_length := 50;
        if scoreboard_ts.count >=1 then
        for b := 0 to scoreboard_ts.count-1 do
        for i:=0 to 7 do if players[i]<> nil then
        if players[i].dxid = strtoint(scoreboard_ts[b]) then begin
                tmp := GetColorTextWidth (players[i].netname,1);
                if tmp > maxnickname_length then
                        maxnickname_length := tmp;
                end;


        maxnickname_length := maxnickname_length + 120;
        sz[0] := mainform.PowerGraph.width div 2 - (maxnickname_length) div 2;
        sz[1] := mainform.PowerGraph.width div 2 - (maxnickname_length + 40) div 2;
        sz[2] := mainform.PowerGraph.width div 2 + maxnickname_length;
        // Rect
        sz[3] := mainform.PowerGraph.Height div 3 - (scoreboard_ts.count * 16) div 2;

        spectadd := SpectatorList.count * 16;

        mainform.PowerGraph.Rectangle(
        sz[0]-10,
        sz[3] - 16,
        maxnickname_length+20,
        (scoreboard_ts.count * 16)+18 + spectadd,
        $FF000000, $88000000,2 or $100);

        mainform.PowerGraph.Line( sz[0]-9, sz[3], sz[0]+maxnickname_length+9, sz[3], $FF000000, 0);

        mainform.Font2b.TextOut('PING',sz[0]+5, sz[3]-16,clwhite);
        mainform.Font2b.TextOut('FRAGS',sz[0]+60, sz[3]-16,clwhite);
        mainform.Font2b.TextOut('NAME',sz[0]+120, sz[3]-16,clwhite);

        // Print Names
        if scoreboard_ts.count >=1 then
        for b := 0 to scoreboard_ts.count-1 do
        for i:=0 to 7 do if players[i]<> nil then
        if players[i].dxid = strtoint(scoreboard_ts[b]) then begin



                if (TeamGame) then begin
                        aph := $44;
                        if players[i].dxid = MyDXIDIS then aph := $99;
                        if PLAYERS[i].TEAM=0 then MainForm.PowerGraph.FillRect(sz[0]-9,sz[3]+1+b*16,maxnickname_length+18,16,(aph shl 24)+$FF0000,2 or $100) else
                        if PLAYERS[i].TEAM=1 then MainForm.PowerGraph.FillRect(sz[0]-9,sz[3]+1+b*16,maxnickname_length+18,16,(aph shl 24)+$0000FF,2 or $100) else
                        MainForm.PowerGraph.FillRect(sz[0]-9,sz[3]+1+b*16,maxnickname_length+18,16,(aph shl 24)+$00FFFF,2 or $100);
                end else
                if players[i].dxid = MyDXIDIS then
                        MainForm.PowerGraph.FillRect(sz[0]-9,sz[3]+1+b*16,maxnickname_length+18,16,$33FFFFFF,2 or $100);

                mainform.Font2b.TextOut(inttostr(players[i].ping),sz[0]+30 - mainform.Font2b.TextWidth (inttostr(players[i].ping)) , sz[3]+b*16,clwhite);
                mainform.Font2b.TextOut(inttostr(players[i].frags),sz[0]+90 - mainform.Font2b.TextWidth (inttostr(players[i].frags)), sz[3]+b*16,clwhite);
                ParseColorText(players[i].netname,sz[0]+120,sz[3]+b*16,1);
                break;
        end;

        if SpectatorList.count > 0 then
        for i := 0 to SpectatorList.count-1 do begin
                ParseColorText(TSpectator ( SpectatorList.items[i]^).netname,sz[0]+120,sz[3]+b*16+i*16,1);
                mainform.Font2b.TextOut('SPECT',sz[0],sz[3]+b*16+i*16, clwhite);
        end;

end;
// ================================
procedure DrawScoreBoard;
var i,b,z, spectadd:byte;
time_ :cardinal;
begin

        time_ := gettickcount;
        if scoreboard_to < time_ then begin
                scoreboard_to := gettickcount + 1000;
                ReSortScoreBoard;
                end;

        if OPT_QWSCOREBOARD then begin
                DrawQWScoreBoard;
                exit;
        end;

with mainform do begin
                if MATCH_GAMETYPE=GAMETYPE_TEAM then begin
                        PowerGraph.FillRect(68,120,502,28,COLORARRAY[OPT_GAMEMENUCOLOR],effectMul);
                        ParseCenterColorText('^1RED ^7TEAM: ^7'+inttostr(GetRedTeamScore)+'           ^4BLUE ^7TEAM: ^7'+inttostr(GetBlueTeamScore),130,4);
                end;
                if MATCH_GAMETYPE=GAMETYPE_CTF then begin
                        PowerGraph.FillRect(68,100,502,48,COLORARRAY[OPT_GAMEMENUCOLOR],effectMul);
                        ParseCenterColorText('^1RED ^7SCORE: ^7'+inttostr(GetRedTeamScore)+'           ^4BLUE ^7SCORE: ^7'+inttostr(GetBlueTeamScore),130,4);
                        ParseCenterColorText('^1RED ^7CAPTURES: ^7'+inttostr(MATCH_REDTEAMSCORE)+'           ^4BLUE ^7CAPTURES: ^7'+inttostr(MATCH_BLUETEAMSCORE),110,4);
                end;

                if MATCH_GAMETYPE=GAMETYPE_DOMINATION then begin
                        PowerGraph.FillRect(68,100,502,48,COLORARRAY[OPT_GAMEMENUCOLOR],effectMul);
                        ParseCenterColorText('^1RED ^7SCORE: ^7'+inttostr(GetRedTeamScore)+'           ^4BLUE ^7SCORE: ^7'+inttostr(GetBlueTeamScore),130,4);
                        if ismultip=1 then
                        ParseCenterColorText('^1RED ^7DOMSCORE: ^7'+inttostr(MATCH_REDTEAMSCORE div 3)+'           ^4BLUE ^7DOMSCORE: ^7'+inttostr(MATCH_BLUETEAMSCORE div 3),110,4) else
                        ParseCenterColorText('^1RED ^7DOMSCORE: ^7'+inttostr(MATCH_REDTEAMSCORE)+'           ^4BLUE ^7DOMSCORE: ^7'+inttostr(MATCH_BLUETEAMSCORE),110,4);
                end;

                spectadd := SpectatorList.count * 16;

                PowerGraph.FillRect(68,148,502,178 + spectadd,COLORARRAY[OPT_GAMEMENUCOLOR],effectMul);
                Font2b.TextOut('NAME',80,164,clRed);
                Font2b.TextOut('FRAGS',400,164,clRed);
                Font2b.TextOut('PING',510,164,clRed);

                if scoreboard_ts.count >=1 then
                for b := 0 to scoreboard_ts.count-1 do
                for i:=0 to 7 do if players[i]<> nil then
                if players[i].dxid = strtoint(scoreboard_ts[b]) then begin

                        if (TeamGame) then begin
                              if PLAYERS[i].TEAM =0 then PowerGraph.FillRect(72,190+b*16,4,10,clBlue,effectAdd) else if PLAYERS[i].TEAM =1 then
                                PowerGraph.FillRect(72,190+b*16,4,10,clred,effectAdd) else if PLAYERS[i].TEAM =2 then
                                PowerGraph.FillRect(72,190+b*16,4,10,clYellow,effectAdd);
                        end;

                        ParseColorText(players[i].netname,80,186+b*16,1);
                        Font2b.TextOut(inttostr(players[i].Frags),416,186+b*16,clwhite);
                        Font2b.TextOut(inttostr(players[i].ping),526,186+b*16,clwhite);
                        break;
                end;

                if SpectatorList.count > 0 then
                for i := 0 to SpectatorList.count-1 do begin
                        ParseColorText(TSpectator ( SpectatorList.items[i]^).netname,80,186+b*16 + i*16,1);
                        Font2b.TextOut('SPECT',416,186+b*16+i*16, clwhite);
                end;



end; end;

// -------------------------------
function CanSelectTeam:boolean;
begin
        result := false;
        if not teamgame then exit;
        if OPT_SV_DEDICATED then exit;
        if DDEMO_VERSION > 0 then exit;
        if (ISMULTIP=1) and (MATCH_STARTSIN < 250) then exit;
        if (ISMULTIP=2) and (MATCH_FAKESTARTSIN < 5) then exit;
        result := true;
end;
// -------------------------------
procedure AddFireWorks(X, Y : word);
var i : word;
begin
        for i := 0 to 1000 do
        if aaa[i].dead = 2 then begin
        aaa[i].x := X;
        aaa[i].y := y;
        aaa[i].DXID := 0;
        aaa[i].dude := true;
        aaa[i].frame := 0;
        aaa[i].dead := 0;
        aaa[i].health := 256 + random(512);
        aaa[i].objname := 'spark';
        aaa[i].topdraw:=2;
        aaa[i].cx := random($FFFFFF);
        aaa[i].spawner := players[0];
        exit;
        end;
end;

procedure Tmainform.DXTimerTimer(Sender: TObject);
var
 i,a,obj : integer;
 Msg: TMP_PlayerPosUpdate;
 Msg2: TMP_HAUpdate;
 Msg3: TMP_TimeUpdate;
 Msg4: TMP_Ping;
 Msg5: TMP_DropPlayer;
 Msg6: TMP_SoundStatData;
 MsgSize: word;
 f : TMonosprite;
 nott : boolean;
 rct : trect;
 str: string;
 stx,sty : word;
 stp,sti,z : byte;
 tmp : byte;
 c : word;
 gxx,gyy : Smallint;
 res,res2 : integer;
 alpha,ccl : cardinal;
 cccl : byte;
begin
 STIME := gettickcount;

 if not OPT_PSYHODELIA then PowerGraph.Clear($FF000000+OPT_FILL_RGB);

 PowerGraph.BeginScene();
 PowerGraph.Antialias := false;
// PowerGraph.


//        ccl := gametic mod 2;
//        ccl := gametic mod 3;

//        powergraph.PutPixel ();

        if font_alpha_dir = 1 then begin
        if font_alpha <$FF then inc(font_alpha,5) else font_alpha_dir := 0;
        end else
        if font_alpha_dir = 0 then begin
        if font_alpha >150 then dec(font_alpha,5) else font_alpha_dir := 1; end;
        font_invalpha := 255 - font_alpha + 150;

        if font_alpha_dir_s = 1 then begin
        if font_alpha_s <$FD then inc(font_alpha_s,2) else font_alpha_dir_s := 0;
        end else
        if font_alpha_dir_s = 0 then begin
        if font_alpha_s >200 then dec(font_alpha_s,2) else font_alpha_dir_s := 1; end;
        font_invalpha_s := 255 - font_alpha_s + 200;

        if SYS_DXINPUT then dxinput.Update;

        if planet_frametime > 0 then dec(planet_frametime) else begin
                planet_frametime := 2;
                inc(planet_frame);
                if planet_frame >= 25 then planet_frame := 0;
        end;

        // NFKAMP MP3 PLAYER
        if (OPT_SOUND = true) and (SYS_NFKAMPSTATE = 1) then begin
                if (SYS_NFKAMPREFRESH = 50) then begin
                      IF (FSOUND_Stream_GetTime(FMODStream) = 0) or (FSOUND_Stream_GetLengthMs(FMODStream)=FSOUND_Stream_GetTime(FMODStream)) then begin
                                if SYS_NFKAMP_PLAYINGCOMMENT then MP3_STOP else MP3_START();
                      end;
                      SYS_NFKAMPREFRESH := 0;
                end else inc(SYS_NFKAMPREFRESH);
        end;

//      DXDraw.Surface.Fill(Conv24to16(RGB(OPT_BG_R, OPT_BG_G, OPT_BG_B)));
        // Menu Draw.
        if inmenu then begin
                DRAWMENU;
                Network_SendAllQueue();
                exit;
        end;

        // Anim Flag;
        if SYS_FLAGFRAMERATE < 2 then inc(SYS_FLAGFRAMERATE) else begin
                 if SYS_FLAGFRAME < 13 then inc(SYS_FLAGFRAME) else SYS_FLAGFRAME := 0;
                 SYS_FLAGFRAMERATE := 0;
        end;

        // Anim DomFlag;
        if SYS_DOMFRAMERATE < 2 then inc(SYS_DOMFRAMERATE) else begin
                 SYS_DOMFRAMERATE := 0;
        end;

        if mapcansel > 0 then dec(mapcansel);

        if not inconsole then
        if application.Active then
                setcursorpos(320, 240);

        for i := 7 downto 0 do if players[i] <> nil then begin
                playermove(i);
                BD_FixAngle(i);
                end;

        // CAMERA
        if OPT_CAMERATYPE = 1 then
        if players[OPT_1BARTRAX] <> nil then begin

                if (players[OPT_1BARTRAX].netobject=false) then begin
                        GX := -trunc(players[OPT_1BARTRAX].x)+mainform.powergraph.width div 2;
                        GY := -trunc(players[OPT_1BARTRAX].Y)+mainform.powergraph.height div 2;
                end else begin
                        GX := -trunc(players[OPT_1BARTRAX].TESTPREDICT_X)+mainform.powergraph.width div 2;
                        GY := -trunc(players[OPT_1BARTRAX].TESTPREDICT_Y)+mainform.powergraph.height div 2;
                end;
        end;

        obj := 0;
        rct := rect(0,0,mainform.powergraph.width,mainform.powergraph.height);

        if OPT_BGMOTION then begin
                gxx := trunc(gx / 1.512);
                gyy := trunc(gy / 1.512);
        end else begin
                gxx := gx;
                gyy := gy;
        end;

        while (gxx < 0) do gxx := gxx + 256;
        while (gyy < 0) do gyy := gyy + 256;

if not OPT_PSYHODELIA then begin

        if OPT_BGMADNESS>0 then begin
                PowerGraph.antialias := true;
                if SYS_BGANGLE < 255 then inc(SYS_BGANGLE) else SYS_BGANGLE := 0;
                PowerGraph.RotateEffect(Images[10+OPT_BG], 320, 240, SYS_BGANGLE*OPT_BGMADNESS,768,0, effectNone);
                PowerGraph.antialias := false;
        end else
{                if DRAW_BACKGROUND then BEGIN
                        if OPT_CAMERATYPE = 0 then begin
                         for i := 0 to 2 do for a := 0 to 1 do PowerGraph.
                         TextureMapRect(Images[10+OPT_BG], 256*i, 256*a,256,256   , 0, effectNone);
                        end else
                         for i := 0 to 3 do for a := 0 to 2 do PowerGraph.TextureMapRect
                         (Images[10+OPT_BG], 256*i+GXX-288,256*a+GYY-256, 256,256 , 0, effectNone);
                end;
}
        if DRAW_BACKGROUND then for i := 0 to (mainform.powergraph.width + 256) div 256 do for a := 0 to (mainform.powergraph.height + 256) div 256 do PowerGraph.TextureMapRect
                (Images[10+OPT_BG], 256*i+GXX-288,256*a+GYY-256, 256, 256 , 0, effectNone);
end;

//      if DRAW_BACKGROUND then for i := 0 to 2 do for a := 0 to 1 do PowerGraph.RenderEffect(Images[10+OPT_BG], 256*i, 256*a   , 0, effectNone);


        for i := 0 to BRICK_X-1 do      // brickz
        for a := 0 to BRICK_Y-1 do begin
                        if (bbb[i,a].image > 0) and (bbb[i,a].image< 54) then begin

                        // mark empty death
                        if (match_gametype<>GAMETYPE_TRIXARENA) or (match_startsin>0) then
                        if OPT_CONTENTEMPTYDEATHHIGHLIGHT then begin
                                if (bbb[i,a].image=CONTENT_EMPTY) then PowerGraph.FillRect(i*32+GX,a*16+GY,32,16,$33FFFF00,effectSrcAlpha or effectDiffuseAlpha);
                                if (bbb[i,a].image=CONTENT_DEATH) then PowerGraph.FillRect(i*32+GX,a*16+GY,32,16,$330000FF,effectSrcAlpha or effectDiffuseAlpha);

                               end;

                        // FLAG.
                        if MATCH_GAMETYPE = GAMETYPE_CTF then
                        if bbb[i,a].dir = 0 then
                        if inscreen(i*32,a*16,32) then
                        if (bbb[i,a].image = 40) or (bbb[i,a].image = 41) then begin
                             if (bbb[i,a].image = 40) then PowerGraph.RenderEffect(Images[47], i*32+GX+2, a*16-25+GY, SYS_FLAGFRAME, effectSrcAlpha);
                             if (bbb[i,a].image = 41) then PowerGraph.RenderEffect(Images[47], i*32+GX-6, a*16-25+GY, 14+SYS_FLAGFRAME, effectSrcAlpha or effectMirror);
                        end;

                        // DOM FLAG.
                        if MATCH_GAMETYPE = GAMETYPE_DOMINATION then
                        if (bbb[i,a].image = 42) then begin
                                if SYS_DOMFRAMERATE=0 then
                                if bbb[i,a].scale < 46 then inc(bbb[i,a].scale) else bbb[i,a].scale := 0;
                                if bbb[i,a].oy > 0 then bbb[i,a].oy := bbb[i,a].oy - 1 else bbb[i,a].oy := 0;

                                if inscreen(i*32,a*16,32) then begin

                                if MATCH_STARTSIN>0 then
                                case bbb[i,a].y of
                                0 : Font2s.textout('alpha',GX + Trunc(i*32) + 16 - Font2s.TextWidth('alpha') div 2,GY+a*16-40,clWhite);
                                1 : Font2s.textout('beta',GX + Trunc(i*32) + 16 - Font2s.TextWidth('beta') div 2,GY+a*16-40  ,clWhite);
                                2 : Font2s.textout('gamma',GX + Trunc(i*32) + 16 - Font2s.TextWidth('gamma') div 2,GY+a*16-40,clWhite);
                                end;

                                        if bbb[i,a].dir <> C_TEAMNON then begin
                                                PowerGraph.TextureMap(Images[52+bbb[i,a].dir],i*32+GX+4, a*16-25+GY, i*32+GX+28, a*16-25+GY,i*32+GX+28, a*16+16+GY, i*32+GX+4, a*16+16+GY,47, effectSrcAlpha);
                                                PowerGraph.RenderEffect(Images[52+bbb[i,a].dir], i*32+GX+2, a*16-23+GY, bbb[i,a].scale, effectSrcAlpha);
                                        end else begin
                                                PowerGraph.TextureCol(Images[52],i*32+GX+4, a*16-25+GY, i*32+GX+28, a*16-25+GY,i*32+GX+28, a*16+16+GY, i*32+GX+4, a*16+16+GY, $66FFFFFF ,47, effectSrcAlpha  or EffectDiffuseAlpha);
                                                PowerGraph.RenderEffectCol (Images[52], i*32+GX+2, a*16-23+GY, $66000000,bbb[i,a].scale, effectSrcAlpha or EffectDiffuseAlpha);
                                        end;

                                end;
                        end;

                        if ((bbb[i,a].image= 38) or (bbb[i,a].image=39)) and (inscreen(i*32,a*16,32)) then begin // jumppad
                                inc(bbb[i,a].dir);
                                if bbb[i,a].dir = 78 then bbb[i,a].dir := 0;
                                if bbb[i,a].dir >= 32 then
                                PowerGraph.RenderEffect(Images[24], i*32+GX, a*16+12+GY, 0, effectSrcAlpha) else
                                PowerGraph.RenderEffect(Images[24], i*32+GX, a*16+12+GY, bbb[i,a].dir div 2, effectSrcAlpha);
                        end else

                        if bbb[i,a].respawnable = true then begin

                                if bbb[i,a].scale < $FF then inc(bbb[i,a].scale,15);

                                if OPT_R_ALPHAITEMSRESPAWN then
                                alpha := bbb[i,a].scale else alpha := $FF;

                                // itemz
                                if IsItemRespawned(i,a) then begin
                                if inscreen(i*32,a*16,32) then begin
                                                if (OPT_WEAPONFLOAT) and ((bbb[i,a].image = 17) OR (bbb[i,a].image = 18)) then begin// floating armors
                                                        //ARMORS. ANIMATED.
                                                        if (bbb[i,a].image = 17) then
                                                        PowerGraph.RenderEffectCol(Images[62], i*32+GX, a*16+GY -5 + round ( cos (STIME/300)*5 ) , (alpha shl 24)+$FFFFFF, (STIME div 96) mod 20, effectSrcAlpha or $100) else
                                                        PowerGraph.RenderEffectCol(Images[62], i*32+GX, a*16+GY -5 + round ( cos (STIME/300)*5 ) , (alpha shl 24)+$FFFFFF, (STIME div 96) mod 20+20, effectSrcAlpha or $100);

                                                end
                                                else
                                                if (bbb[i,a].image>=18) and (bbb[i,a].image<=28) then begin // medikitz

                                                        if (bbb[i,a].y > 62) then bbb[i,a].y := 62;
                                                        if (bbb[i,a].y < 0) then bbb[i,a].y := 2;

                                                        if bbb[i,a].dir = 1 then begin
                                                                bbb[i,a].y := bbb[i,a].y + 1;
                                                                if bbb[i,a].y >= 30 then bbb[i,a].dir := 0;
                                                        end else
                                                        if bbb[i,a].dir = 0 then begin
                                                                bbb[i,a].y := bbb[i,a].y - 1;
                                                                if bbb[i,a].y <= 1 then bbb[i,a].dir := 1;
                                                        end;
                                                        if OPT_R_FLASHINGITEMS then
                                                        ccl := rgb($fE-bbb[i,a].y,$fE-bbb[i,a].y,$fE-bbb[i,a].y) else ccl:=$DDDDDD;

                                                        if (bbb[i,a].image=19) then begin // health +5
                                                                PowerGraph.Antialias := true;
                                                                PowerGraph.RenderEffectCol(Images[37], trunc(i*32+GX)+4, trunc(a*16+GY)+4,  200,(alpha shl 24)+ccl, 0, effectSrcAlpha or effectDiffuseAlpha);
                                                                PowerGraph.Antialias := False;
                                                        end else if (bbb[i,a].image>=20) and (bbb[i,a].image<=22) then
                                                                PowerGraph.RenderEffectCol(Images[37], trunc(i*32+GX), trunc(a*16+GY), (alpha shl 24)+ccl, bbb[i,a].image-19, effectSrcAlpha or effectDiffuseAlpha) else
                                                        PowerGraph.RenderEffectCol(Images[IMAGE_ITEM], trunc(i*32+GX), trunc(a*16+GY), (alpha shl 24)+ccl, bbb[i,a].image, effectSrcAlpha or effectDiffuseAlpha);

                                                end else
                                                // other items
                                                PowerGraph.RenderEffectCol(Images[IMAGE_ITEM], i*32+GX, a*16+GY, (alpha shl 24)+$FFFFFF,bbb[i,a].image, effectSrcAlpha or effectDiffuseAlpha);//
                                end;//#inscreen(i*32,a*16,32)
                                end;//#IsItemRespawned(i,a)

                        end;
                end else
                        if (inscreen(i*32,a*16,32)) then begin
                               z := bbb[i,a].image;

                               if (G_BRICKREPLACE>0) and (z>=54) then z:= G_BRICKREPLACE;

                               if (z >= 54) and (z< 182) then begin
                                        if (SYS_USECUSTOMPALETTE) and (G_BRICKREPLACE=0) then begin
                                                if SYS_USECUSTOMPALETTE_TRANSPARENT then
                                                        PowerGraph.RenderEffect(Images[48], i*32+GX, a*16+GY, z-54, effectSrcAlpha)
                                                else
                                                        PowerGraph.RenderEffect(Images[48], i*32+GX, a*16+GY, z-54, effectNone);
                                        end else
                                                PowerGraph.RenderEffect(Images[IMAGE_BR1], i*32+GX, a*16+GY, z-54, effectNone)
                               end
                                       else if (z >= 181) then PowerGraph.RenderEffect(Images[IMAGE_BR2], i*32+GX, a*16+GY, z-182, effectNone);
                end;
        end;

        // portals, doors, buttonz, etz.
        if NUM_OBJECTS_0 = false then for z := 0 to NUM_OBJECTS do if ddd[z].active = true then
                MAPOBJ_think(z);


        // DRAW background OBJECTs
        for i := 0 to 1000 do if aaa[i].dead < 2 then begin
                if aaa[i].topdraw = 0 then
                if aaa[i].dead < 2 then begin
                        aaa[i].DoMove(100);
                        if aaa[i].objname = 'corpse' then CorpsePhysic(i);
                        if aaa[i].objname = 'shaft2' then if aaa[i].dead = 2 then addmessage('^3 OBJCYCLE DEAD!');

                        inc(obj);
                end;
        end;

        // DRAW PLAYERS
        if draworder = 0 then begin for i := 7 downto 0 do if players[i] <> nil then begin
                setcrosshairpos(players[i], trunc(players[i].x),trunc(players[i].y), players[i].clippixel,true);
                PlayerAnim(i);
                end end
        else begin for i := 0 to 7 do if players[i] <> nil then begin
                setcrosshairpos(players[i], trunc(players[i].x),trunc(players[i].y), players[i].clippixel,true);
                PlayerAnim(i);

        end end;
        if random(2) = 0 then begin for i := 7 downto 0 do if players[i] <> nil then ClipItems(players[i]); end
        else begin for i := 0 to 7 do if players[i] <> nil then ClipItems(players[i]); end;


        // secret code.
        if SYS_BLOODRAIN then for i:= 0 to 7 do
                ParticleEngine.AddParticle(random(640),0,1-random(2),2+random(6),true);

         ParticleEngine.Process();
// render bloooooooooooooooooood.
         ParticleEngine.Render();


//       a := ParticleEngine.Count;
//       mainform.font1.textout(inttostr(players[0].clippixel ),0,0,clred);


        // DRAW background OBJECTs
        for i := 0 to 1000 do if aaa[i].dead < 2 then begin
                if aaa[i].topdraw = 1 then
                if aaa[i].dead < 2 then begin
                        aaa[i].DoMove(100);
                        inc(obj);



                end;
        end;

        // if this section is under commens, then REMOVE THIS SECTION
  //      if NUM_OBJECTS_0 = false then for z := 0 to NUM_OBJECTS do if ddd[z].active = true then
//                MAPOBJ_think(z,true);

        // Rewards\weapon anim
        if draworder = 1 then begin for i := 7 downto 0 do if players[i] <> nil then begin
                if players[i].balloon then PowerGraph.RenderEffectCol(Images[34], trunc(players[i].TESTPREDICT_X-12)+GX, trunc(players[i].TESTPREDICT_Y-50)+GY,$DDFFFFFF, 4, effectSrcAlpha or effectDiffuseAlpha);

                if (players[i].item_invis=0) or ((players[i].netobject=false) and (players[i].idd <> 2 )) or (MATCH_DDEMOPLAY=true) then begin
                        if OPT_SHOWNAMES then if players[i].health > GIB_DEATH then ParseColorText(players[i].netname,GX+trunc(players[i].TESTPREDICT_X)-GetColorTextWidth(players[i].netname,2) div 2,GY+trunc(players[i].TESTPREDICT_Y-40),2);
                        if (players[i].netobject=false) then begin
                        if (INCONSOLE) and (players[i].idd<>2) then players[i].balloon := true else if (players[i].idd<>2)then players[i].balloon := false;
                        end;

                        if players[i].rewardtime > 0 then PowerGraph.RenderEffectCol(Images[34], trunc(players[i].TESTPREDICT_X-12)+GX, trunc(players[i].TESTPREDICT_Y-50)+GY,$DDFFFFFF, players[i].rewardtype -1, effectSrcAlpha or effectDiffuseAlpha);
                end;

                PlayerWeaponAnim(i);
                end; end
        else begin for i := 0 to 7 do if players[i] <> nil then begin
                if players[i].balloon then PowerGraph.RenderEffectCol(Images[34], trunc(players[i].TESTPREDICT_X-12)+GX, trunc(players[i].TESTPREDICT_Y-50)+GY,$DDFFFFFF, 4, effectSrcAlpha or effectDiffuseAlpha);

                if (players[i].item_invis=0) or ((players[i].netobject=false) and (players[i].idd <> 2 )) or (MATCH_DDEMOPLAY=true) then begin
                        if OPT_SHOWNAMES then if players[i].health > GIB_DEATH then
                        ParseColorText(players[i].netname,GX+trunc(players[i].TESTPREDICT_X)-GetColorTextWidth(players[i].netname,2) div 2,GY+trunc(players[i].TESTPREDICT_Y-40),2);
                        if (players[i].netobject=false) then begin
                        if (INCONSOLE) and (players[i].idd<>2) then players[i].balloon := true else if(players[i].idd<>2)then players[i].balloon := false;
                        end;
                        if players[i].rewardtime > 0 then PowerGraph.RenderEffectCol(Images[34], trunc(players[i].TESTPREDICT_X-12)+GX, trunc(players[i].TESTPREDICT_Y-50)+GY,$DDFFFFFF, players[i].rewardtype -1, effectSrcAlpha or effectDiffuseAlpha);
                end;

                PlayerWeaponAnim(i);
                end;
        end;

        // quad...
        for i := 0 to 7 do if players[i] <> nil then if players[i].dead = 0 then begin
                if OPT_FXQUAD then
                if players[i].item_quad > 0 then begin
                      if (TeamGame) and (players[i].team = C_TEAMRED) and (OPT_FXQUAD) then
                      alpha := $880000FF else
                      alpha := $55FFFF00;

                      mainform.powergraph.Antialias := true;
                      mainform.powergraph.RotateEffect(mainform.images[54],round(players[i].TESTPREDICT_X)+gx,round(players[i].TESTPREDICT_Y)+gy,0,1024 - random(150),alpha,0,effectsrcalphaadd or effectdiffusealpha);
                      mainform.powergraph.Antialias := false;
                end;

                if SYS_IAMMOON then begin
                      mainform.powergraph.Antialias := true;
                      mainform.powergraph.RotateEffect(mainform.images[54],round(players[i].TESTPREDICT_X)+gx,round(players[i].TESTPREDICT_Y)+gy,0,2048 - random(300),$aaFFFFFF,0,effectsrcalphaadd or effectdiffusealpha);
                      mainform.powergraph.Antialias := false;
                end;
        end;

        // DRAW TOP OBJECTs
        for i := 0 to 1000 do if aaa[i].dead < 2 then begin
                if aaa[i].topdraw = 2 then
                if aaa[i].dead < 2 then begin
                        aaa[i].DoMove(100);
                        inc(obj);
                end;
        end;
        stx := 0;

        //trunc(cos(STIME/1300)*160), {trunc(sin(STIME/2000)*100)}0

        // Draw Lava Anim
        for i := 0 to BRICK_X-1 do
        for a := 0 to BRICK_Y-1 do begin
                        if bbb[i,a].image=31 then
                                PowerGraph.RenderEffectCol2(Images[19], trunc(i*32+GX), trunc(a*16+GY), (OPT_R_WATERALPHA shl 24) +$FFFFFF , trunc(cos(STIME/1300)*160), {trunc(sin(STIME/2000)*100)}0, 32, 16, 0, effectSrcAlpha or effectDiffuseAlpha) else
                        if bbb[i,a].image=32 then
                                PowerGraph.RenderEffectCol2(Images[58], trunc(i*32+GX), trunc(a*16+GY), (OPT_R_WATERALPHA shl 24) +$FFFFFF , trunc(cos(STIME/1300)*160), {trunc(sin(STIME/2000)*100)}0, 32, 16, 0, effectSrcAlpha or effectDiffuseAlpha);
{
                        if bbb[i,a].image= 31 then begin
                                if bbb[i,a].respawntime > 0 then dec(bbb[i,a].respawntime);
                                if inscreen(i*32,a*16,32) then
                                        PowerGraph.RenderEffectCol(Images[19], trunc(i*32+GX), trunc(a*16+GY),  (OPT_R_WATERALPHA shl 24) +$FFFFFF , bbb[i,a].respawntime, effectSrcAlpha or effectDiffuseAlpha);
                                if bbb[i,a].respawntime = 0 then bbb[i,a].respawntime := 16;
                        end;

                        if bbb[i,a].image= 32 then begin
                                if bbb[i,a].respawntime > 0 then dec(bbb[i,a].respawntime);
                                if inscreen(i*32,a*16,32) then
                                        PowerGraph.RenderEffectCol(Images[19], trunc(i*32+GX), trunc(a*16+GY), (OPT_R_WATERALPHA shl 24) +$FFFFFF , 16+bbb[i,a].respawntime, effectSrcAlpha or effectDiffuseAlpha);
                                if bbb[i,a].respawntime = 0 then bbb[i,a].respawntime := 16;
                                stx := bbb[i,a].respawntime;
                        end;
                        }
        end;

        // render area_waterillusion.
        if NUM_OBJECTS_0 = false then for z := 0 to NUM_OBJECTS do if (ddd[z].active = true) and (ddd[z].objtype = 10) then begin
                for res := 1 to ddd[z].special do for res2 := 1 to ddd[z].orient do
                        if bbb[ddd[z].x+res-1,ddd[z].y+res2-1].image <> 32 then
                        if inscreen(ddd[z].x*32+res*32-32,ddd[z].y*16+res2*16-16,32) then
                        PowerGraph.RenderEffectCol2(Images[58], trunc(ddd[z].x*32+res*32+GX-32), trunc(ddd[z].y*16+res2*16+GY-16), (OPT_R_WATERALPHA shl 24) +$FFFFFF , trunc(cos(STIME/1300)*160), 0, 32, 16, 0, effectSrcAlpha or effectDiffuseAlpha);
//                      PowerGraph.RenderEffectCol(Images[19], trunc(ddd[z].x*32+res*32+GX-32), trunc(ddd[z].y*16+res2*16+GY-16), (OPT_R_WATERALPHA shl 24) +$FFFFFF , 16+stx, effectSrcAlpha or effectDiffuseAlpha);
        end;

        // crosshairs
        if not MATCH_DDEMOPLAY then
        for i := 0 to 7 do if players[i] <> nil then begin
                if players[i].idd = 0 then if players[i].dead =0 then if OPT_P1CROSH > 0 then if OPT_P1CROSHT>0 then
                        PowerGraph.RenderEffectCol(Images[27], trunc(players[i].cx-3+GX), trunc(players[i].cy-3+GY),$FF000000+ACOLOR[OPT_P1CROSH],OPT_P1CROSHT-1, effectSrcAlpha);
                if players[i].idd = 1 then if players[i].dead =0 then if OPT_P2CROSH > 0 then if OPT_P2CROSHT>0 then
                        PowerGraph.RenderEffectCol(Images[27], trunc(players[i].cx-3+GX), trunc(players[i].cy-3+GY),$FF000000+ACOLOR[OPT_P2CROSH],OPT_P2CROSHT-1, effectSrcAlpha);
//                if players[i].idd = 2 then if players[i].dead =0 then if OPT_P2CROSH > 0 then if OPT_P2CROSHT>0 then
//                        PowerGraph.RenderEffectCol(Images[27], trunc(players[i].cx-3+GX), trunc(players[i].cy-3+GY),$FF000000+ACOLOR[OPT_P2CROSH],OPT_P2CROSHT-1, effectSrcAlpha);
        end;

        if SYS_BLOODMONITOR then begin
         mainform.PowerGraph.Antialias := true;
         mainform.PowerGraph.RenderEffect(mainform.Images[3], 0, -100,5200, 2, effectMUl);
         mainform.PowerGraph.RenderEffect(mainform.Images[3], 0, -100,5200, 2, effectSrcAlphaAdd);
         mainform.PowerGraph.Antialias := false;
        end;

        // At my birthday
        if OPT_BIRTHDAY then begin
                AddFireWorks(random(640), random(480));
                PowerGraph.RenderEffect(Images[4], 114, round(cos(STIME/300)*50) + 120,0, effectSrcAlpha);
                PowerGraph.RenderEffect(Images[4], 370, round(cos(STIME/300)*50) + 120, 1, effectSrcAlpha);
                PowerGraph.Antialias := true;
                Font3.Scale := 448;
                Font3.AlignedOut ('TODAY IS NEED FOR KILL',0,230+round(sin(STIME/400)*20),tacenter,tanone,$00FF00);
                Font3.AlignedOut ('AUTHOR''s BIRTHDAY!!',0,280+round(sin(STIME/400)*20),tacenter,tanone,$00FF00);
                Font3.AlignedOut ('HAPPY BIRTHDAY TO 3d[Power]',0,330+round(sin(STIME/400)*20),tacenter,tanone,$00FFFF);
                Font3.Scale := 256;
                Font3.AlignedOut ('Dont forget to leave your congratulation',0,380+round(sin(STIME/400)*20),tacenter,tanone,$FFFFFF);
                Font3.AlignedOut ('messages at www.3dpower.org',0,400+round(sin(STIME/400)*20),tacenter,tanone,$FFFFFF);
                PowerGraph.Antialias := false;
        end;

        // HUD
        if (players[OPT_1BARTRAX] <> nil) then begin
                if p1weapbar > 0 then dec(p1weapbar);
                if p1flashbar > 0 then flashstatusbar(1);
                if not HUD_BigHudAvail then
                        PowerGraph.RenderEffectCol(Images[38],PowerGraph.Width-37,P1BARORIENT-1,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,p1flashbar div 3,EffectSrcAlpha or EffectDiffuseAlpha);
         end;

        if SYS_BAR2AVAILABLE then
        if (players[OPT_2BARTRAX] <> nil) then begin
                if p2weapbar > 0 then dec(p2weapbar);
                if p2flashbar > 0 then flashstatusbar(2);
                PowerGraph.RenderEffectCol(Images[38],0,P1BARORIENT-1,(OPT_R_STATUSBARALPHA shl 24)+ $FFFFFF,p2flashbar div 3,EffectSrcAlpha or EffectDiffuseAlpha);
        end;

//      PowerGraph.RenderEffectCol(Images[50],32*6+4,32*6,$DDFF7777,SYS_FLAGFRAME,EffectSrcAlphaAdd or effectDiffuseAlpha);

        // player.air calculate.
        if not MATCH_DDEMOPLAY then for i := 0 to 7 do if players[i] <> nil then if players[i].dead = 0 then begin

                if players[i].crouch = false then begin
                if IsWaterContentHEAD(players[i]) then begin
                                if players[i].air > 0 then dec(players[i].air);
                                end else players[i].air := SYS_MAXAIR; // ...GET AIR...
                end;

                if players[i].crouch = true then begin
                if IsWaterContentCrouchHEAD(players[i]) then begin
                                if players[i].air > 0 then dec(players[i].air);
                                end else players[i].air := SYS_MAXAIR; // ...GET AIR...
                end;
        end;

        // water HUD
        if not MATCH_DDEMOPLAY then
        if players[OPT_1BARTRAX]<>NIL then
        if players[OPT_1BARTRAX].dead = 0 then
        if players[OPT_1BARTRAX].air > 0 then begin
                if players[OPT_1BARTRAX].crouch = false then
                if IsWaterContentHEAD(players[OPT_1BARTRAX]) then
                       PowerGraph.FillRect(603-players[OPT_1BARTRAX].air div 10,P1BARORIENT+33,players[OPT_1BARTRAX].air div 10,5,clBlue,effectAdd);
                if players[OPT_1BARTRAX].crouch = true then
                if IsWaterContentCrouchHEAD(players[OPT_1BARTRAX]) then
                       PowerGraph.FillRect(603-players[OPT_1BARTRAX].air div 10,P1BARORIENT+33,players[OPT_1BARTRAX].air div 10,5,clBlue,effectAdd);
        end;

        if SYS_BAR2AVAILABLE then
        if not MATCH_DDEMOPLAY then
        if players[OPT_2BARTRAX]<>NIL then
        if players[OPT_2BARTRAX].dead = 0 then
        if players[OPT_2BARTRAX].air > 0 then begin
                if players[OPT_2BARTRAX].crouch = false then
                if IsWaterContentHEAD(players[OPT_2BARTRAX]) then
                       PowerGraph.FillRect(37,P1BARORIENT+33,players[OPT_2BARTRAX].air div 10,5,clBlue,effectAdd);
                if players[OPT_2BARTRAX].crouch = true then
                if IsWaterContentCrouchHEAD(players[OPT_2BARTRAX]) then
                       PowerGraph.FillRect(37,P1BARORIENT+33,players[OPT_2BARTRAX].air div 10,5,clBlue,effectAdd);
        end;

        // STATS image
        if OPT_SHOWSTATS then begin
                powergraph.antialias := true;
                SYS_P1STATSX := LinearInterpolation(SYS_P1STATSX,400,3);
                SYS_P2STATSX := LinearInterpolation(SYS_P2STATSX,240,3);

                if (players[OPT_1BARTRAX] <> nil) then
                if not OPT_TRANSPASTATS then
                PowerGraph.TextureMap(Images[41],SYS_P1STATSX,106,640,106,640,427,SYS_P1STATSX,427,0,effectNone);

                if SYS_BAR2AVAILABLE then if (players[OPT_2BARTRAX] <> nil) then
                if not OPT_TRANSPASTATS then
                PowerGraph.TextureMap(Images[41],0,106,SYS_P2STATSX,106,SYS_P2STATSX,427,0,427,0,effectNone);

                powergraph.antialias := false;
        end;


//        powergraph.RenderEffect(images[54],100,100,512, 0,effectsrcalphaadd or effectdiffusealpha);

     // powerup icons, shownickatsb
     HUD_PowerIcons();

{     Font4.TextOut('BytesRecv:'+Inttostr(BNET1.BytesReceived),4,100,clLime);
     Font4.TextOut('BytesSend:'+Inttostr(BNET1.BytesSent),4,120,clLime);
     if BNET1.GuaranteedPacketsEnabled then
     Font4.TextOut('PacketVerify: 1',4,140,clLime) else
     Font4.TextOut('PacketVerify: 0',4,140,clLime);
}
     // Demo Engine proce$$.
     DEMOPLAREC();

     // BOT
     if BD_Avail then begin
        BD_UpdatePlayers();
        DLL_MainLoop();
     end;


     // mouse button POV CHANGE.

     if CanSpectate then begin
        mapcansel := 15;
        applyHcommand('nextplayer');
     end;


     if players[OPT_1BARTRAX]<>nil then
     if (players[OPT_1BARTRAX].netobject = false) and (players[OPT_1BARTRAX].ping >= 500) and (ismultip=2) then begin
                Font3.AlignedOut ('      Connection Interrupted',0,0,tacenter,tacenter,clwhite);
                MainForm.PowerGraph.RenderEffectCol(MainForm.images[34],200,228,$FFFFFFFF,5,effectSRCALPHA or effectDiffuseAlpha);
                MainForm.PowerGraph.RenderEffectCol(MainForm.images[34],200,228,((font_alpha div 2-75) shl 24)+ $FFFFFF,5,effectSRCALPHAADD or effectDiffuseAlpha);
     end;


     // cheat.
     if SYS_MAGICLEVEL then begin
             i := random(BRICK_X-1);
             c := random(BRICK_Y-1);
             if (bbb[i,c].image < 254) and (bbb[i,c].image > 53) then inc(bbb[i,c].image) else if bbb[i,c].image = 254 then bbb[i,c].image := 54;
     end;

     // server lava & wrong place check.
     if ismultip=1 then for i := 0 to 7 do if (players[i] <> nil) then if (players[i].netobject = true) then ClipTriggers(players[i]);

     if (ismultip=1) and (OPT_SV_DEDICATED) and (MATCH_gameend) then
        if STIME - dedicated_gameend_time > 15000 then begin
                ApplyHCommand('restart');
                dedicated_gameend_time := STIME;
        end;

     // second (sec) event.

     // vote test
        if ismultip=1 then if SVVOTE.voteActive then
        if votetesttime < STIME then begin
                VOTE_TestVote;
                votetesttime := STIME+1000;
        end;

        if MATCH_gameend = false then begin

                // voting

                if ismultip=2 then begin
                        // we are in lag!
                        if pingrecv_tick < pingsend_tick then
                        if pingsend_tick - pingrecv_tick > 1500 then
                        for i := 0 to 7 do if players[i] <> nil then if players[i].netobject = false then players[i].ping := 999;
                end;

                if gametic < 50 then inc(gametic) else begin
                // #second prosla

                // shownames
                if OPT_AUTOSHOWNAMESTIME = 1 then if OPT_AUTOSHOWNAMES then OPT_SHOWNAMES := false;
                if OPT_AUTOSHOWNAMESTIME > 0 then DEC(OPT_AUTOSHOWNAMESTIME);
                if OPT_DRAWFRAGBAR then CalculateFragBar;


                if MATCH_DDEMOPLAY then    // demo powerups
                for i := 0 to 7 do
                   if players[i] <> nil then
                   if players[i].dead = 0 then begin
                        if players[i].item_regen > 0 then
                        if players[i].health < 200 then begin
                                playsound(SND_regen,players[i].x,players[i].y);
                                players[i].item_regen_time := 15;
                        end;
                        if players[i].item_quad   > 0 then dec(players[i].item_quad);
                        if players[i].item_regen  > 0 then dec(players[i].item_regen);
                        if players[i].item_flight > 0 then dec(players[i].item_flight);
                        if players[i].item_invis  > 0 then dec(players[i].item_invis);
                        if players[i].item_battle > 0 then dec(players[i].item_battle);
                        if players[i].item_haste  > 0 then dec(players[i].item_haste);
                end;



                // ==================================================
                if isMultiP=2 then begin        // hels\armor. hud
                        starttime := STIME;

                        // network client powerups
                        for i  := 0 to 7 do if players[i] <> nil then if players[i].dead = 0 then begin

                                if players[i].item_regen > 0 then
                                if players[i].health < 200 then begin
                                        playsound(SND_regen,players[i].x,players[i].y);
                                        players[i].item_regen_time := 15;
                                end;
                                if players[i].item_quad > 0 then dec(players[i].item_quad);
                                if players[i].item_quad = 3 then playsound(SND_damage2,players[i].x,players[i].y);
                                if (players[i].item_flight <= 4) and (players[i].item_flight > 1) then playsound(SND_wearoff,players[i].x,players[i].y);
                                if (players[i].item_battle <= 4) and (players[i].item_battle > 1) then playsound(SND_wearoff,players[i].x,players[i].y);
                                if (players[i].item_haste <= 4) and (players[i].item_haste > 1) then playsound(SND_wearoff,players[i].x,players[i].y);
                                if players[i].item_regen > 0 then dec(players[i].item_regen);
                                if players[i].item_flight > 0 then dec(players[i].item_flight);
                                if players[i].item_invis > 0 then dec(players[i].item_invis);
                                if players[i].item_battle > 0 then dec(players[i].item_battle);
                                if players[i].item_haste > 0 then dec(players[i].item_haste);
                                if IsWaterContentHEAD(players[i]) then
                                        if players[i].paintime = 0 then SpawnBubble(players[i]);

                        end;

                        for i := 0 to 7 do if players[i] <> nil then if players[i].netobject = false then begin
                                  MsgSize := SizeOf(TMP_Ping);
                                  Msg4.Data := MMP_PING;
                                  Msg4.DXID := players[i].dxid;
                                  Msg4.PING := players[i].ping;
                                  pingsend_tick := STIME;
                                  mainform.BNETSendData2HOST (Msg4, MsgSize, 0);
                                  break;
                        end;
                end else
                // ==================================================
                if isMultiP=1 then begin        // send hels\armor data to client.

                        if MATCH_GAMETYPE = GAMETYPE_DOMINATION then DOM_Think();

                        // server drop timedout players.
                        for i := 0 to 7 do if (players[i] <> nil) then if (players[i].netobject = true) and (players[i]. NETNoSignal > 750) then begin

                                  // RETURNFLAG!
                                  if (MATCH_GAMETYPE = GAMETYPE_CTF) and (players[i].flagcarrier = true) and (players[i].dead = 0) then begin
                                        CTF_DropFlag(players[i]);
                                        players[i].team := 2;
                                        end;


                                  MsgSize := SizeOf(TMP_DropPlayer);
                                  Msg5.Data := MMP_DROPPLAYER;
                                  Msg5.DXID := players[i].dxid;
                                  RespawnFlash(players[i].x-16, players[i].y);
                                  mainform.BNETSendData2All (Msg5, MsgSize, 1);
                                  addmessage(players[i].netname+ ' ^7^ndropped by timeout.');


                                  if MATCH_DRECORD then begin
                                        DData.type0 := DDEMO_DROPPLAYER;
                                        DData.gametic := gametic;
                                        DData.gametime := gametime;
                                        DemoStream.Write( DData, Sizeof(DData));
                                        DNETKickDropPlayer.DXID := players[i].DXID;
                                        DemoStream.Write( DNETKickDropPlayer, Sizeof(DNETKickDropPlayer));
                                  end;

                                  SV_Remember_Score_Add(players[i].netname, players[i].nfkmodel,players[i].frags);
                                  if SYS_BOT then DLL_SYSTEM_RemovePlayer(players[i].DXID);
                                  players[i] := nil;


                                  NFKPLANET_UpdateCurrentUsers (GetNumberOfPlayers);

                                  break;
                        end;

                        // server players frags update.
                        for i := 0 to 7 do if (players[i] <> nil) and (players[i].netobject = false) then
                        if (players[i].NETAmmo <> players[i].NETLastammo) or (players[i].frags <> players[i].NETFrags) or (players[i].health <> players[i].NEThealth) then begin
                                  MsgSize := SizeOf(TMP_HAUpdate);

                                  if players[i].weapon = 0 then MSG2.ammo := 0;
                                  if players[i].weapon = 1 then MSG2.ammo := players[i].ammo_mg;
                                  if players[i].weapon = 2 then MSG2.ammo := players[i].ammo_sg;
                                  if players[i].weapon = 3 then MSG2.ammo := players[i].ammo_gl;
                                  if players[i].weapon = 4 then MSG2.ammo := players[i].ammo_rl;
                                  if players[i].weapon = 5 then MSG2.ammo := players[i].ammo_sh;
                                  if players[i].weapon = 6 then MSG2.ammo := players[i].ammo_rg;
                                  if players[i].weapon = 7 then MSG2.ammo := players[i].ammo_pl;
                                  if players[i].weapon = 8 then MSG2.ammo := players[i].ammo_bfg;

                                  Msg2.Data := MMP_HAUPDATE;
                                  Msg2.DXID := players[i].dxid;
                                  Msg2.health := players[i].health;
                                  Msg2.armor := players[i].armor;
                                  Msg2.frags := players[i].frags;
                                  mainform.BNETSendData2All (Msg2, MsgSize, 0);

                                  players[i].NETAmmo := not players[i].NETLastammo;
                                  players[i].NETArmor := players[i].armor;
                                  players[i].NEThealth := players[i].health;
                                  players[i].NETfrags := players[i].frags;
                        end;
                        //****************
                        for i := 0 to 7 do if players[i] <> nil then if players[i].dead = 0 then begin
                                if players[i].health > 100 then if players[i].item_regen = 0 then dec(players[i].health);
                                if players[i].armor >100 then dec(players[i].armor);

                                // network server powerups
                                if players[i].item_regen > 0 then begin
                                                if players[i].health < 200 then begin
                                                        players[i].health := players[i].health + 5;
                                                        playsound(SND_regen,players[i].x,players[i].y);
                                                        players[i].item_regen_time := 15;
                                                end;
                                                if players[i].health > 200 then
                                                        players[i].health := 200;
                                end;
                                if players[i].item_quad > 0 then dec(players[i].item_quad);
                                if players[i].item_quad = 3 then playsound(SND_damage2,players[i].x,players[i].y);
                                if (players[i].item_flight <= 4) and (players[i].item_flight > 1) then playsound(SND_wearoff,players[i].x,players[i].y);
                                if (players[i].item_battle <= 4) and (players[i].item_battle > 1) then playsound(SND_wearoff,players[i].x,players[i].y);
                                if (players[i].item_haste <= 4) and (players[i].item_haste > 1) then playsound(SND_wearoff,players[i].x,players[i].y);
                                if players[i].item_regen > 0 then dec(players[i].item_regen);
                                if players[i].item_flight > 0 then dec(players[i].item_flight);
                                if players[i].item_invis > 0 then dec(players[i].item_invis);
                                if players[i].item_battle > 0 then dec(players[i].item_battle);
                                if players[i].item_haste > 0 then dec(players[i].item_haste);
                                // water check. here.

                                        if players[i].crouch=false then
                                        if IsWaterContentHEAD(players[i]) then begin
                                                if players[i].air=0 then ApplyDamage(players[i],DMG_WATER+random(4),aaa[0],DIE_WATER)
                                                else SpawnBubble(players[i]);
                                        end;

                                        if players[i].crouch=true then
                                        if IsWaterContentCrouchHEAD(players[i]) then begin
                                                if players[i].air=0 then ApplyDamage(players[i],DMG_WATER+random(4),aaa[0],DIE_WATER)
                                                else SpawnBubble(players[i]);
                                        end;
                        end;

                        // health\armor\frags update to clients.
                        for i := 0 to 7 do if (players[i] <> nil) and (players[i].netobject = true) then
                                  if (players[i].health <> players[i].NETHealth) or
                                     (players[i].armor <> players[i].NETArmor) or
                                     (players[i].frags <> players[i].NETFrags) then begin

                                  MsgSize := SizeOf(TMP_HAUpdate);
                                  Msg2.Data := MMP_HAUPDATE;
                                  Msg2.DXID := players[i].dxid;
                                  Msg2.health := players[i].health;
                                  Msg2.armor := players[i].armor;
                                  Msg2.frags := players[i].frags;
                                  mainform.BNETSendData2All (Msg2, MsgSize, 0);

                                  players[i].NETArmor := players[i].armor;
                                  players[i].NEThealth := players[i].health;
                                  players[i].NETfrags := players[i].frags;
                        end;

                        // TIME UPDATE;
                        MsgSize := SizeOf(TMP_TimeUpdate);
                        Msg3.Data := MMP_TIMEUPDATE;

                        iF MATCH_STARTSIN > 1 then begin
                                Msg3.WARMUP := TRUE;
                                Msg3.Min := (MATCH_STARTSIN+50) div 50;
                        end else begin
                                Msg3.Min := GAMETIME;
                                Msg3.WARMUP := false;
                        end;
                        mainform.BNETSendData2All (Msg3, MsgSize, 1);
                end else
                // ==================================================
                if not MATCH_DDEMOPLAY then     // not in demo!
                for i := 0 to 7 do
                if players[i] <> nil then
                if players[i].dead = 0 then begin

                                if players[i].item_regen > 0 then begin
                                        if players[i].health < 200 then begin
                                                players[i].health := players[i].health + 5;
                                                playsound(SND_regen,players[i].x,players[i].y);
                                                players[i].item_regen_time := 15;
                                        end;
                                        if players[i].health > 200 then players[i].health := 200;
                                end;

                                if players[i].health > 100 then if players[i].item_regen = 0 then dec(players[i].health);
                                if players[i].armor >100 then dec(players[i].armor);
                                if players[i].item_quad > 0 then dec(players[i].item_quad);
                                if players[i].item_quad = 3 then playsound(SND_damage2,players[i].x,players[i].y);
                                if (players[i].item_flight <= 4) and (players[i].item_flight > 1) then playsound(SND_wearoff,players[i].x,players[i].y);
                                if (players[i].item_battle <= 4) and (players[i].item_battle > 1) then playsound(SND_wearoff,players[i].x,players[i].y);
                                if (players[i].item_haste <= 4) and (players[i].item_haste > 1) then playsound(SND_wearoff,players[i].x,players[i].y);
                                if players[i].item_regen > 0 then dec(players[i].item_regen);
                                if players[i].item_flight > 0 then dec(players[i].item_flight);
                                if players[i].item_invis > 0 then dec(players[i].item_invis);
                                if players[i].item_battle > 0 then dec(players[i].item_battle);
                                if players[i].item_haste > 0 then dec(players[i].item_haste);


                                // initial water damage.
                                if players[i].crouch = false then
                                if IsWaterContentHEAD(players[i]) then begin
                                        if players[i].air=0 then ApplyDamage(players[i],DMG_WATER+random(4),aaa[0],DIE_WATER) else SpawnBubble(players[i]);
                                end;

                                if players[i].crouch = true then
                                if IsWaterContentCrouchHEAD(players[i]) then begin
                                        if players[i].air=0 then ApplyDamage(players[i],DMG_WATER+random(4),aaa[0],DIE_WATER);
                                end;
                end;

                        gametic := 0; inc(gametime);
                        if map_info>0 then dec(map_info);
                end;
        // =END OF SECOND EVENT =================================================


        if MATCH_GAMETYPE <> GAMETYPE_DOMINATION then
        if ismultip <= 1 then
        if not match_ddemoplay then
        if (MATCH_TIMELIMIT > 0) and (MATCH_STARTSIN = 0) then begin
                if (gametime = MATCH_TIMELIMIT*60 - 300) and (gametic = 0) then begin
                        playsound(SND_5_min,0,0);

                        if ismultip=1 then begin
                                MsgSize := SizeOf(TMP_SoundStatData);
                                Msg6.Data := MMP_SENDSTATESOUND;
                                Msg6.SoundType := 0; // 5min code;
                                mainform.BNETSendData2All (Msg6, MsgSize, 1);
                        end;

                        if MATCH_DRECORD then begin
                                DData.type0 := DDEMO_GAMESTATE;
                                DData.gametic := gametic;
                                DData.gametime := gametime;
                                DGameState.type1  := 1;
                                DemoStream.Write( DData, Sizeof(DData));
                                DemoStream.Write( DGameState, Sizeof(DGameState));
                        end;
                end;

                if (gametime = MATCH_TIMELIMIT*60 - 60) and (gametic = 0) then begin

                        if ismultip=1 then begin
                                MsgSize := SizeOf(TMP_SoundStatData);
                                Msg6.Data := MMP_SENDSTATESOUND;
                                Msg6.SoundType := 1; // 1min code;
                                mainform.BNETSendData2All (Msg6, MsgSize, 0);
                        end;

                        playsound(SND_1_min,0,0);

                        if MATCH_DRECORD then begin
                                DData.type0 := DDEMO_GAMESTATE;
                                DData.gametic := gametic;
                                DData.gametime := gametime;
                                DGameState.type1  := 2;
                                DemoStream.Write( DData, Sizeof(DData));
                                DemoStream.Write( DGameState, Sizeof(DGameState));
                        end;
                end;

        end;


        end;

//        if (trunc(gametime/60)  = MATCH_TIMELIMIT+MATCH_OVERTIME) then addmessage('timelimit!');

        if ismultip <= 1 then
        if MATCH_DDEMOPLAY=false then
        if MATCH_GAMETYPE<>GAMETYPE_TRIXARENA then
        if MATCH_GAMEEND=false then
        if (trunc(gametime/60)  = MATCH_TIMELIMIT+MATCH_OVERTIME) and (MATCH_TIMELIMIT > 0) and (MATCH_STARTSIN = 0) then begin

//                font1.TextOut ('timecheck',100,100,clyellow);

                // Overtime.
                if TeamGame and (IsMapTied) and (OPT_SV_OVERTIME>0) then begin
                        addmessage('^1Overtime ^7+'+inttostr(OPT_SV_OVERTIME)+' minutes');
                        MATCH_OVERTIME := MATCH_OVERTIME + OPT_SV_OVERTIME;
                        MATCH_OVERTIMESHOW := 200;

                        if ismultip=1 then begin
                                MsgSize := SizeOf(TMP_SoundStatData);
                                Msg6.Data := MMP_SENDSTATESOUND;
                                Msg6.SoundType := 3; // overtime code;
                                mainform.BNETSendData2All (Msg6, MsgSize, 0);
                        end;

                end else
                // Sudden Death.
                if (IsMapTied) and (MATCH_SUDDEN = FALSE) and (TeamGame=false) then begin

                        // Sudden Death

                        MATCH_SUDDEN := TRUE;
                        playsound(SND_sudden_death,0,0);

                        if ismultip=1 then begin
                                MsgSize := SizeOf(TMP_SoundStatData);
                                Msg6.Data := MMP_SENDSTATESOUND;
                                Msg6.SoundType := 2; // sudden code;
                                mainform.BNETSendData2All (Msg6, MsgSize, 0);
                        end;

                        gamesudden := 200;

                        if MATCH_DRECORD then begin
                                DData.type0 := DDEMO_GAMESTATE;
                                DData.gametic := gametic;
                                DData.gametime := gametime;
                                DGameState.type1  := 3;
                                DemoStream.Write( DData, Sizeof(DData));
                                DemoStream.Write( DGameState, Sizeof(DGameState));
                        end;

                // timelimit hit.
                END else if (MATCH_SUDDEN = FALSE) THEN begin
                        addmessage('timelimit hit.');
                        GameEnd(END_TIMELIMIT);
                end;

        end;

        // Type Ready message
        if (map_info=0) and (ismultip <= 1) and (MATCH_STARTSIN > 1000) and (OPT_ALLOWMAPCHANGEBG) then
        if GetNumberOfPlayers >= 2 then
        if (cos(STIME/7600) < -0.9)  then ParseCenterColorText('^b^3Press ^5F10 ^3to start game', 37, 1);

        // MAP INFO
        if (OPT_SHOWMAPINFO) and (map_info>0) then begin
                if not MATCH_DDEMOPLAY then begin
                        Font2b.AlignedOut(GAMETYPE_STR[MATCH_GAMETYPE]+' in '+map_filename+' ('+map_name+')',0,57,taCenter,TaNone, ClLime);
                        i := 77;
                        if (MATCH_GAMETYPE <> GAMETYPE_TRIXARENA) and (MATCH_GAMETYPE <> GAMETYPE_DOMINATION) then begin
                                if match_timelimit > 0 then begin
                                        Font2b.AlignedOut('timelimit '+inttostr(match_timelimit),0,i,taCenter,TaNone, ClLime);
                                        inc(i,20);
                                end;

                                if MATCH_GAMETYPE <> GAMETYPE_CTF then
                                if match_fraglimit > 0 then begin
                                        Font2b.AlignedOut('fraglimit '+inttostr(match_fraglimit),0,i,taCenter,TaNone, ClLime);
                                        inc(i,20);
                                end;
                        end;

                        if (MATCH_GAMETYPE = GAMETYPE_CTF) then {if match_capturelimit > 0 then} begin
                                Font2b.AlignedOut('capturelimit '+inttostr(match_capturelimit),0,i,taCenter,TaNone, ClLime);
                                inc(i,20);
                                end;
                        if (MATCH_GAMETYPE = GAMETYPE_DOMINATION) then{ if match_capturelimit > 0 then}
                                Font2b.AlignedOut('domlimit '+inttostr(match_domlimit),0,i,taCenter,TaNone, ClLime);

                end else Font2b.AlignedOut(GAMETYPE_STR[MATCH_GAMETYPE]+' in "'+map_name+'"',0,57,taCenter,TaNone, ClLime);
        end;

        // VOTE  _SHOW
        if SVVOTE.voteActive  then
        if STIME < SVVOTE.voteTimedOut then begin
                i := (SVVOTE.voteTimedOut - STIME) div 1000;
//                if map_info=0 then
                        if SVVOTE.voted then
                        ParseCenterColorText('^2VOTE ^7('+inttostr(i)+'): ^5'+SVVOTE.voteString ,37,1) else
                        ParseCenterColorText('^2VOTE ^7('+inttostr(i)+'): ^5'+SVVOTE.voteString+'^7   Choose  ^2YES^7(F1) or  ^2NO^7(F2)' ,37,1);
                if i=0 then if ISMULTIP=1 then VOTE_CancelVote;
        end;

        if MP_WAITSNAPSHOT = true then Font3.alignedout('AWAITING GAME STATE',230,12,tacenter,tacenter,clwhite);// else

//        if SYS_TEAMSELECT then
  //              Font3.AlignedOut('Select Team',170,15,taCenter,taCenter,ClYellow);

//              if SYS_TEAMSELECT then ParseCenterColorText('^3^bSelect Team',236,6);

        if not ((MATCH_DDEMOPLAY) and (GetNumberOfPlayers = 2) and (BRICK_X = 20) and (BRICK_Y=30)) then // not that!
        if ((ismultip>0) and ((OPT_NETSPECTATOR) or (OPT_SV_DEDICATED))) or (MATCH_DDEMOMPPLAY > 0 ) THEN begin
                if players[OPT_1BARTRAX] <> nil then
                ParseCenterColorText('Following: '+players[OPT_1BARTRAX].netname,37,1) else
                ParseCenterColorText('No players to follow',37,1);
        end;

//        if ismultip=2 then
  //              if (STIME-answertime)>=1500 then begin
    //                    Font2b.AlignedOut('CONNECTION INTERRUPTED',0,230,tacenter,tanone,clred);
      //          end;


        // SCRN Messages
        if contime4 > 0 then begin
                if contime4 > 1 then ParseColorText(conscrmsg4, 2, 36,1);
                dec(contime4);
        end;
        if contime3 > 0 then begin
                if contime3 > 1 then ParseColorText(conscrmsg3, 2, 24,1);
                dec(contime3);
                if contime3 = 0 then if contime4 > 0 then begin
                        contime3 := contime4;
                        conscrmsg3 := conscrmsg4;
                        contime4 := 1;
                        end;
        end;
        if contime2 > 0 then begin
                if contime2 > 1 then ParseColorText(conscrmsg2, 2, 12,1);
                dec(contime2);
                if contime2 = 0 then if contime3 > 0 then begin
                        contime2 := contime3;
                        conscrmsg2 := conscrmsg3;
                        contime3 := 1;
                        end;
        end;
        if contime > 0 then begin
                if contime > 1 then ParseColorText(conscrmsg, 2, 0,1);
                dec(contime);
                if contime = 0 then if contime2 > 0 then begin
                        contime := contime2;
                        conscrmsg := conscrmsg2;
                        contime2 := 1;
                        end;
        end;



//      if BD_Test_Blocked(trunc(players[0].x+20),trunc(players[0].y)) then
  //        Font3.AlignedOut('blocked',170,45,taCenter,taNone,ClWhite) else
    //      Font3.AlignedOut('not blocked',170,45,taCenter,taNone,ClWhite);

       // MAIN TIMER CORE


                if MATCH_STARTSIN >= 1 then begin
                        if (ismultip=2) or (MATCH_DDEMOMPPLAY=2) then
                        Font3.AlignedOut('Match starts in: '+inttostR(MATCH_FAKESTARTSIN),170,15,taCenter,taNone,ClWhite) else
                        Font3.AlignedOut('Match starts in: '+inttostR((MATCH_STARTSIN+50) div 50),170,15,taCenter,taNone,clWhite);


                        font.color := clWhite;


                        if ISMULTIP=1 then begin
                                if MATCH_STARTSIN = 100 then SV_PrepareToMatch; // client items spawn.
                                if MATCH_STARTSIN = 1 then SV_MatchStart;
                        end;

                        if MATCH_STARTSIN = 50 then playsound(SND_one,0,0);
                        if MATCH_STARTSIN = 100 then playsound(SND_two,0,0);
                        if MATCH_STARTSIN = 150 then playsound(SND_three,0,0);

                        if MATCH_STARTSIN = 1 then begin
                                playsound(SND_fight,0,0);
                                p1flashbar := 0; p2flashbar := 0;
                                if MATCH_DDEMOPLAY = false then
                                MAP_RESTART;
                                end;


                        if (MATCH_DDEMOPLAY=true) or ((MATCH_DDEMOPLAY=false) and (DDEMO_VERSION=0)) then
                        if (ismultip <= 1) and (MATCH_DDEMOMPPLAY <= 1) then dec(MATCH_STARTSIN);
                end;

                if (MATCH_STARTSIN = 0) then begin

                        if gamesudden > 0 then begin dec(gamesudden);
                                Font3.AlignedOut('Sudden Death!',240,214,taCenter,taCenter,clREd);
                        end;

                        if MATCH_OVERTIMESHOW > 0 then begin dec(MATCH_OVERTIMESHOW);
                                if OPT_SV_OVERTIME > 1 then
                                Font3.AlignedOut('Overtime +'+inttostr(OPT_SV_OVERTIME)+' minutes',240,214,taCenter,taCenter,clREd) else
                                Font3.AlignedOut('Overtime +1 minute',240,214,taCenter,taCenter,clREd);
                        end;

                        //  :
                        str := '';


                        if (ISMULTIP=2) or (MATCH_DDEMOMPPLAY=2) then begin
                                if trunc(MATCH_FAKEMIN / 60) < 10 then str := '0';
                                str := str + inttostr(trunc(MATCH_FAKEMIN/60))+':';
                                if MATCH_FAKEMIN - trunc(MATCH_FAKEMIN / 60)*60 < 10 then str := str + '0';
                                str := str + inttostr(MATCH_FAKEMIN - trunc(MATCH_FAKEMIN / 60)*60);
                        end else begin
                                if trunc(gametime / 60) < 10 then str := '0';
                                str := str + inttostr(trunc(gametime/60))+':';
                                if gametime - trunc(gametime / 60)*60 < 10 then str := str + '0';
                                str := str + inttostr(gametime - trunc(gametime / 60)*60);
                        end;
                        Font2b.TextOut(str,590,-1,clWhite);
                end;


// =========== statistic ================= \\
        if OPT_SHOWBANDWIDTH then begin
                Font2b.TextOut(' IN:'+inttostr(BNET1.BandwidthIN) +' bs',8,300,$00FF00);
                Font2b.TextOut('OUT:'+inttostr(BNET1.BandwidthOUT)+' bs',0,314,$00FF00);
//                Font2b.TextOut('LAG:'+inttostr(BNET1.ResendSlotsCount),0,328,$00FF00);
        end;

//        Font2b.TextOut('queues:'+inttostr( QueueBuf.count ),0,368,$00FF00);

        if OPT_DONOTSHOW_RECLABEL = true then
        if contime = 0 then
        if MATCH_DRECORD then Font2ss.AlignedOut('Recording '+demo_name_str,0,0,taCenter,TaNone,$22000000+clyellow);

//      if DRAW_EXTBACKGROUND then begin dxdraw.surface.canvas.brush.style := bsclear; dxdraw.surface.canvas.Draw (0,0,extback); end;

{        if DRAW_FPS then begin
                dxtimer.UpdateFrameRateEx ;
                Font2b.AlignedOut('FPS: '+inttostr(DXTimer.ProcessFPS), 590, 15,tafinal,tanone, clWhite);
        end;
}
        if DRAW_OBJECTS then Font2b.TextOut('Objects: '+inttostr(obj),4,15,clWhite);


        // ===========================

        // statistic.
        if OPT_SHOWSTATS then HUD_ShowStats;

        // scoreboard.
        if inconsole=false then
        if ISKEY(CTRL_SCOREBOARD) then DrawScoreBoard;

        // GAMEMENU
        if INGAMEMENU then begin
                if CanSelectTeam then
                PowerGraph.FillRect(208,175,224,142,COLORARRAY[OPT_GAMEMENUCOLOR],effectMul) else
                PowerGraph.FillRect(208,175,224,112,COLORARRAY[OPT_GAMEMENUCOLOR],effectMul);

                if GAMEMENUORDER = 0 then Font3.AlignedOut('[ Resume game ]',208, 190,taCenter,taNone,CLWhite) else Font3.AlignedOut('Resume game',208, 190,taCenter,taNone,CLWhite);

                if CanSelectTeam then begin
                        if GAMEMENUORDER = 1 then Font3.AlignedOut('[ Change Team ]',208, 220,taCenter,taNone,CLWhite) else Font3.AlignedOut('Change Team',208, 220,taCenter,taNone,CLWhite);
                        if GAMEMENUORDER = 2 then Font3.AlignedOut('[ Restart level ]',208, 250,taCenter,taNone,CLWhite) else Font3.AlignedOut('Restart level',208, 250,taCenter,taNone,CLWhite);
                        if GAMEMENUORDER = 3 then Font3.AlignedOut('[ Leave arena ]',208, 280,taCenter,taNone,CLWhite) else Font3.AlignedOut('Leave arena',208, 280,taCenter,taNone,CLWhite);
                end else begin
                        if MATCH_DEMOPLAYING then begin
                                if GAMEMENUORDER = 1 then Font3.AlignedOut('[ Restart demo ]',208, 220,taCenter,taNone,CLWhite) else Font3.AlignedOut('Restart demo',208, 220,taCenter,taNone,CLWhite);
                        end else
                                if GAMEMENUORDER = 1 then Font3.AlignedOut('[ Restart level ]',208, 220,taCenter,taNone,CLWhite) else Font3.AlignedOut('Restart level',208, 220,taCenter,taNone,CLWhite);

                        if GAMEMENUORDER = 2 then Font3.AlignedOut('[ Leave arena ]',208, 250,taCenter,taNone,CLWhite) else Font3.AlignedOut('Leave arena',208, 250,taCenter,taNone,CLWhite);
                        if GAMEMENUORDER = 3 then GAMEMENUORDER := 2;
                end;

        end else if SYS_TEAMSELECT>0 then begin
                PowerGraph.FillRect(208,175,224,100,COLORARRAY[OPT_GAMEMENUCOLOR],effectMul);
                ParseCenterColorText('^3Select team' ,180,4);

                if GAMEMENUORDER = 0 then ParseCenterColorText('[ AUTO ]',205,4) else ParseCenterColorText('AUTO',205,4);
                if GAMEMENUORDER = 1 then ParseCenterColorText('[ RED ]',225,4) else ParseCenterColorText('RED',225,4);
                if GAMEMENUORDER = 2 then ParseCenterColorText('[ BLUE ]',245,4) else ParseCenterColorText('BLUE',245,4);

        end;

        if SYS_TEAMSELECT>1 then dec(SYS_TEAMSELECT);

//        IF INCONSOLE THEN
        DrawConsole;

// ------------------------------------------
// ------------------------------------------
// ------------ BEGIN NETWORK ---------------
// ------------------------------------------
// ------------------------------------------


        BNETWORK_PlayerPosUpdate();
        Network_SendAllQueue(); // New Network.
// ------------------------------------------
//end;
{ ParticleEngine.AddParticle(320, 40, (Random(20) - 10) / 5, (Random(20) - 10) / 5);
 ParticleEngine.AddParticle(300, 40, (Random(20) - 10) / 5, (Random(20) - 10) / 5);
 ParticleEngine.AddParticle(340, 40, (Random(20) - 10) / 5, (Random(20) - 10) / 5);
 ParticleEngine.AddParticle(320, 20, (Random(20) - 10) / 5, (Random(20) - 10) / 5);
 ParticleEngine.AddParticle(320, 60, (Random(20) - 10) / 5, (Random(20) - 10) / 5);
 }
// ------------------------------------------
// ------------------------------------------
// ---------- END NETWORK -------------------
// ------------------------------------------
// ------------------------------------------

 GammaAnimation;

 // finish the rendering
 PowerGraph.EndScene();
 // present the render on the screen
 PowerGraph.Present();


 keyup_ := false;

 if OPT_AVIDEMO then if (gametic div 2) = (gametic / 2) then ScreenShot;

end;

procedure Tmainform.DXDrawInitialize(Sender: TObject);
begin
if not GAME_FULLLOAD then DXTimer.MayProcess := True;
end;

procedure ADDPLAYER (sender : TPLayer);
var i : integer;
        var ppl : TPlayerEx;
begin
for i := 0 to 7 do if players[i] = nil then begin // free cell
               with sender as TPlayer do begin
               players[i] := sender;

               if SYS_BOT then begin
                        fillchar(ppl,sizeof(ppl),0);
                        if players[i].idd = 2 then
                        ppl.bot  := true else
                        ppl.bot  := false;
                        ppl.x    := players[i].x;
                        ppl.y    := players[i].y;
                        ppl.cx   := players[i].cx;
                        ppl.cy   := players[i].cy;
                        ppl.DXID := players[i].dxid;
                        ppl.netname := players[i].netname;
                        DLL_SYSTEM_AddPlayer(ppl);
               end;

//               addmessage('Player classcreate: #'+inttostr(players[i].dxid)+' '+StripColorName(sender.netname));

               loadi.cns.lines.add('Player created: #'+inttostr(i)+' '+StripColorName(sender.netname));
               exit;
               end;
end;
end;

procedure ADDMESSAGE(s : string);
var i : byte;
begin
if s = '' then exit;
if MSG_DISABLE = true then exit;

if contime = 0 then begin conscrmsg := s; contime := OPT_MESSAGETIME; end else
if contime2 = 0 then begin conscrmsg2 := s; contime2 := OPT_MESSAGETIME end else
if contime3 = 0 then begin conscrmsg3 := s; contime3 := OPT_MESSAGETIME end else
if contime4 = 0 then begin conscrmsg4 := s; contime4 := OPT_MESSAGETIME end else
begin
contime := contime2; contime2 := contime3; contime3 := contime4; contime4 := OPT_MESSAGETIME;
conscrmsg := conscrmsg2; conscrmsg2 := conscrmsg3; conscrmsg3 := conscrmsg4; conscrmsg4 := s;
end;
loadi.cns.lines.add('console: '+StripColorName(s));

if conmsg.count=0 then conmsg.add(s) else conmsg.Insert(0,s);
{if conmsg[14] <> '' then begin
     for i := 0 to 14 do begin
        if i < 14 then conmsg[i]:= conmsg[i+1];
     end;
     conmsg[14] := '';
     end;
 for i := 0 to 14 do if conmsg[14-i] = '' then begin conshow := i-1; conmsg[14-i] := s;  exit end;
 }
end;

procedure GetMapWeaponData;
var x,y : word;
begin
        mapweapondata.machine := true;
        mapweapondata.shotgun := false;
        mapweapondata.grenade := false;
        mapweapondata.rocket  := false;
        mapweapondata.shaft  := false;
        mapweapondata.rail  := false;
        mapweapondata.plasma := false;
        mapweapondata.bfg := false;

        if MATCH_GAMETYPE=GAMETYPE_RAILARENA then begin
                mapweapondata.machine := false;
                mapweapondata.rail  := true;
                exit;
        end;

        for x := 0 to BRICK_X-1 do
        for y := 0 to BRICK_Y-1 do begin
                if bbb[x,y].image = 1 then mapweapondata.shotgun := true;
                if bbb[x,y].image = 2 then mapweapondata.grenade := true;
                if bbb[x,y].image = 3 then mapweapondata.rocket := true;
                if bbb[x,y].image = 4 then mapweapondata.shaft := true;
                if bbb[x,y].image = 5 then mapweapondata.rail := true;
                if bbb[x,y].image = 6 then mapweapondata.plasma := true;
                if bbb[x,y].image = 7 then mapweapondata.bfg := true;
        end;

end;

procedure ShowCriticalError(caption,text1,text2 : shortstring);
begin
        mapcansel := 15;
        SYS_SHOWCRITICAL:=TRUE;
        SYS_SHOWCRITICAL_CAPTION:=caption;
        SYS_SHOWCRITICAL_TEXT1:=text1;
        SYS_SHOWCRITICAL_TEXT2:=text2;
        menuwantorder := MENU_PAGE_MAIN;
        TGR:=0;CTGR:=0;
end;

function LOADMAPCRC32(filename:string):Cardinal;
var buffer : array[1..8192] of Char;
    CRC    : Cardinal;
    Count  : Cardinal;
    F : File;
begin
  if not fileexists(filename) then begin
        addmessage('^1CRC32: Could not find map '+(filename));
        exit;
        end;
  CRC := CRC32INIT;
  {$I-}
  AssignFile(F, filename);
  FileMode := 0;
  Reset(F,1);
  {$I+}
  if IOResult<>0 then begin
          CloseFile(f);
          addmessage('^1Cannot open file '+filename);
          exit;
          end;

  repeat
    BlockRead(F, Buffer, SizeOf( Buffer ), Count);
    CRC := CalculateBufferCRC32( CRC, Buffer, Count );
  until Eof(F);
    CRC := CRC xor CRC32INIT;
    result := CRC;
  closefile(f);
end;

procedure AddDirContentMaps(StartDir: string; List:TStrings);
var
SearchRec : TSearchRec;
begin
        if StartDir[Length(StartDir)] <> '\' then StartDir := StartDir + '\';
        if FindFirst(startdir+'*.*', faAnyfile, SearchRec) = 0 then begin

                if (SearchRec.Name <> '..') and (SearchRec.Name <> '.') then
                if (SearchRec.Attr and faDirectory) <> faDirectory then
                        List.Add(copy( StartDir+SearchRec.Name,length(ROOTDIR+'\maps')+2,length(StartDir+SearchRec.Name)-length(ROOTDIR+'\maps')-1 )) else
                        AddDirContentMaps(StartDir+searchrec.name, list);

                while FindNext(SearchRec) = 0 do begin

                if (SearchRec.Name <> '..') and (SearchRec.Name <> '.') then
                if (SearchRec.Attr and faDirectory) <> faDirectory then
                        List.Add(copy( StartDir+SearchRec.Name,length(ROOTDIR+'\maps')+2,length(StartDir+SearchRec.Name)-length(ROOTDIR+'\maps')-1 )) else
                        AddDirContentMaps(StartDir+searchrec.name,list);
                end;
        end;
        FindClose(SearchRec);
end;

{
  Return Values:
  LMS_OK
  LMS_NOTFOUND
  LMS_CRC32FAILED
}
// just scan for filename at the maps folder
function LoadMapSearchSimple(filename:string):byte;
var TempMapList:TStringList;
    i : word;
begin

        TempMapList := TStringList.create;
        AddDirContentMaps(ROOTDIR+'\maps', TempMapList);
        if TempMapList.count = 0 then begin
                TempMapList.free;
                result := LMS_NOTFOUND;
                exit;
                end;

        for i := 0 to TempMapList.Count-1 do begin
                if extractfilename(lowercase(TempMapList[i])) = filename then begin
                        loadmapsearch_lastfile := TempMapList[i];
                        result := LMS_OK;
                        TempMapList.free;
                        exit;
                end;
        end;

        result := LMS_NOTFOUND;
        TempMapList.free;
end;

function MAPExists(filename:string; CRC32:cardinal) : boolean;
var TempMapList:TStringList;
    i : word;
    found:boolean;
begin
        if lowercase(extractfileext(filename))='' then filename := filename + '.mapa';

        result := false;
        TempMapList := TStringList.create;
        AddDirContentMaps(ROOTDIR+'\maps', TempMapList);
        if TempMapList.count = 0 then begin
                TempMapList.free;
                result := false;
                exit;
                end;

        found := false;
        for i := 0 to TempMapList.Count-1 do
        if extractfilename(lowercase(TempMapList[i])) = filename then begin
//        if LOADMAPCRC32(ROOTDIR+'\maps\'+TempMapList[i]) = CRC32 then begin
                result := true;
                TempMapList.free;
                exit;
        end;
end;

function LOADMAPSearch(filename:string;CRC32:cardinal) : byte;
var TempMapList:TStringList;
    i : word;
    found:boolean;
begin
        TempMapList := TStringList.create;
        AddDirContentMaps(ROOTDIR+'\maps', TempMapList);
        if TempMapList.count = 0 then begin
                TempMapList.free;
                result := LMS_NOTFOUND;
                exit;
                end;


        found := false;
        for i := 0 to TempMapList.Count-1 do begin
                if extractfilename(lowercase(TempMapList[i])) = filename then begin
                        found := true;
                        if LOADMAPCRC32(ROOTDIR+'\maps\'+TempMapList[i]) = CRC32 then begin
                                loadmapsearch_lastfile := TempMapList[i];
                                result := LMS_OK;
                                TempMapList.free;
                                exit;
                        end;
                end;
        end;

        if found then
                result := LMS_CRC32FAILED
        else result := LMS_NOTFOUND;
        TempMapList.free;
end;

procedure LOADMAP (Filename : string; inreal : boolean);
Const BufSize = 3*4*4096;
Type TBuffer = array [1..BufSize] of Byte;
var F : File;
    i,a,z : Integer;
    Header     : THeader;
    tmp : TmapobjV2;
    buf : array [0..$FE] of byte;
    Entry:TMapEntry;
    Buffer : TBuffer;
    TotalSize, NumRead:longint;
    CompressedPaletteStream : TMemoryStream;
    ProgressCallback :TProgressEvent;
    realEOF:boolean;
begin
//-------------------------------------------
//addmessage('loading map...');
fillchar(LocationsArray, sizeof(LocationsArray),0);

if not inreal then begin // DEMO MAP LOADING.
        DemoStream.read( Header, Sizeof(Header));
        if header.ID <> 'NDEM' then begin
//        DemoStream.position := 0;
        addmessage(filename +' is not NFK demo');
        ShowCriticalError('Error loading demo',extractfilename(filename) +' is not NFK demo','or file corrupted.');

        playsound(SND_error,0,0);
        Applyhcommand('disconnect');
        exit;
        end;

        DDEMO_VERSION := header.Version;

        if ((header.Version < 3) or (header.Version > 6)) then begin
                addmessage('incorrect demo version ('+inttostr(header.version)+'). Only versions 3-6 supported.');
                ShowCriticalError('Incorrect demo version','incorrect demo version ('+inttostr(header.version)+').','Only versions 3-6 supported.');
                Applyhcommand('disconnect');
                exit;
        end;

        MATCH_GAMETYPE := header.GAMETYPE;
        BRICK_X := header.MapSizeX;
        BRICK_Y := header.MapSizeY;
        map_bg := header.BG;

        if OPT_ALLOWMAPCHANGEBG then if header.BG > 0 then OPT_BG := header.BG;
        if OPT_BG > 8 then OPT_BG := 8;

        //brick field 19x29. erazing.
        for i := 0 to BRICK_X-1 do
        for z := 0 to BRICK_Y-1 do begin
        bbb[i,z].image :=0;
        bbb[i,z].block :=false;
        bbb[i,z].respawntime := 0;
        bbb[i,z].y :=0;
        bbb[i,z].dir  :=0;
        bbb[i,z].scale := 255;
        bbb[i,z].oy  :=0;
        bbb[i,z].respawnable := false;
        end;

        map_name := header.MapName;
        map_author := header.Author;
        RESPAWNS_COUNT := 0;
        RESPAWNSRED_COUNT := 0;
        RESPAWNSBLUE_COUNT := 0;
        for a := 0 to header.MapSizeY - 1 do begin
                DemoStream.read(buf,header.MapSizeX);
        for z := 0 to header.MapSizeX - 1 do
                bbb[z,a].image := buf[z];
        end;

        // prepare some of bricks.
        for a := 0 to BRICK_X do
       for z := 0 to BRICK_Y do begin
        if (bbb[a,z].image >= 1) and (bbb[a,z].image <= 30) then begin // items
                bbb[a,z].block := false;
                bbb[a,z].respawnable := true;
                bbb[a,z].respawntime := 0;
        end;
        if (bbb[a,z].image = 34) then begin // respawn point.
                bbb[a,z].block := false;
                bbb[a,z].respawnable := false;
                bbb[a,z].respawntime := -1;
                bbb[a,z].image := 0;
                inc(RESPAWNS_COUNT);
        end;
        if (bbb[a,z].image >= 54) then begin // bricks
                bbb[a,z].block := true;
                bbb[a,z].respawnable := false;
                bbb[a,z].respawntime := 0;
        end;
        if (bbb[a,z].image >= 31) and (bbb[a,z].image <= 39) then begin  // misc
                bbb[a,z].block := false;
                bbb[a,z].respawnable := false;
                bbb[a,z].respawntime := 0;
        end;
        if (bbb[a,z].image = 37) then begin // empty
                bbb[a,z].block := true;
                bbb[a,z].respawnable := false;
                bbb[a,z].respawntime := 0;
        end;

        if (bbb[a,z].image >= 40) and (bbb[a,z].image <= 42) then
                bbb[a,z].dir := 0;

       end;
        // ======== border block.
        // fill border. pp bugs protection.
        for i := 0 to BRICK_X-1 do begin
        bbb[i,0].block := true;
        bbb[i,BRICK_Y-1].block := true;

                if bbb[i,0].image = 37 then bbb[i,0].image := 0;
                if bbb[i,BRICK_Y-1].image = 37 then bbb[i,BRICK_Y-1].image := 0;
        end;
         for i := 1 to BRICK_Y-2 do begin
        bbb[0,i].block := true;
        bbb[BRICK_X-1,i].block := true;

                if bbb[0,i].image = 37 then bbb[0,i].image := 0;
                if bbb[BRICK_X-1,i].image = 37 then bbb[BRICK_X-1,i].image := 0;
        end;

        GetMapWeaponData; // for stats.

        OPT_SHOWSTATS := false;
        GX := 0; GY := 0;
        if (BRICK_X = 20) and (BRICK_Y = 30) then OPT_CAMERATYPE := 0 else OPT_CAMERATYPE := 1;

        // reset special objects.
        for i := 0 to 255 do ddd[i].active := false;

        MSG_DISABLE := FALSE;

        if header.numobj > 0 then begin
                NUM_OBJECTS := header.numobj-1;
                NUM_OBJECTS_0 := false;
        end;

        z := 0;
        if not NUM_OBJECTS_0 then
        for a := 0 to header.numobj-1 do begin
        DemoStream.read(tmp,sizeof(tmp));

             if tmp.objtype = 1 then begin
                ddd[z].active := true;
                ddd[z].x := tmp.x;
                ddd[z].y := tmp.y;
                ddd[z].lenght := tmp.lenght;
                ddd[z].dir := tmp.dir;
                ddd[z].objtype := 1;
                inc(z);
             end;
             if tmp.objtype = 2 then begin
                ddd[z].active := true;
                ddd[z].objtype := 2;
                ddd[z].x := tmp.x;
                ddd[z].y := tmp.y;
                ddd[z].target := tmp.target;
                ddd[z].targetname := 0;
                ddd[z].wait := tmp.wait;
                ddd[z].orient := tmp.orient;
                ddd[z].special := tmp.special;
                ddd[z].nowanim := 0;
                inc(z);
             end;
             if tmp.objtype = 3 then begin
                ddd[z].active := true;
                ddd[z].objtype := 3;
                ddd[z].x := tmp.x;
                ddd[z].y := tmp.y;
                ddd[z].targetname := tmp.targetname;
                if tmp.wait = 0 then tmp.wait := 100;
                ddd[z].wait := tmp.wait;
                ddd[z].lenght := tmp.lenght;
                ddd[z].special := tmp.special;
                ddd[z].dir := 1;
                ddd[z].orient := tmp.orient;
                if (ddd[z].orient = 1) or (ddd[z].orient = 0) then ddd[z].target := 1 else ddd[z].target := 0;
                ddd[z].nowanim := 0;
                inc(z);
             end;
             if tmp.objtype = 4 then begin
                ddd[z].active := true;
                ddd[z].objtype := 4;
                ddd[z].x := tmp.x;
                ddd[z].y := tmp.y;
                ddd[z].target := tmp.target;
                ddd[z].wait := tmp.wait;
                ddd[z].lenght := tmp.lenght;
                ddd[z].dir := tmp.dir;
                inc(z);
             end;
             if tmp.objtype = 5 then begin
                ddd[z].active := true;
                ddd[z].objtype := 5;
                ddd[z].x := tmp.x;
                ddd[z].y := tmp.y;
                ddd[z].target := tmp.target;
                ddd[z].wait := tmp.wait;
                ddd[z].lenght := tmp.lenght;
                ddd[z].dir := tmp.dir;
                ddd[z].orient := tmp.orient;
                ddd[z].special := tmp.special;
                inc(z);
             end;
             if tmp.objtype = 6 then begin
                ddd[z].active := true;
                ddd[z].objtype := 6;
                ddd[z].x := tmp.x;              // area sizes
                ddd[z].y := tmp.y;
                ddd[z].special := tmp.special;  // lenght_
                ddd[z].lenght := tmp.lenght;    // actwait
                ddd[z].orient := tmp.orient;    // lenght_
                ddd[z].targetname := tmp.targetname; // to be activated
                ddd[z].nowanim := tmp.nowanim ;        // refresh
                ddd[z].dir := tmp.dir;          // dmg
                ddd[z].wait := ddd[z].lenght;
                inc(z);
             end;
             if tmp.objtype = 7 then begin
                ddd[z].active := true;
                ddd[z].objtype := 7;
                ddd[z].x := tmp.x;           // area sizes
                ddd[z].y := tmp.y;
                ddd[z].special := tmp.special;  // lenght_
                ddd[z].orient := tmp.orient;    // lenght_
                inc(z);
             end;
             if tmp.objtype = 8 then begin  /// area_teleport
                ddd[z].active := true;
                ddd[z].objtype := 8;
                ddd[z].x := tmp.x;           // area sizes
                ddd[z].y := tmp.y;
                ddd[z].special := tmp.special;  // lenght_
                ddd[z].orient := tmp.orient;    // lenght_
                ddd[z].dir := tmp.dir;
                ddd[z].wait := tmp.wait;
                inc(z);
             end;
             if tmp.objtype = 9 then begin // doortrigger
                ddd[z].active := true;
                ddd[z].objtype := 9;
                ddd[z].x := tmp.x;
                ddd[z].y := tmp.y;
                ddd[z].target := tmp.target;
                tmp.wait := 5;
                ddd[z].wait := tmp.wait;
                ddd[z].lenght := tmp.lenght;
                ddd[z].orient := tmp.orient;
                inc(z);
             end;
             if tmp.objtype = 10 then begin // waterillusion
                ddd[z].active := true;
                ddd[z].objtype := 10;
                ddd[z].x := tmp.x;
                ddd[z].y := tmp.y;
                ddd[z].special := tmp.special;
                ddd[z].orient := tmp.orient;
                inc(z);
             end;

        end;

        // ulimited loop of reading Entries.
        while true do begin

        // cycling reading
        DemoStream.read(Entry,sizeof(Entry));

        if (Entry.EntryType <> 'pal') and (Entry.EntryType <> 'loc') then begin // nothing here... exit
                DemoStream.Position := DemoStream.Position - sizeof(Entry);
                exit;
                end;

        if (Entry.EntryType = 'pal') then begin
        //      Reading palette entry. decompressed.
                DecompressedPaletteStream.Clear;
                DecompressedPaletteStream.CopyFrom(DemoStream, Entry.Datasize);
                DecompressedPaletteStream.Position := 0;

                SYS_USECUSTOMPALETTE := TRUE;
                SYS_USECUSTOMPALETTE_TRANSPARENT := Entry.Reserved6;
                SYS_USECUSTOMPALETTE_TRANS_COLOR := Entry.Reserved5;

//              update powerdraw...
                if Assigned(mainform.Images[48]) then mainform.Images[48].Finalize();
                mainform.images[48].LoadFromStream(mainform.PowerGraph.D3DDevice8,DeCompressedPaletteStream,32,16,256,256,D3DFMT_A1R5G5B5);
                if SYS_USECUSTOMPALETTE_TRANSPARENT then
                mainform.images[48].Set1bitAlpha(SYS_USECUSTOMPALETTE_TRANS_COLOR);
//                DemoStream.Position := DemoStream.Position + Entry.Datasize;

        end else
        if (Entry.EntryType = 'loc') then begin // reading location table. decompressed.
                for a := 1 to Entry.Datasize div sizeof(TLocationText) do
                        DemoStream.Read (LocationsArray[a],sizeof(LocationsArray[a]));
        end;

        end; // end whiletrue

        exit;
end;
// -------------------------------------------

  chdir(ROOTDIR+'\maps');
  if not fileexists(filename) then begin
        addmessage('^1Could not find map '+extractfilename(filename));
        exit;
        end;

try

  map_crc32 := loadmapcrc32 (filename);

  AssignFile(F, filename);
  Reset(F,1);
  BlockRead(F, Header, Sizeof(Header));

except
        if inreal then
        ShowCriticalError('Error loading map',extractfilename(filename) +' is not NFK map','') else
        ShowCriticalError('Error loading map',extractfilename(filename) +' is not NFK demo','');
        closefile(f);
        playsound(SND_error,0,0);
        Applyhcommand('disconnect');
        exit;
end;


  if header.ID <> 'NMAP' then begin
        closefile(f);
        addmessage(filename +' is not NFK map');
        ShowCriticalError('Error loading map',extractfilename(filename) +' is not NFK map','');
        playsound(SND_error,0,0);
        Applyhcommand('disconnect');
        exit;
        end;

        if (header.Version <> 3) then begin
                addmessage(' incorrect map version ('+inttostr(header.version)+') at the ' +extractfilename(filename)+'. Only version 3 supported.');
                ShowCriticalError('Incorrect map version','Incorrect '+extractfilename(filename)+' version ('+inttostr(header.version)+')','Only version 3 supported.');
                Applyhcommand('disconnect');
                exit;
        end;


  BRICK_X := header.MapSizeX ;
  BRICK_Y := header.MapSizeY;
  if OPT_ALLOWMAPCHANGEBG then if header.BG > 0 then OPT_BG := header.BG;

//brick field 19x29
 for i := 0 to BRICK_X-1 do
 for z := 0 to BRICK_Y-1 do begin
        bbb[i,z].image :=0;
        bbb[i,z].block :=false;
        bbb[i,z].respawntime := 0;
        bbb[i,z].y :=0;
        bbb[i,z].dir  :=0;
        bbb[i,z].scale := 255;
        bbb[i,z].oy  :=0;
        bbb[i,z].respawnable := false;
 end;

  map_name := header.MapName;
  map_bg := header.BG;
//  addmessage('^5LOADMAP: '+filename);
  map_filename_fullpath := filename;
  map_filename := copy(extractfilename(filename),0,length(extractfilename(filename))-5);


  map_author := header.Author;
  RESPAWNS_COUNT := 0;
  RESPAWNSRED_COUNT := 0;
  RESPAWNSBLUE_COUNT := 0;
  for a := 0 to header.MapSizeY - 1 do begin
        blockread(f,buf,header.MapSizeX);
        for z := 0 to header.MapSizeX - 1 do
                bbb[z,a].image := buf[z];
  end;

  for a := 0 to BRICK_X do
  for z := 0 to BRICK_Y do begin
        if (bbb[a,z].image >= 1) and (bbb[a,z].image <= 30) then begin // items
                bbb[a,z].block := false;
                bbb[a,z].respawnable := true;
                bbb[a,z].respawntime := 0;
        end;

        if (bbb[a,z].image = 34) then begin // respawn point.
                bbb[a,z].block := false;
                bbb[a,z].respawnable := false;
                bbb[a,z].image := 0;
                bbb[a,z].respawntime := 0;

                if (a>0) and (a < BRICK_X-1) and (z > 0) and (z < BRICK_Y-1) then begin
                        bbb[a,z].respawntime := -1;
                        inc(RESPAWNS_COUNT);
                end;
        end;
        if (bbb[a,z].image = CONTENT_RESPAWNRED) then begin // red respawn point.
                bbb[a,z].block := false;
                bbb[a,z].respawnable := false;
//                bbb[a,z].image := 0;
                bbb[a,z].respawntime := 0;

                if (a>0) and (a < BRICK_X-1) and (z > 0) and (z < BRICK_Y-1) then begin
//                        bbb[a,z].respawntime := -1;
                        inc(RESPAWNSRED_COUNT);
                end;
        end;
        if (bbb[a,z].image = CONTENT_RESPAWNBLUE) then begin // blue respawn point.
                bbb[a,z].block := false;
                bbb[a,z].respawnable := false;
//                bbb[a,z].image := 0;
                bbb[a,z].respawntime := 0;

                if (a>0) and (a < BRICK_X-1) and (z > 0) and (z < BRICK_Y-1) then begin
//                        bbb[a,z].respawntime := -1;
                        inc(RESPAWNSBLUE_COUNT);
                end;
        end;

        if (bbb[a,z].image >= 54) then begin // bricks
                bbb[a,z].block := true;
                bbb[a,z].respawnable := false;
                bbb[a,z].respawntime := 0;
        end;
        if (bbb[a,z].image >= 31) and (bbb[a,z].image <= 39) then begin  // misc
                bbb[a,z].block := false;
                bbb[a,z].respawnable := false;
                bbb[a,z].respawntime := 0;
        end;
        if (bbb[a,z].image = 37) then begin // empty
                bbb[a,z].block := true;
                bbb[a,z].respawnable := false;
                bbb[a,z].respawntime := 0;
//              bbb[a,z].image := 0;
        end;
  end;


  // fill border. ppl bugs protection.
 for i := 0 to BRICK_X-1 do begin
        bbb[i,0].block := true;
        bbb[i,BRICK_Y-1].block := true;

                if bbb[i,0].image = 37 then bbb[i,0].image := 0;
                if bbb[i,BRICK_Y-1].image = 37 then bbb[i,BRICK_Y-1].image := 0;
        end;
 for i := 1 to BRICK_Y-2 do begin
        bbb[0,i].block := true;
        bbb[BRICK_X-1,i].block := true;

                if bbb[0,i].image = 37 then bbb[0,i].image := 0;
                if bbb[BRICK_X-1,i].image = 37 then bbb[BRICK_X-1,i].image := 0;
        end;




  GetMapWeaponData;

  OPT_SHOWSTATS := false;
  GX := 0; GY := 0;
  if (BRICK_X = 20) and (BRICK_Y = 30) then OPT_CAMERATYPE := 0 else OPT_CAMERATYPE := 1;

//addmessage('number of objects: '+inttostr(header.numobj));
for i := 0 to 255 do ddd[i].active := false;

MSG_DISABLE := FALSE;

if inreal then
        if header.numobj = 0 then begin
//                CloseFile(F);
                NUM_OBJECTS_0 := true;
//                addmessage('no map objects');
//                exit;
        end;

        if header.numobj > 0 then begin
                NUM_OBJECTS := header.numobj-1;
                NUM_OBJECTS_0 := false;
        end;
//end;

z := 0;
if not NUM_OBJECTS_0 then
for a := 0 to header.numobj-1 do begin
        if inreal then
        blockread(f,tmp,sizeof(tmp)) else
        DemoStream.read(tmp,sizeof(tmp));

             if tmp.objtype = 1 then begin
                ddd[z].active := true;
                ddd[z].x := tmp.x;
                ddd[z].y := tmp.y;
                ddd[z].lenght := tmp.lenght;
                ddd[z].dir := tmp.dir;
                ddd[z].objtype := 1;
                inc(z);
             end;
             if tmp.objtype = 2 then begin
                ddd[z].active := true;
                ddd[z].objtype := 2;
                ddd[z].x := tmp.x;
                ddd[z].y := tmp.y;
                ddd[z].target := tmp.target;
                ddd[z].targetname := 0;
                ddd[z].wait := tmp.wait;
                ddd[z].orient := tmp.orient;
                ddd[z].special := tmp.special;
                ddd[z].nowanim := 0;
                inc(z);
             end;
             if tmp.objtype = 3 then begin
                ddd[z].active := true;
                ddd[z].objtype := 3;
                ddd[z].x := tmp.x;
                ddd[z].y := tmp.y;
                ddd[z].targetname := tmp.targetname;
                if tmp.wait = 0 then tmp.wait := 100;
                ddd[z].wait := tmp.wait;
                ddd[z].lenght := tmp.lenght;
                ddd[z].special := tmp.special;
                ddd[z].dir := 1;
                ddd[z].orient := tmp.orient;
                if (ddd[z].orient = 1) or (ddd[z].orient = 0) then ddd[z].target := 1 else ddd[z].target := 0;
                ddd[z].nowanim := 0;
                inc(z);
             end;
             if tmp.objtype = 4 then begin
                ddd[z].active := true;
                ddd[z].objtype := 4;
                ddd[z].x := tmp.x;
                ddd[z].y := tmp.y;
                ddd[z].target := tmp.target;
                ddd[z].wait := tmp.wait;
                ddd[z].lenght := tmp.lenght;
                ddd[z].dir := tmp.dir;
                inc(z);
             end;
             if tmp.objtype = 5 then begin
                ddd[z].active := true;
                ddd[z].objtype := 5;
                ddd[z].x := tmp.x;
                ddd[z].y := tmp.y;
                ddd[z].target := tmp.target;
                ddd[z].wait := tmp.wait;
                ddd[z].lenght := tmp.lenght;
                ddd[z].dir := tmp.dir;
                ddd[z].orient := tmp.orient;
                ddd[z].special := tmp.special;
                inc(z);
             end;
             if tmp.objtype = 6 then begin
                ddd[z].active := true;
                ddd[z].objtype := 6;
                ddd[z].x := tmp.x;              // area sizes
                ddd[z].y := tmp.y;
                ddd[z].special := tmp.special;  // lenght_
                ddd[z].lenght := tmp.lenght;    // actwait
                ddd[z].orient := tmp.orient;    // lenght_
                ddd[z].targetname := tmp.targetname; // to be activated
                ddd[z].nowanim := tmp.nowanim ;        // refresh
                ddd[z].dir := tmp.dir;          // dmg
                ddd[z].wait := ddd[z].lenght;
                inc(z);
             end;
             if tmp.objtype = 7 then begin
                ddd[z].active := true;
                ddd[z].objtype := 7;
                ddd[z].x := tmp.x;           // area sizes
                ddd[z].y := tmp.y;
                ddd[z].special := tmp.special;  // lenght_
                ddd[z].orient := tmp.orient;    // lenght_
                inc(z);
             end;
             if tmp.objtype = 8 then begin  /// area_teleport
                ddd[z].active := true;
                ddd[z].objtype := 8;
                ddd[z].x := tmp.x;           // area sizes
                ddd[z].y := tmp.y;
                ddd[z].special := tmp.special;  // lenght_
                ddd[z].orient := tmp.orient;    // lenght_
                ddd[z].dir := tmp.dir;
                ddd[z].wait := tmp.wait;
                inc(z);
             end;
             if tmp.objtype = 9 then begin // doortrigger
                ddd[z].active := true;
                ddd[z].objtype := 9;
                ddd[z].x := tmp.x;
                ddd[z].y := tmp.y;
                ddd[z].target := tmp.target;
                tmp.wait := 5;
                ddd[z].wait := tmp.wait;
                ddd[z].lenght := tmp.lenght;
                ddd[z].orient := tmp.orient;
                inc(z);
             end;
             if tmp.objtype = 10 then begin // doortrigger
                ddd[z].active := true;
                ddd[z].objtype := 10;
                ddd[z].x := tmp.x;
                ddd[z].y := tmp.y;
                ddd[z].special := tmp.special;
                ddd[z].orient := tmp.orient;
                inc(z);
             end;
  //      freemem(tmp);
end;
///freemem(header);
//  applycommand('objdump');

// this proc is apply to not in real only!
// 040: READ SPECIAL TABLE OF ADDITIONAL MAP MODIFIERZ.

//realEOF := false;
//if  then realEOF := true;


SYS_USECUSTOMPALETTE := FALSE; // no palette data, by default...

if inreal then
while not EOF(F) do begin
        blockread(F,Entry,sizeof(Entry));

        if entry.EntryType = 'pal' then begin // read palette....
            CompressedPaletteStream := TMemoryStream.create;
            CompressedPaletteStream.Clear;
            DeCompressedPaletteStream.Clear;
            DeCompressedPaletteStream.Position;

            SYS_USECUSTOMPALETTE_TRANSPARENT := Entry.Reserved6;
            SYS_USECUSTOMPALETTE_TRANS_COLOR := Entry.Reserved5;

            TotalSize := 0;

            // extracting to memory stream, using buffer.
            repeat
                    if Entry.DataSize > TotalSize+BufSize then
                    NumRead := BufSize
                    else NumRead := Entry.DataSize-TotalSize;

                    BlockRead(F, Buffer, NumRead);// copy data from ppak to buffer;

                    inc(TotalSize,NumRead);
                    CompressedPaletteStream.Write(Buffer,NumRead); // write buffer to new file.
            until TotalSize >= Entry.DataSize;

            CompressedPaletteStream.Position := 0;
            BZDeCompress(CompressedPaletteStream, DeCompressedPaletteStream,ProgressCallback);
            DeCompressedPaletteStream.Position := 0;

            ProgressCallback := nil;
            SYS_USECUSTOMPALETTE := TRUE;

//          update powerdraw..
            if Assigned(mainform.Images[48]) then mainform.Images[48].Finalize();
                mainform.images[48].LoadFromStream(mainform.PowerGraph.D3DDevice8,DeCompressedPaletteStream,32,16,256,256, D3DFMT_A1R5G5B5);
            if SYS_USECUSTOMPALETTE_TRANSPARENT then
                mainform.images[48].Set1bitAlpha(SYS_USECUSTOMPALETTE_TRANS_COLOR);

            CompressedPaletteStream.Free;
        end else if entry.EntryType = 'loc' then begin // read location table....
//            For a := 1 to Entry.DataSize div Sizeof(TLocationText) do
              blockread(F, LocationsArray,Entry.DataSize);
        end;


end; // end reading entry...


// DETECTING SUPPORTED GAMEMODES;
    mapinfo.supportTRIX := false;
    mapinfo.supportCTF := false;
    mapinfo.supportDOM := false;

    for i := 0 to NUM_OBJECTS do if (ddd[i].active = true) and (ddd[i].objtype = 7) then
        mapinfo.supportTRIX := true;

    if CTF_ValidMap then mapinfo.supportCTF := true;
    if DOM_ValidMap then mapinfo.supportDOM := true;
// =

if inreal then CloseFile(F); // not demo. (btw, why it here?);

end; // proc

procedure TMainForm.apperror(sender:TObject; E: Exception);
var errmsg : string;
begin

//socket errors

errmsg := '';

if pos('socket error 10060',lowercase(e.message))<> 0 then errmsg := 'Connection timed out';
if pos('socket error 10061',lowercase(e.message))<> 0 then errmsg := 'Connection refused';

if errmsg<>'' then begin
        ShowCriticalError('Disconnected','NFK PLANET possibly down','Error: '+errmsg);
        applyHcommand('disconnect');
        exit;
        end;


if (pos('async lookup',lowercase(e.message))<> 0)
or (pos('10049',lowercase(e.message))<> 0)
or (pos('10065',lowercase(e.message))<> 0)
then begin
        mp_step := 0;
        BNET_LOBBY_STATUS := 3;
        lobby.active := false;
        exit;
        end;

if (pos('socket error 1005',lowercase(e.message))<> 0) then begin
        if inmenu=false then addmessage('^3NFKPLANET: Connection to NFK PLANET lost...') else
                begin
                        ShowCriticalError('Disconnected','Disconnected from NFK PLANET','');
                        applyHcommand('disconnect');
                end;
                exit;
        end;


addmessage('Internal Error: '+E.Message);
// Application.ShowException(E);
playsound(SND_error,0,0);
exit;
end;

// avoiding ALT+TAB bug.
procedure TMainForm.AppActivate(sender:TObject);
begin
if GAME_FULLLOAD then
if powergraph.FullScreen then DXTimer.MayProcess := true;
end;

procedure TMainForm.AppDeactivate(sender:TObject);
begin
if GAME_FULLLOAD then
if powergraph.FullScreen=true then DXTimer.MayProcess := false;
end;

function IsParamStr(ss : string) : boolean;
var d : byte;
begin
        for d := 0 to paramcount do
        if paramstr(d+1) = lowercase(ss) then begin result := true; exit; end;
        result := false;
end;

procedure DrawBMPFont(s : string; x,y : Smallint ;size : byte);
var i,nm : word;

begin
        exit;
        if s = '' then exit;
        for i := 1 to length(s) do begin
                nm := ord(s[i])-32;
//                case size of
//                14 : mainform.ImageList.Items.Find('font14').Draw(mainform.DXDraw.Surface, x+14*(i-1),y, nm);
  //              12 : mainform.ImageList.Items.Find('font12').Draw(mainform.DXDraw.Surface, x+12*(i-1),y, nm);
    //            10 : mainform.ImageList.Items.Find('font10').Draw(mainform.DXDraw.Surface, x+10*(i-1),y, nm);
      //          8  : mainform.ImageList.Items.Find('font8').Draw(mainform.DXDraw.Surface, x+8*(i-1),y, nm);
//                else addmessage('error: unknown font size: '+inttostr(size));
//                end;
        end;
end;

procedure DrawCBMPFont(s:string;y:integer;size:byte);
var x : word;
begin
      x := round(320-(length(s)*size)/2);
      DrawBMPFont(s,x,y,size);
end;

function IniGetString (filename,section,value: string):String;
var Inifile : TInifile;
begin
     result := '';
     if not FileExists(filename) then exit;
     IniFile := TIniFile.Create(getcurrentdir+'\'+filename);
     with IniFile do begin
     if ValueExists(section, value) then
     result := ReadString(section, value, '');
     free; end;
end;

procedure SC_LoadModels; // SC - system core :) not starcraft
var sr: TSearchRec;
    tmp,tmp2 : TStringList;
    i,a : smallint;
    err : boolean;
    filee : string;
    format : cardinal;
begin
  chdir(ROOTDIR+'\models');
  tmp := TStringList.create;
  tmp2 := TStringList.create;
  tmp.clear;
  tmp2.clear;
  err := false;

  if FindFirst('*.*', faDirectory, sr) = 0 then begin
                if (sr.attr and faDirectory) = faDirectory then
                if (sr.name <> '.') and (sr.name <> '..') then tmp.add(sr.name);
                while FindNext(sr) = 0 do
                if (sr.attr and faDirectory) = faDirectory then
                if (sr.name <> '.') and (sr.name <> '..') then tmp.add(sr.name);
        end;

  if tmp.count = 0 then begin
          loadi.cns.lines.add('FATAL ERROR: no models found.');
          mainform.close;
          exit;
          end;
  NUM_MODELS := 0;
  for i := 0 to tmp.count-1 do begin
        tmp2.clear;
        chdir(ROOTDIR+'\models');
        chdir(tmp[i]);

        if FindFirst('*.nmdl', faAnyFile, sr) = 0 then begin
        tmp2.add(sr.Name);
        while FindNext(sr) = 0 do
                tmp2.add(sr.Name);
        end;

        if tmp2.count = 0 then continue;

        // LOAD MODEL FROM INI;
     for a := 0 to tmp2.count - 1 do begin
        eee[NUM_MODELS].cached := false;
        err := false;
        loadi.cns.lines.add('Loading model "'+tmp[i]+'\'+tmp2[a]+'"');
        eee[NUM_MODELS].classname := lowercase(tmp[i]);
        eee[NUM_MODELS].skinname  := lowercase(IniGetString(tmp2[a],'main','name'));
        eee[NUM_MODELS].walkframes := strtoint(IniGetString(tmp2[a],'main','walkframes'));
        eee[NUM_MODELS].dieframes  := strtoint(IniGetString(tmp2[a],'main','dieframes'));
        eee[NUM_MODELS].modelsizex  := strtoint(IniGetString(tmp2[a],'main','modelsizex'));
        eee[NUM_MODELS].diesizey := strtoint(IniGetString(tmp2[a],'main','diesizey'));
        eee[NUM_MODELS].crouchsizex := strtoint(IniGetString(tmp2[a],'main','crouchsizex'));
        eee[NUM_MODELS].crouchsizey := strtoint(IniGetString(tmp2[a],'main','crouchsizey'));
        eee[NUM_MODELS].crouchframes := strtoint(IniGetString(tmp2[a],'main','crouchframes'));
        if eee[NUM_MODELS].modelsizex > 96 then eee[NUM_MODELS].modelsizex := 96;
        if eee[NUM_MODELS].diesizey > 96 then eee[NUM_MODELS].diesizey := 96;
        if eee[NUM_MODELS].crouchsizex > 96 then eee[NUM_MODELS].crouchsizex := 96;
        if eee[NUM_MODELS].crouchsizey > 96 then eee[NUM_MODELS].crouchsizey := 96;

        if not fileexists(IniGetString(tmp2[a],'main','walkbmp')) then begin err:=true; addmessage('notfound model.walkbmp'); end;
        if not fileexists(IniGetString(tmp2[a],'main','diebmp')) then begin err:=true; addmessage('notfound model.diebmp'); end;
        if not fileexists(IniGetString(tmp2[a],'main','crouchbmp')) then begin err:=true; addmessage('notfound model.crouchbmp'); end;
        if not fileexists(IniGetString(tmp2[a],'main','walkpowerbmp')) then begin err:=true; addmessage('notfound model.walkpowerbmp'); end;
        if not fileexists(IniGetString(tmp2[a],'main','crouchpowerupbmp')) then begin err:=true; addmessage('notfound model.crouchpowerupbmp'); end;
        if not fileexists('death1.wav') then begin err:=true; addmessage('notfound death1.wav'); end;
        if not fileexists('death2.wav') then begin err:=true; addmessage('notfound death2.wav'); end;
        if not fileexists('death3.wav') then begin err:=true; addmessage('notfound death3.wav'); end;
        if not fileexists('jump1.wav') then begin err:=true; addmessage('notfound jump1.wav'); end;
        if not fileexists('pain100_1.wav') then begin err:=true; addmessage('notfound pain100_1.wav'); end;
        if not fileexists('pain75_1.wav') then begin err:=true; addmessage('notfound pain75_1.wav'); end;
        if not fileexists('pain50_1.wav') then begin err:=true; addmessage('notfound pain50_1.wav'); end;
        if not fileexists('pain25_1.wav') then begin err:=true; addmessage('notfound pain25_1.wav'); end;

        if err=true then begin
                loadi.cns.lines.add('model "'+tmp[i]+'\'+tmp2[a]+'"'+' is invalid. ignored.');
                continue;
        end;

        if IniGetString(tmp2[a],'main','version') <> '2' then begin
                loadi.cns.lines.add('model "'+tmp[i]+'\'+tmp2[a]+'"'+' have old version. ignored.');
                continue;
        end;

        try
        filee := IniGetString(tmp2[a],'main','walkbmp');
        format := mainform.format2; if extractfileext(lowercase(filee)) <> '.tga' then format := D3DFMT_A1R5G5B5;
        mainform.IMAGES[IMAGE_LAST+1].LoadFromFile(mainform.PowerGraph.D3DDevice8,filee, eee[NUM_MODELS].modelsizex,48,256,256, format);
        if extractfileext(lowercase(filee)) <> '.tga' then
        mainform.IMAGES[IMAGE_LAST+1].Set1bitAlpha ($FFFFFF);
        except addmessage('error loading walk bitmap for model'); end;
        eee[NUM_MODELS].walk_index := IMAGE_LAST+1;

        try
        filee := IniGetString(tmp2[a],'main','diebmp');
        format := mainform.format2; if extractfileext(lowercase(filee)) <> '.tga' then format := D3DFMT_A1R5G5B5;
        mainform.IMAGES[IMAGE_LAST+2].LoadFromFile(mainform.PowerGraph.D3DDevice8,filee,52,eee[NUM_MODELS].diesizey,256,256, format);
        if extractfileext(lowercase(filee)) <> '.tga' then
        mainform.IMAGES[IMAGE_LAST+2].Set1bitAlpha ($FFFFFF);
        except addmessage('error loading die bitmap for model'); end;
        eee[NUM_MODELS].die_index := IMAGE_LAST+2;

        try
        filee := IniGetString(tmp2[a],'main','crouchbmp');
        format := mainform.format2; if extractfileext(lowercase(filee)) <> '.tga' then format := D3DFMT_A1R5G5B5;
        mainform.IMAGES[IMAGE_LAST+3].LoadFromFile(mainform.PowerGraph.D3DDevice8,filee,eee[NUM_MODELS].crouchsizex,eee[NUM_MODELS].crouchsizey,256,256, format);
        if extractfileext(lowercase(filee)) <> '.tga' then
        mainform.IMAGES[IMAGE_LAST+3].Set1bitAlpha ($FFFFFF);
        except addmessage('error loading crouch bitmap for model'); end;
        eee[NUM_MODELS].crouch_index := IMAGE_LAST+3;

        try
        filee := IniGetString(tmp2[a],'main','walkpowerbmp');
        format := mainform.format2; if extractfileext(lowercase(filee)) <> '.tga' then format := D3DFMT_A1R5G5B5;
        mainform.IMAGES[IMAGE_LAST+4].LoadFromFile(mainform.PowerGraph.D3DDevice8,filee,eee[NUM_MODELS].modelsizex,48,256,256, format);
        if extractfileext(lowercase(filee)) <> '.tga' then
        mainform.IMAGES[IMAGE_LAST+4].Set1bitAlpha ($000000);
        except addmessage('error loading walk power bitmap for model'); end;
        eee[NUM_MODELS].power_index := IMAGE_LAST+4;

        try
        filee := IniGetString(tmp2[a],'main','crouchpowerupbmp');
        format := mainform.format2; if extractfileext(lowercase(filee)) <> '.tga' then format := D3DFMT_A1R5G5B5;
        mainform.IMAGES[IMAGE_LAST+5].LoadFromFile(mainform.PowerGraph.D3DDevice8,filee,eee[NUM_MODELS].crouchsizex,eee[NUM_MODELS].crouchsizey,256,256, format);
        if extractfileext(lowercase(filee)) <> '.tga' then
        mainform.IMAGES[IMAGE_LAST+5].Set1bitAlpha ($000000);
        except addmessage('error loading crouch power bitmap for model'); end;
        eee[NUM_MODELS].cpower_index := IMAGE_LAST+5;

        eee[NUM_MODELS].walkstartframe := strtoint(IniGetString(tmp2[a],'main','walkstartframe'));
        eee[NUM_MODELS].crouchstartframe := strtoint(IniGetString(tmp2[a],'main','crouchstartframe'));
        eee[NUM_MODELS].framerefreshtime := strtoint(IniGetString(tmp2[a],'main','framerefreshtime'));
        eee[NUM_MODELS].crouchrefreshtime := strtoint(IniGetString(tmp2[a],'main','crouchrefreshtime'));

        if IniGetString(tmp2[a],'main','dieframerefreshtime')='' then eee[NUM_MODELS].dieframerefreshtime := eee[NUM_MODELS].framerefreshtime else
                eee[NUM_MODELS].dieframerefreshtime := strtoint(IniGetString(tmp2[a],'main','dieframerefreshtime'));//support old modelz

        if (eee[NUM_MODELS].framerefreshtime < 1) or (eee[NUM_MODELS].framerefreshtime >= 20) then
                eee[NUM_MODELS].framerefreshtime := 5;

        inc(IMAGE_LAST,5);
        inc(NUM_MODELS);
      end;
  end;

  if not GAME_FULLLOAD then for i := 0 to NUM_MODELS-1 do if (eee[i].cached = true) then eee[i].cached := false;

  // load all soundz;
  if not GAME_FULLLOAD then for i := 0 to NUM_MODELS-1 do if (eee[i].cached = false) then begin
                chdir(ROOTDIR+'\models\'+eee[i].classname);

                SAMPLES[FMOD_MAXSOUND+1] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'death1.wav', sampleformat, 0);
                SAMPLES[FMOD_MAXSOUND+2] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'death2.wav', sampleformat, 0);
                SAMPLES[FMOD_MAXSOUND+3] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'death3.wav', sampleformat, 0);
                SAMPLES[FMOD_MAXSOUND+4] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'jump1.wav', sampleformat, 0);
                SAMPLES[FMOD_MAXSOUND+5] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'pain100_1.wav', sampleformat, 0);
                SAMPLES[FMOD_MAXSOUND+6] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'pain75_1.wav', sampleformat, 0);
                SAMPLES[FMOD_MAXSOUND+7] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'pain50_1.wav', sampleformat, 0);
                SAMPLES[FMOD_MAXSOUND+8] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'pain25_1.wav', sampleformat, 0);
                eee[i].SND_death1 := FMOD_MAXSOUND+1;
                eee[i].SND_death2 := FMOD_MAXSOUND+2;
                eee[i].SND_death3 := FMOD_MAXSOUND+3;
                eee[i].SND_Jump := FMOD_MAXSOUND+4;
                eee[i].SND_Pain100 := FMOD_MAXSOUND+5;
                eee[i].SND_Pain75 := FMOD_MAXSOUND+6;
                eee[i].SND_Pain50 := FMOD_MAXSOUND+7;
                eee[i].SND_Pain25 := FMOD_MAXSOUND+8;
                eee[i].cached := true;

                // cache the same skinz
                for a := 0 to NUM_MODELS-1 do if (eee[a].cached = false) and (eee[a].classname = eee[i].classname) then begin
                        eee[a].cached := true;
                        eee[a].SND_death1 := FMOD_MAXSOUND+1;
                        eee[a].SND_death2 := FMOD_MAXSOUND+2;
                        eee[a].SND_death3 := FMOD_MAXSOUND+3;
                        eee[a].SND_Jump :=   FMOD_MAXSOUND+4;
                        eee[a].SND_Pain100 :=FMOD_MAXSOUND+5;
                        eee[a].SND_Pain75 := FMOD_MAXSOUND+6;
                        eee[a].SND_Pain50 := FMOD_MAXSOUND+7;
                        eee[a].SND_Pain25 := FMOD_MAXSOUND+8;
                end;
                inc(FMOD_MAXSOUND,8);
  end;

  loadi.cns.lines.add(Inttostr(NUM_MODELS)+' models processed.');
  FindClose(sr);
  chdir(rootdir);
end;



procedure TMainForm.LoadGrafix();
// var Res: Integer;
var ts : tstringlist;
begin
 Images[0].LoadFromVTDb(VTDb, PowerGraph.D3DDevice8, 'bg_menu', Format1);
 Images[1].LoadFromVTDb(VTDb, PowerGraph.D3DDevice8, 'mainmenu', Format2);
 Images[2].LoadFromVTDb(VTDb, PowerGraph.D3DDevice8, 'combust', Format2);
 Images[3].LoadFromVTDb(VTDb, PowerGraph.D3DDevice8, '32x32', Format2);
 Images[4].LoadFromVTDb(VTDb, PowerGraph.D3DDevice8, 'logo', Format2);
 Images[5].LoadFromVTDb(VTDb, PowerGraph.D3DDevice8, 'buttons', D3DFMT_A4R4G4B4);
 Images[6].LoadFromVTDb(VTDb, PowerGraph.D3DDevice8, 'console', Format2);

 if fileexists(ROOTDIR+'\custom\bg_1.jpg') then
 images[11].LoadFromFileAuto(PowerGraph.D3DDevice8, ROOTDIR+'\custom\bg_1.jpg', Format1) else
 Images[11].LoadFromVTDb(VTDb, PowerGraph.D3DDevice8, 'bg_1', Format1);

 if fileexists(ROOTDIR+'\custom\bg_2.jpg') then
 images[12].LoadFromFileAuto(PowerGraph.D3DDevice8, ROOTDIR+'\custom\bg_2.jpg', Format1) else
 Images[12].LoadFromVTDb(VTDb, PowerGraph.D3DDevice8, 'bg_2', Format1);

 if fileexists(ROOTDIR+'\custom\bg_3.jpg') then
 images[13].LoadFromFileAuto(PowerGraph.D3DDevice8, ROOTDIR+'\custom\bg_3.jpg', Format1) else
 Images[13].LoadFromVTDb(VTDb, PowerGraph.D3DDevice8, 'bg_3', Format1);

 if fileexists(ROOTDIR+'\custom\bg_4.jpg') then
 images[14].LoadFromFileAuto(PowerGraph.D3DDevice8, ROOTDIR+'\custom\bg_4.jpg', Format1) else
 Images[14].LoadFromVTDb(VTDb, PowerGraph.D3DDevice8, 'bg_4', Format1);

 if fileexists(ROOTDIR+'\custom\bg_5.jpg') then
 images[15].LoadFromFileAuto(PowerGraph.D3DDevice8, ROOTDIR+'\custom\bg_5.jpg', Format1) else
 Images[15].LoadFromVTDb(VTDb, PowerGraph.D3DDevice8, 'bg_5', Format1);

 if fileexists(ROOTDIR+'\custom\bg_6.jpg') then
 images[16].LoadFromFileAuto(PowerGraph.D3DDevice8, ROOTDIR+'\custom\bg_6.jpg', Format1) else
 Images[16].LoadFromVTDb(VTDb, PowerGraph.D3DDevice8, 'bg_6', Format1);

 if fileexists(ROOTDIR+'\custom\bg_7.jpg') then
 images[17].LoadFromFileAuto(PowerGraph.D3DDevice8, ROOTDIR+'\custom\bg_7.jpg', Format1) else
 Images[17].LoadFromVTDb(VTDb, PowerGraph.D3DDevice8, 'bg_7', Format1);

 if fileexists(ROOTDIR+'\custom\bg_8.jpg') then
 images[18].LoadFromFileAuto(PowerGraph.D3DDevice8, ROOTDIR+'\custom\bg_8.jpg', Format1) else
 Images[18].LoadFromVTDb(VTDb, PowerGraph.D3DDevice8, 'bg_8', Format1);

// Images[19].LoadFromVTDb(VTDb, PowerGraph.D3DDevice8, 'lava_anim', Format2);

 Images[20].LoadFromVTDb(VTDb, PowerGraph.D3DDevice8, 'bricks_t', Format1);
 Images[21].LoadFromVTDb(VTDb, PowerGraph.D3DDevice8, 'bricks_t2', Format2);
 Images[22].LoadFromVTDb(VTDb, PowerGraph.D3DDevice8, 'item', Format2);
 Images[23].LoadFromVTDb(VTDb, PowerGraph.D3DDevice8, 'medkit', Format2);
 Images[24].LoadFromVTDb(VTDb, PowerGraph.D3DDevice8, 'jumppad_anim', Format2);
 Images[25].LoadFromVTDb(VTDb, PowerGraph.D3DDevice8, 'gauntlet', Format2);
 Images[26].LoadFromVTDb(VTDb, PowerGraph.D3DDevice8, 'weapons', Format2);
 Images[27].LoadFromVTDb(VTDb, PowerGraph.D3DDevice8, 'crosshair', Format2);
 Images[28].LoadFromVTDb(VTDb, PowerGraph.D3DDevice8, 'smoke', Format2);
 Images[29].LoadFromVTDb(VTDb, PowerGraph.D3DDevice8, 'shaft', Format2);
 Images[30].LoadFromVTDb(VTDb, PowerGraph.D3DDevice8, 'portal', Format2);
 Images[31].LoadFromVTDb(VTDb, PowerGraph.D3DDevice8, 'portal_anim', Format2);
 Images[32].LoadFromVTDb(VTDb, PowerGraph.D3DDevice8, 'flash', Format2);
 Images[33].LoadFromVTDb(VTDb, PowerGraph.D3DDevice8, 'explosion', D3DFMT_A4R4G4B4);
 Images[34].LoadFromVTDb(VTDb, PowerGraph.D3DDevice8, '24x24', D3DFMT_A4R4G4B4);
 Images[35].LoadFromVTDb(VTDb2, PowerGraph.D3DDevice8, '16x16', D3DFMT_A4R4G4B4);
// Images[35].LoadFromVTDb(VTDb, PowerGraph.D3DDevice8, '16x16', D3DFMT_A4R4G4B4);
 Images[36].LoadFromVTDb(VTDb, PowerGraph.D3DDevice8, '8x8', Format2);
 Images[37].LoadFromVTDb(VTDb, PowerGraph.D3DDevice8, 'medkits', Format2);
 Images[38].LoadFromVTDb(VTDb, PowerGraph.D3DDevice8, 'statusbar', D3DFMT_A4R4G4B4);
 Images[39].LoadFromVTDb(VTDb, PowerGraph.D3DDevice8, 'weapbar', Format2);
 Images[40].LoadFromVTDb(VTDb, PowerGraph.D3DDevice8, 'powerup', Format2);

 if fileexists(ROOTDIR+'\custom\stats.jpg') then
 images[41].LoadFromFileAuto(PowerGraph.D3DDevice8, ROOTDIR+'\custom\stats.jpg', Format2) else
 Images[41].LoadFromVTDb(VTDb, PowerGraph.D3DDevice8, 'stats', Format2);

 Images[42].LoadFromVTDb(VTDb, PowerGraph.D3DDevice8, 'mainmenu_glow', Format2);
 Images[43].LoadFromVTDb(VTDb, PowerGraph.D3DDevice8, 'scrollbar', Format2);
 Images[44].LoadFromVTDb(VTDb, PowerGraph.D3DDevice8, 'cursorz', Format2);
 Images[45].LoadFromVTDb(VTDb, PowerGraph.D3DDevice8, 'loader', Format2);
 Images[46].LoadFromVTDb(VTDb, PowerGraph.D3DDevice8, 'buttons2', Format2);
 Images[47].LoadFromVTDb(VTDb, PowerGraph.D3DDevice8, 'flag', Format2);

// Images[48]. custom brick palette...
 if SYS_USECUSTOMPALETTE then begin
        DeCompressedPaletteStream.Position := 0;
        images[48].LoadFromStream(PowerGraph.D3DDevice8,DeCompressedPaletteStream,32,16,256,256,D3DFMT_A1R5G5B5);
        if SYS_USECUSTOMPALETTE_TRANSPARENT then images[48].Set1bitAlpha(SYS_USECUSTOMPALETTE_TRANS_COLOR);
 end;

 if fileexists(ROOTDIR+'\custom\console.jpg') then begin
        images[49].LoadFromFileAuto(PowerGraph.D3DDevice8, ROOTDIR+'\custom\console.jpg', D3DFMT_R5G6B5);
        SYS_CUSTOM_GRAPH_CONSOLE := TRUE;
 end;

// Images[50].LoadFromVTDb(VTDb, PowerGraph.D3DDevice8, 'energypole', D3DFMT_R5G6B5);
 Images[50].LoadFromVTDb(VTDb, PowerGraph.D3DDevice8,'weapicon', D3DFMT_A1R5G5B5);
 Images[51].LoadFromVTDb(VTDb, PowerGraph.D3DDevice8, 'ctf_icons', Format2);
 Images[53].LoadFromVTDb(VTDb, PowerGraph.D3DDevice8, 'dom1_2', Format2);
 Images[52].LoadFromVTDb(VTDb, PowerGraph.D3DDevice8, 'dom1_3', Format2);
 Images[54].LoadFromVTDb(VTDb, PowerGraph.D3DDevice8, 'glow', Format2);
 Images[55].LoadFromVTDb(VTDb, PowerGraph.D3DDevice8, 'smoke32b', Format2);

// images[56].LoadFromFile(PowerGraph.D3DDevice8,ROOTDIR+'\planet.bmp',48,48,256,256,D3DFMT_A1R5G5B5);
// images[56].Set1bitAlpha ($FFFFFF);

// images[57].LoadFromFile(PowerGraph.D3DDevice8,ROOTDIR+'\system\p1.dat',24,23,128,128,D3DFMT_A1R5G5B5);
 Images[57].LoadFromVTDb(VTDb2, PowerGraph.D3DDevice8, 'gui', D3DFMT_A1R5G5B5);
// images[57].Set1bitAlpha ($FF00FF);

 if fileexists(ROOTDIR+'\system\p2.dat') then begin
        images[56].LoadFromFileAuto(PowerGraph.D3DDevice8, ROOTDIR+'\system\p2.dat', D3DFMT_R5G6B5);
        SYS_BANNER := TRUE;
 end;

 Images[19].LoadFromVTDb(VTDb2,PowerGraph.D3DDevice8,'env_lava', D3DFMT_R5G6B5);
 Images[58].LoadFromVTDb(VTDb2,PowerGraph.D3DDevice8,'env_water',D3DFMT_R5G6B5);
 Images[59].LoadFromVTDb(VTDb2,PowerGraph.D3DDevice8, 'gibs', Format2);
 Images[60].LoadFromVTDb(VTDb2,PowerGraph.D3DDevice8, 'labels', Format2);
 Images[61].LoadFromFile(PowerGraph.D3DDevice8, ROOTDIR+'\system\numbers.tga', 32, 32,256,256, Format2);
 Images[62].LoadFromFile(PowerGraph.D3DDevice8, ROOTDIR+'\system\armors.tga', 32, 16,128,128, Format2);
 Images[63].LoadFromFile(PowerGraph.D3DDevice8, ROOTDIR+'\system\icons2.tga', 32, 32,128,128, Format2);
// Images[60].Set1bitAlpha ($0);


 IMAGE_LAST := 64;

 Font1.LoadFromFile(ROOTDIR+'\system\verdana10.fnt', Format2);
 Font2.LoadFromFile(ROOTDIR+'\system\verdana8.fnt', Format2);
 Font2b.LoadFromFile(ROOTDIR+'\system\verdana8b.fnt', Format2);
 Font2s.LoadFromFile(ROOTDIR+'\system\verdana7.fnt', Format2);
 Font2ss.LoadFromFile(ROOTDIR+'\system\verdana7ss.fnt', Format2);
 Font3.LoadFromFile(ROOTDIR+'\system\vag14.fnt', Format2);
 Font4.LoadFromFile(ROOTDIR+'\system\vag12.fnt', Format2);

 if GAME_FULLLOAD then SC_LoadModels;

end;

// replace russian(mexican, columbian,china, etc) string of connections names to english strings. Read from DirectPlay registry data.
Procedure FillMP_ProvidersMirror;
var Reg : TRegistry;
    i,b : byte;
    tmp: TStringList;
begin
        exit;

        Tmp := TStringList.Create;
        Reg := TRegistry.Create;
        MP_Providers.Assign(MP_Providers);
        Reg.RootKey := HKEY_LOCAL_MACHINE;

        if MP_Providers.count <= 1 then begin
                addmessage('error: failed to enumerate connection types. Possibly DirectX Failure. Multiplayer may not available...');
                exit;
                end;

        with reg do begin
                OpenKey('Software\Microsoft\DirectPlay\Service Providers', false);
                GetKeyNames(TMP);
                if TMP.count <= 1 then begin
                                addmessage('error: failed to enumerate connection types. Possibly DirectX Failure. Multiplayer may not available...');
                                exit;
                        end;

                Reg.CloseKey;

                for i := 0 to TMP.Count-1 do begin
                        Reg.RootKey := HKEY_LOCAL_MACHINE;
                        OpenKey('Software\Microsoft\DirectPlay\Service Providers\'+TMP[i], false);
                        for b := 0 to MP_Providers.Count-1 do
                                if ReadString('DescriptionW') = MP_Providers[b] then
                                        MP_Providers[b] := tmp[i];
                        Reg.CloseKey;
                end;
        end;

        Reg.Free;
        TMP.Free;
end;

procedure NFKSAMPLESLOAD;
var i : byte;
begin
 if not directoryexists(ROOTDIR+'\sound') then begin
        OPT_SOUND := false;
        addmessage('^1No sounds found. Sound disabled.');
        exit;
        end;
 chdir(ROOTDIR+'\sound\');

 try
 SAMPLES[SND_1_MIN] := FSOUND_Sample_Load(FSOUND_UNMANAGED, '1_min.wav', sampleformat, 0);
 SAMPLES[SND_5_MIN] := FSOUND_Sample_Load(FSOUND_UNMANAGED, '5_min.wav', sampleformat, 0);
 SAMPLES[SND_ammopkup] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'ammopkup.wav', sampleformat, 0);
 SAMPLES[SND_armor] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'armor.wav', sampleformat, 0);
 SAMPLES[SND_bfg_fire] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'bfg_fire.wav', sampleformat, 0);
 SAMPLES[SND_Bounce] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'Bounce.wav', sampleformat, 0);
 SAMPLES[SND_Button] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'button.wav', sampleformat, 0);
 SAMPLES[SND_Damage2] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'Damage2.wav', sampleformat, 0);
 SAMPLES[SND_Damage3] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'Damage3.wav', sampleformat, 0);
 SAMPLES[SND_Dr1_end] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'Dr1_end.wav', sampleformat, 0);
 SAMPLES[SND_Dr1_strt] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'DR1_STRT.WAV', sampleformat, 0);
 SAMPLES[SND_error] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'Error.wav', sampleformat, 0);
 SAMPLES[SND_excellent] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'excellent.wav', sampleformat, 0);
 SAMPLES[SND_expl] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'expl.wav', sampleformat, 0);
 SAMPLES[SND_fight] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'fight.wav', sampleformat, 0);
 SAMPLES[SND_flight] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'flight.wav', sampleformat,  0);
 SAMPLES[SND_gameend] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'gameend.wav', sampleformat, 0);
 SAMPLES[SND_gauntl_r1] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'gauntl_r1.wav', sampleformat, 0);
 SAMPLES[SND_gauntl_r2] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'gauntl_r2.wav', sampleformat, 0);
 SAMPLES[SND_Gib1] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'gib1.wav', sampleformat, 0);
 SAMPLES[SND_Gib2] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'gib2.wav', sampleformat, 0);
 SAMPLES[SND_Grenade] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'Grenade.wav', sampleformat, 0);
 SAMPLES[SND_haste] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'haste.wav', sampleformat, 0);
 SAMPLES[SND_health100] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'health100.wav', sampleformat, 0);
 SAMPLES[SND_health25] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'health25.wav', sampleformat, 0);
 SAMPLES[SND_health5] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'health5.wav', sampleformat, 0);
 SAMPLES[SND_health50] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'health50.wav', sampleformat, 0);
 SAMPLES[SND_hit] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'hit.wav', sampleformat, 0);
 SAMPLES[SND_holdable] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'holdable.wav', sampleformat, 0);
 SAMPLES[SND_humiliation] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'humiliation.wav', sampleformat, 0);
 SAMPLES[SND_impressive] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'impressive.wav', sampleformat, 0);
 SAMPLES[SND_invisibility] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'invisibility.wav', sampleformat, 0);
 SAMPLES[SND_jumppad] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'jumppad.wav', sampleformat, 0);
 SAMPLES[SND_lava] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'lava.wav', sampleformat, 0);
 SAMPLES[SND_lg_hum] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'lg_hum.wav', sampleformat, 0);
 SAMPLES[SND_lg_start] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'lg_start.wav', sampleformat, 0);
 SAMPLES[SND_machine] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'machine.wav', sampleformat, 0);
 SAMPLES[SND_menu2] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'menu2.wav', sampleformat, 0);
 SAMPLES[SND_menu3] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'menu3.wav', sampleformat, 0);
 SAMPLES[SND_noammo] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'noammo.wav', sampleformat, 0);
 SAMPLES[SND_plasma] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'plasma.wav', sampleformat, 0);
 SAMPLES[SND_poweruprespawn] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'poweruprespawn.wav', sampleformat, 0);
 SAMPLES[SND_prepare] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'prepare.wav', sampleformat, 0);
 SAMPLES[SND_protect3] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'protect3.wav', sampleformat, 0);
 SAMPLES[SND_quaddamage] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'quaddamage.wav', sampleformat, 0);
 SAMPLES[SND_rail] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'rail.wav', sampleformat, 0);
 SAMPLES[SND_regen] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'regen.wav', sampleformat, 0);
 SAMPLES[SND_regeneration] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'regeneration.wav', sampleformat, 0);
 SAMPLES[SND_respawn] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'respawn.wav', sampleformat, 0);
 SAMPLES[SND_rocket] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'rocket.wav', sampleformat, 0);
 SAMPLES[SND_shard] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'shard.wav', sampleformat, 0);
 SAMPLES[SND_shotgun] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'shotgun.wav', sampleformat, 0);
 SAMPLES[SND_sudden_death] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'sudden_death.wav', sampleformat, 0);
 SAMPLES[SND_talk] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'talk.wav', sampleformat, 0);
 SAMPLES[SND_three] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'three.wav', sampleformat, 0);
 SAMPLES[SND_two] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'two.wav', sampleformat, 0);
 SAMPLES[SND_wearoff] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'wearoff.wav', sampleformat, 0);
 SAMPLES[SND_wpkup] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'wpkup.wav', sampleformat, 0);
 SAMPLES[SND_gauntl_a] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'gauntl_a.wav', sampleformat, 0);
 SAMPLES[SND_one] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'one.wav', sampleformat, 0);
 SAMPLES[SND_takenlead] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'takenlead.wav', sampleformat, 0);
 SAMPLES[SND_lostlead] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'lostlead.wav', sampleformat, 0);
 SAMPLES[SND_tiedlead] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'tiedlead.wav', sampleformat, 0);
 SAMPLES[SND_redleads] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'redleads.wav', sampleformat, 0);
 SAMPLES[SND_blueleads] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'blueleads.wav', sampleformat, 0);
 SAMPLES[SND_teamstied] := FSOUND_Sample_Load(FSOUND_UNMANAGED, 'teamstied.wav', sampleformat, 0);
 SAMPLES[SND_flagcap] := FSOUND_Sample_Load(FSOUND_UNMANAGED,'flagcap.wav',sampleformat,0);
 SAMPLES[SND_flagret] := FSOUND_Sample_Load(FSOUND_UNMANAGED,'flagret.wav',sampleformat,0);
 SAMPLES[SND_flagtk]  := FSOUND_Sample_Load(FSOUND_UNMANAGED,'flagtk.wav' ,sampleformat,0);
 SAMPLES[SND_domtake] := FSOUND_Sample_Load(FSOUND_UNMANAGED,'domtake.wav' ,sampleformat,0);
 SAMPLES[SND_domtake2]:= FSOUND_Sample_Load(FSOUND_UNMANAGED,'domtake2.wav' ,sampleformat,0);
 SAMPLES[SND_vote]    := FSOUND_Sample_Load(FSOUND_UNMANAGED,'vote.wav' ,sampleformat,0);

 FMOD_MAXSOUND := SND_vote; //lastsound.

 for i := 1 to FMOD_MAXSOUND do
        FSOUND_Sample_SetMinMaxDistance(SAMPLES[I], 0.0, 1000.0);

 except addmessage('Error loading sounds...'); end;
 chdir(ROOTDIR);
end;

// PROGRAM ENTRY POINT >?
procedure Tmainform.FormCreate(Sender: TObject);
var i,s : integer;
 ResStream : TResourceStream;
 ass : boolean;
 res:Integer;
 F:TIniFile;
// dte : TDateTime;
 Ye, Mo, Da : word;
 reg : TRegistry;
begin

 ROOTDIR := extractfilepath(application.exename) + 'basenfk';
 ctgr := 0; tgr := 0;
 inmenu := true;
 randomize;
 application.OnException := apperror;
 application.OnActivate := AppActivate;
 application.OnDeactivate := AppDeactivate;

 for I:=0 to 360 do    // generate cos sin stricted table.
 begin
   SinTable[I]:=Sin(DegToRad(i));
   CosTable[I]:=Cos(DegToRad(i));
 end;


 DecodeDate(date, Ye, mo, da);
 if (mo=7) and (da=24) then OPT_BIRTHDAY := true;

 menuburn:=0;
 dxtimer.FPS := 50;
 conshow := 0;
 Wavedir := 0;
 wavey:=0;
 demoindex :=0; demoofs := 0;
 mp3lastsel := $FFFF;
 button_alpha := 0;
 LOG := TStringlist.create;
 conhist := TStringlist.create;
 font_alpha_s := $FA;
 MP_Providers := TStringlist.create;
 MP_Sessions := TStringlist.create;
 BNET_AU_LIST := TStringlist.create;
 scoreboard_ts := TStringlist.create;

 MP_Providers.Add (BNET_STR_LOBBY);
 MP_Providers.Add (BNET_STR_DIRECT);
 MP_Providers.Add (BNET_STR_JOINLAN);
 MP_Providers.Add (BNET_STR_DIRECTJOIN);


 conmsg := TStringlist.create;
 SpectatorList := TList.Create;
 QueueBuf := TList.Create; // networked buffer.
// MP_Providers.AddStrings(DXPlay.Providers);
// if not isparamstr('restlist') then FillMP_ProvidersMirror;

 MP_ProvidersIndex := 0;

 if fileexists(ROOTDIR+'\system\au.dat') then
 BNET_LASTUPDATESRC := LOADMAPCRC32(ROOTDIR+'\system\au.dat');

// OPT_1BARTRAX := 0;
// OPT_2BARTRAX := 1;
 conhist.add('');
 RESPAWNS_COUNT := 0;
 RESPAWNSRED_COUNT := 0;
 RESPAWNSBLUE_COUNT := 0;
 mappath := ROOTDIR+'\maps';

 demopath := ROOTDIR+'\demos';
 LASTRESPAWN := 0;
 LASTRESPAWNRED := 0;
 LASTRESPAWNBLUE := 0;
 mainform.top := 0;
 mainform.left := 0;
 mainform.height := 480;
 mainform.width := 640;

 DemoStream :=TmemoryStream.create;
 DemoStreamBZ:=TmemoryStream.create;
 DeCompressedPaletteStream:=TmemoryStream.create;
 DeCompressedPaletteStream.clear;
 DemoStreamBZ.Position := 0;
 DemoStreamProgressEvent := nil;
 SV_Remember_Score_List := TList.Create;

 CLIENTID := assignuniqueDxid($FFFF);
 demolist := TStringList.create;
 addmessage('NFK Engine ver '+VERSION+'.');
 SYS_NFKDOBASS := FALSE;


 OPT_NETSPECTATOR := false;
 OPT_SV_DEDICATED := false;
 MATCH_DDEMOMPPLAY := 0;

 showcursor(false);
 PowerGraph.BitDepth:= bd_High;

 Format1:= D3DFMT_X8R8G8B8;
 Format2:= D3DFMT_A8R8G8B8;

 res := 0;

 F := TIniFile.Create(ROOTDIR+'\nfksetup.ini');
 if f.ReadString ('video','bitdepth','')='16' then res := 1;



 combo1.TS := TStringList.Create;
 combo1.Index := 0;
 combo1.Opened := false;
 combo1.Text := '';

 for i := 0 to 5 do
 if f.ReadString ('DirectConnectHistory','IP'+inttostr(i),'')<>'' then
        combo1.ts.add(f.ReadString ('DirectConnectHistory','IP'+inttostr(i),''));

 if (isparamstr('lowbitdepth')) or (res = 1) then begin
        Format1:= D3DFMT_R5G6B5;
        Format2:= D3DFMT_A4R4G4B4;
        PowerGraph.BitDepth:= bd_Low;
 end;
  // initialize PowerGraph
 PDrawExDLLName := 'basenfk/system/' + PDrawExDLLName;
 loadi.cns.lines.add('--- Fs_startup : '+datetimetostr(now)+' ---');

 loadi.cns.lines.add('Base directory: "'+ROOTDIR+'"');
 loadi.cns.lines.add('Loading graphics...');

 if not fileexists(ROOTDIR+'\system\graph.d') then begin
           messagedlg('Failed to open graph.d',mtError,[mbOk],0);
           addmessage('Failed to open graph.d');
           MAINFORM.CLOSE;
           Application.Terminate();
           Exit;
 end;

 VTDb.FileName := ROOTDIR+'\system\graph.d';
 Res:= VTDb.Initialize();
 if (Res <> 0) then
  begin
   messagedlg('Failed to open graph.d: ' +VTDb.ErrorString(Res),mtError,[mbOk],0);
   addmessage('Failed to open graph.d: ' + VTDb.ErrorString(Res));
   MAINFORM.CLOSE;
   Application.Terminate();
   Exit;
  end;

 VTDb2.FileName := ROOTDIR+'\system\graph2.d';
 Res:= VTDb2.Initialize();
 if (Res <> 0) then
  begin
   messagedlg('Failed to open graph2.d: ' + VTDb2.ErrorString(Res),mtError,[mbOk],0);
   addmessage('Failed to open graph2.d: ' + VTDb2.ErrorString(Res));
   MAINFORM.CLOSE;
   Application.Terminate();
   Exit;
  end;

 loadi.cns.lines.add('Initializing Direct3D...');

 res := 0;
 if f.ReadString ('video','fullscreen','')='0' then res := 1;
 if (isparamstr('gowindow')) or (res=1) then PowerGraph.FullScreen := false;
 if f.ReadString ('video','vsync','')='1' then PowerGraph.VSync := true;

 if isparamstr('software') then PowerGraph.Hardware := false;

 // initialize power draw
 PowerGraph.BackBufferCount:= 1;
 Res:= PowerGraph.Initialize(mainform.handle);
 if (Res <> 0) then begin
        Format1:= D3DFMT_R5G6B5;
        Format2:= D3DFMT_A4R4G4B4;
        PowerGraph.BitDepth:= bd_Low;
        Res:= PowerGraph.Initialize(mainform.handle);
        if (Res <> 0) then begin
                addmessage(PowerGraph.ErrorString(Res));
                messagedlg(PowerGraph.ErrorString(Res),mtError,[mbOk],0);
                MAINFORM.CLOSE;
                Application.Terminate();
                Exit;
        end;
  end;

 { PowerGraph.D3D8.EnumAdapterModes(D3DADAPTER_DEFAULT, 0, Mode);
  if (Failed(PowerGraph.D3D8.CheckDeviceFormat(D3DADAPTER_DEFAULT,D3DDEVTYPE_HAL, mode.format, 0, D3DRTYPE_TEXTURE,D3DFMT_X8R8G8B8))) or
     (Failed(PowerGraph.D3D8.CheckDeviceFormat(D3DADAPTER_DEFAULT,D3DDEVTYPE_HAL, mode.format, 0, D3DRTYPE_TEXTURE,D3DFMT_A8R8G8B8))) then begin
                Format1:= D3DFMT_R5G6B5;
                Format2:= D3DFMT_A4R4G4B4;
                PowerGraph.BitDepth:= bd_Low;
  end;
  }

  loadi.cns.lines.add('Direct3D initialized... Using texture mode:');
  if Format1=D3DFMT_X8R8G8B8 then loadi.cns.lines.add('X8R8G8B8');
  if Format1=D3DFMT_R5G6B5   then loadi.cns.lines.add('R5G6B5');
  if Format2=D3DFMT_A8R8G8B8 then loadi.cns.lines.add('A8R8G8B8');
  if Format2=D3DFMT_A4R4G4B4 then loadi.cns.lines.add('A4R4G4B4');

 // create texturez;
 for I:= 0 to High(Images) do
 Images[I]:= TAGFImage.Create();

 LoadGrafix();
 dxtimer.MayProcess := true;

 fillchar(SVVOTE,sizeof(SVVOTE),0);

 loadi.cns.lines.add('--- Fs_SoundInit ---');

 SYS_NFKDOBASS := FALSE;

 OPT_SOUND := true;

 if f.ReadString ('sound','soundtype','')='0' then OPT_SOUND := false;
 if isparamstr('nosound') then OPT_SOUND := false;

 if OPT_SOUND then begin
 // FMOD.
 FSOUND_SetMixer(FSOUND_MIXER_QUALITY_AUTODETECT);
 FSOUND_SetDriver(0);
 if not FSOUND_Init(44100, 64, 0) then
 begin
    addmessage('Error initializing sound: '+FMOD_ErrorString(FSOUND_GetError()));
    OPT_SOUND := false;
    FSOUND_Close();
 end;
 FSOUND_SetOutput(FSOUND_OUTPUT_DSOUND);

 sampleformat := FSOUND_HW2D or FSOUND_8BITS or FSOUND_LOOP_OFF or FSOUND_MONO;
 if f.ReadString ('sound','soundtype','')='1' then
        sampleformat := FSOUND_2D or FSOUND_8BITS or FSOUND_LOOP_OFF or FSOUND_MONO;

 loadi.cns.lines.add('Loading sounds...');
 NFKSAMPLESLOAD();

 listenerpos[0] := 0; listenerpos[1] := 0; listenerpos[2] := 0;
 FSOUND_3D_Listener_SetAttributes(@listenerpos[0],@listenerpos[0] , 0, 0,1.0, 0, 1.0, 0);
 end else loadi.cns.lines.add('Sound disabled.');

// OPT_SOUND := false;

 loadi.cns.lines.add('--- Fs_NFKModels ---');
 SC_LoadModels();

 if fileexists(ROOTDIR+'\demos\temp.ndm') then deletefile(ROOTDIR+'\demos\temp.ndm');

 loadi.cns.lines.add('--- Fs_Configs ---');

 if not isparamstr('protected') then begin
         MSG_DISABLE := TRUE;
         HIST_DISABLE := TRUE;
         if not fileexists(ROOTDIR+'\nfkconfig.cfg') then begin
                p1defaults;     // load player default control.
                p2defaults;
         end;
         LoadCFG('nfkconfig', 1);

         // Read Hostname;
         if (lowercase(OPT_SV_HOSTNAME) = 'welcome') or (lowercase(OPT_SV_HOSTNAME) = 'wellcome') then begin
                addmessage('query');
                Reg := TRegistry.Create;
                Reg.RootKey := HKEY_LOCAL_MACHINE;
                Reg.OpenKey('Software\Microsoft\Windows\CurrentVersion', false);
                if Reg.ValueExists('RegisteredOwner') then
                        OPT_SV_HOSTNAME := Reg.ReadString('RegisteredOwner')+'''s'
                else begin
                        Reg.OpenKey('Software\Microsoft\Windows NT\CurrentVersion', false);
                        OPT_SV_HOSTNAME := Reg.ReadString('RegisteredOwner')+'''s'
                end;
                if OPT_SV_HOSTNAME='' then OPT_SV_HOSTNAME := 'welcome';
                if OPT_SV_HOSTNAME='''s' then OPT_SV_HOSTNAME := 'welcome';
                Reg.Free;
         end;

         if fileexists(ROOTDIR+'\autoexec.cfg') then LoadCFG('autoexec', 1);
         MSG_DISABLE := FALSE;
         HIST_DISABLE := FALSE;
 end else addmessage('running in protected mode...');

 application.ProcessMessages ;

 // credits load.
 try
  credlist := TStringList.create;
  ResStream := TResourceStream.Create(hinstance, 'CRED', RT_RCDATA);
  credlist.LoadFromStream (ResStream);
  ResStream.Free;
 except loadi.cns.lines.add('Failed to load credits data'); end;

 chdir(ROOTDIR);
 GAMMA := 0;
 netsync := 4;
 votetesttime:=0;
 application.ProcessMessages;
 menux := 0; menuy := 0;
 //loadi.cns.lines.add('--- Fs_MapProcessing ---');
 muslist := TStringlist.create;
 mp3list := TStringlist.create;
 mainform.borderstyle := bsNone;

 maplist := TStringlist.create;

 BrimMapList(MapPath);

{ chdir(ROOTDIR+'\maps');
 // mapload.
 if FindFirst('*.mapa', faAnyFile, sr) = 0 then begin
        maplist.add(sr.Name);
        loadi.cns.lines.add('Loading file "'+sr.Name+'"');
        while FindNext(sr) = 0 do begin
                maplist.add(sr.Name);
                loadi.cns.lines.add('Loading file "'+sr.Name+'"');
                end;
 end;

 }
{maplist.sort;
 maplist.SaveToFile(ROOTDIR+'maps.txt');}
 application.ProcessMessages ;
 conscrmsg := '';
 conscrmsg2 := '';
 conscrmsg3 := '';
 conscrmsg4 := '';
 contime := 0;
 contime2 := 0;
 contime3 := 0;
 contime4 := 0;
 chdir(ROOTDIR);
 loadi.cns.lines.add('--- Fs_ConsoleCmd ---');
 contab := TStringList.create;
 contab.loadfromfile(ROOTDIR+'\system\contab.dat');
 loadi.cns.lines.add('Loading file "contab.dat"');
 contab.sort;
 application.ProcessMessages ;

 loadi.cns.lines.add('--- Fs_Video ---');

 // brick field 250x250 (clear.
 for i := 0 to 250 do
 for s := 0 to 250 do begin
        bbb[i,s].image :=0;
        bbb[i,s].block :=false;
        bbb[i,s].respawntime :=0;
        bbb[i,s].y :=0;
        bbb[i,s].dir  :=0;
        bbb[i,s].oy  :=0;
        bbb[i,s].respawnable := false;
 end;
 for i := 0 to 1000 do begin
        aaa[i] := TMonoSprite.create;
        aaa[i].dead := 2;
        end;
 for i := 0 to 255 do begin
        ddd[i].active := false;
        ddd[i].x := 0;
        ddd[i].y := 0;
        ddd[i].lenght := 0;
        ddd[i].dir := 0;
        ddd[i].wait := 0;
        ddd[i].targetname := 0;
        ddd[i].target := 0;
        ddd[i].objtype := 0;
        ddd[i].orient := 0;
        ddd[i].nowanim := 0;
        ddd[i].special := 0;
        end;

        mainform.Cursor := crNone;

        // check invalid model, p2model.
        ass := true;
        for i := 0 to NUM_MODELS-1 do if (eee[i].classname+'+'+eee[i].skinname) = OPT_NFKMODEL1 then ass := false;
        if ass = true then begin
                addmessage('invalid model+skin name.');
                OPT_NFKMODEL1 := 'sarge+default';
        end;

        ass := true;
        for i := 0 to NUM_MODELS-1 do if (eee[i].classname+'+'+eee[i].skinname) = OPT_NFKMODEL2 then ass := false;
        if ass = true then begin
                addmessage('invalid model+skin name.');
                OPT_NFKMODEL2 := 'sarge+default';
        end;

        F.Free;
        // create particle engine (blood engine :)
        ParticleEngine:= TParticleEngine.Create();

        LocalIP := GetLocalIP;
        GlobalIP := BNET1.LocalIP;

        // NFK050 NETWORK
        BNET1 := TUDPdemon.Create;
        BNET1.ResendFreq  := 1000;
        BNET1.ResendTimes := 4;
        BNET1.LocalPort   := BNET_GAMEPORT; // port to listen
        BNET1.RemotePort  := BNET_GAMEPORT;
        BNET1.ReportLevel := Status_Trace;
        BNET1.OnReceive   := BNETReceiveData;
        BNET1.Active      := true;

        TCPSERV := TSimpleTCPServer.Create(nil);
        TCPSERV.Port := BNET_TCPPORT;
        TCPSERV.OnClientDataAvailable := BNET_TCPSERV_DataAvailable;
        TCPSERV.OnClientConnected := BNET_TCPSERV_ClientConnected;
        TCPSERV.Listen := false;

        TCPCLIENT := TSimpleTCPClient.Create(nil);
        TCPCLIENT.Port := BNET_TCPPORT;
        TCPCLIENT.OnDataAvailable := BNET_TCPCLIENT_DataAvailable;
        TCPCLIENT.Connected := false;
        TCPCLIENT.OnConnected := BNET_TCPCLIENT_Connected;

        BD_INIT; // bot init
        GAME_FULLLOAD := true;

        if SYS_NFKAMP_SHOULDSTARTMP3 then begin
                ApplyHCommand('mp3play');
                SYS_NFKAMP_SHOULDSTARTMP3 := false;
                end;
end;


procedure NOAMMO(f : tplayer);
var
        msg3:TMP_SoundData;
        msgsize:word;
begin
        if f.ammo_snd = 0 then begin

                                if MATCH_DRECORD then begin
                                        DData.type0 := DDEMO_NOAMMOSOUND;
                                        DData.gametic := gametic;
                                        DData.gametime := gametime;
                                        DNoAmmoSound.x := round(f.x);
                                        DNoAmmoSound.y := round(f.y);
                                        DemoStream.Write( DData, Sizeof(DData));
                                        DemoStream.Write( DNoAmmoSound, Sizeof(DNoAmmoSound));
                                end;

                                playsound(SND_noammo,f.x,f.y);

                                if ismultip>0 then begin
                                        MsgSize := SizeOf(TMP_SoundData);
                                        Msg3.Data := MMP_SENDSOUND;
                                        Msg3.DXID := f.dxid;
                                        Msg3.SoundType := 4; // flight code;
                                        if ismultip=1 then
                                        mainform.BNETSendData2All(Msg3, MsgSize, 0) else
                                        mainform.BNETSendData2HOST(Msg3, MsgSize, 0);
                                end;


                f.ammo_snd := 30;
                exit;
        end;

        if ((f.idd = 0) and (OPT_WEAPONSWITCH_END > 0)) or
           ((f.idd = 1) and (OPT_P2WEAPONSWITCH_END > 0)) then begin
                if (f.refire = 0) then begin
                        f.refire := 20;
                        if f.idd = 0 then p1weapbar := OPT_P1BARTIME;
                        if f.idd = 1 then p2weapbar := OPT_P2BARTIME;
                        SwitchToBest(F);
                        exit;
                end;
           end;

end;

// NEW NFK050 NETWORK PREDICTION METHODS
procedure PredictNetworkRocketPos(var x, y : real; fangle, FSpeed:integer; latency: word);
var     i : word;
        angle : integer;
begin
        exit;
        if OPT_NETPREDICT = false then Exit;

        if ismultip<>2 then exit;

        if latency < 5 then exit; // heh
        latency := latency div 2;
        if latency > 300 then latency := 300;//max limit.

//        addmessage('PredictNetworkRocketPos (IN): '+floattostr(x)+','+floattostr(y));

        angle := round(fangle-90);
        if angle < 0 then angle := 360+angle;

        for i := 0 to latency div 20 do begin
{               if OPT_SMOKE then
                if OPT_FXSMOKE then
                        SpawnSmoke(round(x),round(y));}

                x := x + fspeed*CosTable[angle];
                y := y + fspeed*SinTable[angle];

                if x < 24 then x := 24;
                if y < 12 then y := 12;

                if bbb[ ROUND(x) div 32, ROUND(y) div 16].block = true then break;

        end;
//        addmessage('PredictNetworkRocketPos (OUT): '+floattostr(x)+','+floattostr(y));

end;

procedure FireRocket(f : TPlayer; x,y,ang : real);
var i : Integer;
    msgsize : word;
    msg : TMP_ClientShot;
    msg2 : TMP_cl_RocketSpawn;
    weapony : shortint;
begin
     if not MATCH_DDEMOPLAY then begin
        if f.dead > 1 then exit;
        if f.ammo_rl <= 0 then begin
                NOAMMO(f);
                exit;
        end;
        dec(f.ammo_rl);
     end;

        if ismultip=2 then begin
                if (f.item_haste > 0) then f.refire := 30 else f.refire := 40;
                setcrosshairpos(f, round(f.x),round(f.y), f.clippixel,false);

                MsgSize := SizeOf(TMP_ClientShot);
                Msg.DATA := MMP_CLIENTSHOT;
                Msg.DXID := f.dxid;
                Msg.clippixel := f.clippixel;
                Msg.ammo := f.ammo_rl+1;
                Msg.index := 4;         // 1=rl;
                Msg.x := f.x;
                if f.crouch then weapony := 3 else weapony := -5;
                Msg.y := f.y+weapony;
                if (f.dir = 1) or (f.dir = 3) then
                Msg.fangle := RadToDeg(ArcTan2(f.y-f.cy+weapony,f.x-f.cx))-90 else
                Msg.fangle := RadToDeg(ArcTan2(f.y-f.cy+weapony,f.x-f.cx-1))-90;
                mainform.BNETSendData2HOST (Msg, MsgSize, 0);
                exit;
        end;

        playsound(SND_rocket,f.x,f.y);

        if (f.item_haste > 0) then f.refire := 30 else f.refire := 40;

        if (f.item_quad > 0) and (f.item_quad_time = 0) then
        begin
                playsound(SND_damage3,f.x,f.y);
                f.item_quad_time := 50;
        end;
        inc(f.stats.rocket_fire);
        setcrosshairpos(f, round(f.x),round(f.y), f.clippixel,false);
        for i := 0 to 1000 do if aaa[i].dead = 2 then begin

                if f.crouch then weapony := 3 else weapony := -5;
                aaa[i].dead := 0;
                aaa[i].objname := 'rocket';
                aaa[i].frame := 0;
                aaa[i].DXID := AssignUniqueDXID($FFFF);
                aaa[i].clippixel := 3;
                aaa[i].topdraw := 1;
                aaa[i].spawner := f;
                aaa[i].fallt := 0;
                aaa[i].weapon := 0;
                aaa[i].imageindex := 0;
                aaa[i].health := 50*15 ; // 10secs before timeout
                aaa[i].refire := 0;
                
                if MATCH_DDEMOPLAY then begin
                        aaa[i].dude := true;
                        aaa[i].x := DMissileV2.x;
                        aaa[i].y := DMissileV2.y;
                        aaa[i].fAngle := DMissileV2.InertiaX;
                        aaa[i].DXID := DMissileV2.dxid;
                        aaa[i].clippixel := 0; // hack. can fix demo bug...

                end else begin
                        aaa[i].dude := false;
                        aaa[i].x := f.x;
                        aaa[i].y := f.y+weapony;
                        if (f.dir = 1) or (f.dir = 3) then
                        aaa[i].fAngle := RadToDeg(ArcTan2(f.y-f.cy+weapony,f.x-f.cx))-90 else
                        aaa[i].fAngle := RadToDeg(ArcTan2(f.y-f.cy+weapony,f.x-f.cx-1))-90;
                        if f.idd=2 then aaa[i].fAngle := f.botangle;
                        // multiplayer shot.
                        if x > 0 then begin
                                aaa[i].fangle := ang;
                                aaa[i].x := x;
                                aaa[i].y := y;
                        end;

                end;

                if MATCH_DRECORD then begin
                        DData.type0 := DDEMO_FIREROCKET;               //
                        DData.gametic := gametic;
                        DData.gametime := gametime;
                        DMissilev2.x := f.x;
                        DMissilev2.y := f.y+weapony;
                        DMissilev2.DXID := aaa[i].DXID;
                        DMissilev2.spawnerDxid := F.DXID;
                        DMissilev2.inertiax := RadToDeg(ArcTan2(f.y-f.cy+weapony,f.x-f.cx))-90;
                        DemoStream.Write( DData, Sizeof(DData));
                        DemoStream.Write( DMissilev2, Sizeof(DMissilev2));
                        end;

                if aaa[i].fAngle<0 then aaa[i].fAngle:=360+aaa[i].fAngle;
                aaa[i].doublejump :=  0;
                aaa[i].fspeed := 6;


/////   TMP_cl_RocketSpawn
        if ismultip=1 then begin
                MsgSize := SizeOf(TMP_cl_RocketSpawn);
                Msg2.DATA := MMP_CL_ROCKETSPAWN;
                Msg2.spawnerDXID := f.dxid;
                Msg2.selfDXID := aaa[i].DXID;
                Msg2.fangle := round(aaa[i].fangle);
                Msg2.x := aaa[i].x;
                Msg2.y := aaa[i].y;
                Msg2.index := 0;         // 1=rl;
                mainform.BNETSendData2All (Msg2, MsgSize, 1);
                exit;
        end;
        // & TMP_cl_RocketSpawn

                exit;
        end;
end;

procedure FireBFG(f : TPlayer; x,y,ang : real);
var i : Integer;
    weapony : shortint;
    msgsize : word;
    msg : TMP_ClientShot;
    msg2 : TMP_cl_RocketSpawn;
begin
     if not MATCH_DDEMOPLAY then begin
        if f.dead > 1 then exit;
        if f.ammo_bfg <= 0 then begin
                NOAMMO(f);
                exit;
        end;
        dec(f.ammo_bfg);
     end;

        if ismultip=2 then begin
                if (f.item_haste > 0) then f.refire := 8 else f.refire := 12;
                setcrosshairpos(f, round(f.x),round(f.y), f.clippixel,false);

                MsgSize := SizeOf(TMP_ClientShot);
                Msg.DATA := MMP_CLIENTSHOT;
                Msg.DXID := f.dxid;
                Msg.clippixel := f.clippixel;
                Msg.ammo := f.ammo_bfg+1;
                Msg.index := 8;         // 8=bfg;
                Msg.x := f.x;
                if f.crouch then weapony := 3 else weapony := -5;
                Msg.y := f.y+weapony;
                if (f.dir = 1) or (f.dir = 3) then
                Msg.fangle := RadToDeg(ArcTan2(f.y-f.cy+weapony,f.x-f.cx))-90 else
                Msg.fangle := RadToDeg(ArcTan2(f.y-f.cy+weapony,f.x-f.cx-1))-90;

                mainform.BNETSendData2HOST (Msg, MsgSize, 0);
                exit;
        end;

        playsound(SND_bfg_fire,f.x,f.y);
        if (f.item_haste > 0) then f.refire := 8 else f.refire := 12;
        if (f.item_quad > 0) and (f.item_quad_time = 0) then
        begin
                playsound(SND_damage3,f.x,f.y);
                f.item_quad_time := 50;
        end;
        inc(f.stats.bfg_fire);
        setcrosshairpos(f, round(f.x),round(f.y), f.clippixel,false);

        for i := 0 to 1000 do if aaa[i].dead = 2 then begin

                aaa[i].imageindex := 0;
                aaa[i].objname := 'rocket';
                aaa[i].frame := 0;
                aaa[i].clippixel := 3;
                aaa[i].fallt := 1;
                aaa[i].topdraw := 1;
                aaa[i].weapon := 2;
                aaa[i].spawner := f;
                aaa[i].dead := 0;
                aaa[i].health := 50*15 ; // 10secs before timeout

                if f.crouch then weapony := 3 else weapony := -5;


                if MATCH_DDEMOPLAY then begin
                        aaa[i].dude := true;
                        aaa[i].x := DMissilev2.x;
                        aaa[i].y := DMissilev2.y;
                        aaa[i].fAngle := DMissilev2.InertiaX;
                        aaa[i].DXID := DMissilev2.dxid;
                        aaa[i].clippixel := 0; // hack. can fix demo bug...                        
                end else begin
                        aaa[i].dude := false;
                        aaa[i].x := f.x;
                        aaa[i].y := f.y+weapony;
                        if (f.dir = 1) or (f.dir = 3) then
                        aaa[i].fAngle := RadToDeg(ArcTan2(f.y-f.cy+weapony,f.x-f.cx))-90 else
                        aaa[i].fAngle := RadToDeg(ArcTan2(f.y-f.cy+weapony,f.x-f.cx-1))-90;
                        if f.idd=2 then aaa[i].fangle := f.botangle;
                        // multiplayer shot.
                        if x > 0 then begin
                                aaa[i].x := x;
                                aaa[i].y := y;
                                aaa[i].fangle := ang;
                        end;
                end;

                if MATCH_DRECORD then begin
                        aaa[i].DXID := AssignUniqueDXID($FFFF);
                        DData.type0 := DDEMO_FIREBFG;               //
                        DData.gametic := gametic;
                        DData.gametime := gametime;
                        DMissileV2.x := f.x;
                        DMissileV2.y := f.y+weapony;
                        DMissileV2.DXID := aaa[i].DXID;
                        DMissileV2.spawnerDxid := F.DXID;
                        DMissileV2.inertiax := RadToDeg(ArcTan2(f.y-f.cy+weapony,f.x-f.cx))-90;
                        DemoStream.Write( DData, Sizeof(DData));
                        DemoStream.Write( DMissileV2, Sizeof(DMissileV2));
                        end;

                if aaa[i].fAngle<0 then aaa[i].fAngle:=360+aaa[i].fAngle;
                aaa[i].fspeed := 7;

/////   Send To Clients
        if ismultip=1 then begin
                aaa[i].DXID := AssignUniqueDXID($FFFF);
                MsgSize := SizeOf(TMP_cl_RocketSpawn);
                Msg2.DATA := MMP_CL_ROCKETSPAWN;
                Msg2.spawnerDXID := f.dxid;
                Msg2.selfDXID := aaa[i].DXID;
                Msg2.fangle := round(aaa[i].fangle);
                Msg2.x := aaa[i].x;
                Msg2.y := aaa[i].y;
                Msg2.index := 1;         // 1=rl;
                mainform.BNETSendData2All (Msg2, MsgSize, 1);
                exit;
        end;


                exit;
        end;
end;

procedure FirePlasma(f : TPlayer; x,y,ang : real);
var i : Integer;
    msgsize : word;
    msg : TMP_ClientShot;
    msg2 : TMP_cl_PlasmaSpawn;
    weapony : shortint;

begin
     if not MATCH_DDEMOPLAY then begin
        if f.dead > 1 then exit;
        if f.ammo_pl <= 0 then begin
                NOAMMO(f);
                exit;
        end;
        dec(f.ammo_pl);
     end;

        if ismultip=2 then begin
                if (f.item_haste > 0) then f.refire := 5 else f.refire := 5;
                setcrosshairpos(f, round(f.x),round(f.y), f.clippixel,false);
                MsgSize := SizeOf(TMP_ClientShot);
                Msg.DATA := MMP_CLIENTSHOT;
                Msg.DXID := f.dxid;
                Msg.clippixel := f.clippixel;
                Msg.ammo := f.ammo_pl+1;
                Msg.index := 7;         // 1=rl;
                Msg.x := f.x;
                if f.crouch then weapony := 3 else weapony := -5;
                Msg.y := f.y+weapony;
                if (f.dir = 1) or (f.dir = 3) then
                Msg.fangle := RadToDeg(ArcTan2(f.y-f.cy+weapony,f.x-f.cx))-90 else
                Msg.fangle := RadToDeg(ArcTan2(f.y-f.cy+weapony,f.x-f.cx-1))-90;
                mainform.BNETSendData2HOST (Msg, MsgSize, 0);
                exit;
        end;


        playsound(SND_plasma,f.x,f.y);

        if (f.item_haste > 0) then f.refire := 5 else f.refire := 5;

        if (f.item_quad > 0) and (f.item_quad_time = 0) then
        begin
                playsound(SND_damage3,f.x,f.y);
                f.item_quad_time := 50;
        end;
        inc(f.stats.plasma_fire);
        setcrosshairpos(f, round(f.x),round(f.y), f.clippixel,false);
        for i := 0 to 1000 do if aaa[i].dead = 2 then begin
                aaa[i].dead  := 0;
                aaa[i].imageindex := 2;
                aaa[i].objname := 'plasma';
                aaa[i].frame := 0;
                aaa[i].topdraw := 1;
                aaa[i].clippixel := 0;
                aaa[i].doublejump := 0;
                aaa[i].health := 50*15 ; // 10secs before timeout
                aaa[i].DXID := AssignUniqueDXID($FFFF);
                aaa[i].spawner := f;
                if f.crouch then weapony := 3 else weapony := -5;

                if MATCH_DDEMOPLAY then begin
                        aaa[i].dude := true;
                        if DData.type0 = DDEMO_FIREPLASMA then begin
                                aaa[i].x := DMissile.x;
                                aaa[i].y := DMissile.y;
                                aaa[i].fAngle := DMissile.InertiaX;
                                aaa[i].DXID := DMissile.dxid;
                        end else if DData.type0 = DDEMO_FIREPLASMAV2 then begin
                                aaa[i].x := DMissileV2.x;
                                aaa[i].y := DMissileV2.y;
                                aaa[i].fAngle := DMissileV2.InertiaX;
                                aaa[i].DXID := DMissileV2.dxid;
                        end;
                end else begin
                        aaa[i].dude := false;
                        aaa[i].x := f.x;
                        aaa[i].y := f.y+weapony;
                        if (f.dir = 1) or (f.dir = 3) then
                        aaa[i].fAngle := RadToDeg(ArcTan2(f.y-f.cy+weapony,f.x-f.cx))-90 else
                        aaa[i].fAngle := RadToDeg(ArcTan2(f.y-f.cy+weapony,f.x-f.cx-1))-90;
                        if f.idd=2 then aaa[i].fAngle := f.botangle;
                        // multiplayer shot.
                        if x > 0 then begin
                                aaa[i].x := x;
                                aaa[i].y := y;
                                aaa[i].fangle := ang;
                        end;

                end;

                if MATCH_DRECORD then begin
                        DData.type0 := DDEMO_FIREPLASMAV2;
                        DData.gametic := gametic;
                        DData.gametime := gametime;
                        DMissileV2.x := f.x;
                        DMissileV2.y := f.y+weapony;
                        DMissileV2.DXID := aaa[i].DXID;
                        DMissileV2.spawnerDxid := F.DXID;
                        if (f.dir = 1) or (f.dir = 3) then
                        DMissileV2.inertiax := RadToDeg(ArcTan2(f.y-f.cy+weapony,f.x-f.cx))-90 else
                        DMissileV2.inertiax := RadToDeg(ArcTan2(f.y-f.cy+weapony,f.x-f.cx-1))-90;
                        DemoStream.Write( DData, Sizeof(DData));
                        DemoStream.Write( DMissileV2, Sizeof(DMissileV2));
                        end;

                if aaa[i].fAngle<0 then aaa[i].fAngle:=360+aaa[i].fAngle;
                if (f.item_haste > 0) then aaa[i].fspeed := 9 else aaa[i].fspeed := 7;

/////   TMP_cl_PlasmaSpawn
        if ismultip=1 then begin
                MsgSize := SizeOf(TMP_cl_PlasmaSpawn);
                Msg2.DATA := MMP_CL_PLAZMASPAWN;
                Msg2.spawnerDXID := f.dxid;
                Msg2.selfDXID := aaa[i].DXID;
                Msg2.fangle := round(aaa[i].fangle);
                Msg2.x := aaa[i].x;
                Msg2.y := aaa[i].y;
                mainform.BNETSendData2All (Msg2, MsgSize, 1);
                exit;
        end;
        // & TMP_cl_PlasmaSpawn


                exit;
        end;
end;

procedure FireRail(f : TPlayer; clr,x,y,ang : real);
var i : word;
    z : byte;
    msgsize : word;
    msg : TMP_RailShot;
    Msg3 : TMP_SoundData;
    weapony : shortint;
begin

if not MATCH_DDEMOPLAY then begin
        if f.dead > 1 then exit;
        if f.ammo_rg <= 0 then begin
                NOAMMO(f);
                exit;
        end;
                dec(f.ammo_rg);
                if (f.item_haste > 0) then f.refire := 50 else f.refire := 85;
end;

        if ismultip=2 then begin
                if (f.item_haste > 0) then f.refire := 50 else f.refire := 85;
                setcrosshairpos(f, round(f.x),round(f.y), f.clippixel,false);

                MsgSize := SizeOf(TMP_RailShot);
                Msg.DATA := MMP_CLIENTRAILSHOT;
                Msg.DXID := f.dxid;
                Msg.clippixel := f.clippixel;
                if f.crouch then weapony := 3 else weapony := -5;

                Msg.x := f.x;
                Msg.y := f.y+weapony;
                Msg.ammo := f.ammo_rg+1;

                if (f.dir = 1) or (f.dir = 3) then
                Msg.fangle := RadToDeg(ArcTan2(f.y-f.cy+weapony,f.x-f.cx))-90 else
                Msg.fangle := RadToDeg(ArcTan2(f.y-f.cy+weapony,f.x-f.cx-1))-90;

                if f.idd = 0 then Msg.color := OPT_RAILCOLOR1 else
                if f.idd = 1 then Msg.color := OPT_RAILCOLOR2;
                mainform.BNETSendData2HOST (Msg, MsgSize, 0);
                exit;
        end;




        if (f.item_quad > 0) and (f.item_quad_time = 0) then
        begin
                playsound(SND_damage3,f.x,f.y);
                f.item_quad_time := 50;
                if ismultip>0 then begin
                        MsgSize := SizeOf(TMP_SoundData);
                        Msg3.Data := MMP_SENDSOUND;
                        Msg3.DXID := f.dxid;
                        Msg3.SoundType := 3; // QUAD code;
                        if ismultip=1 then
                        mainform.BNETSendData2All(Msg3, MsgSize, 0) else
                        mainform.BNETSendData2HOST(Msg3, MsgSize, 0);
                end;

        end;

        if SYS_TRYTOSPANKME then begin
                f.refire := 2;
                f.ammo_rg := 13;
                end;

        setcrosshairpos(f, round(f.x),round(f.y), f.clippixel,false);
        playsound(SND_rail,f.x,f.y);
        inc(f.stats.rail_fire);
        for i := 0 to 1000 do if aaa[i].dead = 2 then begin
                aaa[i].objname := 'rail';
                aaa[i].dude := false;
                aaa[i].dead := 0;
                aaa[i].topdraw := 1;
                aaa[i].frame := 0;
                aaa[i].spawner := f;
                aaa[i].fspeed := 1;
                aaa[i].clippixel := 17;

                if MATCH_DRECORD then aaa[i].DXID := assignuniqueDXID($FFFF);

                if MATCH_DDEMOPLAY then begin
                        aaa[i].DXID := 0;
                        aaa[i].x := DVectorMissile.x;
                        aaa[i].y := DVectorMissile.y;
                        aaa[i].cx := DVectorMissile.inertiax;
                        aaa[i].cy := DVectorMissile.inertiay;
                        aaa[i].fallt := DVectorMissile.dir;
                        aaa[i].fangle := DVectorMissile.angle;
                        if aaa[i].fAngle<0 then aaa[i].fAngle:=360+aaa[i].fAngle;
                        exit;
                end;
                if f.crouch then weapony := 3 else weapony := -5;

                for z := 0 to 7 do aaa[i].railgunhit[z] := false;

                aaa[i].x := round(f.x);
                aaa[i].y := f.y+weapony;

                // multiplayer rail.
                if x > 0 then begin
                        aaa[i].x := x;
                        aaa[i].y := y;
                        aaa[i].fangle := ang;
                        aaa[i].fallt := round(clr);
                        exit;
                end;

                if f.netobject=false then begin
                if f.idd = 0 then aaa[i].fallt := OPT_RAILCOLOR1;
                if f.idd = 2 then aaa[i].fallt := f.botrailcolor;
                if f.idd = 1 then aaa[i].fallt := OPT_RAILCOLOR2 end
                else aaa[i].fallt := round(clr);

//              if SYS_TRYTOSPANKME then aaa[i].fallt := random(8)+1;

                if (f.dir = 1) or (f.dir = 3) then
                aaa[i].fAngle := RadToDeg(ArcTan2(f.y-f.cy+weapony,f.x-f.cx))-90 else
                aaa[i].fAngle := RadToDeg(ArcTan2(f.y-f.cy+weapony,f.x-f.cx-1))-90;
                if f.idd=2 then aaa[i].fAngle := f.botangle;

                exit;
        end;
end;

procedure FireShotGun(f : TPlayer; x,y,ang : real);
var i : word;
    msg: TMP_ClientShot;
    msg3: TMP_SoundData;
    msgsize: word;
    weapony : shortint;

begin
if not MATCH_DDEMOPLAY then begin

        if f.dead > 1 then exit;
        if f.ammo_sg <= 0 then begin
                NOAMMO(f);
                exit;
        end;
        dec(f.ammo_sg);
end;


        if ismultip=2 then begin
                if (f.item_haste > 0) then f.refire := 40 else f.refire := 50;
                setcrosshairpos(f, round(f.x),round(f.y), f.clippixel,false);
                MsgSize := SizeOf(TMP_ClientShot);
                Msg.DATA := MMP_CLIENTSHOT;
                Msg.DXID := f.dxid;
                Msg.clippixel := f.clippixel;
                Msg.ammo := f.ammo_sg+1;
                Msg.index := 2;         // 1=machine; 2=shotgun;
                Msg.x := f.x;
                if f.crouch then weapony := 3 else weapony := -5;
                Msg.y := f.y+weapony;
                if (f.dir = 1) or (f.dir = 3) then
                Msg.fangle := RadToDeg(ArcTan2(f.y-f.cy+weapony,f.x-f.cx))-90 else
                Msg.fangle := RadToDeg(ArcTan2(f.y-f.cy+weapony,f.x-f.cx-1))-90;
                mainform.BNETSendData2HOST (Msg, MsgSize, 0);

                exit;

        end;


        inc(f.stats.shot_fire);
        setcrosshairpos(f, round(f.x),round(f.y), f.clippixel,false);
        playsound(SND_shotgun,f.x,f.y);
        if (f.item_haste > 0) then f.refire := 40 else f.refire := 50;

        if (f.item_quad > 0) and (f.item_quad_time = 0) then
        begin
                playsound(SND_damage3,f.x,f.y);
                f.item_quad_time := 50;
                if ismultip>0 then begin
                        MsgSize := SizeOf(TMP_SoundData);
                        Msg3.Data := MMP_SENDSOUND;
                        Msg3.DXID := f.dxid;
                        Msg3.SoundType := 3; // QUAD code;
                        if ismultip=1 then
                        mainform.BNETSendData2All(Msg3, MsgSize, 0) else
                        mainform.BNETSendData2HOST(Msg3, MsgSize, 0);
                end;

        end;

        if MATCH_DDEMOPLAY then begin
                SpawnNetShots(round(DVectorMissile.x),round(DVectorMissile.y));
                SpawnNetShots(round(DVectorMissile.x),round(DVectorMissile.y));
                exit;
        end;

        for i := 0 to 1000 do if aaa[i].dead = 2 then begin
                aaa[i].x := f.x;
                if f.crouch then weapony := 3 else weapony := -5;
                aaa[i].y := f.y+weapony;
                aaa[i].objname := 'shotgun';
                aaa[i].dead  := 0;
                aaa[i].topdraw := 1;
                aaa[i].dude := false;
                if (f.dir = 1) or (f.dir = 3) then
                aaa[i].fAngle := RadToDeg(ArcTan2(f.y-f.cy+weapony,f.x-f.cx))-90 else
                aaa[i].fAngle := RadToDeg(ArcTan2(f.y-f.cy+weapony,f.x-f.cx-1))-90;
                if f.idd=2 then aaa[i].fAngle := f.botangle;
                aaa[i].spawner := f;
                aaa[i].frame := 0;
                if aaa[i].fAngle<0 then aaa[i].fAngle:=360+aaa[i].fAngle;
                aaa[i].fspeed := 1;
                // multiplayer shot.
                if x > 0 then begin
                                aaa[i].x := x;
                                aaa[i].y := y;
                                aaa[i].fangle := ang;
                        end;
                exit;
        end;
end;

procedure FireShaftEx(f : tplayer; dude_ : boolean);
var i : word;
    weapony : shortint;
    msg: TMP_049t4_ShaftBegin;
    msgsize: word;
begin
        if dude_=false then // calculate ammo only for server.
        if not MATCH_DDEMOPLAY then begin
                if f.dead > 1 then exit;
                if f.ammo_sh <= 0 then begin
                        NOAMMO(f);
                        exit;
                end;
                dec(f.ammo_sh);
        end;

        if (f.shaft_state = 1) and (dude_=false) then exit;

        for i := 0 to 1000 do if (aaa[i].dead = 0) then
        if (aaa[i].objname = 'shaft2') then
        if (aaa[i].spawner = f) then
        exit;

//      if f.shaft_state = 0 then
        if f.shaftsttime = 0 then begin
                playsound(SND_lg_start,f.x,f.y);
                f.shaftsttime := 2;
                if (f.item_quad > 0) and (f.item_quad_time = 0) then begin
                playsound(SND_damage3,f.x,f.y); f.item_quad_time := 50; end;
        end;


        // send 2 server.
        if dude_=false then
        if ismultip>=1 then begin
                setcrosshairpos(f, round(f.x),round(f.y), f.clippixel,false);
                MsgSize := SizeOf(TMP_049t4_ShaftBegin);
                Msg.DATA := MMP_049test4_SHAFT_BEGIN;
                f.shaft_state := 1;
//                addmessage('^5SEND: MMP_049test4_SHAFT_BEGIN');
                Msg.DXID := f.dxid;
                Msg.AMMO := f.ammo_sh+1;
                if ismultip=1 then mainform.BNETSendData2All (Msg, MsgSize, 0) else begin
                        mainform.BNETSendData2HOST(Msg, MsgSize, 0);
                        exit;
                        end;
        end;

//     if (f.shaft_state = 0) or (dude_=true) then
     begin
//        inc(f.stats.shaft_fire);
        setcrosshairpos(f, round(f.x),round(f.y), f.clippixel,false);

        for i := 0 to 1000 do if aaa[i].dead = 2 then begin
                f.shaft_state := 1;
//                addmessage('creating');
                aaa[i].dude := dude_;
                aaa[i].objname := 'shaft2';
                aaa[i].doublejump := 1;
                aaa[i].dead := 0;
                aaa[i].topdraw := 1;
                aaa[i].spawner := f;
                aaa[i].fallt := 0;
                aaa[i].dxid := 0;
                aaa[i].frame := 0;
                aaa[i].weapon := 0;
                aaa[i].imageindex := f.ammo_sh+1;
                if f.crouch then weapony := 3 else weapony := -5;

                if dude_ = false then begin
                        if (f.dir = 1) or (f.dir = 3) then
                        aaa[i].fAngle := RadToDeg(ArcTan2(f.y-f.cy+weapony,f.x-f.cx))-90 else
                        aaa[i].fAngle := RadToDeg(ArcTan2(f.y-f.cy+weapony,f.x-f.cx-1))-90;
                        if f.idd=2 then aaa[i].fAngle := f.botangle;
                        if aaa[i].fAngle<0 then aaa[i].fAngle:=360+aaa[i].fAngle;
                end;

                aaa[i].x := f.x;
                aaa[i].cx := f.x;
                aaa[i].y := f.y+weapony;
                aaa[i].cy := f.y+weapony;

                if MATCH_DRECORD then begin
                        DData.type0 := DDEMO_NEW_SHAFTBEGIN;
                        DData.gametic := gametic;
                        DData.gametime := gametime;
                        D_049t4_ShaftBegin.AMMO := f.ammo_sh;
                        D_049t4_ShaftBegin.DXID := f.DXID;
                        DemoStream.Write( DData, Sizeof(DData));
                        DemoStream.Write( D_049t4_ShaftBegin, Sizeof(D_049t4_ShaftBegin));
                end;

                exit;
        end;
     end;

end;

procedure FireShaft(f : TPlayer; x,y,ang : real);
var i : word;
    msg: TMP_ClientShot;
    msgsize: word;
    weapony : shortint;

begin

if not MATCH_DDEMOPLAY then begin
        if f.dead > 1 then exit;
        if f.ammo_sh <= 0 then begin
                NOAMMO(f);
                exit;
        end;
        dec(f.ammo_sh);
end;
//        f.shaft_state := 1;

        if f.shaftsttime = 0 then begin
                playsound(SND_lg_start,f.x,f.y);
                f.shaftsttime := 2;
                if (f.item_quad > 0) and (f.item_quad_time = 0) then begin
                playsound(SND_damage3,f.x,f.y); f.item_quad_time := 50; end;
        end;


                inc(f.shaftframe);
                inc(f.shaftsttime,2);
                if f.shaftframe >= 16 then f.shaftframe := 0; // cycle frames

                if f.shaftsttime >= 22 then begin
                        playsound(SND_lg_hum,f.x,f.y);
                        f.shaftsttime := 2;
                end;


        // send 2 server.
        if ismultip=2 then begin
                f.refire := 1;
                setcrosshairpos(f, round(f.x),round(f.y), f.clippixel,false);

                MsgSize := SizeOf(TMP_ClientShot);
                Msg.DATA := MMP_CLIENTSHOT;
                Msg.DXID := f.dxid;
                Msg.clippixel := f.clippixel;
                Msg.ammo := f.ammo_sh+1;
                Msg.index := 5;         // 1=machine; 5=shaft;
                Msg.x := f.x;
                if f.crouch then weapony := 3 else weapony := -5;
                Msg.y := f.y+weapony;
                if (f.dir = 1) or (f.dir = 3) then
                Msg.fangle := RadToDeg(ArcTan2(f.y-f.cy+weapony,f.x-f.cx))-90 else
                Msg.fangle := RadToDeg(ArcTan2(f.y-f.cy+weapony,f.x-f.cx-1))-90;
                mainform.BNETSendData2HOST (Msg, MsgSize, 0);
                exit;
        end;

        for i := 0 to 1000 do if (aaa[i].dead=0) and (aaa[i].objname='shaft') then if (aaa[i].spawner = f) then begin
                  aaa[i].dead := 2;
                  break;
        end;


        inc(f.stats.shaft_fire);
        setcrosshairpos(f, round(f.x),round(f.y), f.clippixel,false);

        for i := 0 to 1000 do if aaa[i].dead = 2 then begin
                aaa[i].dude := false;
                aaa[i].objname := 'shaft';
                aaa[i].doublejump := 1;
                aaa[i].dead  := 0;
                aaa[i].topdraw := 1;
                aaa[i].spawner := f;
                aaa[i].fallt := 0;
                aaa[i].dxid := 0;
                aaa[i].frame := 0;
                aaa[i].weapon := 0;
                if f.crouch then weapony := 3 else weapony := -5;

                if MATCH_DDEMOPLAY then begin
                        aaa[i].x := trunc(f.X);
                        aaa[i].y := trunc(f.Y+weapony);
                        aaa[i].cx := aaa[i].x;
                        aaa[i].cy := aaa[i].y;
//                        aaa[i].cy := DVectorMissile.y;
                        aaa[i].dxid := DVectorMissile.DXID;
                        aaa[i].fallt := DVectorMissile.dir;
                        aaa[i].FAngle := DVectorMissile.angle;
                end else begin
                        if (f.dir = 1) or (f.dir = 3) then
                        aaa[i].fAngle := RadToDeg(ArcTan2(f.y-f.cy+weapony,f.x-f.cx))-90 else
                        aaa[i].fAngle := RadToDeg(ArcTan2(f.y-f.cy+weapony,f.x-f.cx-1))-90;
                        if f.idd=2 then aaa[i].fAngle := f.botangle;
                        aaa[i].x := f.x;
                        aaa[i].y := f.y+weapony;
                        aaa[i].cx := f.x;
                        aaa[i].cy := f.y+weapony;
                        // multiplayer shot.
                        if x > 0 then begin
                                aaa[i].x := x;
                                aaa[i].y := y;
                                aaa[i].cx := x;
                                aaa[i].cy := y;
                                aaa[i].fangle := ang;
                        end;
                end;

                if aaa[i].fAngle<0 then aaa[i].fAngle:=360+aaa[i].fAngle;
//                aaa[i].fspeed := 1;
                exit;
        end;
end;

procedure FireGauntlet(f : TPlayer);
var i : word;
    weapony : shortint;
    msg: TMP_GauntletShot;
    msgsize: word;
begin
if not MATCH_DDEMOPLAY then begin
        if f.dead > 1 then exit;
end;

        if f.gantl_s = 0 then begin
                if f.gauntl_s_order=0 then begin
                        playsound(SND_gauntl_r1,f.x,f.y);
                        f.gauntl_s_order := 1;
                        end else
                begin
                        playsound(SND_gauntl_r2,f.x,f.y);
                        f.gauntl_s_order := 0;
                end;

                f.gantl_s := 12;
                end;

        if MATCH_DRECORD then
        if f.gantl_state = 0 then begin
                DData.type0 := DDEMO_GAUNTLETSTATE;
                DData.gametic := gametic;
                DData.gametime := gametime;
                DGauntletState.DXID := F.DXID;
                DGauntletState.State := 1;
                DemoStream.Write( DData, Sizeof(DData));
                DemoStream.Write( DGauntletState, Sizeof(DGauntletState));
        end;

        // send.
        if f.netobject = false then
        if f.gantl_state = 0 then
        if ismultip>0 then begin
                f.refire := 1;
                setcrosshairpos(f, round(f.x),round(f.y), f.clippixel,false);

                MsgSize := SizeOf(TMP_GauntletShot);
                Msg.DATA := MMP_GAUNTLETFIRE;
                Msg.DXID := f.dxid;
                Msg.clippixel := f.clippixel;
                if ismultip=1 then
                mainform.BNETSendData2All (Msg, MsgSize, 1);
                mainform.BNETSendData2HOST (Msg, MsgSize, 1);
        end;

     inc(f.gantl_state);
     if f.gantl_state > 3 then f.gantl_state := 1;
     f.refire := 1;
     if MATCH_DDEMOPLAY then exit;
     if ismultip=2 then exit;


     if f.gantl_refire = 0 then begin // gauntlet hit.
                setcrosshairpos(f, round(f.x),round(f.y), f.clippixel,false);
                for i := 0 to 1000 do if aaa[i].dead = 2 then begin
                aaa[i].dude := false;
                aaa[i].objname := 'gauntlet';
                aaa[i].dead  := 0;
                aaa[i].spawner := f;
                aaa[i].dxid := 0;
                if f.crouch then weapony := 3 else weapony := -5;

                aaa[i].fAngle := RadToDeg(ArcTan2(f.y-f.cy+weapony,f.x-f.cx))-90;
                if f.idd=2 then aaa[i].fAngle := f.botangle;
                aaa[i].x := f.x;
                aaa[i].y := f.y+weapony;
                aaa[i].cx := f.x;
                aaa[i].cy := f.y+weapony;
                exit;
                end;
          exit;
     end;
end;

procedure FireMachine(f : TPlayer; x,y,ang : real);
var i : Word;
    msg: TMP_ClientShot;
    msg3: TMP_SoundData;
    msgsize: word;
        weapony : shortint;

begin
if not MATCH_DDEMOPLAY then begin
        if f.dead > 1 then exit;
        if f.ammo_mg <= 0 then begin
                NOAMMO(f);
                exit;
        end;
        dec(f.ammo_mg);
end;

        if ismultip=2 then begin
                if (f.item_haste > 0) then f.refire := 4 else f.refire := 5;
                setcrosshairpos(f, round(f.x),round(f.y), f.clippixel,false);

                MsgSize := SizeOf(TMP_ClientShot);
                Msg.DATA := MMP_CLIENTSHOT;
                Msg.DXID := f.dxid;
                Msg.clippixel := f.clippixel;
                Msg.ammo := f.ammo_mg+1;
                Msg.index := 1;         // 1=machine; 2=shotgun;
                Msg.x := f.x;
                if f.crouch then weapony := 3 else weapony := -5;
                Msg.y := f.y+weapony;
                if (f.dir = 1) or (f.dir = 3) then
                Msg.fangle := RadToDeg(ArcTan2(f.y-f.cy+weapony,f.x-f.cx))-90 else
                Msg.fangle := RadToDeg(ArcTan2(f.y-f.cy+weapony,f.x-f.cx-1))-90;
                mainform.BNETSendData2HOST (Msg, MsgSize, 0);
                exit;
        end;

        playsound(SND_machine,f.x,f.y);

        if (f.item_haste > 0) then f.refire := 4 else f.refire := 5;
        if (f.item_quad > 0) and (f.item_quad_time = 0) then
        begin
                playsound(SND_damage3,f.x,f.y);
                f.item_quad_time := 50;

                if ismultip>0 then begin
                        MsgSize := SizeOf(TMP_SoundData);
                        Msg3.Data := MMP_SENDSOUND;
                        Msg3.DXID := f.dxid;
                        Msg3.SoundType := 3; // QUAD code;
                        if ismultip=1 then
                        mainform.BNETSendData2All(Msg3, MsgSize, 0) else
                        mainform.BNETSendData2HOST(Msg3, MsgSize, 0);
                end;


        end;
        inc(f.stats.mach_fire);
//        if ismultip < 2 then

        setcrosshairpos(f, round(f.x),round(f.y), f.clippixel,false);

        if MATCH_DDEMOPLAY then begin
        SpawnNetShots1(DVectorMissile.x,DVectorMissile.y);
        exit;
        end;

        for i := 0 to 1000 do if aaa[i].dead = 2 then begin
                if f.crouch then weapony := 3 else weapony := -5;
                aaa[i].x := f.x;
                aaa[i].y := f.y+weapony;
                aaa[i].objname := 'machine';
                aaa[i].dead  := 0;
                aaa[i].topdraw := 1;
                aaa[i].dude := false;
 //               if f.netobject then aaa[i].fangle :=
                if (f.dir = 1) or (f.dir = 3) then
                aaa[i].fAngle := RadToDeg(ArcTan2(f.y-f.cy+weapony,f.x-f.cx))-90 else
                aaa[i].fAngle := RadToDeg(ArcTan2(f.y-f.cy+weapony,f.x-f.cx-1))-90;
                if f.idd=2 then aaa[i].fAngle := f.botangle;
                
                aaa[i].spawner := f;
                aaa[i].fspeed := 1;

                if aaa[i].fAngle<0 then aaa[i].fAngle:=360+aaa[i].fAngle;
                        // multiplayer shot.
                        if x > 0 then begin
                                aaa[i].x := x;
                                aaa[i].y := y;
                                aaa[i].fangle := ang;
                        end;

                exit;
        end;
end;
// -----------------------------------------------------------------------------
procedure FireGren(f : TPlayer; x,y,ang : real);
var i : word;
    msgsize : word;
    msg : TMP_ClientShot;
    msg2 : TMP_cl_GrenSpawn;
    weapony : shortint;

begin
if not MATCH_DDEMOPLAY then begin
        if f.dead > 1 then exit;
        if f.ammo_gl <= 0 then begin
                NOAMMO(f);
                exit;
        end;
                dec(f.ammo_gl);
end;

        if ismultip=2 then begin
                if (f.item_haste > 0) then f.refire := 30 else f.refire := 45;
                setcrosshairpos(f, round(f.x),round(f.y), f.clippixel,false);
                MsgSize := SizeOf(TMP_ClientShot);
                Msg.DATA := MMP_CLIENTSHOT;
                Msg.DXID := f.dxid;
                Msg.clippixel := f.clippixel;
                Msg.ammo := f.ammo_gl+1;
                Msg.index := 3;         // 3=gl;
                Msg.x := f.x;
                if f.crouch then weapony := 3 else weapony := -5;
                Msg.y := f.y+weapony;
                if (f.dir = 1) or (f.dir = 3) then
                Msg.fangle := RadToDeg(ArcTan2(f.y-f.cy+weapony,f.x-f.cx))-90 else
                Msg.fangle := RadToDeg(ArcTan2(f.y-f.cy+weapony,f.x-f.cx-1))-90;
                mainform.BNETSendData2HOST (Msg, MsgSize, 0);
                exit;
        end;

        playsound(SND_grenade,f.x,f.y);
        if (f.item_haste > 0) then f.refire := 30 else f.refire := 45;
        if (f.item_quad > 0) and (f.item_quad_time = 0) then
        begin playsound(SND_damage3,f.x,f.y);
              f.item_quad_time := 50; end;

        if SYS_FIREWORKSSTUDIOS then begin f.refire := 10; f.ammo_gl:=13; end;

        inc(f.stats.gren_fire);
        setcrosshairpos(f, round(f.x),round(f.y), f.clippixel,false);
        for i := 0 to 1000 do if aaa[i].dead = 2 then begin

                if f.crouch then weapony := 3 else weapony := -5;
                aaa[i].objname := 'grenade';
                aaa[i].dead := 0;
                aaa[i].dude := false;
                aaa[i].frame := 0;
                aaa[i].DXID := AssignUniqueDXID($FFFF);
                aaa[i].mass := 2.5;
                aaa[i].topdraw := 1;
                aaa[i].clippixel := 4;
                aaa[i].fAngle := RadToDeg(ArcTan2(f.y-f.cy+weapony,f.x-f.cx))-90;
                if f.idd=2 then aaa[i].fAngle := f.botangle;
                aaa[i].spawner := f;
                aaa[i].fallt := 0;
                aaa[i].refire := 0;
                aaa[i].idd := 0;
                aaa[i].imageindex := 255; // 15secs before timeout
                if OPT_EASTERGRENADES then
                aaa[i].refire := random(21)+8;

                if MATCH_DDEMOPLAY then begin
                        if DDEMO_VERSION=1 then begin
                                aaa[i].x := DVectorMissile.x;
                                aaa[i].y := DVectorMissile.y;
                                aaa[i].InertiaX := DVectorMissile.InertiaX;
                                aaa[i].InertiaY := DVectorMissile.InertiaY;
                                aaa[i].dir := DVectorMissile.dir;
                                aaa[i].dude := false;
                                aaa[i].dxid := DVectorMissile.dxid;
                                aaa[i].fangle := DVectorMissile.angle;
                        end
                        else if DDEMO_VERSION>=3 then begin
                                aaa[i].x := DGrenadeFireV2.x;
                                aaa[i].y := DGrenadeFireV2.y;
                                aaa[i].InertiaX := DGrenadeFireV2.InertiaX;
                                aaa[i].InertiaY := DGrenadeFireV2.InertiaY;
                                aaa[i].dir := DGrenadeFireV2.dir;
                                aaa[i].dude := false;
                                aaa[i].dxid := DGrenadeFireV2.dxid;
                                aaa[i].fangle := DGrenadeFireV2.angle;
                        end;
                end else begin

                aaa[i].x := f.x;
                aaa[i].y := f.y+weapony;

                        // multiplayer shot.
                        if x > 0 then begin
                                aaa[i].x := x;
                                aaa[i].y := y;
                                aaa[i].fangle := ang;
                        end;

                setcrosshairpos(f, trunc(f.x),trunc(f.y), f.clippixel, true);

                if ((f.dir = 0) or (f.dir = 2)) and (f.clippixel <= 0) then begin
                        aaa[i].inertiax := -(CROSHDIST+CROSHADD+f.clippixel)/50;
                        aaa[i].dir := 1;
                        end;
                if ((f.dir = 0) or (f.dir = 2)) and (f.clippixel >= 0) then begin
                        aaa[i].inertiax := -(CROSHDIST+CROSHADD-f.clippixel)/50;
                        aaa[i].dir := 1;
                        end;
                if ((f.dir = 1) or (f.dir = 3)) and (f.clippixel <= 0) then begin
                        aaa[i].inertiax := (CROSHDIST+CROSHADD+f.clippixel)/50;
                        aaa[i].dir := 2;
                        end;
                if ((f.dir = 1) or (f.dir = 3)) and (f.clippixel >= 0) then begin
                        aaa[i].inertiax := (CROSHDIST+CROSHADD-f.clippixel)/50;
                        aaa[i].dir := 2;
                        end;
                aaa[i].inertiay := f.clippixel / 17;
                aaa[i].inertiax := aaa[i].inertiax * 2.7;
                if aaa[i].inertiax < -3 then aaa[i].inertiax := -3;
                if aaa[i].inertiax > 3 then aaa[i].inertiax := 3;
                if aaa[i].inertiay < -4 then aaa[i].inertiay := -4;
                if aaa[i].inertiay > 4 then aaa[i].inertiay := 4;
                end;

                if MATCH_DRECORD then begin
                        DData.type0 := DDEMO_FIREGRENV2;               // VERSION2::
                        DData.gametic := gametic;
                        DData.gametime := gametime;
                        DGrenadeFireV2.x := f.x;
                        DGrenadeFireV2.y := f.y+weapony;
                        DGrenadeFireV2.DXID := aaa[i].DXID;
                        DGrenadeFireV2.spawnerDxid := F.DXID;
                        DGrenadeFireV2.inertiax := aaa[i].Inertiax;
                        DGrenadeFireV2.inertiay := aaa[i].Inertiay;
                        DGrenadeFireV2.dir := aaa[i].dir;
                        DGrenadeFireV2.angle := aaa[i].fAngle;
                        DemoStream.Write( DData, Sizeof(DData));
                        DemoStream.Write( DGrenadeFireV2, Sizeof(DGrenadeFireV2));
                        end;

                if aaa[i].fAngle<0 then aaa[i].fAngle:=360+aaa[i].fAngle;

/////   TMP_cl_GrenSpawn
        if ismultip=1 then begin
                MsgSize := SizeOf(TMP_cl_GrenSpawn);
                Msg2.DATA := MMP_CL_GRENADESPAWN;
                Msg2.spawnerDXID := f.dxid;
                Msg2.selfDXID := aaa[i].DXID;
                Msg2.fangle := round(aaa[i].fangle);
                Msg2.x := aaa[i].x;
                Msg2.y := aaa[i].y;
                Msg2.inertiax := aaa[i].inertiax;
                Msg2.inertiay := aaa[i].inertiay;
                Msg2.dir := aaa[i].dir;
                mainform.BNETSendData2All (Msg2, MsgSize, 1);
                exit;
        end;
        // & TMP_cl_GrenSpawn

                exit;
        end;
end;

procedure FIRE (f : TPlayer; x,y,ang : real);
begin
//if MATCH_RECORD = false then f.refire := 0;
//`if ismultip > 0 then exit; // :)
if (ismultip = 1) and (MATCH_STARTSIN >=1) and (MATCH_STARTSIN<=150) then exit;
if (ismultip = 2) and (MATCH_FAKESTARTSIN >=1) and (MATCH_FAKESTARTSIN<=3) then exit;
if f.refire = 0 then if (f.weapon = 0) then FireGauntlet(f); //gantl
if f.refire = 0 then if (f.weapon = 1) and (f.have_mg = true) then firemachine(f,0,0,0);//mac
if f.refire = 0 then if (f.weapon = 2) and (f.have_sg = true) then fireshotgun(f,0,0,0);//shot
if f.refire = 0 then if (f.weapon = 3) and (f.have_gl = true) then firegren(f,0,0,0);//gren
if f.refire = 0 then if (f.weapon = 4) and (f.have_rl = true) then firerocket(f,0,0,0);//rl
if f.refire = 0 then if (f.weapon = 5) and (f.have_sh = true) then FireShaftEx(f, false);//shaft
//if f.refire = 0 then if (f.weapon = 5) and (f.have_sh = true) then fireshaft(f,0,0,0);//shaft
if f.refire = 0 then if (f.weapon = 6) and (f.have_rg = true) then firerail(f,0,0,0,0);//rail
if f.refire = 0 then if (f.weapon = 7) and (f.have_pl = true) then fireplasma(f,0,0,0);//plaz
if f.refire = 0 then if (f.weapon = 8) and (f.have_bfg = true) then firebfg(f,0,0,0);//bfg
end;

procedure Tmainform.FormClose(Sender: TObject; var Action: TCloseAction);
var i : word;
    F : TINIFILE;
begin
 DXTimer.MayProcess := false;
 showcursor(true);
try
  FinalizeALl;
 except loadi.cns.lines.add('error closing direct3d8.'); end;
 loadi.cns.lines.add('-- Direct3D8 closed --');

// if not isparamstr('protected') then
 SaveCFG('nfkconfig');

 try
 if GAME_LOG then loadi.cns.lines.Savetofile(ROOTDIR+'\LOG.txt');
 except addmessage('cannot save log.txt to '+ROOTDIR+'\log.txt.'); end;


 if FMODStream <> nil then begin
         FSOUND_Stream_Stop(FMODStream);
         FSOUND_Stream_Close(FMODStream);
         end;

 for i := 1 to FMOD_MAXSOUND do
        FSOUND_Sample_Free(SAMPLES[I]);

 FSOUND_Close();

 if combo1.ts.count > 0 then begin
        F := TIniFile.Create(ROOTDIR+'\nfksetup.ini');
        for i := 0 to 5 do
        if i < combo1.ts.count then
                f.WriteString('DirectConnectHistory','IP'+inttostr(i),combo1.ts[i]) else
        f.WriteString('DirectConnectHistory','IP'+inttostr(i),'');
        f.free;
 end;


 combo1.TS.Free;
 BNET_AU_LIST.Free;


// loadi.show;
end;
// -----------------------------------------------------------------------------
procedure Tmainform.FormKeyUp(Sender: TObject; var Key: Word;
  Shift: TShiftState);
//  var  i : integer;
//var
//    i{,confinded} : integer;
var res : Integer;
begin
{  Screen mode change  }
  if (ssAlt in Shift) and (Key=VK_RETURN) then
  begin
        FinalizeAll();
        PowerGraph.Finalize();
        PowerGraph.FullScreen:= not PowerGraph.FullScreen;
        Res:= PowerGraph.Initialize(mainform.handle);
        if (Res <> 0) then begin AddMessage('Error: ' + PowerGraph.ErrorString(Res));
                Application.terminate;
                Exit;
                end;
        LoadGrafix();
  end;
if key=vk_f12 then begin
        if (inmenu=false) and (OPT_TRIXMASTA) and (MATCH_GAMETYPE=GAMETYPE_TRIXARENA) and (MATCH_STARTSIN=0) then applyHcommand('restart');
end;


//addmessage('^2'+inttostr(key));


if key = 19 then if ismultip=0 then dxtimer.mayprocess := not dxtimer.mayprocess;
if key = vk_f10 then if inmenu =false then if not MATCH_DDEMOPLAY then applyhcommand('ready');
if (key=13) and (INCONSOLE) then lastconadd := 0;
if (key=$9) and (INCONSOLE) then begin if (constr <> '') then TABCommand(constr); SYS_CONSOLE_POS := length(constr); end;
if (key=38) and (INCONSOLE) then begin if lastconadd < conhist.Count-1 then inc(lastconadd); constr := conhist[lastconadd]; SYS_CONSOLE_POS := length(constr); end;
if (key=40) and (INCONSOLE) then begin if lastconadd > 0 then dec(lastconadd); constr := conhist[lastconadd]; SYS_CONSOLE_POS := length(constr); end;

if MATCH_DDEMOPLAY then
if key=107 then begin
        if not MATCH_DDEMOPLAY then exit;
        if OPT_SPEEDDEMO < 40 then begin
                inc(OPT_SPEEDDEMO);
                if OPT_SPEEDDEMO < 40 then
                        inc(OPT_SPEEDDEMO);
        end;
        if SYS_NFKAMP_PLAYINGCOMMENT then
        addmessage('"speeddemo" is set to "'+inttostr(OPT_SPEEDDEMO)+'". ^1WARNING: disbalance with mp3 comment') else
        addmessage('"speeddemo" is set to "'+inttostr(OPT_SPEEDDEMO)+'"');

        mainform.dxtimer.fps := 30+OPT_SPEEDDEMO;
end;

if MATCH_DDEMOPLAY then
if key=109 then begin
        if OPT_SPEEDDEMO > 0 then begin
                dec(OPT_SPEEDDEMO);
                if OPT_SPEEDDEMO > 0 then
                        dec(OPT_SPEEDDEMO);
        end;

        if SYS_NFKAMP_PLAYINGCOMMENT then
        addmessage('"speeddemo" is set to "'+inttostr(OPT_SPEEDDEMO)+'". ^1WARNING: disbalance with mp3 comment') else
        addmessage('"speeddemo" is set to "'+inttostr(OPT_SPEEDDEMO)+'"');

        mainform.dxtimer.fps := 30+OPT_SPEEDDEMO;
        if mainform.dxtimer.fps=0 then mainform.dxtimer.fps:=1;
end;

if key=27 then if INMENU=false then begin
        GAMEMENUORDER := 0;
        INGAMEMENU := not INGAMEMENU;
        end;

if (SYS_TEAMSELECT=1)  and (inconsole=false) and (ingamemenu=false) then begin
        if key=40 then if GAMEMENUORDER < 2 then inc(GAMEMENUORDER);
        if key=38 then if GAMEMENUORDER > 0 then dec(GAMEMENUORDER);
        if key=13 then if GAMEMENUORDER = 0 then ApplyHCommand('join auto');
        if key=13 then if GAMEMENUORDER = 1 then ApplyHCommand('join red');
        if key=13 then if GAMEMENUORDER = 2 then ApplyHCommand('join blue');
        end;


// ESC Game Menu
if (ingamemenu=true)  and (inconsole=false) then
        if CanSelectTeam then begin
                if key=40 then if GAMEMENUORDER < 3 then inc(GAMEMENUORDER);
                if key=38 then if GAMEMENUORDER > 0 then dec(GAMEMENUORDER);
                if key=13 then if GAMEMENUORDER = 0 then INGAMEMENU := false;
                if key=13 then if GAMEMENUORDER = 1 then begin SYS_TEAMSELECT:=1;GAMEMENUORDER:=0; INGAMEMENU := false; end;
                if key=13 then if GAMEMENUORDER = 2 then begin ApplyHCommand('restart'); INGAMEMENU := false; end;
                if key=13 then if GAMEMENUORDER = 3 then begin ApplyHCommand('disconnect'); INGAMEMENU := false; end;
        end else begin
                if key=40 then if GAMEMENUORDER < 2 then inc(GAMEMENUORDER);
                if key=38 then if GAMEMENUORDER > 0 then dec(GAMEMENUORDER);
                if key=13 then if GAMEMENUORDER = 0 then INGAMEMENU := false;
                if key=13 then if GAMEMENUORDER = 1 then begin ApplyHCommand('restart'); INGAMEMENU := false; end;
                if key=13 then if GAMEMENUORDER = 2 then begin ApplyHCommand('disconnect'); INGAMEMENU := false; end;
        end;

//if key=vk_f5 then INSCOREBOARD := not INSCOREBOARD;


if menueditmode=0 then
if key= $C0 then begin  // tilda key code
        if INGAMEMENU then INGAMEMENU:=false;

        if INCONSOLE = false then begin
                INCONSOLE := true;
                SYS_CONSOLE_POS := 0;
        end else begin
                constr := '';
                INCONSOLE := false;
                lastconadd := 0;
        end;
end;


//ALIASES
if (INMENU=false) and (inconsole=false) then
        if (KEYALIASES[key]<>'') and (KEYALIASES[key]<>'1') then begin
                HIST_DISABLE := TRUE;
                if MSG_DISABLE then res := 1 else res := 0;
                MSG_DISABLE := FALSE;
                ALIASCOMMAND := True;
                ApplyCommand(KEYALIASES[key]);
                ALIASCOMMAND := False;
                HIST_DISABLE := FALSE;
                if res=1 then MSG_DISABLE := TRUE;
                end;

if not inmenu then begin
        if key=VK_F1 then applyHcommand('vote y');
        if key=VK_F2 then applyHcommand('vote n');
        end;


end;
// -----------------------------------------------------------------------------
procedure SV_Remember_Score_Add(netname, nfkmodel:string; frags : integer);
var t: PSV_Remember_Score;
begin
        if ismultip<>1 then exit;
        if frags<=0 then exit;
        new(t);
        t^.netname := netname;
        t^.nfkmodel := nfkmodel;
        t^.frags := frags;
        SV_Remember_Score_List.Add(t);
end;
// -----------------------------------------------------------------------------
procedure SV_Remember_Score_Clear;
begin
        if ismultip<>1 then exit;
        SV_Remember_Score_List.clear;
end;

function SV_Remember_Score_Retrieve(netname, nfkmodel:string; var frags_:integer):boolean;
var z : byte;
begin
        if ismultip<>1 then exit;
        result := false;
        if SV_Remember_Score_List.count=0 then exit;
        for z := 0 to SV_Remember_Score_List.count-1 do
                if (TSV_Remember_Score(SV_Remember_Score_List.items[z]^).netname=netname) and
                   (TSV_Remember_Score(SV_Remember_Score_List.items[z]^).nfkmodel=nfkmodel) then begin
                        result := true;
                        frags_ := TSV_Remember_Score(SV_Remember_Score_List.items[z]^).frags;
                        SV_Remember_Score_List.Delete (z);
                        exit;
                   end;
end;
// -----------------------------------------------------------------------------
function AssignUniqueDXID (tmp : word) : word;
var newdxid : word;
    i : integer;
    repeatz : boolean;
begin
repeatz := true;
while (repeatz = true) do begin
newdxid := random(tmp);
repeatz := false;
for i := 0 to 1000 do
        if (aaa[i] <> nil) then
                if (aaa[i].DXID = newdxid) then repeatz := true;
for i := 0 to 7 do
        if (players[i] <> nil) then
                if (players[i].DXID = newdxid) then repeatz := true;

if newdxid = 0 then repeatz := true;    // not zero. zero means temporaly unavaible.
end;
//addmessage('assigned DXID: '+inttostr(newdxid));
//loadi.cns.lines.add('assigned DXID: '+inttostr(newdxid));
result := newdxid;
//
end;
// -----------------------------------------------------------------------------
procedure SV_TransmitCMD();
var  msg7: TMP_Svcommand;
     MsgSize: word;
begin
        MsgSize := SizeOf(TMP_Svcommand);
        Msg7.Data := MMP_SV_COMMAND;
        Msg7.fraglimit := MATCH_FRAGLIMIT;
        Msg7.timelimit := MATCH_TIMELIMIT;
        Msg7.warmup := MATCH_WARMUP;
        Msg7.warmuparmor := OPT_WARMUPARMOR;
        Msg7.forcerespawn := OPT_FORCERESPAWN;
        Msg7.railarenainstagib := OPT_RAILARENA_INSTAGIB;
        Msg7.teamdamage := OPT_TEAMDAMAGE;
        Msg7.overtime := OPT_SV_OVERTIME;
        Msg7.sync := OPT_SYNC;
        Msg7.capturelimit := MATCH_CAPTURELIMIT;
        Msg7.domlimit := MATCH_DOMLIMIT;
        mainform.BNETSendData2All (Msg7, MsgSize, 1);
end;
// -----------------------------------------------------------------------------
function TestIP(IP:shortstring):boolean;
var i : byte;
begin
        if IP = BNET_GAMEIP then begin
                result := true;
                exit;
                end;

        result := false;

        for i := 0 to high(players) do
        if players[i] <> nil then
        if players[i].IPAddress = IP then begin
        result := true;
        exit;
        end;
end;
// -----------------------------------------------------------------------------
procedure TestPlayerDead(i:byte);
var
     MsgSize: word;
     msg : TMP_IamRespawn;
begin
        if players[i]=nil then exit;
        if ismultip<>1 then exit;
        if random(10)>0 then exit;
        if players[i].dead < 2 then exit;

        MsgSize := SizeOf(TMP_IamRespawn);
        Msg.Data := MMP_YOUAREREALYKILLED;
        Msg.DXID := players[i].dxid;
        mainform.BNETSendData2IP_(players[i].IPAddress, players[i].Port, Msg, MsgSize, 0);
end;
// -----------------------------------------------------------------------------
procedure TMainForm.BNETReceiveData(Sender: TObject);
var
    FromIP : shortstring;
    FromPort : integer;
var Data:Pointer;
begin
        BNET1.ReadData(ReadBuf, FromIP, FromPort);
        Network_ParsePackets(FromIP, FromPort);
end;
// -----------------------------------------------------------------------------
procedure SendFloodTo(ToIP:shortstring; ToPort: word; order : byte);
var   msg: TMP_IpInvite;
      msgsize : byte;
begin
        MsgSize := SizeOf(TMP_IpInvite);
        Msg.DATA := MMP_FLOOD;
        Msg.ACTION := order;
        mainform.BNETSendData2IP_ (ToIP, ToPort, Msg, MsgSize, 0);
end;
// -----------------------------------------------------------------------------
procedure TMainForm.BNET_TCPSERV_ClientConnected(Sender: TObject; Client: TSimpleTCPClient);
begin
        addmessage('TCPSERV: '+Client.Host + ' connected');
end;

procedure TMainForm.BNET_TCPCLIENT_Connected(Sender: TObject);
begin
        addmessage('TCPCLIENT: Connected to '+BNET_GAMEIP);
        BNET_GAMEIP := inttostr(TCPCLIENT.Socket);
        SPAWNCLIENT;
end;

procedure ParseTCPData(FromIP: shortstring; DataSize: Integer);
var dcc : integer;
//    TmpBuf : array[0..1023] of Byte;
//    i : word;

begin
//        mainform.BNET_NFK_ReceiveData(FromIP, BNET_TCPPORT, dcc);
{        exit;

        move(mainform.readbuf, tmpbuf,DataSize);
        dc := 0;
        dcc := 1;
        repeat

                for i := 0 to dcc-1 do
                        mainform.ReadBuf[i] := TmpBuf[i+dc];

                mainform.BNET_NFK_ReceiveData(FromIP, BNET_GAMEPORT, dcc);

                if dc>=DataSize-1 then exit;

                dcc := dc;
                case tmpbuf[0] of
                        MMP_CREATEPLAYER: inc(dc, SizeOf(TMP_CreatePlayer));
                end;
                dcc := dc - dcc;

        until true;
        }
end;

procedure TMainForm.BNET_TCPSERV_DataAvailable(Sender: TObject; Client: TSimpleTCPClient; DataSize: Integer);
var buf : pointer;
    FromIP : shortstring;
begin
        if DataSize <= 0 then Exit;
        GetMem(Buf, DataSize);
        client.Receive(buf, DataSize, true);
        move(Buf^,readbuf, DataSize);
//      addmessage('^4TCPSERVREAD');
        freemem(buf);
        FromIP := inttostr(Client.Socket);
        ParseTCPData(FromIP, DataSize);
end;

procedure TMainForm.BNET_TCPCLIENT_DataAvailable (Sender: TObject; DataSize: Integer);
var     buf : pointer;
        FromIP : shortstring;
begin
        if DataSize <= 0 then Exit;
        GetMem(Buf, DataSize);
        TCPCLIENT.Receive(buf, DataSize, true);
        move(Buf^,readbuf,DataSize);
//      addmessage('^4TCPCLIENTVREAD');
        freemem(buf);
        FromIP := inttostr(TCPCLIENT.Socket);
        ParseTCPData(FromIP, DataSize);

end;

// ===================================
procedure SV_AnswerLobbyGamestate(FromIP:string; FromPort:word);
var     MsgSize: word;
        msg : TMP_LOBBY_Gamestate_result;
begin
        MsgSize  := SizeOf(TMP_LOBBY_Gamestate_result);
        Msg.Data := MMP_LOBBY_GAMESTATE_RESULT;
        Msg.SIGNNATURE     := NFK_SIGNNATURE;
        Msg.CurrentPlayers := GetNumberOfPlayers;
        Msg.MaxPlayers     := OPT_SV_MAXPLAYERS;
        Msg.Gametype       := MATCH_GAMETYPE;
        Msg.Hostname       := OPT_SV_HOSTNAME;
        Msg.MapName        := map_filename;
        mainform.BNETSendData2IP_(FromIP, FromPort, Msg, MsgSize, 0);
end;
// ===================================
procedure CL_AskLobbyGamestate(ToIP:String);
var     MsgSize: word;
        msg : TMP_GAMESTATERequest;
begin
        MsgSize := SizeOf(TMP_GAMESTATERequest);
        Msg.DATA := MMP_LOBBY_GAMESTATE;
        Msg.SIGNNATURE := NFK_SIGNNATURE;
        mainform.BNETSendData2IP_(ToIP, BNET_GAMEPORT, Msg, MsgSize, 0);
//        AddMEssage('ScanNetwork: '+ToIP);
end;
// ===================================

function BNET_NFK_msgfromserv(FromIP:ShortString):boolean;
begin
{        result := false;

        if TCPCLIENT.Connected then begin
                result := true;
                exit;
                end;

}
        result := FromIP = BNET_GAMEIP;
end;

procedure TMainForm.BNET_NFK_ReceiveData(Data: Pointer; FromIP : shortstring; FromPort : integer; DataSize : integer);
var //Data:Pointer;
  Msg: TMP_CreatePlayer;
  msg2: TMP_ItemAppear;
  msg3: TMP_SV_send_time;
  msg4: TMP_AnswerPing;
  msg5: TMP_SV_PlayerRespawn;
  msg6: TMP_GAMESTATEAnswer;
  msg7: TMP_Svcommand;
  msg8: TMP_ObjChangeState;
  msg9: TMP_SV_MatchStart;
  msg10: TMP_IpInvite;
  msg11: TMP_Svcommand_ex;
  msg12 : TMP_DisconnectClient;

  msgsize : word;

  rzlt : boolean;
  a :word;
  s : string;
  buf : array [0..$FF] of char;
  i : integer;
  pl : TPlayer;
  str : string;
  Spect : PSpectator;
  p : pointer;
begin
//Data := @ReadBuf;



if (FromIP = MainForm.LocalIP) then exit;

if ENABLE_PACKETSHOW then addmessage('RECV '+FromIP+':'+inttostr(FromPort)+' -- '+inttostr(byte(data^)));

//if (FromPort <> BNET_GAMEPORT) and (FromPort <> BNET_TCPPORT) then exit; //tha waz a spam.

{if (inmenu) and (readbuf[0] <> MMP_INVITE) then begin
        addmessage('^5 Connection Killed by NOTINMENU');
        exit;
        end;
}

if (FromIP = '127.0.0.1') then exit; // tha waz a spam

// flood protect..
if ENABLE_PROTECT then begin // All other packets NFK cant be received from every body.
        if      (byte(data^) <> MMP_INVITE) and //
                (byte(data^) <> MMP_FLOOD) and //
                (byte(data^) <> MMP_LOBBY_GAMESTATE_RESULT) and
                (byte(data^) <> MMP_LOBBY_GAMESTATE) and
                (byte(data^) <> MMP_GAMESTATEREQUEST) and //
                (byte(data^) <> MMP_GAMESTATEANSWER) and //
                (byte(data^) <> MMP_SPECTATORCONNECT) and  //
                (byte(data^) <> MMP_SPECTATORDISCONNECT) and  //
                (byte(data^) <> MMP_REGISTERPLAYER) and   //
                (byte(data^) <> MMP_CREATEPLAYER) and   //
                (byte(data^) <> MMP_LOBBY_PING) and     //
                (byte(data^) <> MMP_SV_SEND_TIME) and   //
                (byte(data^) <> MMP_SV_COMMAND) and     //
                (byte(data^) <> MMP_SV_COMMANDEX) and   //
                (byte(data^) <> MMP_LOBBY_ANSWERPING) and //
                (byte(data^) <> MMP_MATCHSTART) and //
                (byte(data^) <> MMP_OBJCHANGESTATE) and  //
                (byte(data^) <> MMP_CREATEPLAYER) then  //
                if inmenu then exit else
                if not TestIP(FromIP) then begin
                        if ENABLE_PACKETSHOW then addmessage('^5 Data Killed by PS ('+FROMIP+')');
                        exit;
                end;
        end;


case byte(data^) of  // detect packet type
//-----------------------------------------------------------
        MMP_INVITE:
        begin
//                AddMessage('^1You have received invite from '+FromIP+'. Type "connect '+FromIP+'" to joingame.');

                if TMP_IpInvite(Data^).ACTION = 0 then begin
                        if inmenu=true then begin
                                BNET_SERVERPORT := FromPort; // super
                                if not OPT_AUTOCONNECT_ONINVITE then begin
                                        addmessage('^2You have received invite from '+FromIP+'. Type "connect '+FromIP+'" to joingame.');
                                        if (inconsole=false) then inconsole:=true;
                                end else if inmenu then BNET_DirectConnect(FromIP);
                        end;

                        MsgSize := SizeOf(TMP_IpInvite);
                        Msg10.DATA := MMP_INVITE;
                        if inmenu=false then
                        Msg10.ACTION := 2 else // in game
                        Msg10.ACTION := 1; // in menu.
                        BNETSendData2IP_(FromIP, FromPort, Msg10, MsgSize, 0);

//                        mainform.BNETSendData2IP (FromIP, Msg10, MsgSize, 0);
                end else if TMP_IpInvite(Data^).ACTION = 1 then
                        addmessage('^2ipinvite: '+FromIP+' has received your invitation.')
                else if TMP_IpInvite(Data^).ACTION = 2 then
                        addmessage('^2ipinvite: '+FromIP+' already playing somewhere... and dont see your invitation');

        end;

//-----------------------------------------------------------
        MMP_LOBBY_GAMESTATE: // some body asked for Search LanGames;
        begin
                if ismultip<>1 then exit;
//                AddMessage('lan info asked');
                SV_AnswerLobbyGamestate(FromIP, FromPort);
                exit;
        end;
//-----------------------------------------------------------
        MMP_LOBBY_GAMESTATE_RESULT:
        begin
                if TMP_LOBBY_Gamestate_result(Data^).SIGNNATURE <> NFK_SIGNNATURE then exit;
                if MP_STEP <> 4 then exit;
                if not INMENU then exit;

                MP_Sessions.Add (
                TMP_LOBBY_Gamestate_result(Data^).Hostname + #0+
                TMP_LOBBY_Gamestate_result(Data^).MapName + #0+
                inttostr(TMP_LOBBY_Gamestate_result(Data^).Gametype) + #0+
                inttostr(TMP_LOBBY_Gamestate_result(Data^).CurrentPlayers) + #0+
                inttostr(TMP_LOBBY_Gamestate_result(Data^).MaxPlayers) + #0+
                FromIP);

                if MP_Sessions.count = 1 then
                sys_lan_refresh_time := gettickcount + 1000;

                NFKPLANET_PingLastServer;
        end;
//-----------------------------------------------------------
        MMP_FLOOD:
        begin
                if TMP_IpInvite(Data^).ACTION = 0 then
                        SendFloodTo(FromIP, FromPort, 1);
                if TMP_IpInvite(Data^).ACTION = 1 then
                        SendFloodTo(FromIP, FromPort, 2);
        end;
//-----------------------------------------------------------
        MMP_LOBBY_PING:
        begin
                MsgSize := SizeOf(TMP_AnswerPing);
                Msg4.Data := MMP_LOBBY_ANSWERPING;
                BNETSendData2IP_(FromIP, FromPort, Msg4, MsgSize, 0);
                BNETSendData2IP_(FromIP, FromPort, Msg4, MsgSize, 0);
                BNETSendData2IP_(FromIP, FromPort, Msg4, MsgSize, 0);


//              addmessage('^3LOBBY PING RECEIVED');
                exit;
        end;
//-----------------------------------------------------------
        MMP_LOBBY_ANSWERPING:
        begin
                NFKPLANET_UpdateServerPing(FromIP);
                exit;
        end;
//-----------------------------------------------------------
        MMP_GAMESTATEREQUEST: // Server Receive Ask For Gamestate.
        begin
                if inmenu then exit;
                if ismultip <> 1 then exit; // clients and localhost cant accept connections.
                if TMP_GAMESTATERequest(Data^).SIGNNATURE <> NFK_SIGNNATURE then exit;

                if (OPT_SV_ALLOWJOINMATCH=false) and (MATCH_STARTSIN=0) then
                addmessage('^3Connection attempt from '+FromIP+'. Dropped by sv_allowjoinmatch 0') else
                        if GetNumberOfPlayers >= OPT_SV_MAXPLAYERS then
                                addmessage('^3Connection attempt from '+FromIP+'. Dropped by sv_maxplayers') else
                                        addmessage('^3Connection attempt from '+FromIP);

                MsgSize := SizeOf(TMP_GAMESTATEAnswer);
                Msg6.Data := MMP_GAMESTATEANSWER;
                Msg6.Filename := copy(extractfilename(map_filename_fullpath),0,length(extractfilename(map_filename_fullpath))-5);
                if Msg6.Filename = '' then begin
                        Msg6.Filename := copy(extractfilename(loadmapsearch_lastfile),0,length(extractfilename(loadmapsearch_lastfile))-5);
                                addmessage('^1SERVER ERROR: map search failed. PLEASE REPORT THIS BUG');
                                applycommand('mp?');
                        end;
                Msg6.VERSION := VERSION;
                Msg6.DODROP:=0;

                if TMP_GAMESTATERequest(Data^).spectator = false then begin
                        if (OPT_SV_ALLOWJOINMATCH=false) and (MATCH_STARTSIN=0) then Msg6.DODROP :=1 else Msg6.DODROP:=0;
                        if GetNumberOfPlayers >= OPT_SV_MAXPLAYERS then Msg6.DODROP:=2;
                end;

                Msg6.CRC32 := LoadMapCRC32(map_filename_fullpath);
                Msg6.MATCH_GAMETYPE := MATCH_GAMETYPE;
                BNETSendData2IP_(FromIP, FromPort, Msg6, MsgSize, 1);

                if Msg6.DODROP=2 then begin
//                      addmessage('^5 Connection Killed by SERVERDROP');
                        exit; // dropped anyway
                        end;

                // sv variables
                MsgSize := SizeOf(TMP_Svcommand);
                Msg7.Data := MMP_SV_COMMAND;
                Msg7.fraglimit := MATCH_FRAGLIMIT;
                Msg7.timelimit := MATCH_TIMELIMIT;
                Msg7.warmup := MATCH_WARMUP;
                Msg7.warmuparmor := OPT_WARMUPARMOR;
                Msg7.forcerespawn := OPT_FORCERESPAWN;
                Msg7.sync := OPT_SYNC;
                Msg7.railarenainstagib := OPT_RAILARENA_INSTAGIB;
                Msg7.teamdamage := OPT_TEAMDAMAGE;
                Msg7.overtime := OPT_SV_OVERTIME;
                Msg7.capturelimit := MATCH_CAPTURELIMIT;
                Msg7.domlimit := MATCH_DOMLIMIT;
                BNETSendData2IP_(FromIP, FromPort, Msg7, MsgSize, 1);

                MsgSize := SizeOf(TMP_Svcommand_ex);
                msg11.data := MMP_SV_COMMANDEX;
                msg11.maxplayers := OPT_SV_MAXPLAYERS;
                msg11.net_predict := OPT_NETPREDICT;
                msg11.reserved1 := 0;
                msg11.powerup := OPT_SV_POWERUP;
                BNETSendData2IP_(FromIP, FromPort, Msg11, MsgSize, 1);

                // send time info.
                MsgSize := SizeOf(TMP_SV_send_time);
                Msg3.DATA := MMP_SV_SEND_TIME;
                Msg3.Gametic := gametic;
                Msg3.gametime := gametime;
                Msg3.warmup := MATCH_STARTSIN;
                BNETSendData2IP_(FromIP, FromPort, Msg3, MsgSize, 1);

                // reupdate teamscore
                if (TeamGame) and (MATCH_STARTSIN=0) then
                        SV_UpdateTeamScore(FromIP, FromPort);

                // send special object states
                for i := 0 to $FF do if ddd[i].active then begin        // send obj states.
                        if (ddd[i].objtype = 2) and (ddd[i].targetname=1) then begin
                        MsgSize := SizeOf(TMP_ObjChangeState);
                        Msg8.Data := MMP_OBJCHANGESTATE;
                        Msg8.objindex := i;
                        Msg8.state := 1;
//                        BNETSendData2IP(FromIP, Msg8, MsgSize, ttGuaranteed);
                        BNET_NFK_SEND(1, Msg8, MsgSize, FromIP, FromPort);
                        end;

                        if (ddd[i].objtype = 3) then begin
                        MsgSize := SizeOf(TMP_ObjChangeState);
                        Msg8.Data := MMP_OBJCHANGESTATE;
                        Msg8.objindex := i;
                        Msg8.state := ddd[i].target;
                        BNETSendData2IP_(FromIP, FromPort, Msg8, MsgSize, ttGuaranteed);
                        end;
                end;

                // if game is finished, then we send GAMEEND
                IF MATCH_GAMEEND then begin
                        MsgSize := SizeOf(TMP_SV_MatchStart);
                        Msg9.DATA := MMP_MATCHSTART;
                        Msg9.gameend := TRUE;
                        Msg9.gameendid := END_JUSTEND;
                        BNETSendData2IP_(FromIP, FromPort, Msg9, MsgSize, ttGuaranteed);
                end;
        end;
        //-----------------------------------------------------------
        MMP_GAMESTATEANSWER: // Client Game Init
        begin
                if not BNET_NFK_msgfromserv(FromIP) then exit;

                IF TMP_GAMESTATEAnswer(Data^).VERSION <> VERSION then begin
                        ShowCriticalError('Incorrect NFK version','Server nfk version version differs from your', 'Server version is: '+TMP_GAMESTATEAnswer(Data^).VERSION);
                        ApplyHCommand('disconnect'); exit;
                        end;

                IF TMP_GAMESTATEAnswer(Data^).DODROP = 1 then begin
                        ShowCriticalError('Disconnected from server','You cannot join this server during match,', 'try to join at the warmup time.');
                        ApplyHCommand('disconnect'); exit;
                        end;

                IF TMP_GAMESTATEAnswer(Data^).DODROP = 2 then begin
                        ShowCriticalError('Disconnected from server','Server is full', '');
                        ApplyHCommand('disconnect'); exit;
                        end;

//                addmessage('^2MAP:'+TMP_GAMESTATEAnswer(Data^).filename+' CRC32:'+inttostr(TMP_GAMESTATEAnswer(Data^).CRC32));

                a := LOADMAPSearch( lowercase(extractfilename(lowercase(TMP_GAMESTATEAnswer(Data^).filename+'.mapa'))), TMP_GAMESTATEAnswer(Data^).CRC32);

                if a = LMS_NOTFOUND then begin
                        ShowCriticalError('Disconnected from server','Can not join. Map not found', '('+TMP_GAMESTATEAnswer(Data^).Filename+')');
                        ApplyHCommand('disconnect'); exit;
                end;

                if a = LMS_CRC32FAILED then begin
                        ShowCriticalError('Disconnected from server','Can not join. Your map differs', 'from server map ('+TMP_GAMESTATEAnswer(Data^).Filename+')');
                        ApplyHCommand('disconnect'); exit;
                end;

                MATCH_GAMETYPE := TMP_GAMESTATEAnswer(Data^).MATCH_GAMETYPE;
                LOADMAP (ROOTDIR+'\maps\'+loadmapsearch_lastfile, true);

                // rmove all itmz
                for i := 0 to BRICK_X-1 do for a := 0 to BRICK_Y-1 do
                        if bbb[i,a].image > 0 then if bbb[i,a].respawnable then
                                bbb[i,a].respawntime := 2;

                SpawnServer;

                BNET_OLDGAMEIP := BNET_GAMEIP; // remember ip for reconnect command.
                BNET_SERVERPORT := FromPort;
                BNET_CONNECTING :=false;

                OPT_SV_DEDICATED := false;
////                OPT_NETSPECTATOR := false;
        end;
        //-----------------------------------------------------------
        MMP_HOSTSHUTDOWN:
        begin
              if not BNET_NFK_msgfromserv(FromIP) then exit;

              ShowCriticalError('Disconnected from server','The game host has left', '');
              if MATCH_DRECORD then DemoEnd(END_JUSTEND);
              ApplyHCommand('disconnect'); exit;
        end;
        //---------------------------------------
        MMP_IAMQUIT:
        begin
                if ismultip=1 then begin
                        CopyMemory(@buf, data,sizeof(TMP_KickPlayer));
                        mainform.BNETSend_SV_Data2All_Except (FromIP,buf,sizeof(TMP_KickPlayer),1);
                end;

//              addmessage('QUIT MSG RECV');
        for i := 0 to 7 do if (players[i] <> nil) then if (players[i].DXID = TMP_KickPlayer(Data^).DXID) and (players[i].netobject = true) then begin
                addmessage(players[i].netname +' ^7^nhas left the game.');
                RespawnFlash(players[i].x-16, players[i].y);

                // RETURNFLAG!
                if ismultip=1 then
                if (MATCH_GAMETYPE = GAMETYPE_CTF) and (players[i].flagcarrier = true) and (players[i].dead = 0) then begin
                        CTF_DropFlag(players[i]);
                        players[i].team := 2;
                        end;

                if MATCH_DRECORD then begin
                        DData.type0 := DDEMO_DROPPLAYER;
                        DData.gametic := gametic;
                        DData.gametime := gametime;
                        DemoStream.Write( DData, Sizeof(DData));
                        DNETKickDropPlayer.DXID := players[i].DXID;
                        DemoStream.Write( DNETKickDropPlayer, Sizeof(DNETKickDropPlayer));
                        end;

                SV_Remember_Score_Add(players[i].netname, players[i].nfkmodel,players[i].frags);

                if SYS_BOT then DLL_SYSTEM_RemovePlayer(players[i].DXID);
                players[i] := nil;

                if ismultip=1 then NFKPLANET_UpdateCurrentUsers (GetNumberOfPlayers);

                break;
                end;
        end;
        //---------------------------------------
        MMP_DROPPLAYER:
        begin
                  if not BNET_NFK_msgfromserv(FromIP) then exit;

                  for i := 0 to 7 do if (players[i] <> nil) then if (players[i].DXID = TMP_DropPlayer(Data^).DXID) and (players[i].netobject = true) then begin
                                addmessage(players[i].netname +' ^7^ndropped by timeout.');
                                RespawnFlash(players[i].x-16, players[i].y);

                                if MATCH_DRECORD then begin
                                        DData.type0 := DDEMO_DROPPLAYER;
                                        DData.gametic := gametic;
                                        DData.gametime := gametime;
                                        DemoStream.Write( DData, Sizeof(DData));
                                        DNETKickDropPlayer.DXID := players[i].DXID;
                                        DemoStream.Write( DNETKickDropPlayer, Sizeof(DNETKickDropPlayer));
                                end;

                                if SYS_BOT then DLL_SYSTEM_RemovePlayer(players[i].DXID);
                                players[i] := nil;
                                if ismultip=1 then NFKPLANET_UpdateCurrentUsers (GetNumberOfPlayers);

                                break;
                        end;
                       for i := 0 to 7 do if (players[i] <> nil) then if (players[i].DXID = TMP_DropPlayer(Data^).DXID) and (players[i].netobject = false) then begin
                                ShowCriticalError('Disconnected from server','You was dropped by timeout', '');
                                ApplyHCommand('disconnect'); exit;
                       end;

        end;
        //---------------------------------------
        MMP_KICKPLAYER:
        begin
                  if not BNET_NFK_msgfromserv(FromIP) then exit;

                  for i := 0 to 7 do if players[i] <> nil then if (players[i].dXID = TMP_KickPlayer(Data^).DXID) then begin
                        if players[i].netobject = true then begin
                                        addmessage(players[i].netname+ ' ^7^nwas kicked.');
                                        players[i].NETUpdateD := false;
                                        players[i].balloon := false;
                                end
                                else begin
                                        ShowCriticalError('Disconnected from server','You was kicked by server', '');
                                        ApplyHCommand('disconnect'); exit;
                                end;
                        break;
                  end;
          end;
          //---------------------------------------
          MMP_SPECTATORDISCONNECT:
          begin
                addmessage('Spectator '+TMP_SpectatorLeave(data^).netname + ' ^7^ndisconnected.');

                if MATCH_DRECORD then begin
                        DData.type0 := DDEMO_SPECTATORDISCONNECT;
                        DData.gametic := gametic;
                        DData.gametime := gametime;
                        DemoStream.Write( DData, Sizeof(DData));
                        DNETSpectator.netname := TMP_SpectatorLeave(data^).netname;
                        DNETSpectator.action := false;
                        DemoStream.Write( DNETSpectator, Sizeof(DNETSpectator));
                end;

                // Spectator Disconnect
                if SpectatorList.Count > 0 then
                for i := 0 to SpectatorList.Count-1 do
                        if (TSpectator( SpectatorList.items[i]^).IP = FromIP) and
                           (TSpectator( SpectatorList.items[i]^).Port = FromPort) then begin
                                SpectatorList.Delete (i);
                                break;
                                end;
          end;
          //---------------------------------------
          MMP_KILL_CLIENT:
          begin
              if not BNET_NFK_msgfromserv(FromIP) then exit;
              if TMP_DisconnectClient(data^).ERROR = 0 then
                      ShowCriticalError('Disconnected from server','Too many spectators already.', '') else
              if TMP_DisconnectClient(data^).ERROR = 1 then
                      ShowCriticalError('Disconnected from server','Server does not allow spectators.', '');
              ApplyHCommand('disconnect'); exit;
          end;
          //---------------------------------------
          MMP_SPECTATORCONNECT:
          begin
                if (SpectatorList.count > OPT_SV_MAXSPECTATORS) or (OPT_SV_ALLOWSPECTATORS=false) then begin
                        MsgSize := SizeOf(TMP_DisconnectClient);
                        Msg12.Data := MMP_KILL_CLIENT;
                        if OPT_SV_ALLOWSPECTATORS=false then
                        Msg12.ERROR := 1 else
                        Msg12.ERROR := 0;
                        mainform.BNETSendData2IP_(FromIP,FromPort, Msg12, MsgSize, 1);
                        exit;
                end;

                addmessage(TMP_SpectatorJoin(data^).netname + ' ^7^njoined as spectator.');

                if MATCH_DRECORD then begin
                        DData.type0 := DDEMO_SPECTATORCONNECT;
                        DData.gametic := gametic;
                        DData.gametime := gametime;
                        DemoStream.Write( DData, Sizeof(DData));
                        DNETSpectator.netname := TMP_SpectatorJoin(data^).netname;
                        DNETSpectator.action := true;
                        DemoStream.Write( DNETSpectator, Sizeof(DNETSpectator));
                end;


                // answer for register. Send ALL playerz info.
                MsgSize := SizeOf(TMP_CreatePlayer);
                Msg.Data := MMP_CREATEPLAYER;

                for i := 0 to 7 do if players[i] <> nil then begin
//                        if (fromip <> Msg.ipaddress_) and (players[i].dxid
                        Msg.x := round(players[i].x);
                        Msg.y := round(players[i].y);
                        Msg.DXID := players[i].dxid;
                        if (players[i].idd = 0) then
                        Msg.ipaddress_ := '0.0.0.0' else // let clients detect this automatically.
                        Msg.ipaddress_ := players[i].IPAddress;
                        Msg.ClientId := 0;
                        Msg.netname := players[i].netname;
                        Msg.nfkmodel := players[i].nfkmodel;
                        Msg.Team := players[i].team;
                        mainform.BNETSendData2IP_ (FromIp, FromPort, Msg, MsgSize, 1);
                end;


                // send itemz data. =)
                for i := 0 to BRICK_X-1 do for a := 0 to BRICK_Y-1 do
                if bbb[i,a].image > 0 then if bbb[i,a].respawnable then if bbb[i,a].respawntime = 0 then begin
                        MsgSize := SizeOf(TMP_ItemAppear);
                        Msg2.DATA := MMP_ITEMAPPEAR;
                        Msg2.x := i; Msg2.y := a;
                        mainform.BNETSendData2IP_ (FromIP, FromPort, Msg2, MsgSize, 1);
                end;

                g_Network_droppableObjects(FromIP, FromPort);

                // send ctf states.
                if MATCH_GAMETYPE = GAMETYPE_CTF then
                        CTF_SVNETWORK_FirstGameState(FromIP, FromPort);


                msgsize := 0;

                if SpectatorList.count > 0 then
                for i := 0 to SpectatorList.count-1 do
                if (TSpectator(SpectatorList.items[i]^).IP = FromIp) and
                   (TSpectator(SpectatorList.items[i]^).Port = FromPort) then begin
                                TSpectator(SpectatorList.items[i]^).Netname := TMP_SpectatorJoin(data^).netname;
                                msgsize := 1;
                                break;
                        end;

                if msgsize = 0 then begin
                        new(spect);
                        spect^.Netname := TMP_SpectatorJoin(data^).netname;
                        spect^.IP := FromIp;
                        spect^.Port := FromPort;
                        spect^.TimedOut := Gettickcount + SPECTATOR_TIMEDOUT;
                        SpectatorList.add(spect);
                end;
          end;
          //---------------------------------------
          MMP_REGISTERPLAYER://demo done
          begin
  //            addmessagE('RECV: MMP_REGISTERPLAYER: '+fromip);
                if TMP_RegisterPlayer(Data^).SIGNNATURE <> NFK_SIGNNATURE then exit;

                // popup alttabbed server if somebody join...
                if ismultip=1 then begin
                        DXTimer.MayProcess := true;
                        Application.BringToFront;
                        AppActivate_(pchar('Need For Kill'));
                end;

                if ismultip=1 then begin        // host
                        pl := TPlayer.create;
                        pl.objname := 'player';
                        pl.netname := TMP_RegisterPlayer(Data^).netname;
                        pl.nfkmodel := TMP_RegisterPlayer(Data^).nfkmodel;
                        pl.dead := 0;
                        pl.frame := 0;
                        pl.health := 125;
                        pl.control := 0;   // no control
                        pl.clippixel := 0;
                        pl.x := 320;
                        pl.y := 240;
                        pl.idd := $FF;
                        pl.IPAddress := FromIP;
                        pl.Port := FromPort;
                        pl.DXID := AssignUniqueDXID($FFFF);
                        pl.netupdated := true;
                        pl.netnosignal := 0;
                        pl.netobject := true; // neT 0bject n0 @pply m0ve 0r phyz1x t0 th1z pr@yer.
//                        if OPT_ENEMYMODEL<>'' then pl.nfkmodel:=OPT_ENEMYMODEL;

                        pl.team := 2; // none

                        // sv_team auto selection
                        if TeamGame then if MATCH_STARTSIN = 0 then begin
                                if GetRedPlayers > GetBluePlayers then pl.team := 0 else
                                if GetRedPlayers < GetBluePlayers then pl.team := 1 else
                                pl.team := random(2);
                        end;

                        addplayer(pl);
                        resetplayer(pl);
                        ASSIGNMODEL(pl);
                        findrespawnpoint(pl,false);
                        playsound(SND_respawn,pl.x,pl.y);

                        pl.TESTPREDICT_X := pl.x;
                        pl.TESTPREDICT_Y := pl.y;
                        pl.frags := 0;
                        if not SV_Remember_Score_Retrieve(pl.netname, pl.nfkmodel, pl.frags) then pl.frags := 0;

                        if MATCH_DRECORD then begin
                                DData.gametic := gametic;
                                DData.gametime := gametime;
                                DData.type0 := DDEMO_CREATEPLAYERV2;
                                DemoStream.Write(DData, Sizeof(DData));
                                DSpawnPlayerV2.x := round(pl.x);
                                DSpawnPlayerV2.y := round(pl.y);
                                DSpawnPlayerV2.dir := pl.dir;
                                DSpawnPlayerV2.team := pl.team;
                                DSpawnPlayerV2.dead := 0;
                                DSpawnPlayerV2.DXID := pl.DXID;
                                DSpawnPlayerV2.modelname := pl.nfkmodel;
                                DSpawnPlayerV2.netname := pl.netname;
                                DSpawnPlayerV2.reserved := 0;
                                DemoStream.Write(DSpawnPlayerV2, Sizeof(DSpawnPlayerV2));
                        end;
                        addmessage(pl.netname+' ^7^njoin the game');

                // answer for register. Send ALL playerz info.
                MsgSize := SizeOf(TMP_CreatePlayer);
                Msg.Data := MMP_CREATEPLAYER;

                for i := 0 to 7 do if players[i] <> nil then begin
//                        if (fromip <> Msg.ipaddress_) and (players[i].dxid
                        Msg.x := round(players[i].x);
                        Msg.y := round(players[i].y);
                        Msg.DXID := players[i].dxid;
                        if (players[i].idd = 0) then
                        Msg.ipaddress_ := '0.0.0.0' else // let clients detect this automatically.
                        Msg.ipaddress_ := players[i].IPAddress;
                        Msg.ClientId := 0;
                        if pl.DXID = players[i].DXID then Msg.CLIENTID := TMP_RegisterPlayer(data^).ClientId;
                        Msg.netname := players[i].netname;
                        Msg.nfkmodel := players[i].nfkmodel;
                        Msg.Team := players[i].team;
                        mainform.BNETSendData2All (Msg, MsgSize, 1);
                end;


                // send itemz data. =)
                for i := 0 to BRICK_X-1 do for a := 0 to BRICK_Y-1 do
                if bbb[i,a].image > 0 then if bbb[i,a].respawnable then if bbb[i,a].respawntime = 0 then begin
                        MsgSize := SizeOf(TMP_ItemAppear);
                        Msg2.DATA := MMP_ITEMAPPEAR;
                        Msg2.x := i; Msg2.y := a;
                        mainform.BNETSendData2IP_ (FromIP, FromPort, Msg2, MsgSize, 1);
                end;

                g_Network_droppableObjects(FromIP, FromPort);

                // send ctf states.
                if MATCH_GAMETYPE = GAMETYPE_CTF then
                        CTF_SVNETWORK_FirstGameState(FromIP, FromPort);

                NFKPLANET_UpdateCurrentUsers (GetNumberOfPlayers);
            end;
        end;
        //---------------------------------------
        MMP_CREATEPLAYER: //demo done.
        begin
                if not BNET_NFK_msgfromserv(FromIP) then exit;
                if ismultip <> 2 then exit;

                // uh.. protect double players...
                for i := 0 to 7 do if players[i] <> nil then if players[i].DXID = TMP_CreatePlayer(Data^).DXID then exit; // already.
                if (FindPlayerByIP(TMP_CreatePlayer(Data^).ipaddress_)) then exit;

                pl := TPlayer.create;
                pl.objname   := 'player';
                pl.netname   := TMP_CreatePlayer(Data^).netname;
                pl.nfkmodel  := TMP_CreatePlayer(Data^).nfkmodel;
                pl.IPAddress := TMP_CreatePlayer(Data^).ipaddress_;
                if pl.IPAddress = '0.0.0.0' then pl.IPAddress := FromIP;
                pl.dead := 0;
                pl.health := 125;
                pl.armor := 0;
                pl.frame := 0;
                pl.control := 0;   // no control
                pl.idd := $FF; // none;
                pl.clippixel := 0;
                pl.DXID := TMP_CreatePlayer(Data^).DXID;
                pl.netobject := true;
                pl.netupdated := false;
                pl.netnosignal := 0;
                pl.team := TMP_CreatePlayer(Data^).Team;

                SPAWNX := TMP_CreatePlayer(Data^).X div 32;
                SPAWNY := TMP_CreatePlayer(Data^).y div 16;

                if TMP_CreatePlayer(Data^).ClientId = CLIENTID then begin
                        pl.NETUpdateD := true;
                        pl.netnosignal := 0;
                        pl.idd := 0;
                        pl.clippixel := 0;
                        setcrosshairpos(pl, trunc(pl.x),trunc(pl.y), pl.clippixel,true);

                        for i := 0 to 7 do if players[i] = nil then begin // IT IS LOCAL PLAYER
                                pl.nfkmodel := OPT_NFKMODEL1;
                                OPT_1BARTRAX := i; break;
                        end;

                        pl.netobject := false;
                        pl.control := 1;   // mouse control

                        if TeamGame then if pl.team < 2 then SYS_TEAMSELECT := 0;

                        end else
                if gametime<1 then
                addmessage(pl.netname+' ^7^nalready in the game.') else
                addmessage(pl.netname+' ^7^nconnected');
                addplayer(pl);
                resetplayer(pl);
                findrespawnpoint(pl,true);
                pl.x := TMP_CreatePlayer(Data^).X;
                pl.y := TMP_CreatePlayer(Data^).y;
                pl.TESTPREDICT_X := pl.x;
                pl.TESTPREDICT_Y := pl.y;
                if pl.x >= 320 then pl.dir := 2 else pl.dir := 3;
                if BRICK_X > 20 then if pl.x >= BRICK_X*16 then pl.dir := 2 else pl.dir := 3;


                if MATCH_DRECORD then begin
                        DData.gametic := gametic;
                        DData.gametime := gametime;
                        DData.type0 := DDEMO_CREATEPLAYERV2;
                        DemoStream.Write(DData, Sizeof(DData));
                        DSpawnPlayerV2.x := round(pl.x);
                        DSpawnPlayerV2.y := round(pl.y);
                        DSpawnPlayerV2.dir := pl.dir;
                        DSpawnPlayerV2.team := pl.team;
                        DSpawnPlayerV2.dead := 0;
                        DSpawnPlayerV2.DXID := pl.DXID;
                        DSpawnPlayerV2.modelname := pl.nfkmodel;
                        DSpawnPlayerV2.netname := pl.netname;
                        DSpawnPlayerV2.reserved := 0;
                        DemoStream.Write(DSpawnPlayerV2, Sizeof(DSpawnPlayerV2));
                end;

                NormalAngle(pl);
                ASSIGNMODEL(pl);
                MP_WAITSNAPSHOT := false;
        end;

        //---------------------------------------
        // Filter Incoming traffic.
        //---------------------------------------
        MMP_STARTVOTE:
        begin
                if ismultip=1 then if not VOTE_SV_ValidVote(FromIP, FromPort, TMP_StartVote(Data^).VoteText) then exit;
                if ismultip=1 then begin
                        CopyMemory(@buf, data,sizeof(TMP_StartVote));
                        mainform.BNETSendData2All (buf,sizeof(TMP_StartVote),0);
                end;

                for i := 0 to 7 do if players[i] <> nil then if players[i].dxid = TMP_StartVote(Data^).DXID then
                        addmessage(players[i].netname+' ^7^ncalled a ^5VOTE^7: ^5'+TMP_StartVote(Data^).VoteText);

                if ismultip=2 then SVVOTE.voted := false;
                VOTE_SV_Start_ClientVote(TMP_StartVote(Data^).DXID, TMP_StartVote(Data^).VoteText);
        end;
        //---------------------------------------
        MMP_VOTERESULT:
        begin
                case TMP_VoteResult(Data^).Result of
                1:addmessage('^7Your ^5VOTE ^7was not accepted by server.');
                2:addmessage('^5VOTE ^7cancelled...');
                3:addmessage('^5VOTE ^7Passed (^5'+SVVOTE.voteString+'^7)');
                end;
                VOTE_ClearVote;
                exit;
        end;
        //---------------------------------------
        MMP_VOTE:
        begin
                if ismultip=1 then begin
                        CopyMemory(@buf, data,sizeof(TMP_Vote));
                        mainform.BNETSend_SV_Data2All_Except(FromIP, buf,sizeof(TMP_Vote),0);
                end;

                for i := 0 to 7 do if players[i] <> nil then if players[i].dxid = TMP_Vote(Data^).DXID then begin
                        if ismultip=1 then players[i].Vote := TMP_Vote(Data^).VOTE;
                        if TMP_Vote(Data^).VOTE=1 then addmessage(players[i].netname + ' ^7^nvoted ^5YES');
                        if TMP_Vote(Data^).VOTE=2 then addmessage(players[i].netname + ' ^7^nvoted ^5NO');
                        break;
                end;
        end;
        //---------------------------------------
          MMP_EARNREWARD:
          begin
                for i := 0 to 7 do if players[i] <> nil then if players[i].dxid = TMP_EarnReward(Data^).DXID then begin
                                if MATCH_DRECORD then begin              // record to demo !!!!!
                                        DData.type0 := DDEMO_EARNREWARD;               //
                                        DData.gametic := gametic;
                                        DData.gametime := gametime;
                                        DemoStream.Write( DData, Sizeof(DData));
                                        DEarnReward.DXID := TMP_EarnReward(Data^).DXID;
                                        DEarnReward.type1 := TMP_EarnReward(Data^).type0;
                                        DemoStream.Write( DEarnReward, Sizeof(DEarnReward));
                                end;

                                players[i].rewardtype := TMP_EarnReward(Data^).type0;
                                if players[i].rewardtime <= 170 then case TMP_EarnReward(Data^).type0 of
                                1 : playsound(SND_impressive,players[i].x,players[i].y);      // no double sound.
                                2 : playsound(SND_excellent,players[i].x,players[i].y);
                                3 : playsound(SND_humiliation,players[i].x,players[i].y);
                                end;
                                players[i].rewardtime := 200;
                                break;
                        end;
          end;
        //---------------------------------------
        MMP_YOUAREREALYKILLED:
        begin
//              addmessagE('^1MMP_YOUAREREALYKILLED');
                if ismultip<>2 then exit;
                for i := 0 to 7 do if (players[i] <> nil) and (players[i].netobject = false) and (players[i].DXID = TMP_IamRespawn(Data^).DXID) then begin
                        if players[i].justrespawned2>0 then exit;
                        if players[i].health <= 0 then exit;
                        players[i].health := -1;
                        IF OPT_CORPSETIME > 0 then SpawnCorpse(players[i]);
                        exit;
                end;
        end;
        //---------------------------------------
        MMP_PLAYERPOSUPDATE://demodone.
        begin
                if (ismultip=1) and (BNETWORK_Players_collective < 2) then begin
                        CopyMemory(@buf, data,sizeof(TMP_PlayerPosUpdate));
                        mainform.BNETSend_SV_Data2All_Except (FromIP,buf,sizeof(TMP_PlayerPosUpdate),0);
                end;
                BNETWORK_Approve_MMP_PLAYERPOSUPDATE(data);
        end;
        //---------------------------------------
        MMP_PLAYERPOSUPDATE_COPY://demodone.
        begin
                // SV_CONTROL.
                if (ismultip=1) and (BNETWORK_Players_collective < 2) then begin
                        CopyMemory(@buf, data,sizeof(TMP_PlayerPosUpdate_copy));
                        mainform.BNETSend_SV_Data2All_Except (FromIP,buf,sizeof(TMP_PlayerPosUpdate_copy),0);
                end;
                BNETWORK_Approve_MMP_PLAYERPOSUPDATE_COPY(data);
        end;
        //---------------------------------------
        MMP_PLAYERPOSUPDATE_PACKED:
        begin
                BNETWORK_CL_ParsePacked(Data);
        end;
        //---------------------------------------
        MMP_RCON_MESSAGE:
        begin
                inc(integer(data),1);
                a := ReadByte(Data);
                str := ReadString(Data);
                RCON_Recv(a,str,fromip,fromport);
        end;
        //---------------------------------------
        MMP_RCON_ANSWER:
        begin
                inc(integer(data),2);
                AddMessage ('^3RCON: ^7'+ReadString(Data));
        end;
        //---------------------------------------
        MMP_CHATMESSAGE: //demo done
        begin
                if inmenu then exit;

                s := '';
                p := data;
                ReadByte(Data); // id
                a := ReadWord(Data); // dxid
                str := ReadString(Data);

                if ismultip=1 then begin
                        CopyMemory(@buf, p,4+length(str));
                        mainform.BNETSend_SV_Data2All_Except(FromIP, buf,4+length(str),0);
                end;

                playsound(SND_talk,0,0);

                if a = 0 then begin // dedicated message
                        addmessage('^%Dedicated^7: ^5'+ str);

                        if MATCH_DRECORD then begin
                                DData.type0 := DDEMO_CHATMESSAGE;
                                DData.gametic := gametic;
                                DData.gametime := gametime;
                                DemoStream.Write( DData, Sizeof(DData));
                                DNETCHATMessage.DXID := 0;
                                DNETCHATMessage.messagelenght := length(str);
                                DemoStream.Write( DNETCHATMessage, Sizeof(DNETCHATMessage));
                                StrLCopy(Buf, pchar(str), length(str));
                                DemoStream.Write(buf, length(str));
                        end;

                        exit;
                end;

                    for i := 0 to 7 do if (players[i] <> nil) then if players[i].DXID = a then begin
                            players[i].netupdated := true;
                            players[i].netnosignal := 0;
                            addmessage(players[i].netname+'^7^n: ^5'+str);
                            if BD_Avail then
                                DLL_ChatReceived(players[i].dxid, str);

                            if MATCH_DRECORD then begin
                                DData.type0 := DDEMO_CHATMESSAGE;
                                DData.gametic := gametic;
                                DData.gametime := gametime;
                                DemoStream.Write( DData, Sizeof(DData));
                                DNETCHATMessage.DXID := players[i].DXID;
                                DNETCHATMessage.messagelenght := length(str);
                                DemoStream.Write( DNETCHATMessage, Sizeof(DNETCHATMessage));
                                StrLCopy(Buf, pchar(str), length(str));
                                DemoStream.Write(buf, length(str));
                            end;

                            break;
                    end;
        end;
        //---------------------------------------
        MMP_CHATTEAMMESSAGE: //demo done
        begin
                if inmenu then exit;
                s := '';

                p := data;
                ReadByte(Data); // id
                a := ReadWord(Data); // dxid
                str := ReadString(Data);

                if ismultip=1 then begin
                        CopyMemory(@buf, p,4+length(str));
                        mainform.BNETSend_SV_Data2All_Except (FromIP,buf,4+length(str),0);
                end;

                    for i := 0 to 7 do if (players[i] <> nil) then if players[i].DXID = a then begin
                        if players[i].team <> MyTeamIs then exit;
                            players[i].netupdated := true;
                            players[i].netnosignal := 0;
                            if players[i].location = '' then addmessage(players[i].netname+'^7^n: ^5'+str) else
                            addmessage(players[i].netname+'^7^n ('+players[i].location+'^7^n): ^5'+str);
                            if BD_Avail then
                                    DLL_ChatReceived(players[i].dxid, str);

                            playsound(SND_talk,0,0);

                            if MATCH_DRECORD then begin
                                DData.type0 := DDEMO_CHATMESSAGE;
                                DData.gametic := gametic;
                                DData.gametime := gametime;
                                DemoStream.Write( DData, Sizeof(DData));
                                DNETCHATMessage.DXID := players[i].DXID;
                                DNETCHATMessage.messagelenght := length(str);
                                DemoStream.Write( DNETCHATMessage, Sizeof(DNETCHATMessage));
                                StrLCopy(Buf, pchar(str), length(str));
                                DemoStream.Write(buf, length(str));
                            end;
                            break;
                            end;
        end;
        //---------------------------------------
        MMP_ITEMAPPEAR://demodone
        begin
            if inmenu then exit;
            bbb[TMP_ItemAppear(data^).x,TMP_ItemAppear(data^).y].respawntime := 0;        // add item;
            if OPT_R_ALPHAITEMSRESPAWN then
            bbb[TMP_ItemAppear(data^).x,TMP_ItemAppear(data^).y].scale := 0
            else bbb[TMP_ItemAppear(data^).x,TMP_ItemAppear(data^).y].scale := $FF;

            if MATCH_DRECORD then begin
                DData.type0 := DDEMO_ITEMAPEAR;
                DData.gametic := gametic;
                DData.gametime := gametime;
                DItemDissapear.x := TMP_ItemAppear(data^).x;
                DItemDissapear.y := TMP_ItemAppear(data^).y;
                DItemDissapear.i := bbb[TMP_ItemAppear(data^).x,TMP_ItemAppear(data^).y].image;
                DemoStream.Write(DData, Sizeof(DData));
                DemoStream.Write(DItemDissapear, Sizeof(DItemDissapear));
            end;

        end;
        //---------------------------------------
        MMP_ITEMDISAPPEAR://demodone
        begin
                 if inmenu then exit;
                 Item_Dissapear(TMP_ItemDisappear(data^).x,TMP_ItemDisappear(data^).y,TMP_ItemDisappear(data^).index,nil);
                 bbb[TMP_ItemDisappear(data^).x,TMP_ItemDisappear(data^).y].respawntime := 2;        // remove item;

                  for i := 0 to 7 do if (players[i] <> nil) then if (players[i].DXID = TMP_ItemDisappear(Data^).DXID) then begin
                        case bbb[TMP_ItemDisappear(data^).x,TMP_ItemDisappear(data^).y].image of
                        23: players[i].item_regen := 31;
                        24: players[i].item_battle := 31;
                        25: players[i].item_haste := 31;
                        26: players[i].item_quad := 31;
                        27: players[i].item_flight := 31;
                        28: players[i].item_invis := 31;
                        end;

                        // record to demo. powerup.
                        if MATCH_DRECORD then
                        if (bbb[TMP_ItemDisappear(data^).x,TMP_ItemDisappear(data^).y].image >= 23) and (bbb[TMP_ItemDisappear(data^).x,TMP_ItemDisappear(data^).y].image <= 28) then begin
                                DData.type0 := DDEMO_EARNPOWERUP;
                                DData.gametic := gametic;
                                DData.gametime := gametime;
                                DemoStream.Write( DData, Sizeof(DData));
                                DEarnPowerup.DXID := players[i].dxid;
                                case bbb[TMP_ItemDisappear(data^).x,TMP_ItemDisappear(data^).y].image of
                                23: DEarnPowerup.type1 := 1;
                                24: DEarnPowerup.type1 := 3;
                                25: DEarnPowerup.type1 := 4;
                                26: DEarnPowerup.type1 := 5;
                                27: DEarnPowerup.type1 := 2;
                                28: DEarnPowerup.type1 := 6;
                                end;
                                DEarnPowerup.time := 31;
                                DemoStream.Write( DEarnPowerup, Sizeof(DEarnPowerup));
                        end;

                        break;
                  end;

                  for i := 0 to 7 do if (players[i] <> nil) then if (players[i].DXID = TMP_ItemDisappear(Data^).DXID) and (players[i].netobject = false) then begin
                        if players[i].idd = 0 then p1flashbar := 1;


                        if players[i].health > 0 then
                        case bbb[TMP_ItemDisappear(data^).x,TMP_ItemDisappear(data^).y].image of // predict medkits and armor.
                                16: begin // shard
                                if players[i].armor < 200 then
                                if players[i].armor+5 < 200 then
                                players[i].armor := players[i].armor + 5 else players[i].armor := 200;
                                end;

                                17: begin // YA
                                if players[i].armor < 200 then
                                if players[i].armor+50 < 200 then
                                players[i].armor := players[i].armor + 50 else players[i].armor := 200;
                                end;

                                18: begin // RA
                                if players[i].armor < 200 then
                                if players[i].armor+100 < 200 then
                                players[i].armor := players[i].armor + 100 else players[i].armor := 200;
                                end;

                                19: begin // hp+5
                                if players[i].health < 200 then
                                if players[i].health+5 < 200 then
                                players[i].health := players[i].health + 5 else players[i].health := 200;
                                end;

                                20: begin // hp+25
                                if players[i].health < 100 then begin
                                        players[i].health := players[i].health + 25;
                                        if players[i].health > 100 then players[i].health := 100;
                                        end;
                                end;

                                21: begin // hp+25
                                if players[i].health < 100 then begin
                                        players[i].health := players[i].health + 50;
                                        if players[i].health > 100 then players[i].health := 100;
                                        end;
                                end;

                                22: begin // hp+100
                                if players[i].health < 200 then
                                if players[i].health+100 < 200 then
                                players[i].health := players[i].health + 100 else players[i].health := 200;
                                end;
                        end;


                    case bbb[TMP_ItemDisappear(data^).x,TMP_ItemDisappear(data^).y].image of
//                      give item;

                        1 : begin  if players[i].ammo_sg >= 10 then begin if players[i].have_sg = true then AddAmmo(players[i], 2, 1)end else
                                players[i].ammo_sg := 10;
                                if not players[i].have_sg then if players[i].netobject = false then DoWeapBar(i); // new weapon.. notice that
                                players[i].have_sg := true; end;

                        2 : begin if players[i].ammo_gl >= 10 then begin if players[i].have_gl = true then AddAmmo(players[i], 3, 1)end else
                                players[i].ammo_gl := 10;
                                if not players[i].have_gl then if players[i].netobject = false then DoWeapBar(i); // new weapon.. notice that
                                players[i].have_gl := true; end;
                        3 : begin
                                if players[i].ammo_rl >= 10 then begin if players[i].have_rl = true then AddAmmo(players[i], 4, 1)end else
                                players[i].ammo_rl := 10;
                                if not players[i].have_rl then if players[i].netobject = false then DoWeapBar(i); // new weapon.. notice that
                                players[i].have_rl := true; end;
                        4 : begin
                                if players[i].ammo_sh >= 130 then begin if players[i].have_sh = true then AddAmmo(players[i], 5, 1)end else
                                players[i].ammo_sh := 130;
                                if not players[i].have_sh then if players[i].netobject = false then DoWeapBar(i); // new weapon.. notice that
                                players[i].have_sh := true; end;
                        5 : begin

                                if players[i].ammo_rg >= 10 then begin if players[i].have_rg = true then AddAmmo(players[i], 6, 1)end else
                                players[i].ammo_rg := 10;
                                if not players[i].have_rg then if players[i].netobject = false then DoWeapBar(i); // new weapon.. notice that
                                players[i].have_rg := true; end;

                        6 : begin
                                if players[i].ammo_pl >= 50 then begin if players[i].have_pl = true then AddAmmo(players[i], 7, 1)end else
                                players[i].ammo_pl := 50;
                                if not players[i].have_pl then if players[i].netobject = false then DoWeapBar(i); // new weapon.. notice that
                                players[i].have_pl := true; end;
                        7 : begin
                                if players[i].ammo_bfg >= 15 then begin if players[i].have_bfg = true then AddAmmo(players[i], 8, 1)end else
                                players[i].ammo_bfg := 15;
                                if not players[i].have_bfg then if players[i].netobject = false then DoWeapBar(i); // new weapon.. notice that
                                players[i].have_bfg := true; end;
                        8 : if players[i].ammo_mg < 200 then AddAmmo(players[i], 1, 50);  // ammo_machine
                        9 : if players[i].ammo_sg < 100 then AddAmmo(players[i], 2, 10);  // ammo_shotgun
                        10 : if players[i].ammo_gl < 100 then AddAmmo(players[i], 3, 5);  // ammo_grenade
                        11 : if players[i].ammo_rl < 100 then AddAmmo(players[i], 4, 5);  // ammo_rocket
                        12 : if players[i].ammo_sh < 200 then AddAmmo(players[i], 5, 70); // ammo_shaft
                        13 : if players[i].ammo_rg < 100 then AddAmmo(players[i], 6, 5);  // ammo_rail
                        14 : if players[i].ammo_pl < 200 then AddAmmo(players[i], 7, 30); // ammo_plasma
                        15 : if players[i].ammo_bfg < 50 then AddAmmo(players[i], 8, 10); // ammo_bfg
                    end;

                        break;
                  end;
        end;
        //---------------------------------------
        MMP_HAUPDATE:
        begin
                if inmenu then exit;
                for i := 0 to 7 do if (players[i] <> nil) and (players[i].netobject = true) and (players[i].DXID = TMP_HAUpdate(Data^).DXID) then begin
                        players[i].frags := TMP_HAUpdate(Data^).frags;
                        players[i].health := TMP_HAUpdate(Data^).health;
                        players[i].AMMO_mg := TMP_HAUpdate(Data^).ammo;
                        players[i].AMMO_sg := TMP_HAUpdate(Data^).ammo;
                        players[i].AMMO_gl := TMP_HAUpdate(Data^).ammo;
                        players[i].AMMO_rl := TMP_HAUpdate(Data^).ammo;
                        players[i].AMMO_sh := TMP_HAUpdate(Data^).ammo;
                        players[i].AMMO_rg := TMP_HAUpdate(Data^).ammo;
                        players[i].AMMO_pl := TMP_HAUpdate(Data^).ammo;
                        players[i].AMMO_bfg := TMP_HAUpdate(Data^).ammo;
                        players[i].armor := TMP_HAUpdate(Data^).armor;
                        break;
                end;

                for i := 0 to 7 do if (players[i] <> nil) and (players[i].netobject = false) and (players[i].DXID = TMP_HAUpdate(Data^).DXID) then begin
                        players[i].frags := TMP_HAUpdate(Data^).frags;
                        if TMP_HAUpdate(Data^).health > 0 then begin
                                players[i].health := TMP_HAUpdate(Data^).health;
                                players[i].armor := TMP_HAUpdate(Data^).armor;
                                break;
                        end;
                end;
        end;
        //---------------------------------------
        MMP_DAMAGEPLAYER:   // DEMODONE
        begin
                if inmenu then exit;
                if ismultip=2 then begin
                        for i := 0 to 7 do if players[i] <> nil then if players[i].DXID = TMP_DamagePlayer(Data^).DXID then begin
                                players[i].health := TMP_DamagePlayer(Data^).health;
                                players[i].armor := TMP_DamagePlayer(Data^).armor;
                                PAINSOUNDZZ(players[i]);

                                if MATCH_DRECORD then begin              // record to demo !!!!!
                                        DData.type0 := DDEMO_DAMAGEPLAYER;               //
                                        DData.gametic := gametic;
                                        DData.gametime := gametime;
                                        DemoStream.Write( DData, Sizeof(DData));
                                        DDamagePlayer.DXID := players[i].DXID;
                                        DDamagePlayer.ext := 0;
                                        DDamagePlayer.health := players[i].health;
                                        DDamagePlayer.armor := players[i].armor;
                                        DDamagePlayer.ext := TMP_DamagePlayer(Data^).exp;
                                        DDamagePlayer.ATTDXID := TMP_DamagePlayer(Data^).AttackerDXID;
                                        DDamagePlayer.attwpn := TMP_DamagePlayer(Data^).dmgtype;
                                        DemoStream.Write( DDamagePlayer, Sizeof(DDamagePlayer));
                                end;


                                if (OPT_HITSND = true) and (TMP_DamagePlayer(Data^).exp = 0) then
                                if TMP_DamagePlayer(Data^).AttackerDXID = players[OPT_1BARTRAX].DXID then
                                if players[OPT_1BARTRAX].hitsnd = 0 then begin playsound(SND_hit,players[OPT_1BARTRAX].x,players[OPT_1BARTRAX].y); players[OPT_1BARTRAX].hitsnd := 5; end;

//                                DSADSADLASHJJLDSGJHDASJKHGDKL:ASHLDKGJ

                                if players[i].item_battle > 0 then
                                if players[i].item_battle_time = 0 then begin
                                        playsound(SND_protect3,players[i].x,players[i].y);
                                        players[i].item_battle_time := 50;
                                end;

                                if TMP_DamagePlayer(Data^).exp = 0 then
                                case TMP_DamagePlayer(Data^).dmgtype of
                                0 : begin
                                        playsound(SND_gauntl_a,players[i].x,players[i].y);
                                        SpawnBlood (players[i]);
                                        SpawnBlood (players[i]);
                                        SpawnBlood (players[i]);
                                        SpawnBlood (players[i]);
                                end;
                                6 : begin
                                        SpawnBlood (players[i]);
                                        SpawnBlood (players[i]);
                                        SpawnBlood (players[i]);
                                        SpawnBlood (players[i]);
                                end;
                                2 : begin
                                        SpawnBlood (players[i]);
                                        SpawnBlood (players[i]);
                                        SpawnBlood (players[i]);
                                        SpawnBlood (players[i]);
                                end;
                                3,4 : begin
                                        SpawnBlood (players[i]);
                                        SpawnBlood (players[i]);
                                        SpawnBlood (players[i]);
                                        end;
                                1,5,7 : begin SpawnBlood (players[i]); end;
                                end;

                                // suicides events.
                                if  TMP_DamagePlayer(Data^).exp = 0 then
                                case TMP_DamagePlayer(Data^).exp of
                                DIE_LAVA : begin playsound(SND_lava,players[i].x,players[i].y);SpawnBlood (players[i]);end;
                                DIE_WRONGPLACE:begin // little bloody flood :]]]
                                        SpawnBlood (players[i]);
                                        SpawnBlood (players[i]);
                                        SpawnBlood (players[i]);
                                        SpawnBlood (players[i]);
                                        SpawnBlood (players[i]);
                                        SpawnBlood (players[i]);
                                end;
                                DIE_INPAIN:SpawnBlood (players[i]);
                                DIE_WATER:begin if IsWaterContentHEAD(players[i]) then begin
                                                SpawnBubble(players[i]);
                                                SpawnBubble(players[i]);
                                                SpawnBubble(players[i]);
                                                end;
                                        end;
                                end;

                                if (TMP_DamagePlayer(Data^).exp = 0) and (TMP_DamagePlayer(Data^).dmgtype=0) then
                                for a := 0 to 7 do if players[a] <> nil then if players[a].DXID = TMP_DamagePlayer(Data^).AttackerDXID then
                                        if (players[a].item_quad > 0) and (players[a].item_quad_time = 0) then
                                        begin playsound(SND_damage3,players[a].x,players[a].y);
                                        players[a].item_quad_time := 50; break; end;



                                if players[i].health <= 0 then begin
                                        if players[i].health <= GIB_DEATH then players[i].rewardtime := 0 else begin

                                                        if MATCH_DRECORD then begin
                                                                DData.type0 := DDEMO_CORPSESPAWN;
                                                                DData.gametic := gametic;
                                                                DData.gametime := gametime;
                                                                DemoStream.Write( DData, Sizeof(DData));
                                                                DCorpseSpawn.DXID := players[i].dxid;
                                                                DemoStream.Write( DCorpseSpawn, Sizeof(DCorpseSpawn));
                                                        end;

                                                  IF OPT_CORPSETIME > 0 then SpawnCorpse(players[i]);
                                                  end;

                                        if TMP_DamagePlayer(Data^).exp>0 then begin
                                                SimpleDeathMessage(players[i],'',0,TMP_DamagePlayer(Data^).exp);
                                                exit;
                                        end;
                                        for a := 0 to 7 do if players[a] <> nil then if players[a].DXID = TMP_DamagePlayer(Data^).AttackerDXID then begin
                                                SimpleDeathMessage(players[i],players[a].netname,TMP_DamagePlayer(Data^).dmgtype,0);
                                                break;
                                        end;
                                end;

                                break;
                        end;
                end;
        end;
        //---------------------------------------
        MMP_IAMRESPAWN: //demodone
        begin

{               if ismultip=1 then
                for i := 0 to 7 do if players[i] <> nil then if players[i].DXID = TMP_IamRespawn(Data^).DXID then
                if players[i].dead = 0 then begin
                        MsgSize := SizeOf(TMP_SV_PlayerRespawn);
                        Msg5.Data := MMP_PLAYERRESPAWN;
                        Msg5.DXID := players[i].dxid;
                        Msg5.x := players[i].olspx;
                        Msg5.y := players[i].olspy;
                        mainform.BNETSendData2IP (FromIP, Msg5, MsgSize, 1);
                end;
}
                if ismultip=1 then
                for i := 0 to 7 do if players[i] <> nil then if players[i].DXID = TMP_IamRespawn(Data^).DXID then begin
//                        if players[i].dead > 0 then begin

                        for a := 0 to 1000 do if (aaa[a].dead = 0) and (aaa[a].objname = 'corpse') then
                        if aaa[a].spawner = players[i] then aaa[a].weapon := 1;

                        players[i].NETUpdateD := true;
                        players[i].netnosignal := 0;
                        players[i].justrespawned := 5;
                        players[i].justrespawned2 := 150;
                        players[i].clippixel := 0;
                        resetplayer(players[i]);

                        MsgSize := SizeOf(TMP_SV_PlayerRespawn);
                        Msg5.Data := MMP_PLAYERRESPAWN;
                        Msg5.DXID := players[i].dxid;
                        FindRespawnPoint(players[i],false);
                        Msg5.x := SPAWNX;
                        Msg5.y := SPAWNY;
                        mainform.BNETSendData2All (Msg5, MsgSize, 1);

                        players[i].olspx := SPAWNX;
                        players[i].olspy := SPAWNY;

                        players[i].x := SPAWNX*32+16;
                        players[i].y := SPAWNY*16-8;
                        players[i].TESTPREDICT_X := players[i].x;
                        players[i].TESTPREDICT_Y := players[i].y;
                        NormalAngle(Players[i]);
                        if players[i].x >= 320 then players[i].dir := 2 else players[i].dir := 3;
                        if BRICK_X > 20 then if players[i].x >= BRICK_X*16 then players[i].dir := 2 else players[i].dir := 3;

                        RespawnFlash(SPAWNX*32,SPAWNY*16);
                        playsound(SND_respawn,SPAWNX*32,SPAWNY*16);
                        break;
                end;
        end;
        //---------------------------------------
        MMP_PLAYERRESPAWN://demodone
        begin
                if inmenu then exit;
                if ismultip=2 then
                for i := 0 to 7 do if players[i] <> nil then if players[i].DXID = TMP_SV_PlayerRespawn(Data^).DXID then begin

                        for a := 0 to 1000 do if (aaa[a].dead = 0) and (aaa[a].objname = 'corpse') then
                        if aaa[a].spawner = players[i] then aaa[a].weapon := 1;

                        ResetPlayer(players[i]);
                        SPAWNX := TMP_SV_PlayerRespawn(Data^).x;
                        SPAWNY := TMP_SV_PlayerRespawn(Data^).y;
                        players[i].netupdated := true;
                        players[i].netnosignal := 0;
                        players[i].justrespawned2 := 150;
                        players[i].clippixel := 0;
                        FindRespawnPoint(players[i],true);
                        if players[i].x >= 320 then players[i].dir := 2 else players[i].dir := 3;
                        if BRICK_X > 20 then if players[i].x >= BRICK_X*16 then players[i].dir := 2 else players[i].dir := 3;

                        RespawnFlash(spawnx*32,spawny*16);
                        playsound(SND_respawn,players[i].x,players[i].y);
                        players[i].TESTPREDICT_X := players[i].x;
                        players[i].TESTPREDICT_Y := players[i].y;
                        break;
                end;
        end;
        //---------------------------------------
        MMP_049test4_SHAFT_BEGIN:
        begin
                if inmenu then exit;
                if ismultip=1 then begin
                        CopyMemory(@buf, data,sizeof(TMP_049t4_ShaftBegin));
                        mainform.BNETSendData2All(buf,sizeof(TMP_049t4_ShaftBegin),1);
                end;

//              addmessage('^5RECV MMP_049test4_SHAFT_BEGIN');
                for i := 0 to 7 do if players[i] <> nil then if players[i].DXID = TMP_049t4_ShaftBegin(Data^).DXID then begin
                        // client fires 049t4 shaft.
                        players[i].weapon := C_WPN_SHAFT;
                        players[i].have_sh := true;
                        if players[i].netobject = true then
                                players[i].ammo_sh := TMP_049t4_ShaftBegin(Data^).ammo;
                        FireShaftEx(players[i], ismultip=2);
                        players[i].shaft_state := 1;
                        break;
                end;
        end;
        //---------------------------------------
        MMP_049test4_SHAFT_END:
        begin
//                addmessage('^5RECV MMP_049test4_SHAFT_END: disabling shaft for +players[i].netname');

                if ismultip=1 then begin
                        CopyMemory(@buf, data,sizeof(TMP_049t4_ShaftEnd));
                        mainform.BNETSend_SV_Data2All_Except(FromIP,buf,sizeof(TMP_049t4_ShaftEnd),1);
                end;

                for i := 0 to 7 do if players[i] <> nil then if players[i].DXID = TMP_049t4_ShaftEnd(Data^).DXID then begin
                        players[i].shaft_state := 0;

                        if MATCH_DRECORD then begin
                                DData.type0 := DDEMO_NEW_SHAFTEND;
                                DData.gametic := gametic;
                                DData.gametime := gametime;
                                D_049t4_ShaftEnd.DXID := players[i].DXID;
                                DemoStream.Write(DData, Sizeof(DData));
                                DemoStream.Write(D_049t4_ShaftEnd, Sizeof(D_049t4_ShaftEnd));
                        end;

                        break;
                end;
        end;
        //---------------------------------------
        MMP_CLIENTSHOT:// DEMOUSELESS
        begin
                if ismultip=1 then
                for i := 0 to 7 do if players[i] <> nil then if players[i].DXID = TMP_ClientShot(Data^).DXID then
                if players[i].health > 0 then begin
                        // mach, shot, rail...

                        players[i].clippixel := TMP_ClientShot(Data^).clippixel;
                        players[i].refire := 0;

                        if TMP_ClientShot(Data^).index = 1 then begin  // mach
                                players[i].weapon := 1;
                                players[i].have_mg := true;
                                players[i].ammo_mg := TMP_ClientShot(Data^).ammo;
                                firemachine(players[i],TMP_ClientShot(Data^).x,TMP_ClientShot(Data^).y,TMP_ClientShot(Data^).fangle);
                        end else
                        if TMP_ClientShot(Data^).index = 2 then begin // shtgn
                                players[i].weapon := 2;
                                players[i].have_sg := true;
                                players[i].ammo_sg := TMP_ClientShot(Data^).ammo;
                                fireshotgun(players[i],TMP_ClientShot(Data^).x,TMP_ClientShot(Data^).y,TMP_ClientShot(Data^).fangle);
                        end else
                        if TMP_ClientShot(Data^).index = 3 then begin // gren
                                players[i].weapon := 3;
                                players[i].have_gl := true;
                                players[i].ammo_gl := TMP_ClientShot(Data^).ammo;
                                FireGren(players[i],TMP_ClientShot(Data^).x,TMP_ClientShot(Data^).y,TMP_ClientShot(Data^).fangle);
                        end else
                        if TMP_ClientShot(Data^).index = 4 then begin // RL
                                players[i].weapon := 4;
                                players[i].have_rl := true;
                                players[i].ammo_rl := TMP_ClientShot(Data^).ammo;
                                FireRocket(players[i],TMP_ClientShot(Data^).x,TMP_ClientShot(Data^).y,TMP_ClientShot(Data^).fangle);
                        end else
{                        if TMP_ClientShot(Data^).index = 5 then begin   // shaft
                                players[i].weapon := 5;
                                players[i].have_sh := true;
                                players[i].ammo_sh := TMP_ClientShot(Data^).ammo;
                                FireShaftEx(players[i]);
                        end;}
                        if TMP_ClientShot(Data^).index = 7 then begin   // plazma
                                players[i].weapon := 7;
                                players[i].have_pl := true;
                                players[i].ammo_pl := TMP_ClientShot(Data^).ammo;
                                firePlasma(players[i],TMP_ClientShot(Data^).x,TMP_ClientShot(Data^).y,TMP_ClientShot(Data^).fangle);
                        end;
                        if TMP_ClientShot(Data^).index = 8 then begin   // BFG
                                players[i].weapon := 8;
                                players[i].have_bfg := true;
                                players[i].ammo_bfg := TMP_ClientShot(Data^).ammo;
                                fireBFG(players[i],TMP_ClientShot(Data^).x,TMP_ClientShot(Data^).y,TMP_ClientShot(Data^).fangle);
                        end;
                        break;
                end;

        end;
        //---------------------------------------
        MMP_CLIENTRAILSHOT:// DEMOUSELESS
        begin
                if ismultip=1 then
                for i := 0 to 7 do if players[i] <> nil then if players[i].DXID = TMP_RailShot(Data^).DXID then
                if players[i].health > 0 then begin
                        // Rail...
                        players[i].clippixel := TMP_RailShot(Data^).clippixel;
                        players[i].refire := 0;
                        players[i].weapon := 6;
                        players[i].have_rg := true;
                        players[i].ammo_rg := TMP_RailShot(Data^).ammo;
                        firerail(players[i],TMP_RailShot(data^).color,TMP_RailShot(data^).x,TMP_RailShot(data^).y,TMP_RailShot(data^).fangle);
                        break;
                end;

        end;
        //---------------------------------------
        MMP_SHOTPARTILE:// DEMODONE
        begin
                if MATCH_DRECORD then begin
                        DData.type0 := DDEMO_NETPARTICLE;
                        DData.gametic := gametic;
                        DData.gametime := gametime;
                        DemoStream.Write( DData, Sizeof(DData));
                        DNetShotParticle.x := trunc(TMP_ShotParticle(Data^).x);
                        DNetShotParticle.y := trunc(TMP_ShotParticle(Data^).y);
                        DNetShotParticle.x1 := trunc(TMP_ShotParticle(Data^).x1);
                        DNetShotParticle.y1 := trunc(TMP_ShotParticle(Data^).y1);
                        DNetShotParticle.index := trunc(TMP_ShotParticle(Data^).index);
                        DemoStream.Write(DNetShotParticle, Sizeof(DNetShotParticle));
                end;

                if ismultip=2 then begin
                        if TMP_ShotParticle(Data^).index = 1 then begin
                          SpawnNetShots1(trunc(TMP_ShotParticle(Data^).x), trunc(TMP_ShotParticle(Data^).y));
                          playsound(SND_machine,trunc(TMP_ShotParticle(Data^).x1),trunc(TMP_ShotParticle(Data^).y1));
                        end;
                        if TMP_ShotParticle(Data^).index = 2 then begin
                          SpawnNetShots(trunc(TMP_ShotParticle(Data^).x), trunc(TMP_ShotParticle(Data^).y));
                          playsound(SND_shotgun,trunc(TMP_ShotParticle(Data^).x1),trunc(TMP_ShotParticle(Data^).y1));
                        end;
                end;

        end;
        //---------------------------------------
        MMP_RAILTRAIL:// DEMODONE
        begin
                if inmenu then exit;
                for i := 0 to 1000 do begin

                        if (aaa[i].dead=0) and (aaa[i].objname = 'rail') and (aaa[i].x=TMP_RailTrail(Data^).x) and (aaa[i].y=TMP_RailTrail(Data^).y) and (aaa[i].fallt = TMP_RailTrail(Data^).color) then exit; // this is dublicate

                        if aaa[i].dead = 2 then begin
                                aaa[i].objname := 'rail';
                                aaa[i].dude := false;
                                aaa[i].dead := 1;
                                aaa[i].topdraw := 1;
                                aaa[i].frame := 0;
                                aaa[i].DXID := 0;
                                aaa[i].x := TMP_RailTrail(Data^).x;
                                aaa[i].y := TMP_RailTrail(Data^).y;
                                aaa[i].cx := TMP_RailTrail(Data^).endx;
                                aaa[i].cy := TMP_RailTrail(Data^).endy;
                                aaa[i].fallt := TMP_RailTrail(Data^).color;
                                playsound(SND_rail,TMP_RailTrail(Data^).x1,TMP_RailTrail(Data^).y1);

                                if MATCH_DRECORD then begin
                                        DData.type0 := DDEMO_NETRAIL;               //
                                        DData.gametic := gametic;
                                        DData.gametime := gametime;
                                        DNetRail.x :=TMP_RailTrail(Data^).x;
                                        DNetRail.y := TMP_RailTrail(Data^).y;
                                        DNetRail.endx := TMP_RailTrail(Data^).endx;
                                        DNetRail.endy := TMP_RailTrail(Data^).endy;
                                        DNetRail.color := TMP_RailTrail(Data^).color;
                                        DNetRail.x1 := TMP_RailTrail(Data^).x1;//sound coordx
                                        DNetRail.y1 := TMP_RailTrail(Data^).y1;//sound coordy
                                        DemoStream.Write(DData, Sizeof(DData));
                                        DemoStream.Write(DNetRail, Sizeof(DNetRail));
                                end;
                                exit;
                        end;
                end;
        end;
        //---------------------------------------
        // (OUTDATED, NOT USED ANYMORE)
        MMP_SHAFTSTREEM: // just client side dude shaft anim. // DEMODONE
        begin
              // kill previous shaft.
               for i := 0 to 1000 do if (aaa[i].dead=0) and (aaa[i].objname='shaft') then if (aaa[i].spawner.dxid = TMP_ShaftStreem(Data^).DXID) then begin
                        aaa[i].dead := 2;
                        break;
               end;


                if ismultip=2 then
                for a := 0 to 7 do if players[a] <> nil then if players[a].DXID = TMP_ShaftStreem(Data^).DXID then
                for i := 0 to 1000 do if aaa[i].dead = 2 then begin
                        aaa[i].objname := 'shaft';
                        aaa[i].doublejump := 1;
                        aaa[i].dead  := 0;
                        aaa[i].topdraw := 1;
                        aaa[i].spawner := players[a];
                        aaa[i].frame := 0;
                        aaa[i].weapon := 1;
                        aaa[i].x := trunc(players[a].x);
                        if players[a].crouch = true then
                        aaa[i].y := trunc(players[a].y+3) else
                        aaa[i].y := trunc(players[a].y-5);
//                        aaa[i].x := TMP_ShaftStreem(data^).x;
//                        aaa[i].y := TMP_ShaftStreem(data^).y;
                        aaa[i].dxid := 0;
                        aaa[i].fallt := round(TMP_ShaftStreem(data^).lenght);
                        aaa[i].fangle := TMP_ShaftStreem(data^).angle;
                        aaa[i].dude := true;


                        if MATCH_DRECORD then begin
                                DData.type0 := 10;
                                DData.gametic := gametic;
                                DData.gametime := gametime;
                                DVectorMissile.x := 0;
                                DVectorMissile.y := 0;
                                DVectorMissile.inertiax := 0;
                                DVectorMissile.inertiay := 0;
                                DVectorMissile.DXID := 0;
                                DVectorMissile.spawnerDxid := TMP_ShaftStreem(Data^).DXID;//spawner.DXID;
                                DVectorMissile.dir := round(TMP_ShaftStreem(data^).lenght);
                                DVectorMissile.angle := TMP_ShaftStreem(data^).angle;
                                DemoStream.Write( DData, Sizeof(DData));
                                DemoStream.Write( DVectorMissile, Sizeof(DVectorMissile));
                        end;



                        // soundz
                        if  players[a].shaftsttime = 0 then begin
                                playsound(SND_lg_start, players[a].x,players[a].y);
                                players[a].shaftsttime := 2; end;

                        if (players[a].item_quad > 0) and (players[a].item_quad_time = 0) then
                        begin playsound(SND_damage3,players[a].x,players[a].y);
                              players[a].item_quad_time := 50; end;

                        if (players[a].item_quad>0) then players[a].item_quad_time := 50;

                        if players[a].netobject then begin
                                inc(players[a].shaftsttime,2);

                                inc(players[a].shaftframe);
                                if players[a].shaftframe >= 16 then players[a].shaftframe := 0; // cycle frames
                        end;


                        if players[a].shaftsttime >= 22 then begin
                                playsound(SND_lg_hum,players[a].x,players[a].y);
                                players[a].shaftsttime := 2; end;


                        exit;
                end;
                addmessage('neterror: MMP_SHAFTSTREEM: dxid owner not found');

        end;
        //---------------------------------------
        MMP_CL_ROCKETSPAWN:          // DEMODONE
        begin
                if ismultip=2 then
                for a := 0 to 7 do if players[a] <> nil then if players[a].DXID = TMP_cl_RocketSpawn(Data^).spawnerDXID then
                for i := 0 to 1000 do begin

                        if (aaa[i].dead=0) and (aaa[i].objname = 'rocket') and (aaa[i].spawner=players[a]) and (aaa[i].DXID = TMP_cl_RocketSpawn(Data^).selfDXID) then exit; // this is dublicate

                        if aaa[i].dead = 2 then begin
                                aaa[i].dead := 0;
                                aaa[i].objname := 'rocket';
                                aaa[i].frame := 0;
                                aaa[i].clippixel := 3;
                                aaa[i].spawner := players[a];
                                aaa[i].imageindex := 0;
                                aaa[i].topdraw := 1;
                                aaa[i].dude := true;
                                aaa[i].x := TMP_cl_RocketSpawn(Data^).x;
                                aaa[i].y := TMP_cl_RocketSpawn(Data^).y;
                                aaa[i].fAngle := TMP_cl_RocketSpawn(Data^).fangle;

//                              PredictNetworkRocketPos(aaa[i].x,aaa[i].y,round(aaa[i].fAngle), 6, MyPingIs);

                                aaa[i].DXID := TMP_cl_RocketSpawn(Data^).selfDXID;
                                aaa[i].doublejump :=  0;
                                aaa[i].health := 50*15;
                                if MATCH_DRECORD then begin // save on clients
                                        if TMP_cl_RocketSpawn(Data^).index =0 then
                                        DData.type0 := DDEMO_FIREROCKET else
                                        DData.type0 := DDEMO_FIREBFG;
                                        DData.gametic := gametic;
                                        DData.gametime := gametime;
                                        DMissileV2.x := TMP_cl_RocketSpawn(Data^).x;
                                        DMissileV2.y := TMP_cl_RocketSpawn(Data^).y;
                                        DMissileV2.DXID := TMP_cl_RocketSpawn(Data^).selfDXID;
                                        DMissileV2.spawnerDxid := players[a].DXID;
                                        DMissileV2.inertiax := TMP_cl_RocketSpawn(Data^).fangle;
                                        DemoStream.Write( DData, Sizeof(DData));
                                        DemoStream.Write( DMissileV2, Sizeof(DMissileV2));
                                end;


                                // RL
                                if TMP_cl_RocketSpawn(Data^).index =0 then begin
                                        aaa[i].fallt := 0;
                                        aaa[i].weapon := 0;
                                        aaa[i].fspeed := 6;

                                        // soundz
                                        playsound(SND_rocket,TMP_cl_RocketSpawn(Data^).x,TMP_cl_RocketSpawn(Data^).y);
                                        if (players[a].item_quad > 0) and (players[a].item_quad_time = 0) then begin
                                                playsound(SND_damage3,TMP_cl_RocketSpawn(Data^).x,TMP_cl_RocketSpawn(Data^).y);
                                        players[a].item_quad_time := 50; end;
                                        // & soundz
                                end else begin //BFG
                                        aaa[i].fallt := 1;
                                        aaa[i].weapon := 2;
                                        aaa[i].fspeed := 7;
                                        // soundz
                                        playsound(SND_bfg_fire,TMP_cl_RocketSpawn(Data^).x,TMP_cl_RocketSpawn(Data^).y);
                                        if (players[a].item_quad > 0) and (players[a].item_quad_time = 0) then begin
                                                playsound(SND_damage3,TMP_cl_RocketSpawn(Data^).x,TMP_cl_RocketSpawn(Data^).y);
                                                players[a].item_quad_time := 50; end;
                                        // & soundz
                                end;
                        exit;
                        end;

                end;//for i := 0 to 1000 do begin

        end;
        //---------------------------------------
        MMP_CL_PLAZMASPAWN:    // DEMODONE
        begin
                if ismultip=2 then
                for a := 0 to 7 do if players[a] <> nil then if players[a].DXID = TMP_cl_PlasmaSpawn(Data^).spawnerDXID then
                for i := 0 to 1000 do begin

                        if (aaa[i].dead=0) and (aaa[i].objname = 'plasma') and (aaa[i].spawner=players[a]) and (aaa[i].DXID = TMP_cl_PlasmaSpawn(Data^).selfDXID) then exit; // this is dublicate

                        if aaa[i].dead = 2 then begin
                                aaa[i].dead  := 0;
                                aaa[i].imageindex := 2;
                                aaa[i].objname := 'plasma';
                                aaa[i].frame := 0;
                                aaa[i].topdraw := 1;
                                aaa[i].clippixel := 4;
                                aaa[i].doublejump := 0;
                                aaa[i].spawner := players[a];
                                aaa[i].dude := true;
                                aaa[i].x := TMP_cl_PlasmaSpawn(Data^).x;
                                aaa[i].y := TMP_cl_PlasmaSpawn(Data^).y;
                                aaa[i].fAngle := TMP_cl_PlasmaSpawn(Data^).fangle;
                                aaa[i].DXID := TMP_cl_PlasmaSpawn(Data^).selfDXID;
                                aaa[i].doublejump :=  0;
                                aaa[i].health := 50*15;

                                if MATCH_DRECORD then begin
                                        DData.type0 := DDEMO_FIREPLASMAV2;
                                        DData.gametic := gametic;
                                        DData.gametime := gametime;
                                        DMissileV2.x := TMP_cl_PlasmaSpawn(Data^).x;
                                        DMissileV2.y := TMP_cl_PlasmaSpawn(Data^).y;
                                        DMissileV2.DXID := TMP_cl_PlasmaSpawn(Data^).selfDXID;
                                        DMissileV2.spawnerDxid := TMP_cl_PlasmaSpawn(Data^).spawnerDXID;
                                        DMissileV2.inertiax :=  TMP_cl_PlasmaSpawn(Data^).fangle;
                                        DemoStream.Write( DData, Sizeof(DData));
                                        DemoStream.Write( DMissileV2, Sizeof(DMissileV2));
                                end;


                                if (players[a].item_haste > 0) then aaa[i].fspeed := 9 else aaa[i].fspeed := 7;

                                // soundz
                                playsound(SND_plasma,TMP_cl_PlasmaSpawn(Data^).x,TMP_cl_PlasmaSpawn(Data^).y);
                                if (players[a].item_quad > 0) and (players[a].item_quad_time = 0) then begin
                                        playsound(SND_damage3,TMP_cl_PlasmaSpawn(Data^).x,TMP_cl_PlasmaSpawn(Data^).y);
                                        players[a].item_quad_time := 50; end;
                                // & soundz
                                exit;
                        end;
                end;

        end;
        //---------------------------------------
        MMP_CL_GRENADESPAWN:   // DEMODONE
        begin
                if ismultip=2 then
                for a := 0 to 7 do if players[a] <> nil then if players[a].DXID = TMP_cl_GrenSpawn(Data^).spawnerDXID then
                for i := 0 to 1000 do begin
                        if (aaa[i].dead=0) and (aaa[i].objname = 'grenade') and (aaa[i].spawner=players[a]) and (aaa[i].DXID = TMP_cl_GrenSpawn(Data^).selfDXID) then exit; // this is dublicate

                        if aaa[i].dead = 2 then begin
                                aaa[i].objname := 'grenade';
                                aaa[i].dead := 0;
                                aaa[i].dude := true;
                                aaa[i].frame := 0;
                                aaa[i].mass := 2.5;
                                aaa[i].topdraw := 1;
                                aaa[i].clippixel := 4;
        //                      aaa[i].fAngle := RadToDeg(ArcTan2(f.y-f.cy-5,f.x-f.cx))-90;
                                aaa[i].spawner := players[a];
                                aaa[i].fallt := 0;
                                aaa[i].refire := 0;
                                aaa[i].idd := 0;
                                aaa[i].x := TMP_cl_GrenSpawn(Data^).x;
                                aaa[i].y := TMP_cl_GrenSpawn(Data^).y;
                                aaa[i].fAngle := TMP_cl_GrenSpawn(Data^).fangle;
                                aaa[i].DXID := TMP_cl_GrenSpawn(Data^).selfDXID;
                                aaa[i].inertiax := TMP_cl_GrenSpawn(Data^).inertiax;
                                aaa[i].inertiay := TMP_cl_GrenSpawn(Data^).inertiay;
                                aaa[i].dir := TMP_cl_GrenSpawn(Data^).dir;
        //                        aaa[i].health := 50*15;
                                aaa[i].imageindex := 255;


                                if MATCH_DRECORD then begin
                                        DData.type0 := DDEMO_FIREGRENV2;               // VERSION2::
                                        DData.gametic := gametic;
                                        DData.gametime := gametime;
                                        DGrenadeFireV2.x := TMP_cl_GrenSpawn(Data^).x;
                                        DGrenadeFireV2.y := TMP_cl_GrenSpawn(Data^).y;
                                        DGrenadeFireV2.DXID := TMP_cl_GrenSpawn(Data^).selfDXID;
                                        DGrenadeFireV2.spawnerDxid := TMP_cl_GrenSpawn(Data^).spawnerDXID;
                                        DGrenadeFireV2.inertiax := TMP_cl_GrenSpawn(Data^).inertiax;
                                        DGrenadeFireV2.inertiay := TMP_cl_GrenSpawn(Data^).inertiay;
                                        DGrenadeFireV2.dir := TMP_cl_GrenSpawn(Data^).dir;
                                        DGrenadeFireV2.angle := TMP_cl_GrenSpawn(Data^).fangle;
                                        DemoStream.Write( DData, Sizeof(DData));
                                        DemoStream.Write( DGrenadeFireV2, Sizeof(DGrenadeFireV2));
                                end;

                                playsound(SND_grenade,players[a].x,players[a].y);
                                if (players[a].item_quad > 0) and (players[a].item_quad_time = 0) then
                                begin playsound(SND_damage3,players[a].x,players[a].y); players[a].item_quad_time := 50; end;
                                exit;
                        end;
                end;
        end;
        //---------------------------------------
        MMP_CL_OBJDESTROY: // DEMODONE!
        begin
                if TMP_cl_ObjDestroy(Data^).killDXID=0 then begin
                        addmessage('neterror: null TMP_cl_ObjDestroy...');
                        exit;
                        end;

                for i := 0 to 1000 do if aaa[i].dead = 0 then if aaa[i].dxid = TMP_cl_ObjDestroy(Data^).killDXID then begin
//                        addmessage('killed '+aaa[i].objname+' . DXID#'+inttostr(aaa[i].dxid));

//                        if aaa[i].dead=
                        if aaa[i].objname = 'rocket' then begin
                                aaa[i].x := TMP_cl_ObjDestroy(Data^).x;
                                aaa[i].y := TMP_cl_ObjDestroy(Data^).y;
                                aaa[i].dead := 1;
                                aaa[i].weapon := 0;
                                aaa[i].frame := 0;
                                aaa[i].topdraw := 2;
                                aaa[i].speed := random(8);
                        end;
                        if (aaa[i].objname = 'plasma') or (aaa[i].objname = 'weapon') then begin
                                        if MATCH_DRECORD then begin
                                                DData.type0 := DDEMO_KILLOBJECT;    // kill this object in demo
                                                DData.gametic := gametic;
                                                DData.gametime := gametime;
                                                DDXIDKill.x := 0;
                                                DDXIDKill.y := 0;
                                                DDXIDKill.DXID := aaa[i].DXID;
                                                DemoStream.Write(DData, Sizeof(DData));
                                                DemoStream.Write(DDXIDKill, Sizeof(DDXIDKill));
                                        end;
                                        aaa[i].dead := 2;
                                end;
                        if (aaa[i].objname = 'grenade') then begin
                                aaa[i].x := TMP_cl_ObjDestroy(Data^).x;
                                aaa[i].y := TMP_cl_ObjDestroy(Data^).y;
                                aaa[i].dead := 1;
                                aaa[i].weapon := 1;
                                aaa[i].speed := random(8);
                                aaa[i].frame := 0;
                                aaa[i].objname := 'rocket';
                                aaa[i].topdraw := 2;  // explosion to the top animaton
                        end;

                        break;
                end;
        end;
        //---------------------------------------
        MMP_SV_SEND_TIME:
        begin
                if not BNET_NFK_msgfromserv(FromIP) then exit;
                gametic := TMP_SV_send_time(Data^).gametic;
                gametime := TMP_SV_send_time(Data^).gametime;
                MATCH_STARTSIN := TMP_SV_send_time(Data^).warmup;
                MP_WAITSNAPSHOT := false;
        end;
        //---------------------------------------
        MMP_SV_COMMAND:
        begin
                if not BNET_NFK_msgfromserv(FromIP) then exit;
                if gametime >= 1 then begin
                        if MATCH_FRAGLIMIT <> TMP_Svcommand(Data^).fraglimit then addmessage('Server changes "fraglimit" to "'+inttostr(TMP_Svcommand(Data^).fraglimit)+'"');
                        if MATCH_TIMELIMIT <> TMP_Svcommand(Data^).timelimit then addmessage('Server changes "timelimit" to "'+inttostr(TMP_Svcommand(Data^).timelimit)+'"');
//                        if MATCH_WARMUP <> TMP_Svcommand(Data^).warmup then addmessage('Server changes "warmup" to "'+inttostr(TMP_Svcommand(Data^).warmup)+'"');
                        if OPT_WARMUPARMOR <> TMP_Svcommand(Data^).warmuparmor then addmessage('Server changes "warmuparmor" to "'+inttostr(TMP_Svcommand(Data^).warmuparmor)+'"');
                        if OPT_FORCERESPAWN <> TMP_Svcommand(Data^).forcerespawn then addmessage('Server changes "forcerespawn" to "'+inttostr(TMP_Svcommand(Data^).forcerespawn)+'"');
                        if OPT_SYNC <> TMP_Svcommand(Data^).sync then addmessage('Server changes "sync" to "'+inttostr(TMP_Svcommand(Data^).sync)+'"');
                        if OPT_RAILARENA_INSTAGIB <> TMP_Svcommand(Data^).railarenainstagib then begin
                                if TMP_Svcommand(Data^).railarenainstagib = true then addmessage('Server changes "railarenainstagib" to "1"') else addmessage('Server changes "railarenainstagib" to "0"');
                                end;
                        if OPT_TEAMDAMAGE <> TMP_Svcommand(Data^).teamdamage then begin
                                if TMP_Svcommand(Data^).teamdamage = true then addmessage('Server changes "sv_teamdamage" to "1"') else addmessage('Server changes "sv_teamdamage" to "0"');
                                end;
                        if OPT_SV_OVERTIME <> TMP_Svcommand(Data^).overtime then addmessage('Server changes "sv_overtime" to "'+inttostr(TMP_Svcommand(Data^).overtime)+'"');

                        if MATCH_GAMETYPE=GAMETYPE_CTF then if MATCH_CAPTURELIMIT <> TMP_Svcommand(Data^).capturelimit then addmessage('Server changes "capturelimit" to "'+inttostr(TMP_Svcommand(Data^).capturelimit)+'"');
                        if MATCH_GAMETYPE=GAMETYPE_DOMINATION then if MATCH_DOMLIMIT <> TMP_Svcommand(Data^).domlimit then addmessage('Server changes "domlimit" to "'+inttostr(TMP_Svcommand(Data^).domlimit)+'"');

                end;

                MATCH_FRAGLIMIT := TMP_Svcommand(Data^).fraglimit;
                MATCH_TIMELIMIT := TMP_Svcommand(Data^).timelimit;
                MATCH_WARMUP := TMP_Svcommand(Data^).warmup;
                OPT_WARMUPARMOR := TMP_Svcommand(Data^).warmuparmor;
                OPT_FORCERESPAWN := TMP_Svcommand(Data^).forcerespawn;
                OPT_SYNC := TMP_svcommand(Data^).sync;
                OPT_RAILARENA_INSTAGIB := TMP_Svcommand(Data^).railarenainstagib;
                OPT_TEAMDAMAGE := TMP_Svcommand(Data^).teamdamage;
                OPT_SV_OVERTIME := TMP_Svcommand(Data^).overtime;
                if MATCH_GAMETYPE=GAMETYPE_CTF then MATCH_CAPTURELIMIT := TMP_Svcommand(Data^).capturelimit;
                if MATCH_GAMETYPE=GAMETYPE_DOMINATION then MATCH_DOMLIMIT := TMP_Svcommand(Data^).domlimit;

                if not teamgame then INTEAMSELECTMENU := false;
        end;
        //---------------------------------------
        MMP_SV_COMMANDEX:
        begin
                if not BNET_NFK_msgfromserv(FromIP) then exit;
                addmessage('Server''s maxplayers is: '+inttostr(TMP_Svcommand_ex(Data^).maxplayers));
                if TMP_Svcommand_ex(Data^).powerup = false then
                        addmessage('^5Powerups ^7are ^1DISABLED ^7on this server.');
                exit;
        end;
        //---------------------------------------
        MMP_SV_COMMAND_CHANGED:begin
                if not BNET_NFK_msgfromserv(FromIP) then exit;
                if (TMP_CommandResult(data^).command = 0) then addmessage('Server changes ^5sv_powerup^7 to ^5'+inttostr(TMP_CommandResult(data^).value));
        end;
        //---------------------------------------
        MMP_TIMEUPDATE:
        begin

                if MATCH_DRECORD then begin
                        DData.type0 := DDEMO_NETTIMEUPDATE;
                        DData.gametic := gametic;
                        DData.gametime := gametime;
                        DemoStream.Write( DData, Sizeof(DData));
                        DNETTimeUpdate.Min := TMP_TimeUpdate(Data^).Min;
                        DNETTimeUpdate.WARMUP := TMP_TimeUpdate(Data^).WARMUP;
                        DemoStream.Write(DNETTimeUpdate, Sizeof(DNETTimeUpdate));
                end;


                if TMP_TimeUpdate(Data^).WARMUP = true then begin
                        if TMP_TimeUpdate(Data^).Min < 1 then MATCH_FAKESTARTSIN:=1 else
                        MATCH_FAKESTARTSIN := TMP_TimeUpdate(Data^).Min;

                        case MATCH_FAKESTARTSIN of
                        1 : playsound(SND_one,0,0);
                        2 : playsound(SND_two,0,0);
                        3 : playsound(SND_three,0,0);
                        end;
                end else begin
                        MATCH_FAKESTARTSIN := 0;
                        MATCH_FAKEMIN := TMP_TimeUpdate(Data^).Min;
                        end;
        end;
        //---------------------------------------
        MMP_MATCHSTART:
        begin
                if not BNET_NFK_msgfromserv(FromIP) then exit;

                if TMP_SV_MatchStart(Data^).gameend = false then begin
                        playsound(SND_fight,0,0);
                        MATCH_STARTSIN:=0;      // GAME!
                        MATCH_FAKESTARTSIN:=0;

                        resetmap;

                        if MATCH_DRECORD then begin
                                DData.type0 := DDEMO_NETSVMATCHSTART;
                                DData.gametic := gametic;
                                DData.gametime := gametime;
                                DNETSV_MatchStart.spacer := $0;
                                DemoStream.Write( DData, Sizeof(DData));
                                DemoStream.Write( DNETSV_MatchStart, Sizeof(DNETSV_MatchStart));
                        end;


                        for i := 0 to 7 do if players[i] <> nil then begin
                                resetplayer(players[i]);
                                resetplayerstats(players[i]);
                                players[i].dead := 0;
                                players[i].clippixel := 0;
                                players[i].health := 125;
                                players[i].armor := 0;
                                players[i].frags := 0;
                                players[i].weapon := 1;
                        end;
                end else begin
                        GameEnd(TMP_SV_MatchStart(Data^).gameendid);
                end;
        end;
        //---------------------------------------
        MMP_MAPRESTART:
        begin
             MAP_RESTART;
             if TMP_SV_MapRestart(Data^).reason = 1 then begin
                        playsound(SND_prepare,0,0);
                        if MATCH_DRECORD then DemoEnd(END_JUSTEND);
                        MATCH_STARTSIN := MATCH_WARMUP*50;
                        MATCH_FAKESTARTSIN := MATCH_STARTSIN;
             end;
        end;
        //---------------------------------------
        MMP_CHANGELEVEL:
        begin
                if MATCH_DRECORD then DemoEnd(END_JUSTEND);

                rzlt := false;
                if TMP_ChangeLevel(Data^).NewGameType<>MATCH_GAMETYPE then
                begin
                        rzlt := true;
                        MATCH_GAMETYPE := TMP_ChangeLevel(Data^).NewGameType;
                        Addmessage('^3Gametype changed to: '+GAMETYPE_STR[MATCH_GAMETYPE]);
                end;

                a := LOADMAPSearch( lowercase(extractfilename(TMP_ChangeLevel(Data^).Filename)), TMP_ChangeLevel(Data^).CRC32);

                if a = LMS_NOTFOUND then begin
                        ShowCriticalError('Disconnected from server','Can not join. Map not found', '('+TMP_ChangeLevel(Data^).Filename+')');
                        ApplyHCommand('disconnect'); exit;
                end;

                if a = LMS_CRC32FAILED then begin
                        ShowCriticalError('Disconnected from server','Can not join. Your map differs', 'from server map ('+TMP_ChangeLevel(Data^).Filename+')');
                        ApplyHCommand('disconnect'); exit;
                end;

                LOADMAP (ROOTDIR+'\maps\'+loadmapsearch_lastfile, true);
                ADDMESSAGE('Server changes map to '+TMP_ChangeLevel(Data^).Filename);

                if rzlt then begin // gametype changed... emulate spawn server...
                        if not SpawnServer_PreInit then exit;
                        SpawnServer_PostInit;
                        ApplyOriginalModels(); // set up team skins.
                end;

        end;
        //---------------------------------------
        MMP_WARMUPIS2: // respawn all items on clients.
        begin

             for i := 0 to 7 do if players[i] <> nil then if (players[i].team >= 2) and (players[i].netobject = false) then begin
                     HIST_DISABLE := TRUE;
                     APPLYHCommand('join auto #auto');
                     HIST_DISABLE := false;
                break;
             end;

             if (MATCH_GAMETYPE <> GAMETYPE_RAILARENA) and (MATCH_GAMETYPE <> GAMETYPE_PRACTICE) then begin
                for i := 0 to BRICK_X-1 do      // brickz
                for a := 0 to BRICK_Y-1 do begin
                        if bbb[i,a].image > 0 then if bbb[i,a].respawntime > 0 then bbb[i,a].respawntime := 0;
                end;
             end;
        end;
        //---------------------------------------
        MMP_PING: // DEMOUSELESS
        begin
                if ismultip=1 then begin
                        CopyMemory(@buf, data,sizeof(TMP_Ping));
                        mainform.BNETSend_SV_Data2All_Except (FromIP,buf,sizeof(TMP_Ping),0);
                end;

                for i := 0 to 7 do if players[i] <> nil then if players[i].DXID= TMP_Ping(Data^).DXID then begin
                        players[i].ping := TMP_Ping(Data^).PING;
                        break;
                end;

                if ismultip=1 then begin
                        MsgSize := SizeOf(TMP_AnswerPing);
                            Msg4.Data := MMP_ANSWERPING;
                            mainform.BNETSendData2IP_ (FromIP, FromPort, Msg4, MsgSize, 1);
                end;
        end;
        //---------------------------------------
        MMP_ANSWERPING:         // DEMOUSELESS
        begin
                answertime := gettickcount;
                pingrecv_tick := answertime;

                for i:=0 to 7 do if players[i] <> nil then if players[i].netobject =false then begin
                        if (gettickcount - starttime >= 0) and (gettickcount - starttime < 10000) then
                        players[i].ping := (gettickcount - starttime) div 2
                        else  players[i].ping := 999;
                        break;
                end;
        end;
        //---------------------------------------
        MMP_THROWPLAYER:        // DEMOUSELESS
        begin
                if fromip = bnet1.localip then exit;
//                addmessage('MMP_THROWPLAYER');
                for i := 0 to 7 do if players[i] <> nil then if (players[i].DXID= TMP_ThrowPlayer(Data^).DXID) and (players[i].dead=0) and ((players[i].netobject = false) or (players[i].dead > 0)) then begin
                        players[i].inertiax := players[i].inertiax + (TMP_ThrowPlayer(Data^).ix / 6553.5) - 5;
                        players[i].inertiay := players[i].inertiay + (TMP_ThrowPlayer(Data^).iy / 6553.5) - 5;
                        if players[i].inertiax > 5 then players[i].inertiax := 5;
                        if players[i].inertiax < -5 then players[i].inertiax := -5;
                        if players[i].inertiay > 5 then players[i].inertiay := 5;
                        if players[i].inertiay < -5 then players[i].inertiay := -5;
                        break;
                end;
        end;
        //---------------------------------------
        MMP_GAUNTLETSTATE:      // DEMODONE
        begin
                if ismultip=1 then begin
                        CopyMemory(@buf, data,sizeof(TMP_GauntletState));
                        mainform.BNETSend_SV_Data2All_Except (FromIP,buf,sizeof(TMP_GauntletState),0);
                end;

                for i := 0 to 7 do if players[i] <> nil then if (players[i].DXID= TMP_GauntletState(Data^).DXID) and (players[i].dead=0) then begin
                        players[i].gantl_state := 0;
//                        addmessage('MMP_GAUNTLETSTATE received');
                      if MATCH_DRECORD then begin
                                DData.type0 := DDEMO_GAUNTLETSTATE;
                                DData.gametic := gametic;
                                DData.gametime := gametime;
                                DGauntletState.DXID := players[i].DXID;
                                DGauntletState.State := 0;
                                DemoStream.Write( DData, Sizeof(DData));
                                DemoStream.Write( DGauntletState, Sizeof(DGauntletState));
                      end;

                        break;
                end;
        end;
        //---------------------------------------
        MMP_GAUNTLETFIRE:       // DEMODONE
        begin
                if ismultip=1 then begin
                        CopyMemory(@buf, data,sizeof(TMP_GauntletShot));
                        mainform.BNETSend_SV_Data2All_Except (FromIP,buf,sizeof(TMP_GauntletShot),0);
                end;

                for i := 0 to 7 do if players[i] <> nil then if (players[i].DXID= TMP_GauntletShot(Data^).DXID) and (players[i].dead=0) then begin
                        if players[i].gantl_state=0 then players[i].gantl_state := 1;
                        if ismultip=1 then begin        // server.
                                players[i].clippixel := TMP_GauntletShot(Data^).clippixel;
                                players[i].refire := 0;
                                players[i].weapon := 0;
                                firegauntlet(players[i]);
                                       
                        end;

                      if MATCH_DRECORD then begin
                                DData.type0 := DDEMO_GAUNTLETSTATE;
                                DData.gametic := gametic;
                                DData.gametime := gametime;
                                DGauntletState.DXID := players[i].DXID;
                                DGauntletState.State := 1;
                                DemoStream.Write( DData, Sizeof(DData));
                                DemoStream.Write( DGauntletState, Sizeof(DGauntletState));
                      end;


                        break;
                end;
        end;
        //---------------------------------------
        MMP_OBJCHANGESTATE:      // DEMODONE
        begin
                if not BNET_NFK_msgfromserv(FromIP) then exit;

                if MATCH_DRECORD then begin
                        // change obj state!
                        ddata.gametic := gametic;
                        ddata.gametime := gametime;
                        ddata.type0 := DDEMO_OBJCHANGESTATE;
                        DemoStream.Write(DData, Sizeof(DData));
                        DObjChangeState.objindex := TMP_ObjChangeState(Data^).objindex;
                        DObjChangeState.state := TMP_ObjChangeState(Data^).state;
                        DemoStream.Write( DObjChangeState, Sizeof(DObjChangeState));
                end;

//                if ddd[TMP_ObjChangeState(Data^).objindex].active =false then begin addmessage('error: MMP_OBJCHANGESTATE for null object'); exit; end;
                if ddd[TMP_ObjChangeState(Data^).objindex].objtype = 2 then begin // btn
                        if TMP_ObjChangeState(Data^).state = ddd[TMP_ObjChangeState(Data^).objindex].targetname then exit;
                        ddd[TMP_ObjChangeState(Data^).objindex].targetname := TMP_ObjChangeState(Data^).state;
                        if TMP_ObjChangeState(Data^).state = 1 then playsound(SND_button,ddd[TMP_ObjChangeState(Data^).objindex].x*32,ddd[TMP_ObjChangeState(Data^).objindex].y*16);
                        end;


                if ddd[TMP_ObjChangeState(Data^).objindex].objtype = 3 then begin // dooR
                        if TMP_ObjChangeState(Data^).state = ddd[TMP_ObjChangeState(Data^).objindex].target then exit;
                        ddd[TMP_ObjChangeState(Data^).objindex].nowanim := 6;
                        ddd[TMP_ObjChangeState(Data^).objindex].target := TMP_ObjChangeState(Data^).state;

                        // corpse removing...
                        if TMP_ObjChangeState(Data^).state = 1 then
                                for i := 0 to 1000 do if aaa[i].dead = 0 then begin
                                rzlt := false;
                                if aaa[i].dead < 2 then begin
                                        if ddd[TMP_ObjChangeState(Data^).objindex].orient  = 0 then rzlt := object_region_touch(ddd[TMP_ObjChangeState(Data^).objindex].x,ddd[TMP_ObjChangeState(Data^).objindex].y-1,ddd[TMP_ObjChangeState(Data^).objindex].x+ddd[TMP_ObjChangeState(Data^).objindex].lenght+1,ddd[TMP_ObjChangeState(Data^).objindex].y, aaa[i]);
                                        if ddd[TMP_ObjChangeState(Data^).objindex].orient  = 1 then rzlt := object_region_touch(ddd[TMP_ObjChangeState(Data^).objindex].x,ddd[TMP_ObjChangeState(Data^).objindex].y,ddd[TMP_ObjChangeState(Data^).objindex].x, ddd[TMP_ObjChangeState(Data^).objindex].y+ddd[TMP_ObjChangeState(Data^).objindex].lenght+1, aaa[i]);
                                        if rzlt = true then if aaa[i].objname = 'corpse' then aaa[i].dead := 2;
                                end;
                        end;

                        if TMP_ObjChangeState(Data^).state = 1 then playsound(SND_dr1_end,ddd[TMP_ObjChangeState(Data^).objindex].x*32,ddd[TMP_ObjChangeState(Data^).objindex].y*16);
                        if TMP_ObjChangeState(Data^).state = 0 then playsound(SND_dr1_strt,ddd[TMP_ObjChangeState(Data^).objindex].x*32,ddd[TMP_ObjChangeState(Data^).objindex].y*16);


                end;


        end;
        //---------------------------------------
        MMP_STATS:
        begin
                for i := 0 to 7 do if players[i] <> nil then if players[i].dxid = TMP_Stats3(Data^).DXID then begin
                        players[i].stats.stat_kills := TMP_Stats3(Data^).stat_kills;
                        players[i].stats.stat_suicide := TMP_Stats3(Data^).stat_suicide;
                        players[i].stats.stat_deaths := TMP_Stats3(Data^).stat_deaths;
                        players[i].stats.stat_dmggiven := TMP_Stats3(Data^).stat_dmggiven;
                        players[i].frags := TMP_Stats3(Data^).frags;
                        players[i].stats.stat_dmgrecvd := TMP_Stats3(Data^).stat_dmgrecvd;
                        players[i].stats.stat_impressives := TMP_Stats3(Data^).bonus_impressive;
                        players[i].stats.stat_excellents := TMP_Stats3(Data^).bonus_excellent;
                        players[i].stats.stat_humiliations := TMP_Stats3(Data^).bonus_humiliation;
                        players[i].stats.gaun_hits := TMP_Stats3(Data^).gaun_hits;
                        players[i].stats.mach_hits := TMP_Stats3(Data^).mach_hits;
                        players[i].stats.shot_hits := TMP_Stats3(Data^).shot_hits;
                        players[i].stats.gren_hits := TMP_Stats3(Data^).gren_hits;
                        players[i].stats.rocket_hits := TMP_Stats3(Data^).rocket_hits;
                        players[i].stats.shaft_hits := TMP_Stats3(Data^).shaft_hits;
                        players[i].stats.plasma_hits := TMP_Stats3(Data^).plasma_hits;
                        players[i].stats.rail_hits := TMP_Stats3(Data^).rail_hits;
                        players[i].stats.bfg_hits := TMP_Stats3(Data^).bfg_hits;
                        players[i].stats.mach_fire := TMP_Stats3(Data^).mach_fire;
                        players[i].stats.shot_fire := TMP_Stats3(Data^).shot_fire;
                        players[i].stats.gren_fire := TMP_Stats3(Data^).gren_fire;
                        players[i].stats.rocket_fire := TMP_Stats3(Data^).rocket_fire;
                        players[i].stats.shaft_fire := TMP_Stats3(Data^).shaft_fire;
                        players[i].stats.plasma_fire := TMP_Stats3(Data^).plasma_fire;
                        players[i].stats.rail_fire := TMP_Stats3(Data^).rail_fire;
                        players[i].stats.bfg_fire := TMP_Stats3(Data^).bfg_fire;
                        break;
                end;
        end;
        //---------------------------------------
        MMP_TELEPORTPLAYER://demodone
        begin
                if ismultip=1 then begin
                        CopyMemory(@buf, data,sizeof(TMP_TeleportPlayer));
                        mainform.BNETSend_SV_Data2All_Except (FromIP,buf,sizeof(TMP_TeleportPlayer),0);
                end;

                RespawnFlash(TMP_TeleportPlayer(Data^).x1,TMP_TeleportPlayer(Data^).y1);
                RespawnFlash(TMP_TeleportPlayer(Data^).x2,TMP_TeleportPlayer(Data^).y2);
        end;
        //---------------------------------------
        MMP_NAMECHANGE:
        begin
                if ismultip=1 then begin
                        CopyMemory(@buf, data,sizeof(TMP_NameModelChange));
                        mainform.BNETSend_SV_Data2All_Except (FromIP,buf,sizeof(TMP_NameModelChange),1);
                end;

                for i := 0 to 7 do if players[i] <> nil then if players[i].dxid = TMP_NameModelChange(Data^).DXID then begin
                        addmessage(players[i].netname+' ^7^nrenamed to '+ TMP_NameModelChange(Data^).newstr);

                        players[i].netname := TMP_NameModelChange(Data^).newstr;
                        if MATCH_DRECORD then begin
                                DData.type0 := DDEMO_PLAYERRENAME;
                                DData.gametic := gametic;
                                DData.gametime := gametime;
                                DemoStream.Write( DData, Sizeof(DData));
                                DNETNameModelChange.DXID := players[i].DXID;
                                DNETNameModelChange.newstr := players[i].netname;
                                DemoStream.Write( DNETNameModelChange, Sizeof(DNETNameModelChange));
                        end;
                        break;
                end;

        end;
        //---------------------------------------
        MMP_MODELCHANGE:
        begin
                if ismultip=1 then begin
                        CopyMemory(@buf, data,sizeof(TMP_NameModelChange));
                        mainform.BNETSend_SV_Data2All_Except (FromIP,buf,sizeof(TMP_NameModelChange),1);
                end;

                for i := 0 to 7 do if players[i] <> nil then if players[i].dxid = TMP_NameModelChange(Data^).DXID then begin
                        addmessage(players[i].netname +' ^7^nchanged his model to '+ TMP_NameModelChange(Data^).newstr);
                        players[i].nfkmodel := TMP_NameModelChange(Data^).newstr;

                        if MATCH_DRECORD then begin
                                DData.type0 := DDEMO_PLAYERMODELCHANGE;
                                DData.gametic := gametic;
                                DData.gametime := gametime;
                                DemoStream.Write( DData, Sizeof(DData));
                                DNETNameModelChange.DXID := players[i].DXID;
                                DNETNameModelChange.newstr := players[i].nfkmodel;
                                DemoStream.Write( DNETNameModelChange, Sizeof(DNETNameModelChange));
                        end;

                        ASSIGNMODEL(players[i]);
                        break;
                end;
        end;
        //---------------------------------------
        MMP_SENDSOUND: // just a sound
        begin
                if ismultip=1 then begin
                        CopyMemory(@buf, data,sizeof(TMP_SoundData));
                        mainform.BNETSend_SV_Data2All_Except (FromIP,buf,sizeof(TMP_SoundData),0);
                end;

                if MATCH_DRECORD then begin
                        DData.type0 := DDEMO_GENERICSOUNDDATA;
                        DData.gametic := gametic;
                        DData.gametime := gametime;
                        DemoStream.Write( DData, Sizeof(DData));
                        DNETSoundData.DXID := TMP_SoundData(Data^).DXID;
                        DNETSoundData.SoundType := TMP_SoundData(Data^).SoundType;
                        DemoStream.Write(DNETSoundData, Sizeof(DNETSoundData));
                end;

                for i := 0 to 7 do if players[i] <> nil then if players[i].dxid = TMP_SoundData(Data^).DXID then begin
                        case TMP_SoundData(Data^).SoundType of
                        0:playsound(players[i].SND_Jump,players[i].x,players[i].y);
                        1:playsound(SND_flight,players[i].x,players[i].y);
                        2:playsound(SND_jumppad,players[i].x,players[i].y);
                        3:playsound(SND_damage3,players[i].x,players[i].y);
                        4:playsound(SND_noammo,players[i].x,players[i].y);
                        end;
                        break;
                end;

        end;
        //---------------------------------------
        MMP_SENDSTATESOUND: // just a sound
        begin

                if MATCH_DRECORD then begin
                        DData.type0 := DDEMO_GENERICSOUNDSTATDATA;
                        DData.gametic := gametic;
                        DData.gametime := gametime;
                        DemoStream.Write( DData, Sizeof(DData));
                        DNETSoundStatData.SoundType := TMP_SoundStatData(Data^).SoundType;
                        DemoStream.Write(DNETSoundStatData, Sizeof(DNETSoundStatData));
                end;

                case TMP_SoundStatData(Data^).SoundType of
                        0:playsound(SND_5_min,0,0);
                        1:playsound(SND_1_min,0,0);
                        2:begin
                                playsound(SND_sudden_death,0,0);
                                MATCH_SUDDEN := TRUE;
                                gamesudden := 200;
                                end;
                        3:begin
                                addmessage('^1Overtime ^7+'+inttostr(OPT_SV_OVERTIME)+' minutes');
//                                MATCH_OVERTIME := MATCH_OVERTIME + OPT_SV_OVERTIME;
                                MATCH_OVERTIMESHOW := 200;
                        end;

                        end;
        end;

        //---------------------------------------
        MMP_XYSOUND:
        begin
                playsound(SND_poweruprespawn,TMP_XYSoundData(data^).x*32,TMP_XYSoundData(data^).y*16);
                if MATCH_DRECORD then begin
                        DData.type0 := DDEMO_POWERUPSOUND;
                        DData.gametic := gametic;
                        DData.gametime := gametime;
                        DPowerUpSound.x := round(TMP_XYSoundData(data^).x*32);
                        DPowerUpSound.y := round(TMP_XYSoundData(data^).y*16);
                        DemoStream.Write( DData, Sizeof(DData));
                        DemoStream.Write( DPowerUpSound, Sizeof(DPowerUpSound));
               end;
        end;
        //---------------------------------------
        MMP_TEAMSELECT:
        begin
                if ismultip=1 then begin
                        CopyMemory(@buf, data,sizeof(TMP_TeamSelect));
                        mainform.BNETSend_SV_Data2All_Except (FromIP,buf,sizeof(TMP_TeamSelect),1);
                end;

                for i := 0 to 7 do if players[i] <> nil then if players[i].dxid = TMP_TeamSelect(Data^).DXID then begin

                        if MATCH_DRECORD then begin
                               DData.type0 := DDEMO_TEAMSELECT;
                               DData.gametic := gametic;
                               DData.gametime := gametime;
                               DemoStream.Write( DData, Sizeof(DData));
                               DNETTeamSelect.DXID := TMP_TeamSelect(Data^).DXID;
                               DNETTeamSelect.team := TMP_TeamSelect(Data^).team;
                               DemoStream.Write( DNETTeamSelect, Sizeof(DNETTeamSelect));
                        end;


                if TMP_TeamSelect(Data^).team = 1 then addmessage(players[i].netname+ ' ^7^njoined ^1RED ^7team') else
                        AddMessage(players[i].netname + ' ^7^njoined ^4BLUE ^7team');

                players[i].team := TMP_TeamSelect(Data^).team;
                ASSIGNMODEL(players[i]);
                break;
                end;
        end;
        //---------------------------------------
        // CTF_
        MMP_CTF_GAMESTATE: // (client only)
        begin
                CTF_RedFlagAssign(TMP_CTF_GameState(Data^).RedFlagAtBase);
                CTF_BlueFlagAssign(TMP_CTF_GameState(Data^).BlueFlagAtBase);
                MATCH_REDTEAMSCORE := TMP_CTF_GameState(Data^).RedScore;
                MATCH_BLUETEAMSCORE := TMP_CTF_GameState(Data^).BlueScore;
        end;
        //---------------------------------------
        MMP_CTF_FLAGCARRIER: // (client only)
        begin
                for i := 0 to 7 do if players[i] <> nil then if players[i].dxid = TMP_CTF_FlagCarrier(Data^).DXID then begin
                        players[i].flagcarrier := true;
                        break;
                end;
        end;
        //---------------------------------------
        MMP_CTF_EVENT_FLAGDROP: // (client only)
        begin
                CTF_CLNETWORK_DropFlag(MMP_CTF_EVENT_FLAGDROP, Data);
        end;
        //---------------------------------------
        MMP_CTF_EVENT_FLAGDROPGAMESTATE: // (client only)
        begin
                CTF_CLNETWORK_DropFlag(MMP_CTF_EVENT_FLAGDROPGAMESTATE, Data);
        end;
        //---------------------------------------
        MMP_CTF_EVENT_FLAGDROP_APPLY: // (client only)
        begin
                for i := 0 to 1000 do if (aaa[i].dead =0) and (aaa[i].objname = 'flag') and (aaa[i].DXID = TMP_CTF_DropFlagApply(Data^).DXID) then begin
                        aaa[i].x := TMP_CTF_DropFlagApply(Data^).x;
                        aaa[i].y := TMP_CTF_DropFlagApply(Data^).y;
                        aaa[i].InertiaX := 0;
                        aaa[i].InertiaY := 0;
                        if MATCH_DRECORD then CTF_SAVEDEMO_FlagDrop_Apply(aaa[i]); // client demo record
                        break;
                end;
        end;
        //---------------------------------------
        MMP_CTF_EVENT_FLAGRETURN: // (client only)
        begin
                for i := 0 to 1000 do if (aaa[i].dead =0) and (aaa[i].objname = 'flag') and (aaa[i].DXID = TMP_CTF_FlagReturnFlag(Data^).FlagDXID) then begin
                        aaa[i].dead := 2;
                        CTF_ReturnFlag(TMP_CTF_FlagReturnFlag(Data^).team);
                        CTF_Event_Message(TMP_CTF_FlagReturnFlag(Data^).team,'retur');
                        playsound(SND_Flagret,0,0);
                        if MATCH_DRECORD then CTF_Event_ReturnFlag(TMP_CTF_FlagReturnFlag(Data^).FlagDXID, TMP_CTF_FlagReturnFlag(Data^).team); // client demo record
                        break;
                end;
        end;
        //---------------------------------------
        MMP_CTF_EVENT_FLAGCAPTURE: // (client only)
        begin
                for i := 0 to 7 do if players[i] <> nil then if players[i].dxid = TMP_CTF_FlagCapture(Data^).DXID then begin
                        players[i].flagcarrier := false;
                        playsound(SND_flagcap,0,0);
                        if players[i].team=0 then CTF_ReturnFlag(1) else CTF_ReturnFlag(0);
                        CTF_Event_Message(players[i].dxid,'captu');
                        if MATCH_DRECORD then CTF_Event_FlagCapture(TMP_CTF_FlagCapture(Data^).DXID); // client demo record
                        break;
                end;
        end;
        //---------------------------------------
        MMP_CTF_EVENT_FLAGTAKEN: // (client only)
        begin
                for i := 0 to 7 do if players[i] <> nil then if players[i].dxid = TMP_CTF_FlagTaken(Data^).DXID then begin
                        players[i].flagcarrier := true;
                        playsound(SND_flagtk,0,0);
                        bbb[TMP_CTF_FlagTaken(Data^).x,TMP_CTF_FlagTaken(Data^).y].dir := 1; // not at base.
                        CTF_Event_Message(players[i].dxid,'taken');
                        if MATCH_DRECORD then CTF_Event_FlagTaken(TMP_CTF_FlagTaken(Data^).x, TMP_CTF_FlagTaken(Data^).y, TMP_CTF_FlagTaken(Data^).DXID);  // client demo record
                        break;
                end;
        end;
        //---------------------------------------
        MMP_CTF_EVENT_FLAGPICKUP: // (client only)
        begin
                for i := 0 to 7 do if players[i] <> nil then if players[i].dxid = TMP_CTF_FlagPickUp(Data^).PlayerDXID then begin
                for a := 0 to 1000 do if (aaa[a].dead=0) and (aaa[a].objname = 'flag') and (aaa[a].DXID = TMP_CTF_FlagPickUp(Data^).FlagDXID) then begin
                        players[i].flagcarrier := true;
                        CTF_Event_Message(players[i].dxid,'taken');
                        aaa[a].dead := 2;
                        playsound(SND_flagtk,0,0);
                        if MATCH_DRECORD then CTF_Event_PickupFlag(aaa[a], players[i]); // client demo record
                        break;
                        end;
                        break;
                end;
        end;
        //---------------------------------------
        MMP_CTF_GAMESTATESCORE: // (client only)
        begin
                MATCH_REDTEAMSCORE := TMP_CTF_GameStateScore(Data^).RedScore;
                MATCH_BLUETEAMSCORE := TMP_CTF_GameStateScore(Data^).BlueScore;
                if MATCH_DRECORD then CTF_Event_GameStateScoreChanged(); // client demo record
        end;
        //---------------------------------------
        MMP_DOM_CAPTURE:
        begin
                DOM_Capture(TMP_DOM_Capture(Data^).x, TMP_DOM_Capture(Data^).y, TMP_DOM_Capture(Data^).team, MMP_DOM_CAPTURE);
        end;
        //---------------------------------------
        MMP_DOM_CAPTUREGAMESTATE:
        begin
                DOM_Capture(TMP_DOM_Capture(Data^).x, TMP_DOM_Capture(Data^).y, TMP_DOM_Capture(Data^).team, MMP_DOM_CAPTUREGAMESTATE);
        end;
        //---------------------------------------
        MMP_DOM_SCORECHANGED:
        begin
                MATCH_REDTEAMSCORE := TMP_DOM_ScoreChanges(Data^).RedScore;
                MATCH_BLUETEAMSCORE := TMP_DOM_ScoreChanges(Data^).BlueScore;
                DOM_CLScoreChanged();
        end;
        //---------------------------------------
        MMP_WPN_EVENT_WEAPONDROP:
        begin
                WPN_CLNETWORK_DropWeapon(MMP_WPN_EVENT_WEAPONDROP, Data);
        end;
        //---------------------------------------
        MMP_WPN_EVENT_WEAPONDROPGAMESTATE:
        begin
                WPN_CLNETWORK_DropWeapon(MMP_WPN_EVENT_WEAPONDROPGAMESTATE, Data);
        end;
        //---------------------------------------
        MMP_POWERUP_EVENT_POWERUPDROP:
        begin
                POWERUP_CLNETWORK_DropPowerup(MMP_POWERUP_EVENT_POWERUPDROP, Data);
        end;
        //---------------------------------------
        MMP_POWERUP_EVENT_POWERUPGAMESTATE:
        begin
                POWERUP_CLNETWORK_DropPowerup(MMP_POWERUP_EVENT_POWERUPGAMESTATE, Data);
        end;
        //---------------------------------------
        MMP_WPN_EVENT_WEAPONDROP_APPLY://update position... avoid lags..
        begin
                for a := 0 to 1000 do if (aaa[a].dead =0) and ((aaa[a].objname = 'weapon') or (aaa[a].objname = 'powerup')) and (aaa[a].DXID = TMP_CTF_DropFlagApply(Data^).DXID) then begin
                        aaa[a].x := TMP_CTF_DropFlagApply(Data^).x;
                        aaa[a].y := TMP_CTF_DropFlagApply(Data^).y;
                        aaa[a].InertiaX := 0;
                        aaa[a].InertiaY := 0;
                        break;
                end;
        end;
        //---------------------------------------
        MMP_WPN_EVENT_PICKUP:
        begin
                for i := 0 to 7 do if players[i] <> nil then if players[i].dxid = TMP_CTF_FlagPickUp(Data^).PlayerDXID then begin
                for a := 0 to 1000 do if (aaa[a].dead =0) and (aaa[a].objname = 'weapon') and (aaa[a].DXID = TMP_CTF_FlagPickUp(Data^).FlagDXID) then begin
                        if WPN_GainWeapon(players[i], aaa[a].imageindex) then
                                if players[i].netobject = false then
                                        DoWeapBar(i); // new weapon.. notice that
                        aaa[a].dead := 2;
                        playsound(SND_wpkup,players[i].x,players[i].y);

                        WPN_Event_Pickup(aaa[a],players[i]);

                        break;
                        end;
                        break;
                end;
        end;
        //---------------------------------------
        MMP_POWERUP_EVENT_PICKUP:
        begin
                for i := 0 to 7 do if players[i] <> nil then if players[i].dxid = TMP_CTF_FlagPickUp(Data^).PlayerDXID then begin
                for a := 0 to 1000 do if (aaa[a].dead =0) and (aaa[a].objname = 'powerup') and (aaa[a].DXID = TMP_CTF_FlagPickUp(Data^).FlagDXID) then begin
                        POWERUP_GainPowerup(players[i], aaa[a].dir, aaa[a].imageindex);
                        if players[i].netobject = false then DoWeapBar(i); // new powerup.. notice that
                        aaa[a].dead := 2;
                        POWERUP_Event_Pickup(aaa[a], players[i]);
                        break;
                        end;
                        break;
                end;
        end;
        //---------------------------------------
        MMP_MULTITRIX_WIN:
        begin
                for i := 0 to 7 do if players[i] <> nil then if players[i].dxid = TMP_TrixArenaWin(Data^).DXID then begin
                s := '';
                if trunc(TMP_TrixArenaWin(Data^).gametime / 60) < 10 then s := '0';
                s := s + inttostr(trunc(TMP_TrixArenaWin(Data^).gametime/60))+':';
                if TMP_TrixArenaWin(Data^).gametime - trunc(TMP_TrixArenaWin(Data^).gametime / 60)*60 < 10 then s := s + '0';
                s := s + inttostr(TMP_TrixArenaWin(Data^).gametime - trunc(TMP_TrixArenaWin(Data^).gametime / 60)*60);
                addmessage(players[i].netname + ' ^7^nfinished the level. Time: '+s+'.'+inttostr(TMP_TrixArenaWin(Data^).gametic));
                break;
                end;
        end;
        //---------------------------------------



end; // endcase.

end;

//---------------------------------------
procedure SPAWNCLIENT;
var MSG : TMP_GAMESTATERequest;
    MsgSize: word;
begin
        if ismultip<>2 then exit;
//      addmessage('connect request sended');

        SendFloodTo(BNET_GAMEIP, BNET_SERVERPORT, 0);
        if BNET_SERVERPORT <> BNET_GAMEPORT then
                SendFloodTo(BNET_GAMEIP, BNET_GAMEPORT, 0);

        MsgSize := SizeOf(TMP_GAMESTATERequest);
        Msg.DATA := MMP_GAMESTATEREQUEST;
        Msg.spectator := OPT_NETSPECTATOR;
        Msg.SIGNNATURE := NFK_SIGNNATURE; // control packet.
        if BNET_SERVERPORT <> BNET_GAMEPORT then
        mainform.BNETSendData2IP_ (BNET_GAMEIP, BNET_SERVERPORT, Msg, MsgSize, 1);
        mainform.BNETSendData2IP_ (BNET_GAMEIP, BNET_GAMEPORT, Msg, MsgSize, 1);

        SendFloodTo(BNET_GAMEIP, BNET_SERVERPORT, 0);
        if BNET_SERVERPORT <> BNET_GAMEPORT then
                SendFloodTo(BNET_GAMEIP, BNET_GAMEPORT, 0);
end;
//---------------------------------------

procedure Tmainform.DXPlayOpen(Sender: TObject);
var i,a: word;
begin
   loadi.cns.lines.add('Network Session Opened...');

   dxtimer.fps := 50;
   if ISMULTIP=1 then begin
        MENUORDER := MENU_PAGE_MAIN;
        SPAWNSERVER;
        end;


   if ismultip = 2 then begin
           mapcansel := 25;
           SPAWNCLIENT;
           for i := 0 to BRICK_X-1 do for a := 0 to BRICK_Y-1 do // create temp empty map. to avoid nfk crash.
              bbb[i,a].image := 0;
   end;

// ------------------------------------------
end;

function formatnumber(n : integer) : integer;
begin
if n < 0 then n := -n;
if n > $FFFF then n := $FFFF;
result := n;
end;

function formatbyte(n : integer) : integer;
begin
if n < 0 then n := n * -1;
if n > $FF then n := $FF;
result := n;
end;

procedure Gamma_set(a : byte);
begin
end;

procedure AddHistory(s : string);
begin
if HIST_DISABLE = TRUE then exit;
        if conhist.Count>1 then if conhist[0] = s then exit;
        conhist.insert(1,s);
end;

procedure TABCommand(s : string);
var found,i : integer;
    foundd : string[255];
    lastchar : char;
    resultstring : string;
//    balance : boolean;
begin
s := lowercase(s);
found := 0;


  //      found := 0;

{       resultstring := lowercase(s);
       found := 0;

        repeat
                found := 0;
                for i := 0 to contab.count-1 do begin

                        if length(contab[i]) > length(resultstring) then
                        if copy(contab[i], 0,length(resultstring)) = resultstring then begin
                                lastchar := contab[i][length(resultstring)+1];
                                inc(found);
                                end;
                end;

             if found=1 then found :=0;

                if found >= 2 then
                for i := 0 to contab.count-1 do begin
                        if length(contab[i]) >= length(resultstring+lastchar) then
                        if copy(contab[i], 0,length(resultstring+lastchar)) = resultstring+lastchar then begin
                                resultstring:= resultstring+lastchar;
                                break;
                                end;
                end;


//                if found>=1 then
  //`                      resultstring:= resultstring+lastchar;
        until (found=0);


        addmessage(resultstring);

        exit;
{        if found>0 then begin
                found := 0;
                for i := 0 to contab.count-1 do begin
                        if copy(contab[i], 0,length(S)) = s then begin
                                if found>0 then if
                                inc(found);

                        end;
        end;
 }

  {     addmessage(resultstring);

{        repeat
        balance := true;
        lastchar:=#00;
        found := 0;

{        for i := 0 to contab.count-1 do begin
                if length(contab[i]) > length(S) then
//                        if copy(contab[i], 0,length(S)) = s then begin
  //    /                          if found>0 then begin
    /    //                                if lastchar <> contab[i][length(resultstring)+1] then balance := false;
     //                                   found:=2;
       /                                 end else begin
                                lastchar:=contab[i][length(resultstring)+1];
                                found := 1;
                                end;
                        end;
        end;

        resultstring:=resultstring+lastchar;
        until (found<=1) or (balance=false);
        constr := resultstring;
//        until found=1;



//for i := 0 to contab.count-1 do begin
//end;
}
s := lowercase(s);
for i := 0 to contab.count-1 do begin
        if lowercase(copy(contab[i], 0,length(S))) = s then begin foundd := contab[i]; inc(found); end;
        end;
if found > 1 then begin
            addmessage(' ');
            for i := 0 to contab.count-1 do
                if lowercase(copy(contab[i], 0,length(S))) = s then addmessage('>   '+contab[i]);
        end else if found = 1 then
                constr := foundd+' ';
end;

procedure LoadCFG (s : string; option: byte);
var ts : tstringlist;
    i : integer;
begin
if not fileexists(ROOTDIR+'\'+s+'.cfg') then begin addmessage(s+'.cfg not found in basenfk directory'); exit; end;
ts := TStringList.create;
ts.loadfromfile(ROOTDIR+'\'+s+'.cfg');
for i := 0 to ts.count - 1 do if
        lowercase(ts[i]) <> 'exec '+s+'.cfg' then begin// do not exec it self.. deadloop
                if (not GAME_FULLLOAD) and ((lowercase(ts[i]) = 'quit') or (lowercase(ts[i]) = 'halfquit')) then continue;
                ApplyHCommand(ts[i]);
        end;
ts.free;
if MSG_DISABLE = TRUE then begin
        MSG_DISABLE := FALSE;
        if option <> 0 then addmessage('execing '+s+'.cfg');
        MSG_DISABLE := TRUE;
        end else addmessage('execing '+s+'.cfg');
end;

procedure SaveCFG (s : string);
const b : string[5] = 'bind ';
var ts : tstringlist;
begin
//loadi.cns.lines.add ('saving config '+ROOTDIR+'\'+s+'.cfg');
if isparamstr('protected') then exit;
ts := TStringList.create;
if s<>'nfkconfig' then ts.add('// generated by NFK, '+datetimetostr(now));
if DRAW_BACKGROUND = true then ts.add('drawbackground 1') else ts.add('drawbackground 0');
if DRAW_FPS = true then ts.add('drawfps 1') else ts.add('drawfps 0');
if DRAW_OBJECTS = true then ts.add('drawnumobjects 1') else ts.add('drawnumobjects 0');
if OPT_STEREO = true then ts.add('s_stereo 1') else ts.add('s_stereo 0');
if OPT_REVERSESTEREO = true then ts.add('s_reversestereo 1') else ts.add('s_reversestereo 0');
//ts.add('gamma '+inttostr(GAMMA));
//ts.add('fill_r '+inttostr(OPT_BG_R));
//ts.add('fill_g '+inttostr(OPT_BG_G));
//ts.add('fill_b '+inttostr(OPT_BG_B));
if OPT_MENUANIM = true then ts.add('menuanimation 1') else ts.add('menuanimation 0');
if OPT_HITSND = true then ts.add('hitsound 1') else ts.add('hitsound 0');
if OPT_GIBBLOOD = true then ts.add('gibblood 1') else ts.add('gibblood 0');
if OPT_DOORSOUNDS = true then ts.add('doorsounds 1') else ts.add('doorsounds 0');
if OPT_ALLOWMAPCHANGEBG then ts.add('allowmapschangebg 1') else ts.add('allowmapschangebg 0');
if OPT_AUTOSHOWNAMES then ts.add('autoshownick 1') else ts.add('autoshownick 0');
if GAME_LOG then ts.add('log 1') else ts.add('log 0');
if OPT_TRANSPASTATS then ts.add('transparentstats 1') else ts.add('transparentstats 0');
if OPT_P1GAUNTLETNEXTWPN then ts.add('gauntletnextweapon 1') else ts.add('gauntletnextweapon 0');
if OPT_P2GAUNTLETNEXTWPN then ts.add('p2gauntletnextweapon 1') else ts.add('p2gauntletnextweapon 0');
if OPT_P1NEXTWPNSKIPEMPTY then ts.add('nextwpn_skipempty 1') else ts.add('nextwpn_skipempty 0');
if OPT_P2NEXTWPNSKIPEMPTY then ts.add('p2nextwpn_skipempty 1') else ts.add('p2nextwpn_skipempty 0');
if OPT_SHOWMAPINFO then ts.add('showmapinfo 1') else ts.add('showmapinfo 0');
if OPT_RAILARENA_INSTAGIB then ts.add('railarenainstagib 1') else ts.add('railarenainstagib 0');
if OPT_SHOWNICKATSB then ts.add('shownickatsb 1') else ts.add('shownickatsb 0');
if OPT_SV_ALLOWJOINMATCH then ts.add('sv_allowjoinmatch 1') else ts.add('sv_allowjoinmatch 0');
if OPT_MINVERT then ts.add('m_invert 1') else ts.add('m_invert 0');
if OPT_MROTATED then ts.add('m_rotated 1') else ts.add('m_rotated 0');
if OPT_SV_DEDICATED then ts.add('sv_dedicated 1') else ts.add('sv_dedicated 0');
if OPT_TEAMDAMAGE then ts.add('sv_teamdamage 1') else ts.add('sv_teamdamage 0');
if OPT_P1MOUSELOOK then ts.add('mouselook 1') else ts.add('mouselook 0');
if OPT_ANNOUNCER then ts.add('announcer 1') else ts.add('announcer 0');
if SYS_CONSOLE_STRETCH then ts.add('ch_constretch 1') else  ts.add('ch_constretch 0');
if OPT_CONTENTEMPTYDEATHHIGHLIGHT then ts.add('r_markemptydeath 1') else ts.add('r_markemptydeath 0');
if OPT_CL_AVIMODE then ts.add('cl_avimode 1') else ts.add('cl_avimode 0');
if OPT_DONOTSHOW_RECLABEL then ts.add('ch_showrecordinglabel 1') else ts.add('ch_showrecordinglabel 0');
if OPT_AUTOCONNECT_ONINVITE then ts.add('c_autoconnectoninvite 1') else ts.add('c_autoconnectoninvite 0');
if OPT_QWSCOREBOARD then ts.add('ch_qwscoreboard 1') else ts.add('ch_qwscoreboard 0');
ts.add('sv_hostname '+OPT_SV_HOSTNAME);
ts.add('sv_overtime '+inttostr(OPT_SV_OVERTIME));
ts.add('sv_maxplayers '+inttostr(OPT_SV_MAXPLAYERS));
ts.add('weapbartime '+inttostr(OPT_P1BARTIME));
if OPT_DRAWFRAGBAR then ts.add('drawfragbar 1') else ts.add('drawfragbar 0');
ts.add('fragbarx '+inttostr(OPT_DRAWFRAGBARX));
ts.add('fragbary '+inttostr(OPT_DRAWFRAGBARY));
ts.add('messagetime '+inttostr(OPT_MESSAGETIME));
ts.add('m_accelerate '+inttostr(OPT_MOUSEACCELDELIM));
ts.add('sync '+inttostr(OPT_SYNC));
ts.add('p2weapbartime '+inttostr(OPT_P1BARTIME));
ts.add('forcerespawn '+inttostr(OPT_FORCERESPAWN));
ts.add('corpsetime '+inttostr(OPT_CORPSETIME));
ts.add('barposition '+inttostr(P1BARORIENT));
ts.add('s_channelapproach '+inttostr(OPT_CHANNELAPPROACH));
ts.add('crosscolor '+inttostr(OPT_P1CROSH));
ts.add('bg '+inttostr(OPT_BG));
ts.add('warmuparmor '+inttostr(OPT_WARMUPARMOR));
ts.add('mousesmooth '+inttostr(OPT_MOUSESMOOTH));
ts.add('weaponswitch_on_end '+inttostr(OPT_WEAPONSWITCH_END));
ts.add('model '+OPT_NFKMODEL1);
ts.add('p2model '+OPT_NFKMODEL2);
ts.add('menucolor '+inttostr(OPT_GAMEMENUCOLOR));
ts.add('p2crosscolor '+inttostr(OPT_P2CROSH));
ts.add('p2weaponswitch_on_end '+inttostr(OPT_P2WEAPONSWITCH_END));
ts.add('p2crosstype '+inttostr(OPT_P2CROSHT));
ts.add('railcolor '+inttostr(OPT_RAILCOLOR1));
ts.add('railtrailtime '+inttostr(OPT_RAILTRAILTIME));
ts.add('p2railcolor '+inttostr(OPT_RAILCOLOR2));
ts.add('mp3volume '+inttostr(OPT_MP3VOLUME));
ts.add('volume '+inttostr(OPT_VOLUME));
ts.add('p2keybaccelerate '+inttostr(OPT_KEYBACCELDELIM));
ts.add('keybaccelerate '+inttostr(OPT_P1KEYBACCELDELIM));
ts.add('p2name '+p2name);
ts.add('crosstype '+inttostr(OPT_P1CROSHT));
ts.add('meatlevel '+inttostr(OPT_MEATLEVEL));
ts.add('name '+p1name);
if OPT_SMOKE = true then ts.add('smoke 1') else ts.add('smoke 0');
ts.add('sensitivity '+inttostr(OPT_SENS));
ts.add('keybsensitivity '+inttostr(OPT_KSENS));
if draw_barflash = true then ts.add('barflash 1') else ts.add('barflash 0');
ts.add('warmup '+inttostr(MATCH_WARMUP));
ts.add('fraglimit '+inttostr(MATCH_FRAGLIMIT));
ts.add('timelimit '+inttostr(MATCH_TIMELIMIT));
ts.add('capturelimit '+inttostr(MATCH_CAPTURELIMIT));
ts.add('domlimit '+inttostr(MATCH_DOMLIMIT));
if OPT_TB_SHOWMYSELF = true then ts.add('ch_teambar_showmyself 1') else ts.add('ch_teambar_showmyself 0');
ts.add('ch_teambar_color '+inttostr(OPT_TB_COLOR));
ts.add('ch_teambar_style '+inttostr(OPT_TB_STYLE));
if OPT_R_TRANSPARENTBULLETMARKS then ts.add('r_transparentbulletmarks 1') else ts.add('r_transparentbulletmarks 0');
if OPT_R_TRANSPARENTEXPLOSIONS then ts.add('r_transparentexplosions 1') else ts.add('r_transparentexplosions 0');
if OPT_R_FLASHINGITEMS then ts.add('r_flashingitems 1') else ts.add('r_flashingitems 0');
if OPT_R_ALPHAITEMSRESPAWN then ts.add('r_alphaitemsrespawn 1') else ts.add('r_alphaitemsrespawn 0');
ts.add('r_wateralpha '+inttostr(OPT_R_WATERALPHA));
ts.add('r_statusbaralpha '+inttostr(OPT_R_STATUSBARALPHA));
ts.add('r_railstyle '+inttostr(OPT_R_RAILSTYLE));
if OPT_RAILSMOOTH then ts.add('r_railsmooth 1') else ts.add('r_railsmooth 0');
if OPT_RAILPROGRESSIVEALPHA then ts.add('r_railprogressivealpha 1') else ts.add('r_railprogressivealpha 0');
if OPT_R_BUBBLES then ts.add('r_drawbubbles 1') else ts.add('r_drawbubbles 0');
ts.add('fill_bgr $' +inttohex(OPT_FILL_RGB,3));
if OPT_BGMOTION then ts.add('r_bgmotion 1') else ts.add('r_bgmotion 0');

ts.add('ch_conspeed ' +inttostr(SYS_CONSOLE_DELIMETER));
ts.add('ch_conheight '+inttostr(SYS_CONSOLE_MAXY));
ts.add('ch_conalpha ' +inttostr(SYS_CONSOLE_ALPHA));
ts.add('ch_dombarpos '+inttostr(OPT_DOMBARPOS));
if OPT_NETPREDICT then ts.add('net_predict 1') else  ts.add('net_predict 0');

// VOTEZ
if OPT_SV_ALLOWVOTE then ts.add('sv_allowvote 1') else  ts.add('sv_allowvote 0');
if OPT_SV_ALLOWVOTE_RESTART then ts.add('sv_allowvote_restart 1') else  ts.add('sv_allowvote_restart 0');
if OPT_SV_ALLOWVOTE_FRAGLIMIT then ts.add('sv_allowvote_fraglimit 1') else  ts.add('sv_allowvote_fraglimit 0');
if OPT_SV_ALLOWVOTE_TIMELIMIT then ts.add('sv_allowvote_timelimit 1') else  ts.add('sv_allowvote_timelimit 0');
if OPT_SV_ALLOWVOTE_CAPTURELIMIT then ts.add('sv_allowvote_capturelimit 1') else  ts.add('sv_allowvote_capturelimit 0');
if OPT_SV_ALLOWVOTE_DOMLIMIT then ts.add('sv_allowvote_domlimit 1') else  ts.add('sv_allowvote_domlimit 0');
if OPT_SV_ALLOWVOTE_READY then ts.add('sv_allowvote_ready 1') else  ts.add('sv_allowvote_ready 0');
if OPT_SV_ALLOWVOTE_MAP then ts.add('sv_allowvote_map 1') else  ts.add('sv_allowvote_map 0');
if OPT_SV_ALLOWVOTE_WARMUP then ts.add('sv_allowvote_warmup 1') else  ts.add('sv_allowvote_warmup 0');
if OPT_SV_ALLOWVOTE_WARMUPARMOR then ts.add('sv_allowvote_warmuparmor 1') else  ts.add('sv_allowvote_warmuparmor 0');
if OPT_SV_ALLOWVOTE_FORCERESPAWN then ts.add('sv_allowvote_forcerespawn 1') else  ts.add('sv_allowvote_forcerespawn 0');
if OPT_SV_ALLOWVOTE_SYNC then ts.add('sv_allowvote_sync 1') else  ts.add('sv_allowvote_sync 0');
if OPT_SV_ALLOWVOTE_SV_TEAMDAMAGE then ts.add('sv_allowvote_sv_teamdamage 1') else  ts.add('sv_allowvote_sv_teamdamage 0');
if OPT_SV_ALLOWVOTE_NET_PREDICT then ts.add('sv_allowvote_net_predict 1') else  ts.add('sv_allowvote_net_predict 0');
if OPT_SV_ALLOWVOTE_SV_MAXPLAYERS then ts.add('sv_allowvote_sv_maxplayers 1') else  ts.add('sv_allowvote_sv_maxplayers 0');
if OPT_SV_ALLOWVOTE_SV_POWERUP then ts.add('sv_allowvote_sv_powerup 1') else  ts.add('sv_allowvote_sv_powerup 0');
ts.add('sv_vote_percent '+inttostr(OPT_SV_VOTE_PERCENT));
ts.add('sv_maxspectators '+inttostr(OPT_SV_MAXSPECTATORS));
if OPT_SV_ALLOWSPECTATORS then ts.add('sv_allowspectators 1') else ts.add('sv_allowspectators 0');
if OPT_SV_POWERUP then ts.add('sv_powerup 1') else ts.add('sv_powerup 0');

if OPT_FXSHAFT then  ts.add('r_fx_shaft 1') else  ts.add('r_fx_shaft 0');
if OPT_FXSMOKE then  ts.add('r_fx_smoke 1') else  ts.add('r_fx_smoke 0');
if OPT_FXLIGHTRLBFG then  ts.add('r_fx_rlbfg 1') else  ts.add('r_fx_rlbfg 0');
if OPT_FXPLASMA then ts.add('r_fx_plasma 1') else ts.add('r_fx_plasma 0');
if OPT_FXQUAD then   ts.add('r_fx_quad 1') else   ts.add('r_fx_quad 0');
if OPT_FXEXPLO then  ts.add('r_fx_explo 1') else  ts.add('r_fx_explo 0');
if OPT_ALTGRENADES then ts.add('r_altgrenades 1') else ts.add('r_altgrenades 0');

// hud
if OPT_RCON_PASSWORD <> '' then ts.add('rconpassword '+OPT_RCON_PASSWORD);
ts.add('ch_hudwidth '+inttostr(OPT_HUD_WIDTH));
ts.add('ch_hudheight '+inttostr(OPT_HUD_HEIGTH));
ts.add('ch_hudx '+inttostr(OPT_HUD_X));
ts.add('ch_hudy '+inttostr(OPT_HUD_Y));
ts.add('ch_hudalpha '+inttostr(OPT_HUD_ALPHA));
ts.add('ch_hudstretch '+inttostr(OPT_HUD_DIVISOR));
ts.add('ch_hudvisible '+inttostr(OPT_HUD_VISIBLE));
if OPT_HUD_SHADOWED then ts.add('ch_hudshadow 1') else ts.add('ch_hudshadow 0');
if OPT_HUD_ICONS then ts.add('ch_hudicons 1') else ts.add('ch_hudicons 0');

if s = 'nfkconfig' then if OPT_NOPLAYER=2 then ts.add('noplayer 2');

ts.add('ch_dombarstyle '+inttostr(OPT_DOMBARSTYLE));
// save bindingz
// MOVEDOWN!
if CTRL_MOVERIGHT>0 then ts.add(b+KEYSTR[ord(CTRL_MOVERIGHT)]+' moveright');
if CTRL_MOVELEFT>0 then ts.add(b+KEYSTR[ord(CTRL_MOVELEFT)]+' moveleft');
if CTRL_MOVEUP>0 then ts.add(b+KEYSTR[ord(CTRL_MOVEUP)]+' moveup');
if CTRL_MOVEDOWN>0 then ts.add(b+KEYSTR[ord(CTRL_MOVEDOWN)]+' movedown');
if CTRL_NEXTWEAPON>0 then ts.add(b+KEYSTR[ord(CTRL_NEXTWEAPON)]+' nextweapon');
if CTRL_PREVWEAPON>0 then ts.add(b+KEYSTR[ord(CTRL_PREVWEAPON)]+' prevweapon');
if CTRL_LOOKUP>0 then ts.add(b+KEYSTR[ord(CTRL_LOOKUP)]+' lookup');
if CTRL_LOOKDOWN>0 then ts.add(b+KEYSTR[ord(CTRL_LOOKDOWN)]+' lookdown');
if CTRL_FIRE>0 then ts.add(b+KEYSTR[ord(CTRL_FIRE)]+' fire');
if CTRL_CENTER>0 then ts.add(b+KEYSTR[ord(CTRL_CENTER)]+' center');
if CTRL_WEAPON0>0 then ts.add(b+KEYSTR[ord(CTRL_WEAPON0)]+' weapon0');
if CTRL_WEAPON1>0 then ts.add(b+KEYSTR[ord(CTRL_WEAPON1)]+' weapon1');
if CTRL_WEAPON2>0 then ts.add(b+KEYSTR[ord(CTRL_WEAPON2)]+' weapon2');
if CTRL_WEAPON3>0 then ts.add(b+KEYSTR[ord(CTRL_WEAPON3)]+' weapon3');
if CTRL_WEAPON4>0 then ts.add(b+KEYSTR[ord(CTRL_WEAPON4)]+' weapon4');
if CTRL_WEAPON5>0 then ts.add(b+KEYSTR[ord(CTRL_WEAPON5)]+' weapon5');
if CTRL_WEAPON6>0 then ts.add(b+KEYSTR[ord(CTRL_WEAPON6)]+' weapon6');
if CTRL_WEAPON7>0 then ts.add(b+KEYSTR[ord(CTRL_WEAPON7)]+' weapon7');
if CTRL_WEAPON8>0 then ts.add(b+KEYSTR[ord(CTRL_WEAPON8)]+' weapon8');
if CTRL_SCOREBOARD>0 then ts.add(b+KEYSTR[ord(CTRL_SCOREBOARD)]+' scoreboard');
if CTRL_P2MOVERIGHT>0 then ts.add(b+KEYSTR[ord(CTRL_P2MOVERIGHT)]+' p2moveright');
if CTRL_P2MOVELEFT>0 then ts.add(b+KEYSTR[ord(CTRL_P2MOVELEFT)]+' p2moveleft');
if CTRL_P2MOVEUP>0 then ts.add(b+KEYSTR[ord(CTRL_P2MOVEUP)]+' p2moveup');
if CTRL_P2MOVEDOWN>0 then ts.add(b+KEYSTR[ord(CTRL_P2MOVEDOWN)]+' p2movedown');
if CTRL_P2NEXTWEAPON>0 then ts.add(b+KEYSTR[ord(CTRL_P2NEXTWEAPON)]+' p2nextweapon');
if CTRL_P2PREVWEAPON>0 then ts.add(b+KEYSTR[ord(CTRL_P2PREVWEAPON)]+' p2prevweapon');
if CTRL_P2LOOKUP>0 then ts.add(b+KEYSTR[ord(CTRL_P2LOOKUP)]+' p2lookup');
if CTRL_P2LOOKDOWN>0 then ts.add(b+KEYSTR[ord(CTRL_P2LOOKDOWN)]+' p2lookdown');
if CTRL_P2FIRE>0 then ts.add(b+KEYSTR[ord(CTRL_P2FIRE)]+' p2fire');
if CTRL_P2CENTER>0 then ts.add(b+KEYSTR[ord(CTRL_P2CENTER)]+' p2center');
if CTRL_P2WEAPON0>0 then ts.add(b+KEYSTR[ord(CTRL_P2WEAPON0)]+' p2weapon0');
if CTRL_P2WEAPON1>0 then ts.add(b+KEYSTR[ord(CTRL_P2WEAPON1)]+' p2weapon1');
if CTRL_P2WEAPON2>0 then ts.add(b+KEYSTR[ord(CTRL_P2WEAPON2)]+' p2weapon2');
if CTRL_P2WEAPON3>0 then ts.add(b+KEYSTR[ord(CTRL_P2WEAPON3)]+' p2weapon3');
if CTRL_P2WEAPON4>0 then ts.add(b+KEYSTR[ord(CTRL_P2WEAPON4)]+' p2weapon4');
if CTRL_P2WEAPON5>0 then ts.add(b+KEYSTR[ord(CTRL_P2WEAPON5)]+' p2weapon5');
if CTRL_P2WEAPON6>0 then ts.add(b+KEYSTR[ord(CTRL_P2WEAPON6)]+' p2weapon6');
if CTRL_P2WEAPON7>0 then ts.add(b+KEYSTR[ord(CTRL_P2WEAPON7)]+' p2weapon7');
if CTRL_P2WEAPON8>0then ts.add(b+KEYSTR[ord(CTRL_P2WEAPON8)]+' p2weapon8');
ALIAS_SaveAlias(ts);
ts.sort;
ts.savetofile(ROOTDIR+'\'+s+'.cfg');
ts.free;
end;

function forma(a : real): real;
begin
        if a < 0 then result := 0 else
        if a > 1 then result := 1 else result := a;
end;

procedure GammaAnimation;
var alph :cardinal;
begin
  Alph := round(ctgR);
  MainForm.PowerGraph.FillRect(0,0,640,480, (Alph shl 24)+$000000, effectSrcAlpha or EffectDiffuseAlpha);
  if (ctgr=tgr) then exit;

  if OPT_MENUANIM = FALSE then begin
        ctgr:=tgr;
        exit
        end;

   if ctgR < tgR then ctgR := ctgR + 35 else
   if ctgR > tgR then ctgR := ctgR - 35;
   if ctgR < 0 then ctgR := 0;
   if ctgR > 255 then ctgR := 255;
end;

function toValidFilename(str : string) : string;
var i : word;
begin
        result := '';
        for i := 1 to length(str) do begin
        if (str[i]=':') then result:= result+'_' else
        if (str[i]=' ') or (str[i]='\') or (str[i]='/') or (str[i]='.') or (str[i]='*') or(str[i]='^') or(str[i]='%') or(str[i]='$') or(str[i]='#') or(str[i]='?') or(str[i]='`') or(str[i]='~') or(str[i]='&') or(str[i]='?') or(str[i]='<') or(str[i]='>')or(str[i]='|') then result:= result+'' else result := result + str[i];
        end;
end;

procedure p1defaults;
begin
  OPT_P1MOUSELOOK:=true;
  UnBindKey(ord(#37));
  UnBindKey(ord(#38));
  UnBindKey(ord(#39));
  UnBindKey(ord(#40));
  UnBindKey(mbutton1);
  UnBindKey(mbutton2);
  CTRL_MOVERIGHT := ord(#39);
  CTRL_MOVELEFT := ord(#37);
  CTRL_MOVEUP := ord(#38);
  CTRL_MOVEDOWN := ord(#40);
  CTRL_NEXTWEAPON := mbutton2;
  CTRL_PREVWEAPON := ord(#00);
  CTRL_LOOKUP := ord(#00);
  CTRL_LOOKDOWN := ord(#00);
  CTRL_FIRE := mbutton1;
  CTRL_CENTER := ord(#00);
  CTRL_WEAPON0 := ord(#00);
  CTRL_WEAPON1 := ord(#00);
  CTRL_WEAPON2 := ord(#00);
  CTRL_WEAPON3 := ord(#00);
  CTRL_WEAPON4 := ord(#00);
  CTRL_WEAPON5 := ord(#00);
  CTRL_WEAPON6 := ord(#00);
  CTRL_WEAPON7 := ord(#00);
  CTRL_WEAPON8 := ord(#00);
  CTRL_SCOREBOARD := ord(#32);
  addmessage('player 1 controls now default.');
end;

procedure p2defaults;
begin
  UnBindKey(ord('D'));
  UnBindKey(ord('A'));
  UnBindKey(ord('W'));
  UnBindKey(ord('S'));
  UnBindKey(ord('Q'));
  UnBindKey(ord('T'));
  UnBindKey(ord('F'));
  UnBindKey(ord('R'));
  CTRL_P2MOVERIGHT := ord('D');
  CTRL_P2MOVELEFT := ord('A');
  CTRL_P2MOVEUP := ord('W');
  CTRL_P2MOVEDOWN := ord('S');
  CTRL_P2NEXTWEAPON := ord('Q');
  CTRL_P2PREVWEAPON := 0;
  CTRL_P2LOOKUP := ord('T');
  CTRL_P2LOOKDOWN := ord('F');
  CTRL_P2FIRE := ord('R');
  CTRL_P2CENTER := 0;
  CTRL_P2WEAPON0 := 0;
  CTRL_P2WEAPON1 := 0;
  CTRL_P2WEAPON2 := 0;
  CTRL_P2WEAPON3 := 0;
  CTRL_P2WEAPON4 := 0;
  CTRL_P2WEAPON5 := 0;
  CTRL_P2WEAPON6 := 0;
  CTRL_P2WEAPON7 := 0;
  CTRL_P2WEAPON8 := 0;
  addmessage('player 2 controls now default.');
end;

procedure unbindkey(k : byte);
begin
KEYALIASES[K] := '1';
if k = 0 then exit;
if CTRL_MOVELEFT = k then CTRL_MOVELEFT := 0;
if CTRL_MOVERIGHT = k then CTRL_MOVERIGHT := 0;
if CTRL_MOVEUP = k then CTRL_MOVEUP := 0;
if CTRL_MOVEDOWN = k then CTRL_MOVEDOWN := 0;
if CTRL_FIRE = k then CTRL_FIRE := 0;
if CTRL_LOOKUP = k then CTRL_LOOKUP := 0;
if CTRL_LOOKDOWN = k then CTRL_LOOKDOWN := 0;
if CTRL_NEXTWEAPON = k then CTRL_NEXTWEAPON := 0;
if CTRL_PREVWEAPON = k then CTRL_PREVWEAPON := 0;
if CTRL_CENTER = k then CTRL_CENTER := 0;
if CTRL_WEAPON0 = k then CTRL_WEAPON0 := 0;
if CTRL_WEAPON1 = k then CTRL_WEAPON1 := 0;
if CTRL_WEAPON2 = k then CTRL_WEAPON2 := 0;
if CTRL_WEAPON3 = k then CTRL_WEAPON3 := 0;
if CTRL_WEAPON4 = k then CTRL_WEAPON4 := 0;
if CTRL_WEAPON5 = k then CTRL_WEAPON5 := 0;
if CTRL_WEAPON6 = k then CTRL_WEAPON6 := 0;
if CTRL_WEAPON7 = k then CTRL_WEAPON7 := 0;
if CTRL_WEAPON8 = k then CTRL_WEAPON8 := 0;
if CTRL_SCOREBOARD = k then CTRL_SCOREBOARD := 0;
if CTRL_P2MOVELEFT = k then CTRL_P2MOVELEFT := 0;
if CTRL_P2MOVERIGHT = k then CTRL_P2MOVERIGHT := 0;
if CTRL_P2MOVEUP = k then CTRL_P2MOVEUP  := 0;
if CTRL_P2MOVEDOWN = k then CTRL_P2MOVEDOWN  := 0;
if CTRL_P2NEXTWEAPON = k then CTRL_P2NEXTWEAPON := 0;
if CTRL_P2PREVWEAPON = k then CTRL_P2PREVWEAPON := 0;
if CTRL_P2LOOKUP = k then CTRL_P2LOOKUP  := 0;
if CTRL_P2LOOKDOWN = k then CTRL_P2LOOKDOWN := 0;
if CTRL_P2FIRE = k then CTRL_P2FIRE    := 0;
if CTRL_P2CENTER = k then CTRL_P2CENTER := 0;
if CTRL_P2WEAPON0 = k then CTRL_P2WEAPON0 := 0;
if CTRL_P2WEAPON1 = k then CTRL_P2WEAPON1 := 0;
if CTRL_P2WEAPON2 = k then CTRL_P2WEAPON2 := 0;
if CTRL_P2WEAPON3 = k then CTRL_P2WEAPON3 := 0;
if CTRL_P2WEAPON4 = k then CTRL_P2WEAPON4 := 0;
if CTRL_P2WEAPON5 = k then CTRL_P2WEAPON5 := 0;
if CTRL_P2WEAPON6 = k then CTRL_P2WEAPON6 := 0;
if CTRL_P2WEAPON7 = k then CTRL_P2WEAPON7 := 0;
if CTRL_P2WEAPON8 = k then CTRL_P2WEAPON8 := 0;
end;

procedure ApplyModels();
var i : byte;
begin
        for i := 0 to 7 do if players[i] <> nil then// if players[i].netobject = true then
                AssignModel(players[i]);
end;

procedure ApplyOriginalModels();
var i : byte;
begin
        for i := 0 to 7 do if players[i] <> nil then begin
                if modelexists(players[i].realmodel) then
                        players[i].nfkmodel := players[i].realmodel;
                AssignModel(players[i]);
        end;
end;

procedure g_DemoRecord_droppableObjects;
var i : word;
begin
        for i := 0 to 1000 do if aaa[i].dead = 0 then begin
                if aaa[i].objname = 'flag' then
                        CTF_SAVEDEMO_FlagDropGameState(aaa[i]);
                if aaa[i].objname = 'weapon' then
                        WPN_SAVEDEMO_WeaponDropGameState(aaa[i]);
                if aaa[i].objname = 'powerup' then
                        POWERUP_SAVEDEMO_PowerupDropGameState(aaa[i]);
        end;

        if MATCH_GAMETYPE=GAMETYPE_DOMINATION then
                DOM_SaveDemo_Gamestate;
end;

procedure g_Network_droppableObjects(ToIP:ShortString; ToPort: word);
var i : word;
begin
        for i := 0 to 1000 do if aaa[i].dead = 0 then begin
                if aaa[i].objname = 'flag' then
                        CTF_SVNETWORK_FlagDropGameState(ToIP, ToPort, aaa[i]);
                if aaa[i].objname = 'weapon' then
                        WPN_SVNETWORK_WeaponDropGameState(ToIP, ToPort, aaa[i]);
                if aaa[i].objname = 'powerup' then
                        POWERUP_SVNETWORK_PowerupDropGameState(ToIP, ToPort, aaa[i]);
        end;

        // This is not droppable object.. but i have to save dompoints status
        if MATCH_GAMETYPE=GAMETYPE_DOMINATION then
                DOM_SvNetwork_Gamestate;
end;

procedure ALIAS_Assign(s, laststr: string;kk:byte);
var i : word;
    alias : string;
begin
        if laststr='' then begin
                addmessage('^1Invalid alias');
                exit;
        end;

        laststr := lowercase(laststr); // key to bind
        unbindkey(kk);
        i := pos (laststr,lowercase(s));
        alias := copy(s,i,length(s)-i+1);

        if alias = '' then begin
                addmessage('parameter expected');
                exit;
                end;


//        addmessage('^2ASSIGNING: '+laststr+' TO '+ alias);
//        if lowercase(strpar(alias,1)) = '' then
        i := 0;
        KEYALIASES[kk] := lowercase(strpar(alias,0));

        repeat
        inc(i);
        if strpar(alias,i) <> '' then
        KEYALIASES[kk] := KEYALIASES[kk] +' '+ strpar(alias,i);
        until strpar(alias,i) = '';

//        KEYALIASES[kk] := lowercase(strpar(alias,0))+' '+strpar(alias,1);

//        addmessage('^2ALIAS Assigned: '+alias+'. Finally:'+KEYALIASES[kk]);
end;

function ALIAS_VIEW(s:string; kk:byte) : boolean;
begin
        result := false;
        if (KEYALIASES[kk] <> '') and (KEYALIASES[kk] <> '1') then begin
                addmessage('"'+strpar(s,1)+'" binded to "'+KEYALIASES[kk]+'"');
                result := true;
        end;
end;

procedure ALIAS_ClearAll;
var i : byte;
begin
        for i := 0 to 255 do if (KEYALIASES[i] <> '') and (KEYALIASES[i] <> '1') then KEYALIASES[i] := '1';
end;

procedure ALIAS_SaveAlias(var TS:TStringList);
var i :byte;
begin
        for i := 0 to 255 do if (KEYALIASES[i] <> '') and (KEYALIASES[i] <> '1') then
                ts.add('bind '+KEYSTR[ord(i)]+' '+KEYALIASES[i]);
end;

procedure RandomModel();
var i : byte;
    b : word;
begin
        if INMENU then begin addmessage('This command is not available from mainmenu'); exit; end;
        OPT_ENEMYMODEL := '';

        for i := 0 to 7 do if players[i]<> nil then begin
                if (players[i].idd = 0) and (MATCH_DDEMOPLAY=false) then continue;
                b := random(NUM_MODELS-1);
                players[i].nfkmodel := eee[b].classname+'+'+eee[b].skinname;
//                addmessage('randoming : '+players[i].nfkmodel);
                AssignModel(players[i]);
        end;
end;

procedure ApplyCommand(s : string);
var tmp : string;
    ss,st : string;
    i,a : word;
    par : shortstring;
    s1 : shortstring;
    e : integer;
//    r,g,b : integer;
    Msg  : TMP_ChatMessage;
    Msg2 : TMP_HostShutDown;
    Msg3 : TMP_SpectatorLeave;
    Msg4 : TMP_SV_MapRestart;
    Msg5 : TMP_ChangeLevel;
    Msg6 : TMP_KickPlayer;
    Msg7 : TMP_NameModelChange;
    Msg8 : TMP_TeamSelect;
    Msg9 : TMP_CommandResult;

    Header : THeader;
    MsgSize:word;
    stp: Integer;
    kk : byte;
    buf : array [0..$FE] of byte;
    buff : array [0..$FF] of char;
    chatP : pointer;
    ass : boolean;
    Entry : TMAPENTRY;

    musvol, samvol, strvol : Cardinal;

    par0,par1 : string;
    mtrl : TD3DMaterial8;
var _mat : TD3DMaterial8;
    _lit : TD3DLight8;
    _tim : single;
//    _vecDir : TD3DXVector3;

begin
//MSG_DISABLE := TRUE; HIST_DISABLE := TRUE;
ss := s;                // require string case.
s := RemoveQuotes(s);
AddHistory(s);

s := lowercase(s);
if s = '' then exit;
if (s[1]='/') and (s[2]='/') then exit; // this is a comment.

par0 := strpar(s,0);
par1 := strpar(s,1);
s1 := strpar(s,1);




// mp chat.
// ------------------------------------------------------------
if (copy(s,0,1) = '\') or (copy(s,0,4) = 'say ') then begin
                if ismultip = 0 then exit;

                if (ismultip=2) and (OPT_NETSPECTATOR) then begin
                        addmessage('Spectators can''t chat.');
                        exit;
                        end;

                if length(s) > $FF then s := copy(s, 1, $FF);

                if (copy(s,1,1) = '\') then st := copy(ss,2,Length(ss));
                if (copy(s,1,4) = 'say ') then st := copy(ss,5,Length(ss)-4);

                kk := 0;
                for i := 0 to 7 do if players[i] <> nil then if players[i].netobject = false then begin // find first active uzer.
                        ass := MSG_DISABLE;
                        MSG_DISABLE := false;
                        addmessage(players[i].netname+'^7^n: ^5'+ st);
                        MSG_DISABLE := ass;
                        kk := 1;
                        break;
                end;

                if not OPT_SV_DEDICATED then
                if BD_Avail then DLL_ChatReceived(players[i].dxid, st);

                if MATCH_DRECORD then begin
                        DData.type0 := DDEMO_CHATMESSAGE;
                        DData.gametic := gametic;
                        DData.gametime := gametime;
                        DemoStream.Write( DData, Sizeof(DData));
                        DNETCHATMessage.DXID := 0;
                        if kk = 1 then DNETCHATMessage.DXID := players[i].DXID;
                        DNETCHATMessage.messagelenght := length(st);
                        DemoStream.Write( DNETCHATMessage, Sizeof(DNETCHATMessage));
                        StrLCopy(Buff, pchar(st), length(st));
                        DemoStream.Write(buff, length(st));
                end;

                chatP := @buf;
                addbyte(chatP, MMP_CHATMESSAGE);
                if kk = 0 then begin // players wan not found.. it is dedicated.
                        addword(chatP, 0);//dedicated
                        addmessage('^%Dedicated^7: ^5'+ st);
                end else
                        addword(chatP, players[i].dxid);

                AddString(chatP,st);
                msgsize := Length(st)+4;

                if ismultip=1 then
                mainform.BNETSendData2All (buf, MsgSize, 1) else
                mainform.BNETSendData2HOST (buf, MsgSize, 1);

                playsound(SND_talk,0,0);
                exit;
end;
// ------------------------------------------------------------
// mp chat.
// ------------------------------------------------------------
if (copy(s,0,9) = 'say_team ') then begin
                if ismultip = 0 then exit;
                if Length(s) <= 9 then exit;

                if (ismultip=2) and (OPT_NETSPECTATOR) then begin
                        addmessage('Spectators can''t chat.');
                        exit;
                        end;

                if length(s) > $FF then s := copy(s,1,$FF);

//                if (copy(s,0,1) = '\') then st := copy(s,2,Length(s)-1);
                if (copy(s,0,9) = 'say_team ') then st := copy(ss,10,Length(ss)-9);
//                addmessage(st);

                msgSize := SizeOf(TMP_ChatMessage) + Length(st);
                if BD_Avail then
                        DLL_ChatReceived(players[i].dxid, st);

                if (TeamGame) and (MyTeamIs < 2) then msg.DATA := MMP_CHATTEAMMESSAGE
                else msg.DATA := MMP_CHATMESSAGE;
                for i := 0 to 7 do if players[i] <> nil then if players[i].netobject = false then begin // find first active uzer.
                                ass := MSG_DISABLE;
                                MSG_DISABLE := false;

                                if players[i].location = '' then addmessage(players[i].netname+'^7^n: ^5'+st) else
                                addmessage(players[i].netname+'^7^n ('+players[i].location+'^7^n): ^5'+st);

//                                addmessage(players[i].netname+'^7^n: ^5'+ st);
                                MSG_DISABLE := ass;
//                                msg.DXID := players[i].dxid;


                                if MATCH_DRECORD then begin
                                        DData.type0 := DDEMO_CHATMESSAGE;
                                        DData.gametic := gametic;
                                        DData.gametime := gametime;
                                        DemoStream.Write( DData, Sizeof(DData));
                                        DNETCHATMessage.DXID := players[i].DXID;
                                        DNETCHATMessage.messagelenght := length(st);
                                        DemoStream.Write( DNETCHATMessage, Sizeof(DNETCHATMessage));
                                        StrLCopy(Buff, pchar(st), length(st));
                                        DemoStream.Write(buff, length(st));
                                end;


                                break;
                        end;

                chatP := @buf;
                addbyte(chatP,MMP_CHATTEAMMESSAGE);
                addword(chatP,players[i].dxid);
                AddString(chatP,st);
                msgsize := length(st)+4;

                if ismultip=1 then
                mainform.BNETSendData2All (buf, MsgSize, 1) else
                mainform.BNETSendData2HOST (buf, MsgSize, 1);

                playsound(SND_talk,0,0);
                exit;
end;
// ------------------------------------------------------------
if not ALIASCOMMAND then addmessage(s);
if BD_Avail then DLL_CMD(ss);
// ------------------------------------------------------------


if strpar(s,0) = 'sok' then begin
{       SetSockOpt(TCPSERV.Socket, IPPROTO_TCP, TCP_NODELAY, pchar(true), sizeof(true));
        SetSockOpt(TCPCLIENT.Socket, IPPROTO_TCP, TCP_NODELAY, pchar(true), sizeof(true));
        addmessage('TCP_NODELAY');}
end;

if strpar(s,0) = 'sss' then begin
        if inmenu then exit;
        if strpar(s,1) <> '' then
        loadmap(strpar(s,1)+'.mapa', true) else
        loadmap('dm2.mapa', true);
        inmenu:=false;
        BNET_ISMULTIP := 1;
        BNET1.Active := true;
        SPAWNSERVER;
end;

if (par0 = 'skipvc') or (par0 = 'skipnfkplanetversioncheck') then begin
        BNET_AUTOUPDATE := false;
        AddMessage('NFK Planet version check disabled.');
        end;

if par0 = 'proxy' then NFKPLANET_IWantJoinProxy(MainForm.GlobalIP);
if par0 = 'proxyd' then NFKPLANET_proxyd;

if strpar(s,0) = 'ddcc' then SpawnCorpse(players[0]);
if par0 = 'nastyrmove' then players[1] := nil;
if par0 = 'noconsolescroll' then OPT_NOCONSOLESCROLL := true;
//---------------------------------
if strpar(s,0) = 'pr' then begin
        ENABLE_PROTECT := not ENABLE_PROTECT;

        if ENABLE_PROTECT then addmessage('^5PR ENABLED')
        else addmessage('^5PR DISABLED');
end;
//---------------------------------
if strpar(s,0) = 'ps' then begin
        ENABLE_PACKETSHOW := not ENABLE_PACKETSHOW;

        if ENABLE_PACKETSHOW then addmessage('^5PS ENABLED')
        else addmessage('^5PS DISABLED');
end;
//-------------------------------


{if strpar(s,0) = 'asd' then begin
        MENUORDER := MENU_PAGE_MULTIPLAYER;
        MP_STEP := 1;
        end;
}
if strpar(s,0) = 'getnews' then begin
        if fileexists(ROOTDIR+'\system\au.dat')
                then deletefile(ROOTDIR+'\system\au.dat');
                addmessage('^5Next time you connect to NFK PLANET, you will get the news.');
                BNET_LASTUPDATESRC := 0;
        end;


if strpar(s,0) = 'connect' then begin
        if BNET_CONNECTING then exit;
        if strpar(s,1) = '' then begin
                addmessage('connect <ipaddress_or_hostname>');
                exit;
                end else
        BNET_DirectConnect (strpar(s,1));
end;

if strpar(s,0) = 'reconnect' then begin
        if (BNET_CONNECTING) and (inmenu) then exit;
        if not BNET_ValidIPAdress(BNET_OLDGAMEIP) then begin addmessage('invalid ip address stored in reconnect command, you cant connect.'); exit; end;
        if not inmenu then begin
                try
                        applyhcommand('disconnect');
                finally
                        BNET_DirectConnect (BNET_OLDGAMEIP);
                end;
        end else
        BNET_DirectConnect (BNET_OLDGAMEIP);
end;

{if strpar(s,0) = 'dd' then
        MP_Sessions.Add (
        'HOSTNAME'+#0+
        'MAPNAME'+#0+
        inttostr(random(6))+#0+
        inttostr(random(8)+1)+#0+
        '8'+#0+'127.0.0.1'+#0+'0'+#+
        inttostr(random(998)+1) );  }

if strpar(s,0) = 'http' then begin
        NFKPLANET_AutoUpdate;
end;

if par0 = 'df' then CTF_DropFlag(players[0]);
{if strpar(s,0) = 'dde' then begin
        MP_STEP :=1;
        BNET_LOBBY_STATUS := 2;
        end;}
//if strpar(s,0) = 'aa' then BNET1.GuaranteedPacketsEnabled := not BNET1.GuaranteedPacketsEnabled;

if strpar(s,0) = 'cmdlist' then begin addmessage('^2------------------'); for i := 0 to contab.count-1 do addmessage(contab[i]); addmessage('^2------------------'); end;
if strpar(s,0) = 'ipaddress' then addmessage('^5IPAddress:  ^7 Local: ^5'+MainForm.LocalIP+'  ^7External: ^5'+MainForm.GlobalIP);

if par0 = 'dee' then addmessage('M:'+map_filename);//copy(map_filename,0,length(loadmapsearch_lastfile)-5));

if strpar(s,0) = 'ipinvite' then BNET_IPINVITE(strpar(s,1));
if strpar(s,0) = 'floodto'  then BNET_FLOOOOOD(strpar(s,1), strpar(s,2), strpar(s,3));
if par0 = 'scan' then CL_AskLobbyGamestate(par1);

if strpar(s,0) = 'hidep2statusbar' then SYS_BAR2AVAILABLE:=false;

if strpar(s,0) = 'lms' then LOADMAPSearch('',0);

if strpar(s,0) = 'upl' then NFKPLANET_UpdateCurrentUsers(2);


if strpar(s,0) = 'mp?' then addmessage('^5'+map_filename_fullpath);

//if strpar(s,0) = 'ansi' then addmessage( RemoveQuotes(s));

if strpar(s,0) = 'sv_lock' then begin
                if ismultip<>1 then begin addmessage('server side multiplayer command.'); exit; end;
                addmessage('Server''s commands now locked.');
                OPT_SV_LOCK := TRUE;
        end;

if strpar(s,0) = 'randommodels' then RandomModel();
if strpar(s,0) = 'wireframe' then begin
mainform.PowerGraph.D3DDevice8.GetRenderState(D3DRS_FILLMODE,musvol);
if musvol = D3DFILL_SOLID then
mainform.PowerGraph.D3DDevice8.SetRenderState(D3DRS_FILLMODE, D3DFILL_WIREFRAME) else
mainform.PowerGraph.D3DDevice8.SetRenderState(D3DRS_FILLMODE, D3DFILL_SOLID);
end;


if strpar(s,0) = 'cl_avidemo' then begin
                OPT_AVIDEMO := not OPT_AVIDEMO;
                if OPT_AVIDEMO then begin
                        try OPT_AVIDEMOC := strtoint(strpar(s,1));
                        except
                        OPT_AVIDEMOC := 0;
                        end;
                end;
        end;

if strpar(s,0) = 'zzz' then begin
        if SYS_USECUSTOMPALETTE_TRANSPARENT then addmessage('SYS_USECUSTOMPALETTE_TRANSPARENT=true')
        else addmessage('SYS_USECUSTOMPALETTE_TRANSPARENT=false');
        addmessage(inttohex(SYS_USECUSTOMPALETTE_TRANS_COLOR,3));
        mainform.images[48].Set1bitAlpha(SYS_USECUSTOMPALETTE_TRANS_COLOR);
        end;


if strpar(s,0) = 'clear' then begin
        conmsg_index := 0;
        conmsg.clear;
        addmessage('NFK Engine ver '+VERSION+'.');
        end;

if strpar(s,0) = 'teamscore' then begin
        addmessage('RED TEAM SCORE: '+inttostr(MATCH_REDTEAMSCORE));
        addmessage('BLUE TEAM SCORE: '+inttostr(MATCH_BLUETEAMSCORE));
        end;


// NFK AMP
if strpar(s,0) = 'mp3play' then MP3_START;
//if strpar(s,0) = 'hardware?' then if doHardware in mainform.dxdraw.options then addmessage('hardware') else addmessage('software');
if strpar(s,0) = 'gametype' then addmessage('Gametype is ^3'+GAMETYPE_STR[MATCH_GAMETYPE]);
if strpar(s,0) = 'score' then CalculateFragBar;


if strpar(s,0) = 'brim' then BrimMapList(ROOTDIR+'\maps');
if strpar(s,0) = 'mp3next' then MP3_START;
if strpar(s,0) = 'mp3stop' then MP3_STOP;
if strpar(s,0) = 'mp3reset' then MP3_RESET;
if strpar(s,0) = 'p1defaultcontrols' then p1defaults;
if strpar(s,0) = 'p2defaultcontrols' then p2defaults;
if strpar(s,0) = 'traffic' then begin
                addmessage('Out: '+inttostr(bnet1.BytesSent));
                addmessage('In:  '+inttostr(bnet1.BytesReceived));
        end;


// cheats.
if ismultip=0 then begin
        if strpar(s,0) = 'gottago' then for i := 0 to 7 do if players[i] <> nil then players[i].framerefreshtime := 1;
        if strpar(s,0) = 'needforblood' then begin
        for i := 0 to BRICK_X-1 do
        for a := 0 to BRICK_Y-1 do
                if bbb[i,a].block = false then SpawnXYNulBlood(i*32+16,a*16+8);
        end;
        if strpar(s,0) = 'comeonlady' then SYS_COMETOPAPA := not SYS_COMETOPAPA;
        if strpar(s,0) = 'lolgrenade' then OPT_EASTERGRENADES := not OPT_EASTERGRENADES;
        if strpar(s,0) = 'fireworksstudios' then SYS_fireworksstudios := not SYS_fireworksstudios;
        if strpar(s,0) = 'bloodrain' then SYS_BLOODRAIN := not SYS_BLOODRAIN;
        if strpar(s,0) = 'bloodmonitor' then SYS_BLOODMONITOR := not SYS_BLOODMONITOR;
        if strpar(s,0) = 'bloodpunk' then SYS_BLOODPUNK := not SYS_BLOODPUNK;
        if strpar(s,0) = 'magiclevel' then SYS_MAGICLEVEL := not SYS_MAGICLEVEL;
        if strpar(s,0) = 'drunkrocket' then SYS_DRUNKRL := not SYS_DRUNKRL;
        if strpar(s,0) = 'psyhodelia' then OPT_PSYHODELIA := not OPT_PSYHODELIA;
        if strpar(s,0) = 'moon' then SYS_IAMMOON := not SYS_IAMMOON;
        if strpar(s,0) = 'starwars' then SYS_STARWARS := not SYS_STARWARS;

        if strpar(s,0) = 'slowgame' then begin
                if mainform.dxtimer.fps = 25 then
                mainform.dxtimer.fps := 50 else
                mainform.dxtimer.fps := 25;
        end;

        if (strpar(s,0) = 'god') then begin
                if (strpar(s,1) = '') then begin if GODMODE = true then addmessage('"god" is "1". Default is "0". Possible range is 0-1.') else addmessage('"god" is "0". Default is "0". Possible range is 0-1.') end;
                if (strpar(s,1) = '1') then begin addmessage('"god" is set to "1"'); GODMODE := true; end;
                if (strpar(s,1) = '0') then begin addmessage('"god" is set to "0"'); GODMODE := false; end;
        end;

        if strpar(s,0) = 'alienblaster' then begin
        if (MATCH_DDEMOPLAY) or (ismultip>0) then exit;
        SYS_TRYTOSPANKME := not SYS_TRYTOSPANKME;
        if SYS_TRYTOSPANKME then addmessage('aliens rewards you');
        end;
end;


//if strpar(s,0) = 'mdlclass' then addmessage(ExtractModelClassName(strpar(s,1)));
//if strpar(s,0) = 'mdlskin' then addmessage(ExtractModelSkinName(strpar(s,1)));

if strpar(s,0) = 'mp3volume' then begin
        kk := OPT_MP3VOLUME;
        if strpar(s,1) = '' then begin addmessage('"mp3volume" is "'+inttostr(kk)+'". Default "100". Range 0-100.'); exit; end;
        try kk := strtoint(strpar(s,1));
        except kk := 100; end;
        if kk <= 0 then kk := 0;
        if kk >= 100 then kk := 100;

        addmessage('"mp3volume" is set to "'+inttostR(kk)+'".');
        OPT_MP3VOLUME := kk;
        if SYS_NFKAMPSTATE=1 then addmessage('changes will take effect with next track.');
end;

if strpar(s,0) = 'volume' then begin
        kk := OPT_VOLUME;
        if strpar(s,1) = '' then begin addmessage('"volume" is "'+inttostr(kk)+'". Default "100". Range 0-100.'); exit; end;
        try kk := strtoint(strpar(s,1));
        except kk := 100; end;
        if kk <= 0 then kk := 0;
        if kk >= 100 then kk := 100;
        addmessage('"volume" is set to "'+inttostR(kk)+'".');
        OPT_VOLUME := kk;
end;

if GAME_FULLLOAD then
if strpar(s,0) = 'r_displayrefresh' then begin
        if not mainform.PowerGraph.FullScreen then begin
                addmessage('this command for fullscreen mode only');
                exit;
                end;

        try kk := strtoint(strpar(s,1));
        except addmessage('invalid value'); exit; end;

        if (kk < 60) or (kk > 160) then
        begin addmessage('value out of range'); exit; end;

        mainform.PowerGraph.RefreshRate := rr_Custom;
        mainform.PowerGraph.CustomRefreshRate := kk;

        mainform.FinalizeAll();
        mainform.PowerGraph.Finalize();
        e:= mainform.PowerGraph.Initialize(mainform.handle);
        if (e <> 0) then begin AddMessage('Error: ' + mainform.PowerGraph.ErrorString(e));
                Application.terminate;
                Exit;
                end;
        mainform.LoadGrafix();
end;


if strpar(s,0) = 'nextplayer' then begin
        if (OPT_NETSPECTATOR = false) and (OPT_SV_DEDICATED=false) and (MATCH_DDEMOPLAY=false) then begin addmessage('You are not spectator'); exit; end;
        SYS_BAR2AVAILABLE := FALSE;
        if (GetNumberOfPlayers=1) and (players[OPT_1BARTRAX] <> nil) then exit;
        SYS_ANNOUNCER := 0;

        if OPT_1BARTRAX < 7 then inc(OPT_1BARTRAX) else OPT_1BARTRAX:=0; if players[OPT_1BARTRAX] <> nil then exit;
        if OPT_1BARTRAX < 7 then inc(OPT_1BARTRAX) else OPT_1BARTRAX:=0; if players[OPT_1BARTRAX] <> nil then exit;
        if OPT_1BARTRAX < 7 then inc(OPT_1BARTRAX) else OPT_1BARTRAX:=0; if players[OPT_1BARTRAX] <> nil then exit;
        if OPT_1BARTRAX < 7 then inc(OPT_1BARTRAX) else OPT_1BARTRAX:=0; if players[OPT_1BARTRAX] <> nil then exit;
        if OPT_1BARTRAX < 7 then inc(OPT_1BARTRAX) else OPT_1BARTRAX:=0; if players[OPT_1BARTRAX] <> nil then exit;
        if OPT_1BARTRAX < 7 then inc(OPT_1BARTRAX) else OPT_1BARTRAX:=0; if players[OPT_1BARTRAX] <> nil then exit;
        if OPT_1BARTRAX < 7 then inc(OPT_1BARTRAX) else OPT_1BARTRAX:=0; if players[OPT_1BARTRAX] <> nil then exit;
end;

if strpar(s,0) = 'fuck' then addmessage('lol');
//if strpar(s,0) = 'dxgdump' then mainform.ImageList.Items.SaveToFile(ROOTDIR+'\DUMP.DXG');
//if strpar(s,0) = 'dxwdump' then WAVELST.Items.SaveToFile(ROOTDIR+'\DUMP.DXW');

//if strpar(s,0) = 'msgon' then MSG_DISABLE := FALSE;
//if strpar(s,0) = 'maxrate' then mainform.dxtimer.interval := 1;
//if strpar(s,0) = 'tied?' then if IsMapTied then addmessage('map tied') else addmessage('map not tied');
//if strpar(s,0) = 'bot' then players[1].idd := 2;//togglebot

// ------------------------------------------------------------
if strpar(s,0) = 'showcons' then begin loadi.show; mainform.SetFocus; end;
// ------------------------------------------------------------
if strpar(s,0) = 'halfquit' then begin
        loadi.show;
        if MATCH_DRECORD then DemoEnd(END_JUSTEND);
        mainform.dxtimer.MayProcess := false;
//        mainform.dxdraw.finalize;
        loadi.cns.Lines.Add('d3d8 finalize');
        mainform.hide;
end;
// ------------------------------------------------------------
if strpar(s,0) =  'zoomwindow' then begin
        if Mainform.PowerGraph.FullScreen then begin addmessage('command works only at the windowed mode'); exit; end;
        if mainform.Width <> screen.width then begin
                mainform.Width := screen.width;
                mainform.Height  := screen.Height ;
        end else begin
                mainform.Width := mainform.PowerGraph.width;
                mainform.Height  := mainform.PowerGraph.Height ;
        end;
end;
// ------------------------------------------------------------
if strpar(s,0) =  'test90' then begin
  //      Mainform.FinalizeAll();
//        Mainform.PowerGraph.Finalize();
        Mainform.Width := 320;
        Mainform.Height := 200;
        mainform.left := 100;
        mainform.top := 100;
//        Mainform.PowerGraph.Initialize();
 //       Mainform.LoadGrafix();
        end;
if strpar(s,0) =  'test91' then begin
        if ismultip > 0 then exit;
        Mainform.FinalizeAll();
        Mainform.PowerGraph.Finalize();
        Mainform.PowerGraph.Width := 1024;
        Mainform.PowerGraph.Height := 768;
        Mainform.PowerGraph.Initialize(mainform.handle);
        Mainform.LoadGrafix();
end;
// ------------------------------------------------------------
if strpar(s,0) =  'gofullscreen' then begin
        if Mainform.PowerGraph.FullScreen then begin addmessage('already in fullscreen mode'); exit; end;
        Mainform.FinalizeAll();
        Mainform.PowerGraph.Finalize();
        Mainform.PowerGraph.FullScreen:= true;
        Mainform.PowerGraph.Initialize(mainform.handle);
        Mainform.LoadGrafix();
end;
// ------------------------------------------------------------
if strpar(s,0) = 'callvote' then begin
        if inmenu then exit;
        if strpar(s,1)='' then exit;
        VOTE_Start(strpar_next (s,1), MyDXIDIS);
      end;
// ------------------------------------------------------------
if strpar(s,0) = 'vote' then
        if (s1='yes') or (s1='y') then VOTE_VOTE(1) else
        if (s1='no') or (s1='n') then VOTE_VOTE(2) else
        addmessage('invalid parameter.');
// ------------------------------------------------------------
if strpar(s,0) =  'sndrestart' then begin
        ADDMESSAGE('this command useless...');
end;
// ------------------------------------------------------------
if strpar(s,0) = 'minimize' then application.minimize;
if strpar(s,0) = 'gowindow' then begin
        if Mainform.PowerGraph.FullScreen=false then begin addmessage('already in windowed mode'); exit; end;
        Mainform.FinalizeAll();
        Mainform.PowerGraph.Finalize();
        Mainform.PowerGraph.FullScreen:= false;
        Mainform.PowerGraph.Initialize(mainform.handle);
        Mainform.LoadGrafix();
end;
// ------------------------------------------------------------
if strpar(s,0) = 'objdump' then begin
        addmessage('map objects:');
        for i := 0 to 1000 do if aaa[i].dead <= 1 then begin
                addmessage(aaa[i].objname + ' #'+inttostr(aaa[i].dxid)+' id:'+inttostr(i)+ ' FRAME:'+inttostr(aaa[i].frame)+ ' dead:'+inttostr(aaa[i].dead));
        end;

end;

if strpar(s,0) = 'sobjdump' then begin
        addmessage('map special objects:');
        for i := 0 to 255 do if ddd[i].active = true then begin
//              addmessage('#'+inttostr(I));
                tmp := 'ddd['+inttostr(I)+'].';
                addmessage(tmp+'x:='+inttostr(ddd[i].x)+';');
                addmessage(tmp+'y:='+inttostr(ddd[i].y)+';');
                addmessage(tmp+'lenght:='+inttostr(ddd[i].lenght)+';');
                addmessage(tmp+'dir:='+inttostr(ddd[i].dir)+';');
                addmessage(tmp+'wait:='+inttostr(ddd[i].wait)+';');
                addmessage(tmp+'targetname:='+inttostr(ddd[i].targetname)+';');
                addmessage(tmp+'target:='+inttostr(ddd[i].target)+';');
                addmessage(tmp+'objtype:='+inttostr(ddd[i].objtype)+';');
                addmessage(tmp+'orient:='+inttostr(ddd[i].orient)+';');
                addmessage(tmp+'nowanim:='+inttostr(ddd[i].nowanim)+';');
                addmessage('--------------------');
                end;
end;
// ------------------------------------------------------------
{if strpar(s,0) = 'swap' then begin
                if players[0] = nil then begin addmessage('cannot execute command. no server.'); exit; end;
                if players[0].control = 1 then begin
                        players[0].control := 2;
                        players[1].control := 1;
                end
                else begin;
                        players[0].control := 1;
                        players[1].control := 2;
                end;
        end;}
// ------------------------------------------------------------
if strpar(s,0) = 'quit' then begin
        try
        if inmenu=false then applyhcommand('disconnect');
        finally mainform.close; end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'leavearena' then applyHcommand('disconnect');

if strpar(s,0) = 'disconnect' then begin
                MATCH_GAMEEND := false;
                OPT_AVIDEMO := false;
                mainform.dxtimer.fps := 50;
                if MATCH_DDEMOPLAY then DemoStream.position := 0;
                if MATCH_DRECORD then DemoEnd(END_JUSTEND);

                DemoStreamBZ.Clear;
                DemoStream.Clear;
                MATCH_DEMOPLAYING := false;

                if MATCH_DDEMOPLAY then addmessage('Finished playing demo.');

                if (ismultip=2) and (OPT_NETSPECTATOR) then begin
                        MsgSize := SizeOf(TMP_SpectatorLeave);
                        Msg3.DATA := MMP_SPECTATORDISCONNECT;
                        Msg3.netname := P1NAME;
                        mainform.BNETSendData2HOST (Msg3, MsgSize, 1);
                end;

                if (ismultip=2) and (OPT_NETSPECTATOR=false) then begin
                        MsgSize := SizeOf(TMP_KickPlayer);
                        Msg6.DATA := MMP_IAMQUIT;
                        Msg6.DXID := MyDXIDIs;
                        mainform.BNETSendData2HOST (Msg6, MsgSize, 1);
                end;


                // multiplayer
                if ismultip>0 then
                if ismultip=1 then begin
                MsgSize := SizeOf(TMP_HostShutDown);
                Msg2.Data := MMP_HOSTSHUTDOWN;
                mainform.BNETSendData2All (Msg2, MsgSize, 1);
                end;

                CLIENTID := AssignUniqueDxID($FFFF); // RESET CLIENTID.

                if SYS_BOT then DLL_SYSTEM_RemoveAllPlayers;

                for i := 0 to 7 do
                        if players[i] <> nil then players[i] := nil;

                OPT_SV_LOCK := false;
                MATCH_DDEMOPLAY := false;
                OPT_SHOWSTATS := false;
                SYS_TEAMSELECT := 0;
                menuorder := MENU_PAGE_MAIN;
                menuwantorder := MENU_PAGE_MAIN;
                BNET_AU_ShowUpdateInfo := false;
                MATCH_DDEMOMPPLAY := 0;
                menuburn := 0;
                INGAMEMENU := false;
                MATCH_GAMEEND := false;
                button_alpha := 0;
                button1_alpha := 0;
                button2_alpha := 0;
                button3_alpha := 0;
                MATCH_OVERTIME := 0;
                ALIASCOMMAND := False;
                SpectatorList.Clear;
                if SYS_NFKAMP_PLAYINGCOMMENT then
                        applyHCommand('mp3reset');
                SYS_NFKAMP_PLAYINGCOMMENT := false;

                for i := 0 to BRICK_X-1 do begin      // brickz
                for a := 0 to BRICK_Y-1 do begin
                        if bbb[i,a].image > 0 then
                        if bbb[i,a].respawntime > 0 then bbb[i,a].respawntime := 0;
                end;
                end;

                for e := 0 to 1000 do
                        aaa[e].dead := 2; // clear objects

                gametic := 0;
                gametime := 0;
                gamesudden := 0;
                OPT_SPEEDDEMO := 20;
                contime := 0; contime2 := 0; contime3 := 0; contime4 := 0;
                MATCH_SUDDEN := false;
                draworder := random(2);

                if MATCH_GAMETYPE = GAMETYPE_TRIXARENA then begin
                        MATCH_GAMETYPE := GAMETYPE_FFA;
                        OPT_NOPLAYER:=0;
                        end;

                MP_WAITSNAPSHOT := false;
                DDEMO_VERSION := 0;
                if OPT_CACHELEVEL = 3 then begin // i
                        ctgr := 255; tgr := 0;
                        end;

                // KILL 050 BNET

                Network_SendAllQueue;
                BNET_ISMULTIP := 0; //now. im not use network.
                BNET_LOBBY_STATUS := 0;
                BNET_CONNECTING := false;
//                BNET1.Active := false;
                if mainform.LOBBY.Active then mainform.LOBBY.Close;
                SV_Remember_Score_Clear;
                VOTE_ClearVote;
                BNET1.CleanUp;

                if TCPSERV.Listen then TCPSERV.Listen := false;
                if TCPCLIENT.Connected then TCPCLIENT.Connected := false;

                BNET1.CleanUp;
                INMENU := true;
        end;

// ------------------------------------------------------------
if strpar(s,0) = 'autorecord' then begin
        if INMENU then begin addmessage('Can record only in game.'); exit;end;
        if MATCH_DRECORD then begin addmessage('Already recording.'); exit;end;
        if MATCH_DDEMOPLAY then begin addmessage('Cant record. demo is playing.'); exit;end;
        if MATCH_GAMEEND then begin addmessage('Game finished. Please restart.'); exit;end;

  //      addmessage(map_filename_fullpath);

//        exit;

        demo_name := '';

        e := GetNumberOfPlayers;

        for i := 0 to 7 do if players[i] <> nil then
                demo_name := demo_name + copy(StripColorName(players[i].netname), 1, 30-e*3)  +'_';
        demo_name := demo_name + '(';

        st := lowercase(extractfilename(map_filename_fullpath));

        demo_name := demo_name + copy(st, 1, length(st)-5)+')_';

        case MATCH_GAMETYPE of
        GAMETYPE_FFA:st := 'DM';
        GAMETYPE_TEAM:st := 'TDM';
        GAMETYPE_CTF:st := 'CTF';
        GAMETYPE_RAILARENA:st := 'RAIL';
        GAMETYPE_TRIXARENA:st := 'TRIX';
        GAMETYPE_PRACTICE:st := 'PRAC';
        GAMETYPE_DOMINATION:st := 'DOM';
        end;
        demo_name := demo_name + st + '_'

        +datetostr(date)+'_'+timetostr(time);
        demo_name := toValidFilename(demo_name);
        applyHcommand('record '+demo_name);
end;


// ------------------------------------------------------------
if strpar(s,0) = 'record' then begin
//      addmessage('demos currently disbled...'); exit;

        if strpar(s,1) = '' then begin addmessage('Usage: record filename'); exit;end;
        if INMENU then begin addmessage('Can record only in game.'); exit;end;
        if MATCH_DRECORD then begin addmessage('Already recording.'); exit;end;
        if MATCH_DDEMOPLAY then begin addmessage('Cant record. demo is playing.'); exit;end;
        if MATCH_GAMEEND then begin addmessage('Game finished. Please restart.'); exit;end;
//      if MSG_DISABLE = true then begin MSG_DISABLE := false; addmessage('Game finished. Please restart.'); exit;end;
//      if ismultip>0 then begin addmessage('^1not avaible yet...'); exit;end;

        addmessage('recording '+strpar_next(s,1)+'.ndm');

        DemoStream.Position := 0;
        DemoStreamBZ.Clear;
        DemoStream.Clear;

        demofilename := rootdir+'\demos\'+strpar_next(s,1)+'.ndm';

        // savemap
        header.ID      := 'NDEM';
        header.Version := 6; // DEMO VERSION.
        header.Author := map_author;
        header.mapname := map_name;
        header.BG := map_bg;
        header.MapSizeX := BRICK_X;
        header.MapSizeY := BRICK_Y;
        header.GAMETYPE := MATCH_GAMETYPE;

        a:= 0;
        for i := 0 to $FF do if ddd[i].active = true then inc(a);
        header.numobj := a;
        header.numlights := 0;
        DemoStream.Write(Header,Sizeof(Header));

          for a := 0 to BRICK_Y-1 do begin
          for i := 0 to BRICK_X do begin
                if (bbb[i,a].image =0) and (bbb[i,a].respawntime = -1) then buf[i]:= 35 else
                buf[i]:= bbb[i,a].image ;
                end;
          DemoStream.Write(buf,BRICK_X);
          end;

        for i := 0 to $FF do
        if ddd[i].active = true then
                DemoStream.Write(ddd[i],Sizeof(ddd[i]));

        if SYS_USECUSTOMPALETTE then begin // include palette...
                FillChar(Entry,Sizeof(Entry),0);
                Entry.EntryType := 'pal';
                Entry.DataSize := DeCompressedPaletteStream.Size;
                Entry.Reserved5 := SYS_USECUSTOMPALETTE_TRANS_COLOR;
                Entry.Reserved6 := SYS_USECUSTOMPALETTE_TRANSPARENT;
                DemoStream.Write(Entry,sizeof(entry));

                DeCompressedPaletteStream.Position := 0;
                DemoStream.CopyFrom(DeCompressedPaletteStream,DeCompressedPaletteStream.size);
        end;

        // save locations table.
        if GetLocationsCount>0 then begin
                FillChar(Entry,Sizeof(Entry),0);
                Entry.EntryType := 'loc';
                Entry.Datasize := GetLocationsCount*sizeof(TLocationText);
                DemoStream.Write(Entry,sizeof(entry));
                for i := 1 to 50 do if LocationsArray[i].enabled then
                DemoStream.Write(LocationsArray[i],sizeof(LocationsArray[i]));
//                addmessage('^1DEBUG demo: saved loc table. count:'+inttostR(getlocationscount)+'*'+
//                inttostR(sizeof(TLocationText))+'='+inttostr(Entry.Datasize));
        end;

        // REMEMBER_THE_TIME!
        ddata.gametic := gametic;
        ddata.gametime := gametime;
        ddata.type0 := 3;
        DemoStream.Write( ddata, Sizeof(ddata));
        DImmediateTimeSet.newgametic := gametic;
        DImmediateTimeSet.newgametime  := gametime;
        DImmediateTimeSet.warmup := MATCH_STARTSIN;
        DemoStream.Write(DImmediateTimeSet, Sizeof(DImmediateTimeSet));


        // save players.
        for i := 0 to 7 do if players[i] <> nil then begin
                DData.gametic := gametic;
                DData.gametime := gametime;
                DData.type0 := DDEMO_CREATEPLAYERV2;
                DemoStream.Write(DData, Sizeof(DData));
                DSpawnPlayerV2.x := round(players[i].x);
                DSpawnPlayerV2.y := round(players[i].y);
                DSpawnPlayerV2.dir := players[i].dir;
                DSpawnPlayerV2.team := players[i].team;
                DSpawnPlayerV2.dead := players[i].dead;
                DSpawnPlayerV2.DXID := players[i].DXID;
                if MODELEXISTS(players[i].realmodel) then
                        DSpawnPlayerV2.modelname := players[i].realmodel else
                        DSpawnPlayerV2.modelname := players[i].nfkmodel;
                DSpawnPlayerV2.netname := players[i].netname;
                DSpawnPlayerV2.reserved := 0;
                DemoStream.Write(DSpawnPlayerV2, Sizeof(DSpawnPlayerV2));
        end;

        if ismultip>0 then begin
        // detect multiplayer in demo...
                ddata.gametic := gametic;
                ddata.gametime := gametime;
                ddata.type0 := DDEMO_MPSTATE;
                DemoStream.Write( ddata, Sizeof(ddata));
                DMultiplayer.y := ismultip;
                DMultiplayer.pov := OPT_1BARTRAX;
                DemoStream.Write( DMultiplayer, Sizeof(DMultiplayer));
        end;

        for i := 0 to BRICK_X-1 do for a := 0 to BRICK_Y-1 do
        if bbb[i,a].image > 0 then if bbb[i,a].respawnable then if bbb[i,a].respawntime = 0 then begin
                DData.type0 := DDEMO_ITEMAPEAR;
                DData.gametic := 0;
                DData.gametime := 0;
                DItemDissapear.x := i;
                DItemDissapear.y := a;
                DItemDissapear.i := bbb[i,a].image;
                DemoStream.Write(DData, Sizeof(DData));
                DemoStream.Write(DItemDissapear, Sizeof(DItemDissapear));
                end;

        for i := 0 to $FF do if ddd[i].active then begin        // save obj states.
                if (ddd[i].objtype = 2) and (ddd[i].targetname=1) then begin
                        ddata.gametic := gametic;
                        ddata.gametime := gametime;
                        ddata.type0 := DDEMO_OBJCHANGESTATE;
                        DemoStream.Write(DData, Sizeof(DData));
                        DObjChangeState.objindex := i;
                        DObjChangeState.state := 1;     // active
                        DemoStream.Write(DObjChangeState, Sizeof(DObjChangeState));
                end;
                if (ddd[i].objtype = 3) then begin
                        ddata.gametic := gametic;
                        ddata.gametime := gametime;
                        ddata.type0 := DDEMO_OBJCHANGESTATE;
                        DemoStream.Write(DData, Sizeof(DData));
                        DObjChangeState.objindex := i;
                        DObjChangeState.state := ddd[i].target;     // active
                        DemoStream.Write(DObjChangeState, Sizeof(DObjChangeState));
                end;
        end;

        demo_name := strpar_next(s,1);
        demo_name_str := demo_name;
        MATCH_DRECORD := true;

        g_DemoRecord_droppableObjects;

        // record ctf gamestate.
        if MATCH_GAMETYPE = GAMETYPE_CTF then begin
                Ddata.gametic := gametic;
                Ddata.gametime := gametime;
                Ddata.type0 := DDEMO_CTF_GAMESTATE;
                DemoStream.Write(DData, Sizeof(DData));
                DCTF_GameState.RedFlagAtBase := CTF_RedFlagAtBase;
                DCTF_GameState.BlueFlagAtBase := CTF_BlueFlagAtBase;
                DCTF_GameState.RedScore := MATCH_REDTEAMSCORE;
                DCTF_GameState.BlueScore := MATCH_BLUETEAMSCORE;
                DemoStream.Write(DCTF_GameState, Sizeof(DCTF_GameState));

                // remember ctf flagcarriers.
                for i := 0 to 7 do if players[i] <> nil then
                if players[i].flagcarrier then begin
                        Ddata.gametic := gametic;
                        Ddata.gametime := gametime;
                        Ddata.type0 := DDEMO_CTF_FLAGCARRIER;
                        DCTF_FlagCarrier.DXID := players[i].DXID;
                        DemoStream.Write(DData, Sizeof(DData));
                        DemoStream.Write(DCTF_FlagCarrier, Sizeof(DCTF_FlagCarrier));
                end;
        end;

end;
// ------------------------------------------------------------
if strpar(s,0) = 'demo' then begin
        if inmenu=false then begin addmessage('Can playdemo only from mainmenu.'); exit;end;;
        if MATCH_DRECORD then begin addmessage('Cant playdemo, recording now.'); exit;end;
        if MATCH_DDEMOPLAY then begin addmessage('Cant playdemo. already playing.'); exit;end;
        if strpar(s,1) = '' then begin addmessage('Usage: demo filename'); exit;end;
        if MATCH_GAMEEND then begin addmessage('Game finished. Please restart.'); exit;end;
        if not (fileexists(rootdir+'\demos\'+strpar_next(s,1)+'.ndm'))// and
//        not (fileexists(strpar_next(s,1)+'.ndm'))
        then begin addmessage(strpar_next(s,1) + '.ndm not found.'); exit; end;

        tmp := '';
        st := extractfilename(strpar_next(s,1));

        LastDemoCommand := s;

        // COMMENTS AUTO PLAY
        // -------------------------
        if OPT_SOUND then
        if fileexists(lowercase(rootdir+'\demos\'+strpar_next(s,1)+'.mp3')) then tmp := lowercase(rootdir+'\demos\'+strpar_next(s,1)+'.mp3') else
        if fileexists(lowercase(rootdir+'\music\'+strpar_next(s,1)+'.mp3')) then tmp := lowercase(rootdir+'\music\'+strpar_next(s,1)+'.mp3') else
        if fileexists(lowercase(rootdir+'\demos\'+st+'.mp3')) then tmp := lowercase(rootdir+'\demos\'+st+'.mp3') else
        if fileexists(lowercase(rootdir+'\music\'+st+'.mp3')) then tmp := lowercase(rootdir+'\music\'+st+'.mp3');
        // -------------------------

        if tmp <>'' then
        begin
                if SYS_NFKAMPSTATE > 0 then applyHcommand('mp3stop');
                mp3list.clear;
                FMODStream := FSOUND_Stream_OpenFile(pchar(tmp), FSOUND_LOOP_OFF or FSOUND_NORMAL, 0);
                stp := FSOUND_Stream_Play(FSOUND_FREE, FMODStream);
                FSOUND_SetVolume(stp, trunc(OPT_MP3VOLUME*2.5));
                SYS_NFKAMPREFRESH := 0;
                SYS_NFKAMPSTATE := 1;
                SYS_NFKAMP_PLAYINGCOMMENT := true;
        end;

        MSG_DISABLE := false;
        loadi.cns.lines.add ('demo playing: '+strpar_next(s,1));

        ctgr := 255; tgr := 0;
        OPT_1BARTRAX := 0;
        OPT_2BARTRAX := 1;

        DemoStream.position := 0;
        DemoStreamBZ.position := 0;
        DemoStreamBZ.Clear;
        DemoStream.Clear;
        DemoStreamBZ.LoadFromFile (rootdir+'\demos\'+strpar_next(s,1)+'.ndm');
        DemoStreamBZ.position := 0;
        PowerArcDeCompress(DemoStreamBZ, DemoStream, DemoStreamProgressEvent);
        DemoStream.position := 0;

        SYS_BAR2AVAILABLE := true;
        MATCH_DDEMOMPPLAY := 0;
        MATCH_DEMOPLAYING := true;

        for e := 0 to 1000 do aaa[e].dead := 2; // clear objects
        mainform.dxtimer.fps := 50;
        MATCH_STARTSIN := MATCH_WARMUP*50;
        gametic := 0; gametime := 0;
        SYS_USECUSTOMPALETTE := false;// disabled by default;
        LOADMAP('demo',false);

        if lowercase(strpar_next(s,1)) = 'demo1' then
        if OPT_ALLOWMAPCHANGEBG then OPT_BG := 2; // optimiza

        map_info := 8;
        INMENU := false;

        addmessage('Playing demo "'+extractfilename(strpar_next(s,1)+'.ndm')+'". Using demo engine version '+inttostr(DDEMO_VERSION));
        if (DDEMO_VERSION < 3) or (DDEMO_VERSION > 6) then begin
               addmessage('Demo version is '+inttostr(DDEMO_VERSION)+'. Demo Engine version is 6 (support 3-6). Cant play.');
               applyhcommand('disconnect');
               exit;
        end;

        DemoStream.Read(DData,sizeof(DData));
        if DData.type0 = 3 then DemoStream.read(DImmediateTimeSet,sizeof(DImmediateTimeSet));
        gametic := DImmediateTimeSet.newgametic ;
        gametime := DImmediateTimeSet.newgametime;
        MATCH_STARTSIN := DImmediateTimeSet.warmup;

        for i := 0 to BRICK_X-1 do for a := 0 to BRICK_Y-1 do
        if bbb[i,a].image > 0 then if bbb[i,a].respawnable then
                bbb[i,a].respawntime := 2;

        MATCH_DDEMOPLAY := true;
        if OPT_AUTOSHOWNAMES then begin
                OPT_AUTOSHOWNAMESTIME := OPT_AUTOSHOWNAMESDEFTIME+4;
                OPT_SHOWNAMES := TRUE;
        end;

        if MATCH_GAMETYPE=GAMETYPE_DOMINATION then
                DOM_Reset;

        inconsole := false;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'stoprecord' then begin
        if MATCH_DRECORD=false then begin addmessage('Not recording.'); exit;end;
        if MATCH_DRECORD then DemoEnd(END_JUSTEND);
end;

// ------------------------------------------------------------
if strpar(s,0) = 'join' then begin
        if INMENU=true then begin addmessage('Use this command in the match.'); exit; end;
        if ISMULTIP=0 then begin addmessage('This command for multiplayer teamgame only.'); exit; end;
        if not TeamGame then begin addmessage('This command for teamgame only.'); exit; end;
        if (ISMULTIP=1) and (MATCH_STARTSIN < 250) and (strpar(s,2) <> '#auto') then begin addmessage('can join at the warmup only'); exit; end;
        if (ISMULTIP=2) and (MATCH_FAKESTARTSIN < 5) and (strpar(s,2) <> '#auto') then begin addmessage('can join at the warmup only'); exit; end;

        if strpar(s,1) = 'red' then
        for i := 0 to 7 do if players[i] <> nil then
                if players[i].netobject = false then
//                if players[i].team = 2 then
                begin
                        players[i].team := 1;
                        SYS_TEAMSELECT := 0;
                        ASSIGNMODEL(players[i]);

                        if MSG_DISABLE=TRUE then begin
                                MSG_DISABLE := false;
                                addmessage(players[i].netname + ' ^7^njoined ^1RED ^7team');
                                MSG_DISABLE := true;
                                end else

                        addmessage(players[i].netname + ' ^7^njoined ^1RED ^7team');

                        if ismultip>0 then begin
                                MsgSize := SizeOf(TMP_TeamSelect);
                                Msg8.DATA := MMP_TEAMSELECT;
                                Msg8.DXID := players[i].dxid;
                                Msg8.team := players[i].team;
                                if ismultip=1 then
                                mainform.BNETSendData2All (Msg8, MsgSize, 1) else
                                mainform.BNETSendData2HOST(Msg8, MsgSize, 1);

                        end;

                        if MATCH_DRECORD then begin
                               DData.type0 := DDEMO_TEAMSELECT;
                               DData.gametic := gametic;
                               DData.gametime := gametime;
                               DemoStream.Write( DData, Sizeof(DData));
                               DNETTeamSelect.DXID := players[i].DXID;
                               DNETTeamSelect.team := players[i].team;
                               DemoStream.Write( DNETTeamSelect, Sizeof(DNETTeamSelect));
                        end;

                        ApplyModels();
                        exit;
                end;

        if (strpar(s,1) = 'blue') or
           (strpar(s,1) = 'blu') then
        for i := 0 to 7 do if players[i] <> nil then
                if players[i].netobject = false then
//                if players[i].team = 2 then
                begin
                        players[i].team := 0;
                        SYS_TEAMSELECT := 0;
                        ASSIGNMODEL(players[i]);
                        if MSG_DISABLE=TRUE then begin
                                MSG_DISABLE := false;
                                addmessage(players[i].netname + ' ^7^njoined ^4BLUE ^7team');
                                MSG_DISABLE := true;
                                end else
                        addmessage(players[i].netname + ' ^7^njoined ^4BLUE ^7team');

                        if ismultip>0 then begin
                                MsgSize := SizeOf(TMP_TeamSelect);
                                Msg8.DATA := MMP_TEAMSELECT;
                                Msg8.DXID := players[i].dxid;
                                Msg8.team := players[i].team;

                                if ismultip=1 then
                                mainform.BNETSendData2All (Msg8, MsgSize, 1) else
                                mainform.BNETSendData2HOST(Msg8, MsgSize, 1);
                        end;

                        if MATCH_DRECORD then begin
                               DData.type0 := DDEMO_TEAMSELECT;
                               DData.gametic := gametic;
                               DData.gametime := gametime;
                               DemoStream.Write( DData, Sizeof(DData));
                               DNETTeamSelect.DXID := players[i].DXID;
                               DNETTeamSelect.team := players[i].team;
                               DemoStream.Write( DNETTeamSelect, Sizeof(DNETTeamSelect));
                        end;

                        ApplyModels();
                        exit;
                end;

        if (strpar(s,1) = '') or
           (strpar(s,1) = 'auto') then

                if GetRedPlayers > GetBluePlayers then begin
                        for i := 0 to 7 do if players[i] <> nil then
                        if players[i].netobject = false then begin
                        players[i].team := 0;
                        SYS_TEAMSELECT := 0;
                        ASSIGNMODEL(players[i]);

                        if MSG_DISABLE=TRUE then begin
                                MSG_DISABLE := false;
                                addmessage(players[i].netname + ' ^7^njoined ^4BLUE ^7team');
                                MSG_DISABLE := true;
                                end else

                        addmessage(players[i].netname + ' ^7^njoined ^4BLUE ^7team');

                        if ismultip>0 then begin
                                MsgSize := SizeOf(TMP_TeamSelect);
                                Msg8.DATA := MMP_TEAMSELECT;
                                Msg8.DXID := players[i].dxid;
                                Msg8.team := players[i].team;
                                if ismultip=1 then
                                mainform.BNETSendData2All (Msg8, MsgSize, 1) else
                                mainform.BNETSendData2HOST(Msg8, MsgSize, 1);
                        end;
                        if MATCH_DRECORD then begin
                               DData.type0 := DDEMO_TEAMSELECT;
                               DData.gametic := gametic;
                               DData.gametime := gametime;
                               DemoStream.Write( DData, Sizeof(DData));
                               DNETTeamSelect.DXID := players[i].DXID;
                               DNETTeamSelect.team := players[i].team;
                               DemoStream.Write( DNETTeamSelect, Sizeof(DNETTeamSelect));
                        end;

                        ApplyModels();
                        exit;
                        end;
                end else if GetRedPlayers < GetBluePlayers then begin // auto, join
                        for i := 0 to 7 do if players[i] <> nil then if players[i].netobject = false then begin
                        players[i].team := 1;
                        SYS_TEAMSELECT := 0;
                        ASSIGNMODEL(players[i]);

                        if MSG_DISABLE=TRUE then begin
                                MSG_DISABLE := false;
                                addmessage(players[i].netname + ' ^7^njoined ^1RED ^7team');
                                MSG_DISABLE := true;
                                end else

                        addmessage(players[i].netname + ' ^7^njoined ^1RED ^7team');

                        if ismultip>0 then begin
                                MsgSize := SizeOf(TMP_TeamSelect);
                                Msg8.DATA := MMP_TEAMSELECT;
                                Msg8.DXID := players[i].dxid;
                                Msg8.team := players[i].team;
                                if ismultip=1 then
                                mainform.BNETSendData2All (Msg8, MsgSize, 1) else
                                mainform.BNETSendData2HOST(Msg8, MsgSize, 1);
                        end;

                        if MATCH_DRECORD then begin
                               DData.type0 := DDEMO_TEAMSELECT;
                               DData.gametic := gametic;
                               DData.gametime := gametime;
                               DemoStream.Write( DData, Sizeof(DData));
                               DNETTeamSelect.DXID := players[i].DXID;
                               DNETTeamSelect.team := players[i].team;
                               DemoStream.Write( DNETTeamSelect, Sizeof(DNETTeamSelect));
                        end;

                        ApplyModels();
                        exit;
                        end;
                end else begin// random join auto
                        for i := 0 to 7 do if players[i] <> nil then if players[i].netobject = false then begin
                        players[i].team := random(2);
                        SYS_TEAMSELECT := 0;
                        ASSIGNMODEL(players[i]);

                        if MSG_DISABLE=TRUE then begin
                                MSG_DISABLE := false;
                                addmessage(players[i].netname + ' ^7^njoined ^1RED ^7team');
                                MSG_DISABLE := true;
                                end else

                        addmessage(players[i].netname + ' ^7^njoined ^1RED ^7team');

                        if ismultip>0 then begin
                                MsgSize := SizeOf(TMP_TeamSelect);
                                Msg8.DATA := MMP_TEAMSELECT;
                                Msg8.DXID := players[i].dxid;
                                Msg8.team := players[i].team;
                                if ismultip=1 then
                                mainform.BNETSendData2All (Msg8, MsgSize, 1) else
                                mainform.BNETSendData2HOST(Msg8, MsgSize, 1);
                        end;

                        if MATCH_DRECORD then begin
                               DData.type0 := DDEMO_TEAMSELECT;
                               DData.gametic := gametic;
                               DData.gametime := gametime;
                               DemoStream.Write( DData, Sizeof(DData));
                               DNETTeamSelect.DXID := players[i].DXID;
                               DNETTeamSelect.team := players[i].team;
                               DemoStream.Write( DNETTeamSelect, Sizeof(DNETTeamSelect));
                        end;

                        ApplyModels();
                        exit;
                        end;

                end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'echo' then begin
        if strpar(s,1) = '' then exit;
        if MSG_DISABLE then begin
                MSG_DISABLE := false;
                tmp := '';
                i := 1;
                repeat
                if i = 1 then
                tmp := strpar(ss,i) else
                tmp := tmp + ' '+strpar(ss,i);
                inc(i);
                until strpar(ss,i) = '';
                addmessage(tmp);
                MSG_DISABLE := false;
        end else begin
                tmp := '';
                i := 1;
                repeat
                if i = 1 then
                tmp := strpar(ss,i) else
                tmp := tmp + ' '+strpar(ss,i);
                inc(i);
                until strpar(ss,i) = '';
                addmessage(tmp);
                end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'mo' then begin
        menueditmode := 0;
        menu_sl := 0;
        menu_tab := 0;
        menuorder := strtoint(strpar(s,1));
        end;

if strpar(s,0) = 'test10' then
        SYS_TEST10 := strtoint (strpar(s,1));

// ------------------------------------------------------------
if strpar(s,0) = 'writeconfig' then begin
        if strpar(s,1)='' then begin
                addmessage('USAGE: writeconfig <filename>');
                exit;
                end;

        par := lowercase(strpar(s,1));

        if extractfileext(par) = '.cfg' then
                par := copy (par,1,length(par) - 4);

        if par = 'nfkconfig' then begin
                addmessage('You can''t overwrite nfkconfig.cfg, please select another config name.');
                exit;
                end;

        if not fileexists(ROOTDIR+'\'+par+'.cfg') then
                addmessage('^2'+par+'.cfg saved.') else
        addmessage('^2'+par+'.cfg saved (overwrited).');

        SaveCFG(par);
end;

// ------------------------------------------------------------
if strpar(s,0) = 'ready' then begin
        if ismultip=2 then exit;
        if MATCH_DDEMOPLAY then begin addmessage('Not able in demo.'); exit; end;
        if players[0] = nil then begin addmessage('cannot execute command. no server.'); exit; end;
        if MATCH_STARTSIN > 250 then begin
                MATCH_STARTSIN := 250;
                if MATCH_DRECORD then begin              // record to demo !!!!!
                        DData.type0 := DDEMO_READYPRESS;               //
                        DData.gametic := gametic;
                        DData.gametime := gametime;
                        DemoStream.Write(DData, Sizeof(DData));
                        DReadyPress.newmatch_statsin := MATCH_STARTSIN;
                        DemoStream.Write(DReadyPress, Sizeof(DReadyPress));
                end;

                end;
        end;
// ------------------------------------------------------------
if strpar(s,0) = 'stats' then begin
        addmessage('this command disabled');
end;
// ------------------------------------------------------------
if strpar(s,0) = 'currenttime' then addmessage('current time is: ^3'+timetostr(Time));
// ------------------------------------------------------------
if strpar(s,0) = 'restart' then begin
        if MATCH_DEMOPLAYING then begin
                applyHCommand('disconnect');
                applyHCommand(LastDemoCommand);
                exit;
                end;

        if MATCH_DDEMOPLAY then begin addmessage('Not able in demo.'); exit; end;
        if DDEMO_VERSION>0 then begin addmessage('Not able in demo.'); exit; end;
        if ismultip=2 then begin addmessage('server side command.'); exit; end;
        if players[0] = nil then begin addmessage('cannot execute command. no server.'); exit; end;
        if MATCH_DRECORD then DemoEnd(END_JUSTEND);
        MATCH_STARTSIN := MATCH_WARMUP*50;

        if ismultip=1 then begin
                MsgSize := SizeOf(TMP_SV_MapRestart);
                Msg4.DATA := MMP_MAPRESTART;
                Msg4.reason := 1;// respawn all itemz;
                mainform.BNETSendData2All (Msg4, MsgSize, 1);
        end;

        if MATCH_GAMETYPE = GAMETYPE_TRIXARENA then begin
                if OPT_TRIXMASTA then
                        MATCH_STARTSIN := 150 else begin
                                MATCH_STARTSIN := 500;
                                playsound(SND_prepare,0,0);
                        end;
                end else playsound(SND_prepare,0,0);

        MAP_RESTART;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'bind' then begin          //[65-90][97-122]
        kk := 0;
        if length(strpar(s,1)) = 1 then begin
                if (ord(strpar(s,1)[1]) >= 97) and (ord(strpar(s,1)[1]) <= 122) then kk := ord(strpar(s,1)[1])-32;
                if (ord(strpar(s,1)[1]) >= 46) and (ord(strpar(s,1)[1]) <= 59) then kk := ord(strpar(s,1)[1]);
        end;

        if strpar(s,1) = 'shift' then kk := 16 else
        if strpar(s,1) = 'ctrl' then kk := 17 else
        if strpar(s,1) = 'alt' then kk := 18 else
        if strpar(s,1) = 'tab' then kk := 9 else
        if strpar(s,1) = 'space' then kk := 32 else
        if strpar(s,1) = 'capslock' then kk := 20 else
    //    if strpar(s,1) = '\' then kk := 92 else
        if strpar(s,1) = 'num0' then kk := 96 else
        if strpar(s,1) = 'num1' then kk := 97 else
        if strpar(s,1) = 'num2' then kk := 98 else
        if strpar(s,1) = 'num3' then kk := 99 else
        if strpar(s,1) = 'num4' then kk := 100 else
        if strpar(s,1) = 'num5' then kk := 101 else
        if strpar(s,1) = 'num6' then kk := 102 else
        if strpar(s,1) = 'num7' then kk := 103 else
        if strpar(s,1) = 'num8' then kk := 104 else
        if strpar(s,1) = 'num9' then kk := 105 else
        if strpar(s,1) = 'num/' then kk := 111 else
        if strpar(s,1) = 'num*' then kk := 106 else
//        if strpar(s,1) = ',' then kk := 44 else
        if strpar(s,1) = 'num-' then kk := 109 else
        if strpar(s,1) = 'num+' then kk := 107 else
        if strpar(s,1) = 'num.' then kk := 110 else
        if strpar(s,1) = 'enter' then kk := 13 else
        if strpar(s,1) = 'insert' then kk := 45 else
        if strpar(s,1) = 'home' then kk := 36 else
        if strpar(s,1) = 'pgup' then kk := 33 else
        if strpar(s,1) = 'pgdown' then kk := 34 else
        if strpar(s,1) = 'delete' then kk := 46 else
  //      if strpar(s,1) = '/' then kk := 47 else
        if strpar(s,1) = 'end' then kk := 35 else
        if strpar(s,1) = 'backspace' then kk := 8 else
        if strpar(s,1) = 'leftarrow' then kk := 37 else
        if strpar(s,1) = 'rightarrow' then kk := 39 else
        if strpar(s,1) = 'uparrow' then kk := 38 else
        if strpar(s,1) = 'downarrow' then kk := 40 else
        if strpar(s,1) = 'mbutton1' then kk := ord(mbutton1) else
        if strpar(s,1) = 'mbutton2' then kk := ord(mbutton2) else
        if strpar(s,1) = 'mbutton3' then kk := ord(mbutton3) else
        if strpar(s,1) = 'mwheelup' then kk := ord(mscrollup) else
        if strpar(s,1) = 'mwheeldown' then kk := ord(mscrolldn);

        if kk > 0 then begin
                if strpar(s,2) > '' then unbindkey(kk);
                if strpar(s,2) = 'moveup' then CTRL_MOVEUP := kk else
                if strpar(s,2) = 'moveleft' then CTRL_MOVELEFT := kk else
                if strpar(s,2) = 'moveright' then CTRL_MOVERIGHT := kk else
                if strpar(s,2) = 'movedown' then CTRL_MOVEDOWN := kk else
                if strpar(s,2) = 'nextweapon' then CTRL_NEXTWEAPON := kk else
                if strpar(s,2) = 'prevweapon' then CTRL_PREVWEAPON := kk else
                if strpar(s,2) = 'lookup' then CTRL_LOOKUP := kk else
                if strpar(s,2) = 'lookdown' then CTRL_LOOKDOWN := kk else
                if strpar(s,2) = 'fire' then CTRL_FIRE := kk else
                if strpar(s,2) = 'p2moveup' then CTRL_P2MOVEUP := kk else
                if strpar(s,2) = 'p2moveleft' then CTRL_P2MOVELEFT := kk else
                if strpar(s,2) = 'p2moveright' then CTRL_P2MOVERIGHT := kk else
                if strpar(s,2) = 'p2movedown' then CTRL_P2MOVEDOWN := kk else
                if strpar(s,2) = 'p2nextweapon' then CTRL_P2NEXTWEAPON := kk else
                if strpar(s,2) = 'p2prevweapon' then CTRL_P2PREVWEAPON := kk else
                if strpar(s,2) = 'p2lookup' then CTRL_P2LOOKUP := kk else
                if strpar(s,2) = 'p2lookdown' then CTRL_P2LOOKDOWN := kk else
                if strpar(s,2) = 'p2fire' then CTRL_P2FIRE := kk else
                if strpar(s,2) = 'center' then CTRL_CENTER := kk else
                if strpar(s,2) = 'weapon0' then CTRL_WEAPON0 := kk else
                if strpar(s,2) = 'weapon1' then CTRL_WEAPON1 := kk else
                if strpar(s,2) = 'weapon2' then CTRL_WEAPON2 := kk else
                if strpar(s,2) = 'weapon3' then CTRL_WEAPON3 := kk else
                if strpar(s,2) = 'weapon4' then CTRL_WEAPON4 := kk else
                if strpar(s,2) = 'weapon5' then CTRL_WEAPON5 := kk else
                if strpar(s,2) = 'weapon6' then CTRL_WEAPON6 := kk else
                if strpar(s,2) = 'weapon7' then CTRL_WEAPON7 := kk else
                if strpar(s,2) = 'weapon8' then CTRL_WEAPON8 := kk else
                if strpar(s,2) = 'scoreboard' then CTRL_SCOREBOARD := kk else
                if strpar(s,2) = 'p2center' then CTRL_P2CENTER := kk else
                if strpar(s,2) = 'p2weapon0' then CTRL_P2WEAPON0 := kk else
                if strpar(s,2) = 'p2weapon1' then CTRL_P2WEAPON1 := kk else
                if strpar(s,2) = 'p2weapon2' then CTRL_P2WEAPON2 := kk else
                if strpar(s,2) = 'p2weapon3' then CTRL_P2WEAPON3 := kk else
                if strpar(s,2) = 'p2weapon4' then CTRL_P2WEAPON4 := kk else
                if strpar(s,2) = 'p2weapon5' then CTRL_P2WEAPON5 := kk else
                if strpar(s,2) = 'p2weapon6' then CTRL_P2WEAPON6 := kk else
                if strpar(s,2) = 'p2weapon7' then CTRL_P2WEAPON7 := kk else
                if strpar(s,2) = 'p2weapon8' then CTRL_P2WEAPON8 := kk else
                if strpar(s,2) <> '' then ALIAS_Assign(Ss,strpar(ss,2),kk);

        end;
        if strpar(s,2) = '' then begin
                if kk = 0 then begin addmessage('"'+strpar(s,1)+'" possibly unbinded'); exit; end else
                if kk = ord(CTRL_LOOKUP) then addmessage('"'+strpar(s,1)+'" binded to "lookup"') else
                if kk = ord(CTRL_LOOKDOWN) then addmessage('"'+strpar(s,1)+'" binded to "lookdown"') else
                if kk = ord(CTRL_FIRE) then addmessage('"'+strpar(s,1)+'" binded to "fire"') else
                if kk = ord(CTRL_MOVEUP) then addmessage('"'+strpar(s,1)+'" binded to "moveup"') else
                if kk = ord(CTRL_MOVEDOWN) then addmessage('"'+strpar(s,1)+'" binded to "movedown"') else
                if kk = ord(CTRL_MOVELEFT) then addmessage('"'+strpar(s,1)+'" binded to "moveleft"') else
                if kk = ord(CTRL_MOVERIGHT) then addmessage('"'+strpar(s,1)+'" binded to "moveright"') else
                if kk = ord(CTRL_NEXTWEAPON) then addmessage('"'+strpar(s,1)+'" binded to "nextweapon"') else
                if kk = ord(CTRL_PREVWEAPON) then addmessage('"'+strpar(s,1)+'" binded to "prevweapon"') else
                if kk = ord(CTRL_P2MOVEUP) then addmessage('"'+strpar(s,1)+'" binded to "p2moveup"') else
                if kk = ord(CTRL_P2MOVEDOWN) then addmessage('"'+strpar(s,1)+'" binded to "p2movedown"') else
                if kk = ord(CTRL_P2MOVELEFT) then addmessage('"'+strpar(s,1)+'" binded to "p2moveleft"') else
                if kk = ord(CTRL_P2MOVERIGHT) then addmessage('"'+strpar(s,1)+'" binded to "p2moveright"') else
                if kk = ord(CTRL_P2NEXTWEAPON) then addmessage('"'+strpar(s,1)+'" binded to "p2nextweapon"') else
                if kk = ord(CTRL_P2PREVWEAPON) then addmessage('"'+strpar(s,1)+'" binded to "p2prevweapon"') else
                if kk = ord(CTRL_P2LOOKUP) then addmessage('"'+strpar(s,1)+'" binded to "p2lookup"') else
                if kk = ord(CTRL_P2LOOKDOWN) then addmessage('"'+strpar(s,1)+'" binded to "p2lookdown"') else
                if kk = ord(CTRL_P2FIRE) then addmessage('"'+strpar(s,1)+'" binded to "p2fire"') else
                if kk = ord(CTRL_CENTER) then addmessage('"'+strpar(s,1)+'" binded to "center"') else
                if kk = ord(CTRL_WEAPON0) then addmessage('"'+strpar(s,1)+'" binded to "weapon0"') else
                if kk = ord(CTRL_WEAPON1) then addmessage('"'+strpar(s,1)+'" binded to "weapon1"') else
                if kk = ord(CTRL_WEAPON2) then addmessage('"'+strpar(s,1)+'" binded to "weapon2"') else
                if kk = ord(CTRL_WEAPON3) then addmessage('"'+strpar(s,1)+'" binded to "weapon3"') else
                if kk = ord(CTRL_WEAPON4) then addmessage('"'+strpar(s,1)+'" binded to "weapon4"') else
                if kk = ord(CTRL_WEAPON5) then addmessage('"'+strpar(s,1)+'" binded to "weapon5"') else
                if kk = ord(CTRL_WEAPON6) then addmessage('"'+strpar(s,1)+'" binded to "weapon6"') else
                if kk = ord(CTRL_WEAPON7) then addmessage('"'+strpar(s,1)+'" binded to "weapon7"') else
                if kk = ord(CTRL_WEAPON8) then addmessage('"'+strpar(s,1)+'" binded to "weapon8"') else
                if kk = ord(CTRL_SCOREBOARD) then addmessage('"'+strpar(s,1)+'" binded to "scoreboard"') else
                if kk = ord(CTRL_P2CENTER) then addmessage('"'+strpar(s,1)+'" binded to "p2center"') else
                if kk = ord(CTRL_P2WEAPON0) then addmessage('"'+strpar(s,1)+'" binded to "p2weapon0"') else
                if kk = ord(CTRL_P2WEAPON1) then addmessage('"'+strpar(s,1)+'" binded to "p2weapon1"') else
                if kk = ord(CTRL_P2WEAPON2) then addmessage('"'+strpar(s,1)+'" binded to "p2weapon2"') else
                if kk = ord(CTRL_P2WEAPON3) then addmessage('"'+strpar(s,1)+'" binded to "p2weapon3"') else
                if kk = ord(CTRL_P2WEAPON4) then addmessage('"'+strpar(s,1)+'" binded to "p2weapon4"') else
                if kk = ord(CTRL_P2WEAPON5) then addmessage('"'+strpar(s,1)+'" binded to "p2weapon5"') else
                if kk = ord(CTRL_P2WEAPON6) then addmessage('"'+strpar(s,1)+'" binded to "p2weapon6"') else
                if kk = ord(CTRL_P2WEAPON7) then addmessage('"'+strpar(s,1)+'" binded to "p2weapon7"') else
                if kk = ord(CTRL_P2WEAPON8) then addmessage('"'+strpar(s,1)+'" binded to "p2weapon8"') else
                if not ALIAS_VIEW(s, kk) then addmessage('"'+strpar(s,1)+'" is unbinded');
        end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'exec' then begin
    MSG_DISABLE := TRUE;
    HIST_DISABLE := TRUE;
    LoadCFG(strpar(s,1),1);
    MSG_DISABLE := FALSE;
    HIST_DISABLE := FALSE;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'h_exec' then begin
    MSG_DISABLE := TRUE;
    HIST_DISABLE := TRUE;
    LoadCFG(strpar(s,1), 0);
    MSG_DISABLE := FALSE;
    HIST_DISABLE := FALSE;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'midiplay' then
if mainform.mediaplayer1.Enabled = false then begin
        mainform.mediaplayer1.Enabled := true;
        STARTMUSIC(0);
end;

if strpar(s,0) = 'midinext' then
if mainform.mediaplayer1.Enabled = true then begin
        mainform.mediaplayer1.Stop;
end;

if strpar(s,0) = 'midistop' then begin
mainform.mediaplayer1.Enabled := false;
mainform.mediaplayer1.stop;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'unbindkeys' then begin
        ALIAS_ClearAll;
        CTRL_MOVERIGHT := 0;
        CTRL_MOVELEFT := 0;
        CTRL_MOVEUP := 0;
        CTRL_MOVEDOWN := 0;
        CTRL_NEXTWEAPON := 0;
        CTRL_PREVWEAPON := 0;
        CTRL_LOOKUP := 0;
        CTRL_LOOKDOWN := 0;
        CTRL_FIRE := 0;
        CTRL_CENTER := 0;
        CTRL_WEAPON0 := 0;
        CTRL_WEAPON1 := 0;
        CTRL_WEAPON2 := 0;
        CTRL_WEAPON3 := 0;
        CTRL_WEAPON4 := 0;
        CTRL_WEAPON5 := 0;
        CTRL_WEAPON6 := 0;
        CTRL_WEAPON7 := 0;
        CTRL_WEAPON8 := 0;
        CTRL_SCOREBOARD := 0;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'p2unbindkeys' then begin
        CTRL_P2MOVELEFT := 0;
        CTRL_P2MOVERIGHT := 0;
        CTRL_P2MOVEUP  := 0;
        CTRL_P2MOVEDOWN  := 0;
        CTRL_P2NEXTWEAPON := 0;
        CTRL_P2PREVWEAPON := 0;
        CTRL_P2LOOKUP  := 0;
        CTRL_P2LOOKDOWN := 0;
        CTRL_P2FIRE    := 0;
        CTRL_P2CENTER := 0;
        CTRL_P2WEAPON0 := 0;
        CTRL_P2WEAPON1 := 0;
        CTRL_P2WEAPON2 := 0;
        CTRL_P2WEAPON3 := 0;
        CTRL_P2WEAPON4 := 0;
        CTRL_P2WEAPON5 := 0;
        CTRL_P2WEAPON6 := 0;
        CTRL_P2WEAPON7 := 0;
        CTRL_P2WEAPON8 := 0;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'svinfo' then begin
        addmessage('---svinfo------');
        for i := 0 to 7 do if players[i] <> nil then begin
                if players[i].netobject = false then addmessage(inttostr(i)+'|Player "'+players[i].netname+'^n^7" DXID#'+inttostr(players[i].DXID)+' IP:'+players[i].IPAddress +' (local)') else
                                addmessage(inttostr(i)+'|Player "'+players[i].netname+'^n^7" DXID#'+inttostr(players[i].DXID)+' IP:'+players[i].IPAddress +' (networked)');
        end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'volume' then begin
        exit;
        if strpar(s,1) = '' then begin addmessage('"volume" is "'+inttostr(OPT_VOLUME)+'"'); exit; end;
        try
        OPT_VOLUME := strtoint(strpar(s,1));
        except OPT_VOLUME := 1; end;
        addmessage('"volume" is set to "'+strpar(s,1)+'"');
end;
// ------------------------------------------------------------OPT_MOUSESMOOTH
if strpar(s,0)  = 'bg' then begin
        if strpar(s,1) = '' then begin addmessage('"bg" is "'+inttostr(OPT_BG)+'". Default is "1". Possible range 1-8.'); exit; end;
        try
        OPT_BG := strtoint(strpar(s,1));
        except OPT_BG := 1; end;
        if OPT_BG <= 0 then opt_bg := 1;
        if OPT_BG > 8 then opt_bg := 8;
        addmessage('"bg" is set to "'+inttostr(opt_bg)+'"');
end;

// ------------------------------------------------------------
if strpar(s,0) = 'net_predict' then begin
        if strpar(s,1) = '' then begin
                st := '"net_predict" is "';
                if OPT_NETPREDICT = true then st := st + '1' else st := st + '0';
                st := st + '". Default is "1". Possible range 0-1.';
                addmessage(st);
        end else begin
                par := strpar(s,1);
                if par='1' then OPT_NETPREDICT := true;
                if par='0' then OPT_NETPREDICT := false;
                if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else
                addmessage('invalid value "'+par+'"');
        end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'net_guaranteed' then begin
        if strpar(s,1) = '' then begin
                st := '"net_guaranteed" is "';
                if OPT_NETGUARANTEED = true then st := st + '1' else st := st + '0';
                st := st + '". Default is "1". Possible range 0-1.';
                addmessage(st);
        end else begin
                par := strpar(s,1);
                if par='1' then OPT_NETGUARANTEED := true;
                if par='0' then OPT_NETGUARANTEED := false;
                if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else
                addmessage('invalid value "'+par+'"');
        end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'net_showbandwidth' then begin
        if strpar(s,1) = '' then begin
                st := '"net_showbandwidth" is "';
                if OPT_SHOWBANDWIDTH = true then st := st + '1' else st := st + '0';
                st := st + '". Default is "0". Possible range 0-1.';
                addmessage(st);
        end else begin
                par := strpar(s,1);
                if par='1' then OPT_SHOWBANDWIDTH := true;
                if par='0' then OPT_SHOWBANDWIDTH := false;
                if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else
                addmessage('invalid value "'+par+'"');
        end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'sv_allowspectators' then begin if strpar(s,1) = '' then begin
        st := '"sv_allowspectators" is "';
        if OPT_SV_ALLOWSPECTATORS = true then st := st + '1' else st := st + '0';
        st := st + '". Default is "0". Possible range 0-1.';
        addmessage(st); end else begin
        par := strpar(s,1);
        if par='1' then OPT_SV_ALLOWSPECTATORS := true;
        if par='0' then OPT_SV_ALLOWSPECTATORS := false;
        if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else addmessage('invalid value "'+par+'"'); end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'sv_powerup' then begin if strpar(s,1) = '' then begin
        st := '"sv_powerup" is "';
        if OPT_SV_POWERUP = true then st := st + '1' else st := st + '0';
        st := st + '". Default is "0". Possible range 0-1.';
        addmessage(st); end else begin
        par := strpar(s,1);
        if par='1' then OPT_SV_POWERUP := true;
        if par='0' then OPT_SV_POWERUP := false;
        if (par = '1') or (par = '0') then begin

                if ismultip=1 then begin
                MsgSize := SizeOf(TMP_CommandResult);
                Msg9.Data := MMP_SV_COMMAND_CHANGED;
                msg9.value := integer(OPT_SV_POWERUP);
                mainform.BNETSendData2All (Msg9, MsgSize, 1);
                end;
                addmessage(strpar(s,0) + ' is set to "'+par+'"')
        end
                else addmessage('invalid value "'+par+'"'); end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'sv_allowvote' then begin if strpar(s,1) = '' then begin
        st := '"sv_allowvote" is "';
        if OPT_SV_ALLOWVOTE = true then st := st + '1' else st := st + '0';
        st := st + '". Default is "1". Possible range 0-1.';
        addmessage(st); end else begin
        par := strpar(s,1);
        if par='1' then OPT_SV_ALLOWVOTE := true;
        if par='0' then OPT_SV_ALLOWVOTE := false;
        if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else addmessage('invalid value "'+par+'"'); end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'sv_allowvote_restart' then begin if strpar(s,1) = '' then begin
        st := '"sv_allowvote_restart" is "';
        if OPT_SV_ALLOWVOTE_RESTART = true then st := st + '1' else st := st + '0';
        st := st + '". Default is "1". Possible range 0-1.';
        addmessage(st); end else begin
        par := strpar(s,1);
        if par='1' then OPT_SV_ALLOWVOTE_RESTART := true;
        if par='0' then OPT_SV_ALLOWVOTE_RESTART := false;
        if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else addmessage('invalid value "'+par+'"'); end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'sv_allowvote_fraglimit' then begin if strpar(s,1) = '' then begin
        st := '"sv_allowvote_fraglimit" is "';
        if OPT_SV_ALLOWVOTE_FRAGLIMIT = true then st := st + '1' else st := st + '0';
        st := st + '". Default is "1". Possible range 0-1.';
        addmessage(st); end else begin
        par := strpar(s,1);
        if par='1' then OPT_SV_ALLOWVOTE_FRAGLIMIT := true;
        if par='0' then OPT_SV_ALLOWVOTE_FRAGLIMIT := false;
        if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else addmessage('invalid value "'+par+'"'); end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'sv_allowvote_timelimit' then begin if strpar(s,1) = '' then begin
        st := '"sv_allowvote_timelimit" is "';
        if OPT_SV_ALLOWVOTE_TIMELIMIT = true then st := st + '1' else st := st + '0';
        st := st + '". Default is "1". Possible range 0-1.';
        addmessage(st); end else begin
        par := strpar(s,1);
        if par='1' then OPT_SV_ALLOWVOTE_TIMELIMIT := true;
        if par='0' then OPT_SV_ALLOWVOTE_TIMELIMIT := false;
        if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else addmessage('invalid value "'+par+'"'); end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'sv_allowvote_capturelimit' then begin if strpar(s,1) = '' then begin
        st := '"sv_allowvote_capturelimit" is "';
        if OPT_SV_ALLOWVOTE_CAPTURELIMIT = true then st := st + '1' else st := st + '0';
        st := st + '". Default is "1". Possible range 0-1.';
        addmessage(st); end else begin
        par := strpar(s,1);
        if par='1' then OPT_SV_ALLOWVOTE_CAPTURELIMIT := true;
        if par='0' then OPT_SV_ALLOWVOTE_CAPTURELIMIT := false;
        if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else addmessage('invalid value "'+par+'"'); end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'sv_allowvote_domlimit' then begin if strpar(s,1) = '' then begin
        st := '"sv_allowvote_domlimit" is "';
        if OPT_SV_ALLOWVOTE_DOMLIMIT = true then st := st + '1' else st := st + '0';
        st := st + '". Default is "1". Possible range 0-1.';
        addmessage(st); end else begin
        par := strpar(s,1);
        if par='1' then OPT_SV_ALLOWVOTE_DOMLIMIT := true;
        if par='0' then OPT_SV_ALLOWVOTE_DOMLIMIT := false;
        if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else addmessage('invalid value "'+par+'"'); end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'sv_allowvote_ready' then begin if strpar(s,1) = '' then begin
        st := '"sv_allowvote_ready" is "';
        if OPT_SV_ALLOWVOTE_READY = true then st := st + '1' else st := st + '0';
        st := st + '". Default is "1". Possible range 0-1.';
        addmessage(st); end else begin
        par := strpar(s,1);
        if par='1' then OPT_SV_ALLOWVOTE_READY := true;
        if par='0' then OPT_SV_ALLOWVOTE_READY := false;
        if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else addmessage('invalid value "'+par+'"'); end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'sv_allowvote_map' then begin if strpar(s,1) = '' then begin
        st := '"sv_allowvote_map" is "';
        if OPT_SV_ALLOWVOTE_MAP = true then st := st + '1' else st := st + '0';
        st := st + '". Default is "1". Possible range 0-1.';
        addmessage(st); end else begin
        par := strpar(s,1);
        if par='1' then OPT_SV_ALLOWVOTE_MAP := true;
        if par='0' then OPT_SV_ALLOWVOTE_MAP := false;
        if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else addmessage('invalid value "'+par+'"'); end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'sv_allowvote_warmup' then begin if strpar(s,1) = '' then begin
        st := '"sv_allowvote_warmup" is "';
        if OPT_SV_ALLOWVOTE_WARMUP = true then st := st + '1' else st := st + '0';
        st := st + '". Default is "1". Possible range 0-1.';
        addmessage(st); end else begin
        par := strpar(s,1);
        if par='1' then OPT_SV_ALLOWVOTE_WARMUP := true;
        if par='0' then OPT_SV_ALLOWVOTE_WARMUP := false;
        if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else addmessage('invalid value "'+par+'"'); end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'sv_allowvote_warmuparmor' then begin if strpar(s,1) = '' then begin
        st := '"sv_allowvote_warmuparmor" is "';
        if OPT_SV_ALLOWVOTE_WARMUPARMOR = true then st := st + '1' else st := st + '0';
        st := st + '". Default is "1". Possible range 0-1.';
        addmessage(st); end else begin
        par := strpar(s,1);
        if par='1' then OPT_SV_ALLOWVOTE_WARMUPARMOR := true;
        if par='0' then OPT_SV_ALLOWVOTE_WARMUPARMOR := false;
        if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else addmessage('invalid value "'+par+'"'); end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'sv_allowvote_forcerespawn' then begin if strpar(s,1) = '' then begin
        st := '"sv_allowvote_forcerespawn" is "';
        if OPT_SV_ALLOWVOTE_FORCERESPAWN = true then st := st + '1' else st := st + '0';
        st := st + '". Default is "1". Possible range 0-1.';
        addmessage(st); end else begin
        par := strpar(s,1);
        if par='1' then OPT_SV_ALLOWVOTE_FORCERESPAWN := true;
        if par='0' then OPT_SV_ALLOWVOTE_FORCERESPAWN := false;
        if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else addmessage('invalid value "'+par+'"'); end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'sv_allowvote_sync' then begin if strpar(s,1) = '' then begin
        st := '"sv_allowvote_sync" is "';
        if OPT_SV_ALLOWVOTE_SYNC = true then st := st + '1' else st := st + '0';
        st := st + '". Default is "1". Possible range 0-1.';
        addmessage(st); end else begin
        par := strpar(s,1);
        if par='1' then OPT_SV_ALLOWVOTE_SYNC := true;
        if par='0' then OPT_SV_ALLOWVOTE_SYNC := false;
        if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else addmessage('invalid value "'+par+'"'); end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'sv_allowvote_sv_teamdamage' then begin if strpar(s,1) = '' then begin
        st := '"sv_allowvote_sv_teamdamage" is "';
        if OPT_SV_ALLOWVOTE_SV_TEAMDAMAGE = true then st := st + '1' else st := st + '0';
        st := st + '". Default is "1". Possible range 0-1.';
        addmessage(st); end else begin
        par := strpar(s,1);
        if par='1' then OPT_SV_ALLOWVOTE_SV_TEAMDAMAGE := true;
        if par='0' then OPT_SV_ALLOWVOTE_SV_TEAMDAMAGE := false;
        if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else addmessage('invalid value "'+par+'"'); end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'sv_allowvote_net_predict' then begin if strpar(s,1) = '' then begin
        st := '"sv_allowvote_net_predict" is "';
        if OPT_SV_ALLOWVOTE_NET_PREDICT = true then st := st + '1' else st := st + '0';
        st := st + '". Default is "1". Possible range 0-1.';
        addmessage(st); end else begin
        par := strpar(s,1);
        if par='1' then OPT_SV_ALLOWVOTE_NET_PREDICT := true;
        if par='0' then OPT_SV_ALLOWVOTE_NET_PREDICT := false;
        if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else addmessage('invalid value "'+par+'"'); end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'sv_allowvote_sv_maxplayers' then begin if strpar(s,1) = '' then begin
        st := '"sv_allowvote_sv_maxplayers" is "';
        if OPT_SV_ALLOWVOTE_SV_MAXPLAYERS = true then st := st + '1' else st := st + '0';
        st := st + '". Default is "1". Possible range 0-1.';
        addmessage(st); end else begin
        par := strpar(s,1);
        if par='1' then OPT_SV_ALLOWVOTE_SV_MAXPLAYERS := true;
        if par='0' then OPT_SV_ALLOWVOTE_SV_MAXPLAYERS := false;
        if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else addmessage('invalid value "'+par+'"'); end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'sv_allowvote_sv_powerup' then begin if strpar(s,1) = '' then begin
        st := '"sv_allowvote_sv_powerup" is "';
        if OPT_SV_ALLOWVOTE_SV_POWERUP = true then st := st + '1' else st := st + '0';
        st := st + '". Default is "1". Possible range 0-1.';
        addmessage(st); end else begin
        par := strpar(s,1);
        if par='1' then OPT_SV_ALLOWVOTE_SV_POWERUP := true;
        if par='0' then OPT_SV_ALLOWVOTE_SV_POWERUP := false;
        if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else addmessage('invalid value "'+par+'"'); end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'sv_vote_percent' then begin
        if strpar(s,1) = '' then begin addmessage('"sv_vote_percent" is "'+inttostr(OPT_SV_VOTE_PERCENT)+'". Default "60". Range 1-100.'); exit; end;
        try
        OPT_SV_VOTE_PERCENT := strtoint(strpar(s,1));
        except OPT_SV_VOTE_PERCENT := 60; end;
        if OPT_SV_VOTE_PERCENT < 1 then OPT_SV_VOTE_PERCENT := 1;
        if OPT_SV_VOTE_PERCENT > 100 then OPT_SV_VOTE_PERCENT := 100;
        addmessage('"sv_vote_percent" is set to "'+inttostr(OPT_SV_VOTE_PERCENT)+'"');
end;

// ------------------------------------------------------------
// GRAPH COMMANZ:
// ------------------------------------------------------------



// ------------------------------------------------------------
if strpar(s,0) = 'cl_avimode' then begin
        if strpar(s,1) = '' then begin
                st := '"cl_avimode" is "';
                if OPT_CL_AVIMODE = true then st := st + '1' else st := st + '0';
                st := st + '". Default is "0". Possible range 0-1.';
                addmessage(st);
        end else begin
                par := strpar(s,1);
                if par='1' then begin OPT_CL_AVIMODE := true; addmessage('^2BMP Output'); end;
                if par='0' then begin OPT_CL_AVIMODE := false; addmessage('^2JPG Output'); end;
                if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else
                addmessage('invalid value "'+par+'"');
        end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'ch_teambar_showmyself' then begin
        if strpar(s,1) = '' then begin
                st := '"ch_teambar_showmyself" is "';
                if OPT_TB_SHOWMYSELF = true then st := st + '1' else st := st + '0';
                st := st + '". Default is "1". Possible range 0-1.';
                addmessage(st);
        end else begin
                par := strpar(s,1);
                if par='1' then OPT_TB_SHOWMYSELF := true;
                if par='0' then OPT_TB_SHOWMYSELF := false;
                if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else
                addmessage('invalid value "'+par+'"');
        end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'ch_teambar_color' then begin
        if strpar(s,1) = '' then begin addmessage('"ch_teambar_color" is "'+inttostr(OPT_TB_COLOR)+'". Default "6". Range 0-13.'); exit; end;
        try
        OPT_TB_COLOR := strtoint(strpar(s,1));
        except OPT_TB_COLOR := 14; end;
        if OPT_TB_COLOR < 0 then OPT_TB_COLOR := 0;
        if OPT_TB_COLOR > 13 then OPT_TB_COLOR := 13;
        addmessage('"ch_teambar_color" is set to "'+inttostr(OPT_TB_COLOR)+'"');
end;
// ------------------------------------------------------------
if strpar(s,0) = 'ch_teambar_style' then begin
        if strpar(s,1) = '' then begin addmessage('"ch_teambar_style" is "'+inttostr(OPT_TB_STYLE)+'". Default "1". Range 0-3.'); exit; end;
        try
        OPT_TB_STYLE := strtoint(strpar(s,1));
        except OPT_TB_STYLE := 1; end;
        if OPT_TB_STYLE < 0 then OPT_TB_STYLE := 0;
        if OPT_TB_STYLE > 3 then OPT_TB_STYLE := 3;
        addmessage('"ch_teambar_style" is set to "'+inttostr(OPT_TB_STYLE)+'"');
end;
// ------------------------------------------------------------
if strpar(s,0) = 'sv_maxplayers' then begin
        if strpar(s,1) = '' then begin addmessage('"sv_maxplayers" is "'+inttostr(OPT_SV_MAXPLAYERS)+'". Default "8". Range 2-8.'); exit; end;
        try
        OPT_SV_MAXPLAYERS := strtoint(strpar(s,1));
        except OPT_SV_MAXPLAYERS := 8; end;
        if OPT_SV_MAXPLAYERS < 2 then OPT_SV_MAXPLAYERS := 2;
        if OPT_SV_MAXPLAYERS > 8 then OPT_SV_MAXPLAYERS := 8;
        addmessage('"sv_maxplayers" is set to "'+inttostr(OPT_SV_MAXPLAYERS)+'"');
        if not inmenu then NFKPLANET_UpdateMaxUsers (OPT_SV_MAXPLAYERS);
end;
// ------------------------------------------------------------
if strpar(s,0) = 'sv_maxspectators' then begin
        if strpar(s,1) = '' then begin addmessage('"sv_maxspectators" is "'+inttostr(OPT_SV_MAXSPECTATORS)+'". Default "4". Range 1-4.'); exit; end;
        try
        OPT_SV_MAXSPECTATORS := strtoint(strpar(s,1));
        except OPT_SV_MAXSPECTATORS := 4; end;
        if OPT_SV_MAXSPECTATORS < 1 then OPT_SV_MAXSPECTATORS := 1;
        if OPT_SV_MAXSPECTATORS > 4 then OPT_SV_MAXSPECTATORS := 4;
        addmessage('"sv_maxspectators" is set to "'+inttostr(OPT_SV_MAXSPECTATORS)+'"');
end;
// ------------------------------------------------------------
if strpar(s,0) = 'ch_showrecordinglabel' then begin
        if strpar(s,1) = '' then begin
                st := '"ch_showrecordinglabel" is "';
                if OPT_DONOTSHOW_RECLABEL = true then st := st + '1' else st := st + '0';
                st := st + '". Default is "1". Possible range 0-1.';
                addmessage(st);
        end else begin
                par := strpar(s,1);
                if par='1' then OPT_DONOTSHOW_RECLABEL := true;
                if par='0' then OPT_DONOTSHOW_RECLABEL := false;
                if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else
                addmessage('invalid value "'+par+'"');
        end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'c_autoconnectoninvite' then begin
        if strpar(s,1) = '' then begin
                st := '"c_autoconnectoninvite" is "';
                if OPT_AUTOCONNECT_ONINVITE = true then st := st + '1' else st := st + '0';
                st := st + '". Default is "1". Possible range 0-1.';
                addmessage(st);
        end else begin
                par := strpar(s,1);
                if par='1' then OPT_AUTOCONNECT_ONINVITE := true;
                if par='0' then OPT_AUTOCONNECT_ONINVITE := false;
                if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else
                addmessage('invalid value "'+par+'"');
        end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'drawfragbar' then begin
        if strpar(s,1) = '' then begin
                st := '"drawfragbar" is "';
                if OPT_DRAWFRAGBAR = true then st := st + '1' else st := st + '0';
                st := st + '". Default is "0". Possible range 0-1.';
                addmessage(st);
        end else begin
                par := strpar(s,1);
                if par='1' then OPT_DRAWFRAGBAR := true;
                if par='0' then OPT_DRAWFRAGBAR := false;
                if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else
                addmessage('invalid value "'+par+'"');
        end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'r_fx_explo' then begin
        if strpar(s,1) = '' then begin
                st := '"r_fx_explo" is "';
                if OPT_FXEXPLO = true then st := st + '1' else st := st + '0';
                st := st + '". Default is "1". Possible range 0-1.';
                addmessage(st);
        end else begin
                par := strpar(s,1);
                if par='1' then OPT_FXEXPLO := true;
                if par='0' then OPT_FXEXPLO := false;
                if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else
                addmessage('invalid value "'+par+'"');
        end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'r_fx_quad' then begin
        if strpar(s,1) = '' then begin
                st := '"r_fx_quad" is "';
                if OPT_FXQUAD = true then st := st + '1' else st := st + '0';
                st := st + '". Default is "1". Possible range 0-1.';
                addmessage(st);
        end else begin
                par := strpar(s,1);
                if par='1' then OPT_FXQUAD := true;
                if par='0' then OPT_FXQUAD := false;
                if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else
                addmessage('invalid value "'+par+'"');
        end;
end;
// ------------------------------------------------------------

if strpar(s,0) = 'r_fx_shaft' then begin
        if strpar(s,1) = '' then begin
                st := '"r_fx_shaft" is "';
                if OPT_FXSHAFT = true then st := st + '1' else st := st + '0';
                st := st + '". Default is "1". Possible range 0-1.';
                addmessage(st);
        end else begin
                par := strpar(s,1);
                if par='1' then OPT_FXSHAFT := true;
                if par='0' then OPT_FXSHAFT := false;
                if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else
                addmessage('invalid value "'+par+'"');
        end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'r_fx_plasma' then begin
        if strpar(s,1) = '' then begin
                st := '"r_fx_plasma" is "';
                if OPT_FXPLASMA = true then st := st + '1' else st := st + '0';
                st := st + '". Default is "1". Possible range 0-1.';
                addmessage(st);
        end else begin
                par := strpar(s,1);
                if par='1' then OPT_FXPLASMA := true;
                if par='0' then OPT_FXPLASMA := false;
                if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else
                addmessage('invalid value "'+par+'"');
        end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'r_fx_rlbfg' then begin
        if strpar(s,1) = '' then begin
                st := '"r_fx_rlbfg" is "';
                if OPT_FXLIGHTRLBFG = true then st := st + '1' else st := st + '0';
                st := st + '". Default is "1". Possible range 0-1.';
                addmessage(st);
        end else begin
                par := strpar(s,1);
                if par='1' then OPT_FXLIGHTRLBFG := true;
                if par='0' then OPT_FXLIGHTRLBFG := false;
                if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else
                addmessage('invalid value "'+par+'"');
        end;
end;

// ------------------------------------------------------------
if strpar(s,0) = 'r_fx_smoke' then begin
        if strpar(s,1) = '' then begin
                st := '"r_fx_smoke" is "';
                if OPT_FXSMOKE = true then st := st + '1' else st := st + '0';
                st := st + '". Default is "1". Possible range 0-1.';
                addmessage(st);
        end else begin
                par := strpar(s,1);
                if par='1' then OPT_FXSMOKE := true;
                if par='0' then OPT_FXSMOKE := false;
                if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else
                addmessage('invalid value "'+par+'"');
        end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'r_altgrenades' then begin
        if strpar(s,1) = '' then begin
                st := '"r_altgrenades" is "';
                if OPT_ALTGRENADES = true then st := st + '1' else st := st + '0';
                st := st + '". Default is "1". Possible range 0-1.';
                addmessage(st);
        end else begin
                par := strpar(s,1);
                if par='1' then OPT_ALTGRENADES := true;
                if par='0' then OPT_ALTGRENADES := false;
                if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else
                addmessage('invalid value "'+par+'"');
        end;
end;
// ------------------------------------------------------------
{if strpar(s,0) = 'r_040fx' then begin
        if strpar(s,1) = '' then begin
                st := '"r_040fx" is "';
                if OPT_LIGHTFX = true then st := st + '1' else st := st + '0';
                st := st + '". Default is "1". Possible range 0-1.';
                addmessage(st);
        end else begin
                par := strpar(s,1);
                if par='1' then OPT_LIGHTFX := true;
                if par='0' then OPT_LIGHTFX := false;
                if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else
                addmessage('invalid value "'+par+'"');
        end;
end;

 }

// ------------------------------------------------------------
if strpar(s,0) = 'r_bgmotion' then begin
        if strpar(s,1) = '' then begin
                st := '"r_bgmotion" is "';
                if OPT_BGMOTION = true then st := st + '1' else st := st + '0';
                st := st + '". Default is "0". Possible range 0-1.';
                addmessage(st);
        end else begin
                par := strpar(s,1);
                if par='1' then OPT_BGMOTION := true;
                if par='0' then OPT_BGMOTION := false;
                if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else
                addmessage('invalid value "'+par+'"');
        end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'sv_dedicated' then begin
        if strpar(s,1) = '' then begin
                st := '"sv_dedicated" is "';
                if OPT_SV_DEDICATED = true then st := st + '1' else st := st + '0';
                st := st + '". Default is "0". Possible range 0-1.';
                addmessage(st);
        end else begin
                if INMENU=false then begin addmessage('You can change this variable only at the mainmenu.'); exit; end;
                par := strpar(s,1);
                if par='1' then OPT_SV_DEDICATED := true;
                if par='0' then OPT_SV_DEDICATED := false;
                if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else
                addmessage('invalid value "'+par+'"');
        end;
end;

// ------------------------------------------------------------
if strpar(s,0) = 'r_markemptydeath' then begin
        if strpar(s,1) = '' then begin
                st := '"r_markemptydeath" is "';
                if OPT_CONTENTEMPTYDEATHHIGHLIGHT = true then st := st + '1' else st := st + '0';
                st := st + '". Default is "0". Possible range 0-1.';
                addmessage(st);
        end else begin
                par := strpar(s,1);
                if par='1' then OPT_CONTENTEMPTYDEATHHIGHLIGHT := true;
                if par='0' then OPT_CONTENTEMPTYDEATHHIGHLIGHT := false;
                if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else
                addmessage('invalid value "'+par+'"');
        end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'ch_constretch' then begin
        if strpar(s,1) = '' then begin
                st := '"ch_constretch" is "';
                if SYS_CONSOLE_STRETCH = true then st := st + '1' else st := st + '0';
                st := st + '". Default is "1". Possible range 0-1.';
                addmessage(st);
        end else begin
                par := strpar(s,1);
                if par='1' then SYS_CONSOLE_STRETCH := true;
                if par='0' then SYS_CONSOLE_STRETCH := false;
                if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else
                addmessage('invalid value "'+par+'"');
        end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'ch_dombarstyle' then begin
        if strpar(s,1) = '' then begin addmessage('"ch_dombarstyle" is "'+inttostr(OPT_DOMBARSTYLE)+'". Default "1". Range 0-3.'); exit; end;
        try
        OPT_DOMBARSTYLE := strtoint(strpar(s,1));
        except OPT_DOMBARSTYLE := 0; end;
        if OPT_DOMBARSTYLE < 0 then OPT_DOMBARSTYLE := 0;
        if OPT_DOMBARSTYLE > 3 then OPT_DOMBARSTYLE := 3;
        addmessage('"ch_dombarstyle" is set to "'+inttostr(OPT_DOMBARSTYLE)+'"');
end;
// ------------------------------------------------------------
if strpar(s,0) = 'ch_conspeed' then begin
        if strpar(s,1) = '' then begin addmessage('"ch_conspeed" is "'+inttostr(SYS_CONSOLE_DELIMETER)+'". Default "32". Range 1-480.'); exit; end;
        try
        SYS_CONSOLE_DELIMETER := strtoint(strpar(s,1));
        except SYS_CONSOLE_DELIMETER := 64; end;
        if SYS_CONSOLE_DELIMETER < 1 then SYS_CONSOLE_DELIMETER := 1;
        if SYS_CONSOLE_DELIMETER > 480 then SYS_CONSOLE_DELIMETER := 480;
        addmessage('"ch_conspeed" is set to "'+inttostr(SYS_CONSOLE_DELIMETER)+'"');
end;

// ------------------------------------------------------------
if strpar(s,0) = 'ch_dombarpos' then begin
        if strpar(s,1) = '' then begin addmessage('"ch_dombarpos" is "'+inttostr(OPT_DOMBARPOS)+'". Default "0". Range 0-400.'); exit; end;
        try
        OPT_DOMBARPOS := strtoint(strpar(s,1));
        except OPT_DOMBARPOS := 0; end;
        if OPT_DOMBARPOS < 0 then OPT_DOMBARPOS := 0;
        if OPT_DOMBARPOS > 400 then OPT_DOMBARPOS := 400;
        addmessage('"ch_dombarpos" is set to "'+inttostr(OPT_DOMBARPOS)+'"');
end;
// ------------------------------------------------------------
if strpar(s,0) = 'ch_conheight' then begin
        if strpar(s,1) = '' then begin addmessage('"ch_conheight" is "'+inttostr(SYS_CONSOLE_MAXY)+'". Default "240". Range 64-480.'); exit; end;
        try
        SYS_CONSOLE_MAXY := strtoint(strpar(s,1));
        except SYS_CONSOLE_MAXY := 240; end;
        if SYS_CONSOLE_MAXY < 64 then SYS_CONSOLE_MAXY := 64;
        if SYS_CONSOLE_MAXY > 480 then SYS_CONSOLE_MAXY := 480;
        conmsg_index :=0;
        addmessage('"ch_conheight" is set to "'+inttostr(SYS_CONSOLE_MAXY)+'"');
end;
// ------------------------------------------------------------
if strpar(s,0) = 'ch_conalpha' then begin
        if strpar(s,1) = '' then begin addmessage('"ch_conalpha" is "'+inttostr(SYS_CONSOLE_ALPHA)+'". Default "238". Range 1-255.'); exit; end;
        try
        SYS_CONSOLE_ALPHA := strtoint(strpar(s,1));
        except SYS_CONSOLE_ALPHA := 238; end;
        if SYS_CONSOLE_ALPHA < 1 then SYS_CONSOLE_ALPHA := 1;
        if SYS_CONSOLE_ALPHA > 255 then SYS_CONSOLE_ALPHA := 255;
        addmessage('"ch_conalpha" is set to "'+inttostr(SYS_CONSOLE_ALPHA)+'"');
end;
// ------------------------------------------------------------

if strpar(s,0) = 'net_coordinterpolate' then begin
        if strpar(s,1) = '' then begin addmessage('"net_coordinterpolate" is "'+inttostr(trunc(OPT_NETPREDICTION*100))+'". Default "85". Range 0-100. 0=disabled.'); exit; end;
        try
        OPT_NETPREDICTION := strtoint(strpar(s,1)) / 100;
        except OPT_NETPREDICTION := 0.85; end;
        if OPT_NETPREDICTION < 0 then OPT_NETPREDICTION := 0;
        if OPT_NETPREDICTION > 1 then OPT_NETPREDICTION := 1;
        addmessage('"net_coordinterpolate" is set to "'+inttostr(trunc(OPT_NETPREDICTION*100))+'"');
end;

// ------------------------------------------------------------
if strpar(s,0) = 'spectator' then begin
        if strpar(s,1) = '' then begin
                st := '"spectator" is "';
                if OPT_NETSPECTATOR = true then st := st + '1' else st := st + '0';
                st := st + '". Default is "0". Possible range 0-1.';
                addmessage(st);
        end else begin
                if INMENU=false then begin addmessage('You can change this variable only at the mainmenu.'); exit; end;
                par := strpar(s,1);
                if par='1' then OPT_NETSPECTATOR := true;
                if par='0' then OPT_NETSPECTATOR := false;
                if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else
                addmessage('invalid value "'+par+'"');
        end;
end;
// ------------------------------------------------------------

{if strpar(s,0) = 'c_shownickcolor' then begin
        if strpar(s,1) = '' then begin addmessage('"c_shownickcolor" is "'+inttostr(OPT_C_NICKCOLOR)+'". Default "0". Range 0-15.'); exit; end;
        try
        OPT_C_NICKCOLOR := strtoint(strpar(s,1));
        except OPT_C_NICKCOLOR := 0; end;
//        if OPT_C_NICKCOLOR < 0 then OPT_C_NICKCOLOR := 0;
        if OPT_C_NICKCOLOR > 16 then OPT_C_NICKCOLOR := 16;
        addmessage('"c_shownickcolor" is set to "'+inttostR(OPT_C_NICKCOLOR)+'"');
end;}
// ------------------------------------------------------------
{if strpar(s,0) = 'net_correctcoordinterpolate' then begin
        if strpar(s,1) = '' then begin
                st := '"net_correctcoordinterpolate" is "';
                if OPT_NETCORRECTINTERPOLATEERROR = true then st := st + '1' else st := st + '0';
                st := st + '". Default is "0". Possible range 0-1.';
                addmessage(st);
        end else begin
                par := strpar(s,1);
                if par='1' then OPT_NETCORRECTINTERPOLATEERROR := true;
                if par='0' then OPT_NETCORRECTINTERPOLATEERROR := false;
                if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else
                addmessage('invalid value "'+par+'"');
        end;
end;
}
// ------------------------------------------------------------
if strpar(s,0) = 'm_rotated' then begin
        if strpar(s,1) = '' then begin
                st := '"m_rotated" is "';
                if OPT_MROTATED = true then st := st + '1' else st := st + '0';
                st := st + '". Default is "0". Possible range 0-1.';
                addmessage(st);
        end else begin
                par := strpar(s,1);
                if par='1' then OPT_MROTATED := true;
                if par='0' then OPT_MROTATED := false;
                if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else
                addmessage('invalid value "'+par+'"');
        end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'm_invert' then begin
        if strpar(s,1) = '' then begin
                st := '"m_invert" is "';
                if OPT_MINVERT = true then st := st + '1' else st := st + '0';
                st := st + '". Default is "0". Possible range 0-1.';
                addmessage(st);
        end else begin
                par := strpar(s,1);
                if par='1' then OPT_MINVERT := true;
                if par='0' then OPT_MINVERT := false;
                if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else
                addmessage('invalid value "'+par+'"');
        end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'shownickatsb' then begin
        if strpar(s,1) = '' then begin
                st := '"shownickatsb" is "';
                if OPT_SHOWNICKATSB = true then st := st + '1' else st := st + '0';
                st := st + '". Default is "0". Possible range 0-1.';
                addmessage(st);
        end else begin
                par := strpar(s,1);
                if par='1' then OPT_SHOWNICKATSB := true;
                if par='0' then OPT_SHOWNICKATSB := false;
                if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else
                addmessage('invalid value "'+par+'"');
        end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'announcer' then begin
        if strpar(s,1) = '' then begin
                st := '"announcer" is "';
                if OPT_ANNOUNCER = true then st := st + '1' else st := st + '0';
                st := st + '". Default is "1". Possible range 0-1.';
                addmessage(st);
        end else begin
                par := strpar(s,1);
                if par='1' then OPT_ANNOUNCER := true;
                if par='0' then OPT_ANNOUNCER := false;
                if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else
                addmessage('invalid value "'+par+'"');
        end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'r_railsmooth' then begin
        if strpar(s,1) = '' then begin
                st := '"r_railsmooth" is "';
                if OPT_RAILSMOOTH = true then st := st + '1' else st := st + '0';
                st := st + '". Default is "1". Possible range 0-1.';
                addmessage(st);
        end else begin
                par := strpar(s,1);
                if par='1' then OPT_RAILSMOOTH := true;
                if par='0' then OPT_RAILSMOOTH := false;
                if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else
                addmessage('invalid value "'+par+'"');
        end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'r_railprogressivealpha' then begin
        if strpar(s,1) = '' then begin
                st := '"r_railprogressivealpha" is "';
                if OPT_RAILPROGRESSIVEALPHA = true then st := st + '1' else st := st + '0';
                st := st + '". Default is "1". Possible range 0-1.';
                addmessage(st);
        end else begin
                par := strpar(s,1);
                if par='1' then OPT_RAILPROGRESSIVEALPHA := true;
                if par='0' then OPT_RAILPROGRESSIVEALPHA := false;
                if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else
                addmessage('invalid value "'+par+'"');
        end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'r_transparentbulletmarks' then begin
        if strpar(s,1) = '' then begin
                st := '"r_transparentbulletmarks" is "';
                if OPT_R_TRANSPARENTBULLETMARKS = true then st := st + '1' else st := st + '0';
                st := st + '". Default is "1". Possible range 0-1.';
                addmessage(st);
        end else begin
                par := strpar(s,1);
                if par='1' then OPT_R_TRANSPARENTBULLETMARKS := true;
                if par='0' then OPT_R_TRANSPARENTBULLETMARKS := false;
                if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else
                addmessage('invalid value "'+par+'"');
        end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'r_flashingitems' then begin
        if strpar(s,1) = '' then begin
                st := '"r_flashingitems" is "';
                if OPT_R_FLASHINGITEMS = true then st := st + '1' else st := st + '0';
                st := st + '". Default is "1". Possible range 0-1.';
                addmessage(st);
        end else begin
                par := strpar(s,1);
                if par='1' then OPT_R_FLASHINGITEMS := true;
                if par='0' then OPT_R_FLASHINGITEMS := false;
                if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else
                addmessage('invalid value "'+par+'"');
        end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'r_alphaitemsrespawn' then begin
        if strpar(s,1) = '' then begin
                st := '"r_alphaitemsrespawn" is "';
                if OPT_R_ALPHAITEMSRESPAWN = true then st := st + '1' else st := st + '0';
                st := st + '". Default is "1". Possible range 0-1.';
                addmessage(st);
        end else begin
                par := strpar(s,1);
                if par='1' then OPT_R_ALPHAITEMSRESPAWN := true;
                if par='0' then OPT_R_ALPHAITEMSRESPAWN := false;
                if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else
                addmessage('invalid value "'+par+'"');
        end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'r_transparentexplosions' then begin
        if strpar(s,1) = '' then begin
                st := '"r_transparentexplosions" is "';
                if OPT_R_TRANSPARENTEXPLOSIONS = true then st := st + '1' else st := st + '0';
                st := st + '". Default is "1". Possible range 0-1.';
                addmessage(st);
        end else begin
                par := strpar(s,1);
                if par='1' then OPT_R_TRANSPARENTEXPLOSIONS := true;
                if par='0' then OPT_R_TRANSPARENTEXPLOSIONS := false;
                if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else
                addmessage('invalid value "'+par+'"');
        end;
end;

// ------------------------------------------------------------
if strpar(s,0) = 'sv_teamdamage' then begin
        if strpar(s,1) = '' then begin
                st := '"sv_teamdamage" is "';
                if OPT_TEAMDAMAGE = true then st := st + '1' else st := st + '0';
                st := st + '". Default is "1". Possible range 0-1.';
                addmessage(st);
        end else begin
                if (ismultip=1) and (OPT_SV_LOCK) then begin addmessage('server commands locked!'); exit; end;

                par := strpar(s,1);
                if par='1' then OPT_TEAMDAMAGE := true;
                if par='0' then OPT_TEAMDAMAGE := false;
                if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else
                addmessage('invalid value "'+par+'"');
                if ismultip=1 then SV_TransmitCMD;
        end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'r_drawbubbles' then begin
        if strpar(s,1) = '' then begin
                st := '"r_drawbubbles" is "';
                if OPT_R_BUBBLES = true then st := st + '1' else st := st + '0';
                st := st + '". Default is "1". Possible range 0-1.';
                addmessage(st);
        end else begin
                par := strpar(s,1);
                if par='1' then OPT_R_BUBBLES := true;
                if par='0' then OPT_R_BUBBLES := false;
                if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else
                addmessage('invalid value "'+par+'"');
        end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'fragbarx' then begin
        if strpar(s,1) = '' then begin addmessage('"fragbarx" is "'+inttostr(OPT_DRAWFRAGBARX)+'". Default "0". Range 0-620.'); exit; end;
        try
        OPT_DRAWFRAGBARX := strtoint(strpar(s,1));
        except OPT_DRAWFRAGBARX := 0; end;
        if OPT_DRAWFRAGBARX <= 0 then OPT_DRAWFRAGBARX := 0;
        if OPT_DRAWFRAGBARX > 620 then OPT_DRAWFRAGBARX := 620;
        addmessage('"fragbarx" is set to "'+inttostR(OPT_DRAWFRAGBARX)+'"');
end;
if strpar(s,0) = 'fragbary' then begin
        if strpar(s,1) = '' then begin addmessage('"fragbary" is "'+inttostr(OPT_DRAWFRAGBARY)+'". Default "464". Range 0-464.'); exit; end;
        try
        OPT_DRAWFRAGBARY := strtoint(strpar(s,1));
        except OPT_DRAWFRAGBARY := 464; end;
        if OPT_DRAWFRAGBARY <= 0 then OPT_DRAWFRAGBARY := 0;
        if OPT_DRAWFRAGBARY > 464 then OPT_DRAWFRAGBARY := 464;
        addmessage('"fragbary" is set to "'+inttostR(OPT_DRAWFRAGBARY)+'"');
end;
// ------------------------------------------------------------
if strpar(s,0) = 'r_statusbaralpha' then begin
        if strpar(s,1) = '' then begin addmessage('"r_statusbaralpha" is "'+inttostr(OPT_R_STATUSBARALPHA)+'". Default "221". Range 0-255.'); exit; end;
        try
        OPT_R_STATUSBARALPHA := strtoint(strpar(s,1));
        except OPT_R_STATUSBARALPHA := $BB; end;
        if OPT_R_STATUSBARALPHA <= 0 then OPT_R_STATUSBARALPHA := 0;
        if OPT_R_STATUSBARALPHA >= $FF then OPT_R_STATUSBARALPHA := $FF;
        addmessage('"r_statusbaralpha" is set to "'+inttostR(OPT_R_STATUSBARALPHA)+'"');
end;
// ------------------------------------------------------------
if strpar(s,0) = 'madness' then begin
        if strpar(s,1) = '' then begin addmessage('"madness" is "'+inttostr(OPT_BGMADNESS)+'". Default "0". Range 0-10.'); exit; end;
        try
        OPT_BGMADNESS := strtoint(strpar(s,1));
        except OPT_BGMADNESS := $BB; end;
//        if OPT_BGMADNESS < 0 then OPT_BGMADNESS := 0;
        if OPT_BGMADNESS > 10 then OPT_BGMADNESS := 10;
        addmessage('"madness" is set to "'+inttostR(OPT_BGMADNESS)+'"');
end;
// ------------------------------------------------------------
if strpar(s,0) = 'sv_overtime' then begin
        if strpar(s,1) = '' then begin addmessage('"sv_overtime" is "'+inttostr(OPT_SV_OVERTIME)+'". Default "5". Range 0-30.'); exit; end;
        if (ismultip=1) and (OPT_SV_LOCK) then begin addmessage('server commands locked!'); exit; end;
        try
        OPT_SV_OVERTIME := strtoint(strpar(s,1));
        except OPT_SV_OVERTIME := 5; end;
        if OPT_SV_OVERTIME < 0 then OPT_SV_OVERTIME := 0;
        if OPT_SV_OVERTIME > 30 then OPT_SV_OVERTIME := 30;
        addmessage('"sv_overtime" is set to "'+inttostR(OPT_SV_OVERTIME)+'"');
        if ismultip=1 then SV_TransmitCMD;
end;

// ------------------------------------------------------------
if strpar(s,0) = 'r_railstyle' then begin
        if strpar(s,1) = '' then begin addmessage('"r_railstyle" is "'+inttostr(OPT_R_RAILSTYLE)+'". Default "0". Range 0-4.'); exit; end;
        try
        OPT_R_RAILSTYLE := strtoint(strpar(s,1));
        except OPT_R_RAILSTYLE := 0; end;
        if OPT_R_RAILSTYLE < 0 then OPT_R_RAILSTYLE := 0;
        if OPT_R_RAILSTYLE > 4 then OPT_R_RAILSTYLE := 4;
        addmessage('"r_railstyle" is set to "'+inttostR(OPT_R_RAILSTYLE)+'"');
end;
// ------------------------------------------------------------
if strpar(s,0) = 'r_wateralpha' then begin
        if strpar(s,1) = '' then begin addmessage('"r_wateralpha" is "'+inttostr(OPT_R_WATERALPHA)+'". Default "187". Range 25-255.'); exit; end;
        try
        OPT_R_WATERALPHA := strtoint(strpar(s,1));
        except OPT_R_WATERALPHA := $BB; end;
        if OPT_R_WATERALPHA <= 25 then OPT_R_WATERALPHA := 25;
        if OPT_R_WATERALPHA >= $FF then OPT_R_WATERALPHA := $FF;
        addmessage('"r_wateralpha" is set to "'+inttostR(OPT_R_WATERALPHA)+'"');
end;
// ------------------------------------------------------------
if strpar(s,0) = 'mouselook' then begin
        if strpar(s,1) = '' then begin
                st := '"mouselook" is "';
                if OPT_P1MOUSELOOK = true then st := st + '1' else st := st + '0';
                st := st + '". Default is "1". Possible range 0-1.';
                addmessage(st);
        end else begin
                par := strpar(s,1);
                if par='1' then OPT_P1MOUSELOOK := true;
                if par='0' then OPT_P1MOUSELOOK := false;
                if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else
                addmessage('invalid value "'+par+'"');
        end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'gauntletnextweapon' then begin
        if strpar(s,1) = '' then begin
                st := '"gauntletnextweapon" is "';
                if OPT_P1GAUNTLETNEXTWPN = true then st := st + '1' else st := st + '0';
                st := st + '". Default is "1". Possible range 0-1.';
                addmessage(st);
        end else begin
                par := strpar(s,1);
                if par='1' then OPT_P1GAUNTLETNEXTWPN := true;
                if par='0' then OPT_P1GAUNTLETNEXTWPN := false;
                if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else
                addmessage('invalid value "'+par+'"');
        end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'p2gauntletnextweapon' then begin
        if strpar(s,1) = '' then begin
                st := '"p2gauntletnextweapon" is "';
                if OPT_P2GAUNTLETNEXTWPN = true then st := st + '1' else st := st + '0';
                st := st + '". Default is "1". Possible range 0-1.';
                addmessage(st);
        end else begin
                par := strpar(s,1);
                if par='1' then OPT_P2GAUNTLETNEXTWPN := true;
                if par='0' then OPT_P2GAUNTLETNEXTWPN := false;
                if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else
                addmessage('invalid value "'+par+'"');
        end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'nextwpn_skipempty' then begin
        if strpar(s,1) = '' then begin
                st := '"nextwpn_skipempty" is "';
                if OPT_P1NEXTWPNSKIPEMPTY = true then st := st + '1' else st := st + '0';
                st := st + '". Default is "0". Possible range 0-1.';
                addmessage(st);
        end else begin
                par := strpar(s,1);
                if par='1' then OPT_P1NEXTWPNSKIPEMPTY := true;
                if par='0' then OPT_P1NEXTWPNSKIPEMPTY := false;
                if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else
                addmessage('invalid value "'+par+'"');
        end;
end;
if strpar(s,0) = 'p2nextwpn_skipempty' then begin
        if strpar(s,1) = '' then begin
                st := '"p2nextwpn_skipempty" is "';
                if OPT_P2NEXTWPNSKIPEMPTY = true then st := st + '1' else st := st + '0';
                st := st + '". Default is "0". Possible range 0-1.';
                addmessage(st);
        end else begin
                par := strpar(s,1);
                if par='1' then OPT_P2NEXTWPNSKIPEMPTY := true;
                if par='0' then OPT_P2NEXTWPNSKIPEMPTY := false;
                if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else
                addmessage('invalid value "'+par+'"');
        end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'railarenainstagib' then begin
        if strpar(s,1) = '' then begin
                st := '"railarenainstagib" is "';
                if OPT_RAILARENA_INSTAGIB = true then st := st + '1' else st := st + '0';
                st := st + '". Default is "1". Possible range 0-1.';
                addmessage(st);
        end else begin
                if ismultip=2 then begin addmessage('server side command.'); exit; end;
                if (ismultip=1) and (OPT_SV_LOCK) then begin addmessage('server commands locked!'); exit; end;

                par := strpar(s,1);
                if par='1' then OPT_RAILARENA_INSTAGIB := true;
                if par='0' then OPT_RAILARENA_INSTAGIB := false;
                if (par = '1') or (par = '0') then begin
                        addmessage(strpar(s,0) + ' is set to "'+par+'"');
                        if ismultip=1 then SV_TransmitCMD;
                        end else
                addmessage('invalid value "'+par+'"');
        end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'trixmasta' then begin
        if strpar(s,1) = '' then begin
                st := '"trixmasta" is "';
                if OPT_TRIXMASTA = true then st := st + '1' else st := st + '0';
                st := st + '". Default is "1". Possible range 0-1.';
                addmessage(st);
        end else begin
                par := strpar(s,1);
                if par='1' then begin
                        if (inmenu=false) and (OPT_TRIXMASTA=false) and (MATCH_GAMETYPE=GAMETYPE_TRIXARENA) and (MATCH_STARTSIN>1) then
                                applyHcommand('record temp');
                        OPT_TRIXMASTA := true;
                        end;
                if par='0' then OPT_TRIXMASTA := false;
                if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else
                addmessage('invalid value "'+par+'"');
        end;
end;

// ------------------------------------------------------------
if strpar(s,0) = 'sv_testplayer2' then begin
        if strpar(s,1) = '' then begin
                st := '"sv_testplayer2" is "';
                if OPT_SV_TESTPLAYER2 = true then st := st + '1' else st := st + '0';
                st := st + '". Default is "0". Possible range 0-1.';
                addmessage(st);
        end else begin
                if ismultip=2 then begin addmessage('server side command.'); exit; end;
                par := strpar(s,1);
                if par='1' then OPT_SV_TESTPLAYER2 := true;
                if par='0' then OPT_SV_TESTPLAYER2 := false;
                if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else
                addmessage('invalid value "'+par+'"');
        end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'sv_allowjoinmatch' then begin
        if strpar(s,1) = '' then begin
                st := '"sv_allowjoinmatch" is "';
                if OPT_SV_ALLOWJOINMATCH = true then st := st + '1' else st := st + '0';
                st := st + '". Default is "1". Possible range 0-1.';
                addmessage(st);
        end else begin
                if ismultip=2 then begin addmessage('server side command.'); exit; end;
                par := strpar(s,1);
                if par='1' then OPT_SV_ALLOWJOINMATCH := true;
                if par='0' then OPT_SV_ALLOWJOINMATCH := false;
                if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else
                addmessage('invalid value "'+par+'"');
        end;
end;
// ------------------------------------------------------------
{if strpar(s,0) = 'paredrail' then begin
        if strpar(s,1) = '' then begin
                st := '"paredrail" is "';
                if OPT_RESTRICTEDRAIL = true then st := st + '1' else st := st + '0';
                st := st + '". Default is "0". Possible range 0-1.';
                addmessage(st);
        end else begin
                par := strpar(s,1);
                if par='1' then OPT_RESTRICTEDRAIL := true;
                if par='0' then OPT_RESTRICTEDRAIL := false;
                if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else
                addmessage('invalid value "'+par+'"');
        end;
end;}
// ------------------------------------------------------------
{if strpar(s,0) = 'nfkitemspawn' then begin
        if strpar(s,1) = '' then begin
                st := '"nfkitemspawn" is "';
                if OPT_NFKITEMS = true then st := st + '1' else st := st + '0';
                st := st + '". Default is "1". Possible range 0-1.';
                addmessage(st);
        end else begin
                par := strpar(s,1);
                if par='1' then OPT_NFKITEMS := true;
                if par='0' then OPT_NFKITEMS := false;
                if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else
                addmessage('invalid value "'+par+'"');
        end;
end;}
// ------------------------------------------------------------
if strpar(s,0) = 'log' then begin
        if strpar(s,1) = '' then begin
                st := '"log" is "';
                if GAME_LOG = true then st := st + '1' else st := st + '0';
                st := st + '". Default is "1". Possible range 0-1.';
                addmessage(st);
        end else begin
                par := strpar(s,1);
                if par='1' then GAME_LOG := true;
                if par='0' then GAME_LOG := false;
                if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else
                addmessage('invalid value "'+par+'"');
        end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'shownick' then begin
        if strpar(s,1) = '' then begin
                st := '"shownick" is "';
                if OPT_SHOWNAMES = true then st := st + '1' else st := st + '0';
                st := st + '". Default is "1". Possible range 0-1.';
                addmessage(st);
        end else begin
                par := strpar(s,1);
                if par='1' then OPT_SHOWNAMES := true;
                if par='0' then OPT_SHOWNAMES := false;

                if par='1' then OPT_AUTOSHOWNAMESTIME := 0;
                if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else
                addmessage('invalid value "'+par+'"');
        end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'transparentstats' then begin
        if strpar(s,1) = '' then begin
                st := '"transparentstats" is "';
                if OPT_TRANSPASTATS = true then st := st + '1' else st := st + '0';
                st := st + '". Default is "0". Possible range 0-1.';
                addmessage(st);
        end else begin
                par := strpar(s,1);
                if par='1' then OPT_TRANSPASTATS := true;
                if par='0' then OPT_TRANSPASTATS := false;
                if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else
                addmessage('invalid value "'+par+'"');
        end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'autoshownick' then begin
        if strpar(s,1) = '' then begin
                st := '"autoshownick" is "';
                if OPT_AUTOSHOWNAMES = true then st := st + '1' else st := st + '0';
                st := st + '". Default is "1". Possible range 0-1.';
                addmessage(st);
        end else begin
                par := strpar(s,1);
                if par='1' then OPT_AUTOSHOWNAMES := true;
                if par='0' then OPT_AUTOSHOWNAMES := false;
                if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else
                addmessage('invalid value "'+par+'"');
        end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'showmapinfo' then begin
        if strpar(s,1) = '' then begin
                st := '"showmapinfo" is "';
                if OPT_SHOWMAPINFO = true then st := st + '1' else st := st + '0';
                st := st + '". Default is "1". Possible range 0-1.';
                addmessage(st);
        end else begin
                par := strpar(s,1);
                if par='1' then OPT_SHOWMAPINFO := true;
                if par='0' then OPT_SHOWMAPINFO := false;
                if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else
                addmessage('invalid value "'+par+'"');
        end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'ch_qwscoreboard' then begin
        if strpar(s,1) = '' then begin
                st := '"ch_qwscoreboard" is "';
                if OPT_QWSCOREBOARD = true then st := st + '1' else st := st + '0';
                st := st + '". Default is "1". Possible range 0-1.';
                addmessage(st);
        end else begin
                par := strpar(s,1);
                if par='1' then OPT_QWSCOREBOARD := true;
                if par='0' then OPT_QWSCOREBOARD := false;
                if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else
                addmessage('invalid value "'+par+'"');
        end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'allowmapschangebg' then begin
        if strpar(s,1) = '' then begin
                st := '"allowmapschangebg" is "';
                if OPT_ALLOWMAPCHANGEBG = true then st := st + '1' else st := st + '0';
                st := st + '". Default is "1". Possible range 0-1.';
                addmessage(st);
        end else begin
                par := strpar(s,1);
                if par='1' then OPT_ALLOWMAPCHANGEBG := true;
                if par='0' then OPT_ALLOWMAPCHANGEBG := false;
                if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else
                addmessage('invalid value "'+par+'"');
        end;
end;
//OPT_GAMEMENUCOLOR

//                addmessage('u must restart programm to apply 100% effect.');
//                 end;

// ------------------------------------------------------------
if strpar(s,0) = 'menucolor' then begin
        if strpar(s,1) = '' then begin addmessage('"menucolor" is "'+inttostr(OPT_GAMEMENUCOLOR)+'". Default "5". Range 0-13.'); exit; end;
//                applyhcommand('quit');
        try
        OPT_GAMEMENUCOLOR := strtoint(strpar(s,1));
        except OPT_GAMEMENUCOLOR := 1; end;
//        if OPT_GAMEMENUCOLOR < 0 then OPT_GAMEMENUCOLOR := 0;
        if OPT_GAMEMENUCOLOR > 13 then OPT_GAMEMENUCOLOR := 13;
        addmessage('"menucolor" is set to "'+inttostR(OPT_GAMEMENUCOLOR)+'"');
end;
// ------------------------------------------------------------
{if strpar(s,0) = 'cachelevel' then begin
        if strpar(s,1) = '' then begin addmessage('"cachelevel" is "'+inttostr(OPT_CACHELEVEL)+'". Default "1". Range 0-3.'); exit; end;
        addmessage('"cachelevel" is readonly in this version...'); exit;
//        applyhcommand('quit');
        try
        OPT_CACHELEVEL := strtoint(strpar(s,1));
        except OPT_CACHELEVEL := 1; end;
        if OPT_CACHELEVEL <= 0 then OPT_CACHELEVEL := 0;
        if OPT_CACHELEVEL >= 3 then OPT_CACHELEVEL := 3;
        if GAME_FULLLOAD then begin
                addmessage('"cachelevel" is set to "'+inttostR(OPT_CACHELEVEL)+'". it requires full programm restart.');
                applyhcommand('quit');
        end;
end;}
// ------------------------------------------------------------
if strpar(s,0) = 'mousesmooth' then begin
        if strpar(s,1) = '' then begin addmessage('"mousesmooth" is "'+inttostr(OPT_MOUSESMOOTH)+'". Default "0". Range 0-100. "0"=disabled.'); exit; end;
        try
        OPT_MOUSESMOOTH := strtoint(strpar(s,1));
        except OPT_MOUSESMOOTH := 0; end;
        if OPT_MOUSESMOOTH <= 0 then OPT_MOUSESMOOTH := 0;
        if OPT_MOUSESMOOTH >= 100 then OPT_MOUSESMOOTH := 100;
        addmessage('"mousesmooth" is set to "'+inttostR(OPT_MOUSESMOOTH)+'"');
end;
// ------------------------------------------------------------
if strpar(s,0) = 'noplayer' then begin
        if strpar(s,1) = '' then begin addmessage('"noplayer" is "'+inttostr(OPT_NOPLAYER)+'". Default is "0". Possible range 0-2.'); exit; end;
        try
        OPT_NOPLAYER := strtoint(strpar(s,1));
        except OPT_NOPLAYER := 0; end;
        if OPT_NOPLAYER <= 0 then OPT_NOPLAYER := 0;
        if OPT_NOPLAYER >= 2 then OPT_NOPLAYER := 2;
        addmessage('"noplayer" is set to "'+inttostR(OPT_NOPLAYER)+'"');
end;
// ------------------------------------------------------------
if strpar(s,0) = 'fill_rgb' then addmessage('use command "fill_bgr"');

if strpar(s,0) = 'fill_bgr' then begin
        if strpar(s,1) = '' then begin addmessage('"fill_bgr" is "$'+inttohex(OPT_FILL_RGB,3)+'". Default is "$000000". Possible range $000000-$FFFFFF.'); exit; end;
        try OPT_FILL_RGB := strtoint(strpar(s,1));
        except OPT_FILL_RGB := 0;
        addmessage('invalid value, usage: "fill_bgr $FF0000"');
        end;
        if OPT_FILL_RGB <= 0 then OPT_FILL_RGB := 0;
        if OPT_FILL_RGB > $FFFFFF then OPT_FILL_RGB := $FFFFFF;
        addmessage('"fill_bgr" is set to "$'+inttohex(OPT_FILL_RGB,3)+'"');
end;                     

{
if strpar(s,0) = 'fill_g' then begin
        if strpar(s,1) = '' then begin addmessage('"fill_g" is "'+inttostr(OPT_BG_G)+'". Default is "0". Possible range 0-255.'); exit; end;
        try OPT_BG_G := strtoint(strpar(s,1));
        except OPT_BG_G := 0; end;
        if OPT_BG_G <= 0 then OPT_BG_G := 0;
        addmessage('"fill_g" is set to "'+inttostR(OPT_BG_G)+'"');
end;
if strpar(s,0) = 'fill_b' then begin
        if strpar(s,1) = '' then begin addmessage('"fill_b" is "'+inttostr(OPT_BG_B)+'". Default is "0". Possible range 0-255.'); exit; end;
        try OPT_BG_B := strtoint(strpar(s,1));
        except OPT_BG_B := 0; end;
        if OPT_BG_B <= 0 then OPT_BG_B := 0;
        addmessage('"fill_b" is set to "'+inttostR(OPT_BG_B)+'"');
end;}
// ------------------------------------------------------------
if strpar(s,0) = 'weaponswitch_on_end' then begin
        if strpar(s,1) = '' then begin addmessage('"weaponswitch_on_end" is "'+inttostr(OPT_WEAPONSWITCH_END)+'". Default is "1". Possible range 0-2.'); exit; end;
        try
        OPT_WEAPONSWITCH_END := strtoint(strpar(s,1));
        except OPT_WEAPONSWITCH_END := 1; end;
        if OPT_WEAPONSWITCH_END <= 0 then OPT_WEAPONSWITCH_END := 0;
        if OPT_WEAPONSWITCH_END >= 2 then OPT_WEAPONSWITCH_END := 2;
        addmessage('"weaponswitch_on_end" is set to "'+inttostR(OPT_WEAPONSWITCH_END)+'"');
end;
if strpar(s,0) = 'p2weaponswitch_on_end' then begin
        if strpar(s,1) = '' then begin addmessage('"p2weaponswitch_on_end" is "'+inttostr(OPT_P2WEAPONSWITCH_END)+'". Default is "1". Possible range 0-2.'); exit; end;
        try
        OPT_P2WEAPONSWITCH_END := strtoint(strpar(s,1));
        except OPT_P2WEAPONSWITCH_END := 1; end;
        if OPT_P2WEAPONSWITCH_END <= 0 then OPT_P2WEAPONSWITCH_END := 0;
        if OPT_P2WEAPONSWITCH_END >= 2 then OPT_P2WEAPONSWITCH_END := 2;
        addmessage('"p2weaponswitch_on_end" is set to "'+inttostR(OPT_P2WEAPONSWITCH_END)+'"');
end;
// ------------------------------------------------------------
if strpar(s,0) = 'brickreplace' then begin
        IF strpar(s,1) = '' THEN BEGIN addmessage('usage: brickreplace <bricknumber>'); exit; end;
        try
                strtoint(strpar(s,1));
        except addmessage('Invalid value. Possible value "54-254"'); exit; end;

        if strtoint(strpar(s,1)) = 0 then begin
                        G_BRICKREPLACE := 0;
                        addmessage('brickreplace disabled.'); exit;
                end;
        if (strtoint(strpar(s,1)) < 54) or (strtoint(strpar(s,1)) > 254) then begin
                addmessage('Out of range. Possible value "54-254"'); exit; end;

        G_BRICKREPLACE := strtoint(strpar(s,1));

{        for i := 0 to BRICK_X - 1 do
        for a := 0 to BRICK_Y - 1 do
                if bbb[i,a].image >= 54 then bbb[i,a].image := strtoint(strpar(s,1));}
end;
// ------------------------------------------------------------
if strpar(s,0) = 'messagetime' then begin
        if strpar(s,1) = '' then begin addmessage('"messagetime" is "'+inttostr(OPT_MESSAGETIME)+'". Default is "125". Possible range 0-500.'); exit; end;
        try
        OPT_MESSAGETIME := strtoint(strpar(s,1));
        except OPT_MESSAGETIME := 125; end;
        if OPT_MESSAGETIME > 500 then OPT_MESSAGETIME := 500;
        addmessage('"messagetime" is set to "'+inttostR(OPT_MESSAGETIME)+'"');
end;
// ------------------------------------------------------------
if strpar(s,0) = 'forcerespawn' then begin
        if strpar(s,1) = '' then begin addmessage('"forcerespawn" is "'+inttostr(OPT_FORCERESPAWN)+'". Default is "10". Possible range 2-10.'); exit; end;
        if ismultip=2 then begin addmessage('server side command.'); exit; end;
        if (ismultip=1) and (OPT_SV_LOCK) then begin addmessage('server commands locked!'); exit; end;

        try
        OPT_FORCERESPAWN := strtoint(strpar(s,1));
        except OPT_FORCERESPAWN := 10; end;
        if OPT_FORCERESPAWN < 2 then OPT_FORCERESPAWN := 2;
        if OPT_FORCERESPAWN > 10 then OPT_FORCERESPAWN := 10;
        addmessage('"forcerespawn" is set to "'+inttostR(OPT_FORCERESPAWN)+'"');
        if ismultip=1 then SV_TransmitCMD;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'speeddemo' then begin
        if not MATCH_DDEMOPLAY then begin
                addmessage('available only in demo');
                exit;
                end;
        if strpar(s,1) = '' then begin addmessage('"speeddemo" is "'+inttostr(OPT_SPEEDDEMO)+'". Normal speed is "20". Possible range 0-40.'); exit; end;
        try
        OPT_SPEEDDEMO := strtoint(strpar(s,1));
        except OPT_SPEEDDEMO := 20; end;
        if OPT_SPEEDDEMO <= 0 then OPT_SPEEDDEMO := 0;
        if OPT_SPEEDDEMO >= 40 then OPT_SPEEDDEMO := 40;
        if OPT_SPEEDDEMO > 20 then
                mainform.dxtimer.fps := 30+trunc(OPT_SPEEDDEMO*2)
        else mainform.dxtimer.fps := 30+OPT_SPEEDDEMO;

        if SYS_NFKAMP_PLAYINGCOMMENT then
        addmessage('"speeddemo" is set to "'+inttostr(OPT_SPEEDDEMO)+'". ^1WARNING: disbalance with mp3 comment') else
        addmessage('"speeddemo" is set to "'+inttostr(OPT_SPEEDDEMO)+'"');
end;
if strpar(s,0) = 'testspeeddemo' then begin
        if not MATCH_DDEMOPLAY then begin
                addmessage('available only in demo');
                exit;
                end;
        if strpar(s,1) = '' then begin addmessage('"speeddemo" is "'+inttostr(OPT_SPEEDDEMO)+'". Normal speed is "20". Possible range 0-?.'); exit; end;
        try
        OPT_SPEEDDEMO := strtoint(strpar(s,1));
        except OPT_SPEEDDEMO := 20; end;
        if OPT_SPEEDDEMO <= 0 then OPT_SPEEDDEMO := 0;
        if OPT_SPEEDDEMO >= 100 then OPT_SPEEDDEMO := 100;
        mainform.dxtimer.fps := 30+OPT_SPEEDDEMO;


        addmessage('"speeddemo" is set to "'+inttostR(OPT_SPEEDDEMO)+'"');
end;
// ---------
{ if strpar(s,0) = 'setspeed' then begin
        try mainform.dxtimer.fps := strtoint(strpar(s,1));
        except mainform.dxtimer.fps := 50; end;
 end;}
// ------------------------------------------------------------
if strpar(s,0) = 'corpsetime' then begin
        if strpar(s,1) = '' then begin addmessage('"corpsetime" is "'+inttostr(OPT_CORPSETIME)+'". Default is "10". Possible range 0-60.'); exit; end;
        try
        OPT_CORPSETIME := strtoint(strpar(s,1));
        except OPT_CORPSETIME := 2; end;
        if OPT_CORPSETIME <= 0 then OPT_CORPSETIME := 0;
        if OPT_CORPSETIME >= 60 then OPT_CORPSETIME := 60;
        addmessage('"corpsetime" is set to "'+inttostR(OPT_CORPSETIME)+'"');
end;
// ------------------------------------------------------------
if strpar(s,0) = 'getplayersid' then begin
        if INMENU=true then begin addmessage('Use this command in the match'); exit; end;
        addmessage('= ID = Name ============ ');
        if strpar(s,1) = '' then
                for i:=0 to 7 do if players[i] <> nil then addmessage('     '+inttostr(i)+'     '+players[i].netname);
end;
// ------------------------------------------------------------
if strpar(s,0) = 'bar2assign' then begin
        if (INMENU=true) or (MATCH_DDEMOPLAY=false) then begin addmessage('Use this command in the demo.'); exit; end;
        if strpar(s,1) = '' then begin addmessage('Usage: bar2assign <playerid>'); exit; end;
        try strtoint(strpar(s,1)); except addmessage('Invalid value '+strpar(s,1)); exit; end;
        if (strtoint(strpar(s,1)) < 0) or (strtoint(strpar(s,1)) > 7) then begin addmessage('no such player with playerid='+strpar(s,1)); exit; end;
        if players[strtoint(strpar(s,1))] = nil then begin addmessage('no such player with playerid='+strpar(s,1)); exit; end;
        if strtoint(strpar(s,1)) = OPT_1BARTRAX then begin addmessage('cannot assign. another statusbar uses this player.'); exit; end;
        SYS_BAR2AVAILABLE := true;
        OPT_2BARTRAX := strtoint(strpar(s,1));
        addmessage('statusbar2 assigned to '+players[OPT_2BARTRAX].netname);
end;
// ------------------------------------------------------------

if strpar(s,0)= 'kickplayer' then begin
        if INMENU=true then begin addmessage('Use this command in the match.'); exit; end;
        if ISMULTIP=0 then begin addmessage('This command for multiplayer only.'); exit; end;
        if ISMULTIP=2 then begin addmessage('Serverside command.'); exit; end;
        if strpar(s,1) = '' then begin
                if hist_disable = true then MsgSize := 1 else MsgSize := 0;
                if ALIASCOMMAND then kk := 1 else kk := 0;
                addmessage('^3Usage:^7 kickplayer <playerid>');
                ALIASCOMMAND := true;
                HIST_DISABLE := true;
                applycommand('getplayersid');
                if MsgSize = 0 then HIST_DISABLE := false;
                if kk=1 then ALIASCOMMAND := false;
                exit; end;
        try strtoint(strpar(s,1)); except addmessage('Invalid value '+strpar(s,1)); exit; end;
        if (strtoint(strpar(s,1)) < 0) or (strtoint(strpar(s,1)) > 7) then begin addmessage('no such player with playerid='+strpar(s,1)); exit; end;
        if players[strtoint(strpar(s,1))] = nil then begin addmessage('no such player with playerid='+strpar(s,1)); exit; end;
        if players[strtoint(strpar(s,1))].netobject = false then begin addmessage('Cannot kick local players.'); exit; end;
        if players[strtoint(strpar(s,1))].NETUpdateD = false then begin addmessage('Looks like this player already kicked.'); exit; end;
        if players[strtoint(strpar(s,1))] <> nil then
        if ismultip=1 then begin
                MsgSize := SizeOf(TMP_KickPlayer);
                Msg6.DATA := MMP_KICKPLAYER;
                Msg6.DXID := players[strtoint(strpar(s,1))].dxid;
                mainform.BNETSendData2All (Msg6, MsgSize, 1);
        end;
        players[strtoint(strpar(s,1))].NETUpdateD := false;
        players[strtoint(strpar(s,1))].balloon := false;
        addmessage(players[strtoint(strpar(s,1))].netname +' ^7^nwas kicked.');
end;
// ------------------------------------------------------------
if strpar(s,0) = 'cameratype' then begin
        if strpar(s,1) = '' then begin addmessage('"cameratype" is "'+inttostr(OPT_CAMERATYPE)+'". Default is "1". Possible range 0-1.'); exit; end;
        try
        OPT_CAMERATYPE := strtoint(strpar(s,1));
        except OPT_CAMERATYPE := 1; end;
        if OPT_CAMERATYPE <= 0 then OPT_CAMERATYPE := 0;
        if OPT_CAMERATYPE >= 1 then OPT_CAMERATYPE := 1;
        if OPT_CAMERATYPE = 0 then begin
                GX := 0;
                GY := 0;
        end;

        if inmenu=false then // cheat block.
        if (ISHotSeatMap=false) and (OPT_CAMERATYPE=0) then OPT_CAMERATYPE := 1;

        addmessage('"cameratype" is set to "'+inttostR(OPT_CAMERATYPE)+'"');
end;
// ------------------------------------------------------------
if strpar(s,0) = 'railtrailtime' then begin
        if strpar(s,1) = '' then begin addmessage('"railtrailtime" is "'+inttostr(OPT_RAILTRAILTIME)+'". Default is "8". Possible value 1-17.'); exit; end;
        try
        OPT_RAILTRAILTIME := strtoint(strpar(s,1));
        except OPT_RAILTRAILTIME := 6; end;
        OPT_RAILTRAILTIME := formatbyte(OPT_RAILTRAILTIME);
        if OPT_RAILTRAILTIME <= 0 then OPT_RAILTRAILTIME := 1;
        if OPT_RAILTRAILTIME > 17 then OPT_RAILTRAILTIME := 17;

        addmessage('"railtrailtime" is set to "'+strpar(s,1)+'"');
end;
// ------------------------------------------------------------
if strpar(s,0) = 'sync' then begin
        if strpar(s,1) = '' then begin addmessage('sync is "'+inttostr(OPT_SYNC)+'". Default is "3". Possible value 1-3. (1=heavy).'); exit; end;
        if ismultip=2 then begin addmessage('server side command.'); exit; end;
        if (ismultip=1) and (OPT_SV_LOCK) then begin addmessage('server commands locked!'); exit; end;

        try
        OPT_SYNC := strtoint(strpar(s,1));
        except OPT_SYNC := 1; end;
        if OPT_SYNC < 1 then OPT_SYNC:=1;
        if OPT_SYNC > 3 then OPT_SYNC:=3;
        addmessage('"sync" is set to "'+inttostr(OPT_SYNC)+'"');
        if ismultip=1 then SV_TransmitCMD;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'barflash' then begin
        if strpar(s,1) = '1' then begin ADDMESSAGE('"barflash" is set to "1"'); DRAW_BARFLASH := true; end;
        if strpar(s,1) = '0' then begin ADDMESSAGE('"barflash" is set to "0"'); DRAW_BARFLASH :=false; end;
        if strpar(s,1) = '' then begin
                if DRAW_BARFLASH = true then ADDMESSAGE('"barflash" is "1". Default "0". Possible range 0-1.') else
                ADDMESSAGE('"barflash" is "0". Default "0". Possible range 0-1.'); end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'doorsounds' then begin
        if strpar(s,1) = '1' then begin ADDMESSAGE('"doorsounds" is set to "1"'); OPT_DOORSOUNDS := true; end;
        if strpar(s,1) = '0' then begin ADDMESSAGE('"doorsounds" is set to "0"'); OPT_DOORSOUNDS :=false; end;
        if strpar(s,1) = '' then begin
                if OPT_DOORSOUNDS = true then ADDMESSAGE('"doorsounds" is "1". Default "1". Possible range 0-1.') else
                ADDMESSAGE('"doorsounds" is "0". Default "1". Possible range 0-1.'); end;
end;
// ------------------------------------------------------------
if (strpar(s, 0) = 'warmuparmor') then begin
                if strpar(s,1) = '' then addmessage('"warmuparmor" is "'+inttostr(OPT_WARMUPARMOR)+'". Default is "100". Possible range is 0-200.')
        else begin
                if ismultip=2 then begin addmessage('server side command.'); exit; end;
                tmp := FilterString(strpar(s,1));
                try OPT_WARMUPARMOR := strtoint(tmp); except addmessage('"'+strpar(s,1)+'" is invalid value.'); OPT_WARMUPARMOR := 100; end;
                OPT_WARMUPARMOR := formatbyte(OPT_WARMUPARMOR);
                if OPT_WARMUPARMOR > 200 then  OPT_WARMUPARMOR := 200;
                if OPT_WARMUPARMOR <= 0 then  OPT_WARMUPARMOR := 0;
                addmessage('"warmuparmor" is set to "'+inttostr(OPT_WARMUPARMOR)+'"');
                if ismultip=1 then SV_TransmitCMD;
        end;end;
// ------------------------------------------------------------
if (strpar(s, 0) = 'ch_hudwidth') then begin
        if strpar(s,1) = '' then addmessage('"ch_hudwidth" is "'+inttostr(OPT_HUD_WIDTH)+'". Default is "32". Possible range is 8-128.')
        else begin
                tmp := FilterString(par1);
                try OPT_HUD_WIDTH := strtoint(tmp); except addmessage('"'+strpar(s,1)+'" is invalid value.'); OPT_HUD_WIDTH := 32; end;
                OPT_HUD_WIDTH := formatbyte(OPT_HUD_WIDTH);
                if OPT_HUD_WIDTH > 128 then  OPT_HUD_WIDTH := 128;
                if OPT_HUD_WIDTH <= 8 then  OPT_HUD_WIDTH := 8;
                addmessage('"ch_hudwidth" is set to "'+inttostr(OPT_HUD_WIDTH)+'"');
        end;
end;
// ------------------------------------------------------------
if (strpar(s, 0) = 'ch_hudheight') then begin
        if strpar(s,1) = '' then addmessage('"ch_hudheight" is "'+inttostr(OPT_HUD_HEIGTH)+'". Default is "32". Possible range is 8-128.')
        else begin
                tmp := FilterString(par1);
                try OPT_HUD_HEIGTH := strtoint(tmp); except addmessage('"'+strpar(s,1)+'" is invalid value.'); OPT_HUD_HEIGTH := 32; end;
                OPT_HUD_HEIGTH := formatbyte(OPT_HUD_HEIGTH);
                if OPT_HUD_HEIGTH > 128 then  OPT_HUD_HEIGTH := 128;
                if OPT_HUD_HEIGTH <= 8 then  OPT_HUD_HEIGTH := 8;
                addmessage('"ch_hudheight" is set to "'+inttostr(OPT_HUD_HEIGTH)+'"');
        end;
end;
// ------------------------------------------------------------
if (strpar(s, 0) = 'ch_hudx') then begin
        if strpar(s,1) = '' then addmessage('"ch_hudx" is "'+inttostr(OPT_HUD_X)+'". Default is "320". Possible range is 0-640.')
        else begin
                tmp := FilterString(par1);
                try OPT_HUD_X := strtoint(tmp); except addmessage('"'+strpar(s,1)+'" is invalid value.'); OPT_HUD_X := 320; end;
//                OPT_HUD_X := formatbyte(OPT_HUD_X);
                if OPT_HUD_X > 640 then  OPT_HUD_X := 640;
                if OPT_HUD_X <= 0 then  OPT_HUD_X := 0;
                addmessage('"ch_hudx" is set to "'+inttostr(OPT_HUD_X)+'"');
        end;
end;
// ------------------------------------------------------------
if (strpar(s, 0) = 'ch_hudy') then begin
        if strpar(s,1) = '' then addmessage('"ch_hudy" is "'+inttostr(OPT_HUD_Y)+'". Default is "432". Possible range is 0-500.')
        else begin
                tmp := FilterString(par1);
                try OPT_HUD_Y := strtoint(tmp); except addmessage('"'+strpar(s,1)+'" is invalid value.'); OPT_HUD_Y := 432; end;
//                OPT_HUD_Y := formatbyte(OPT_HUD_Y);
                if OPT_HUD_Y > 500 then  OPT_HUD_Y := 500;
                if OPT_HUD_Y <= 0 then  OPT_HUD_Y := 0;
                addmessage('"ch_hudy" is set to "'+inttostr(OPT_HUD_Y)+'"');
        end;
end;
// ------------------------------------------------------------
if (strpar(s, 0) = 'ch_hudalpha') then begin
        if strpar(s,1) = '' then addmessage('"ch_hudalpha" is "'+inttostr(OPT_HUD_ALPHA)+'". Default is "432". Possible range is 20-255.')
        else begin
                tmp := FilterString(par1);
                try OPT_HUD_ALPHA := strtoint(tmp); except addmessage('"'+strpar(s,1)+'" is invalid value.'); OPT_HUD_ALPHA := 200; end;
                OPT_HUD_ALPHA := formatbyte(OPT_HUD_ALPHA);
                if OPT_HUD_ALPHA > 255 then OPT_HUD_ALPHA := 255;
                if OPT_HUD_ALPHA <= 20 then OPT_HUD_ALPHA := 20;
                addmessage('"ch_hudalpha" is set to "'+inttostr(OPT_HUD_ALPHA)+'"');
        end;
end;
// ------------------------------------------------------------
if (strpar(s, 0) = 'ch_hudstretch') then begin
        if strpar(s,1) = '' then addmessage('"ch_hudstretch" is "'+inttostr(OPT_HUD_DIVISOR)+'". Default is "6". Possible range is 3-15.')
        else begin
                tmp := FilterString(par1);
                try OPT_HUD_DIVISOR := strtoint(tmp); except addmessage('"'+strpar(s,1)+'" is invalid value.'); OPT_HUD_DIVISOR := 6; end;
                OPT_HUD_DIVISOR := formatbyte(OPT_HUD_DIVISOR);
                if OPT_HUD_DIVISOR > 15 then  OPT_HUD_DIVISOR := 15;
                if OPT_HUD_DIVISOR <= 3 then  OPT_HUD_DIVISOR := 3;
                addmessage('"ch_hudstretch" is set to "'+inttostr(OPT_HUD_DIVISOR)+'"');
        end;
end;
// ------------------------------------------------------------
if (strpar(s, 0) = 'ch_hudvisible') then begin
        if strpar(s,1) = '' then addmessage('"ch_hudvisible" is "'+inttostr(OPT_HUD_VISIBLE)+'". Default is "1". [0-none; 1-large maps; 2-always]')
        else begin
                tmp := FilterString(par1);
                try OPT_HUD_VISIBLE := strtoint(tmp); except addmessage('"'+strpar(s,1)+'" is invalid value.'); OPT_HUD_VISIBLE := 1; end;
                OPT_HUD_VISIBLE := formatbyte(OPT_HUD_VISIBLE);
                if OPT_HUD_VISIBLE > 2 then  OPT_HUD_VISIBLE := 2;
                if OPT_HUD_VISIBLE <= 0 then  OPT_HUD_VISIBLE := 0;
                addmessage('"ch_hudvisible" is set to "'+inttostr(OPT_HUD_VISIBLE)+'"   [0-none; 1-large maps; 2-always]');
        end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'ch_hudshadow' then begin
        if strpar(s,1) = '' then begin
                st := '"ch_hudshadow" is "';
                if OPT_HUD_SHADOWED = true then st := st + '1' else st := st + '0';
                st := st + '". Default is "1". Possible range 0-1.';
                addmessage(st);
        end else begin
                par := strpar(s,1);
                if par='1' then OPT_HUD_SHADOWED := true;
                if par='0' then OPT_HUD_SHADOWED := false;
                if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else
                addmessage('invalid value "'+par+'"');
        end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'ch_hudicons' then begin
        if strpar(s,1) = '' then begin
                st := '"ch_hudicons" is "';
                if OPT_HUD_ICONS = true then st := st + '1' else st := st + '0';
                st := st + '". Default is "1". Possible range 0-1.';
                addmessage(st);
        end else begin
                par := strpar(s,1);
                if par='1' then OPT_HUD_ICONS := true;
                if par='0' then OPT_HUD_ICONS := false;
                if (par = '1') or (par = '0') then addmessage(strpar(s,0) + ' is set to "'+par+'"') else
                addmessage('invalid value "'+par+'"');
        end;
end;



// ------------------------------------------------------------
if (strpar(s, 0) = 's_channelapproach') then begin
                if strpar(s,1) = '' then addmessage('"s_channelapproach" is "'+inttostr(OPT_CHANNELAPPROACH)+'". Default is "8". Possible range is 1-30.')
        else begin
                tmp := FilterString(strpar(s,1));
                try OPT_CHANNELAPPROACH := strtoint(tmp); except addmessage('"'+strpar(s,1)+'" is invalid value.'); OPT_CHANNELAPPROACH := 10; end;
                OPT_CHANNELAPPROACH := formatbyte(OPT_CHANNELAPPROACH);
                if OPT_CHANNELAPPROACH > 30 then  OPT_CHANNELAPPROACH := 30;
                if OPT_CHANNELAPPROACH = 0 then  OPT_CHANNELAPPROACH := 1;
                addmessage('"s_channelapproach" is set to "'+inttostr(OPT_CHANNELAPPROACH)+'"');
        end;end;
// ------------------------------------------------------------
if strpar(s,0) = 's_reversestereo' then begin
        if strpar(s,1) = '1' then begin ADDMESSAGE('"s_reversestereo" is set to "1"'); OPT_REVERSESTEREO := true; end;
        if strpar(s,1) = '0' then begin ADDMESSAGE('"s_reversestereo" is set to "0"'); OPT_REVERSESTEREO :=false; end;
        if strpar(s,1) = '' then begin
                if OPT_REVERSESTEREO = true then ADDMESSAGE('"s_reversestereo" is "1". Default "0". Possible range 0-1.') else
                ADDMESSAGE('"s_reversestereo" is "0". Default "0". Possible range 0-1.'); end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 's_stereo' then begin
        if strpar(s,1) = '1' then begin ADDMESSAGE('"s_stereo" is set to "1"'); OPT_STEREO := true; end;
        if strpar(s,1) = '0' then begin ADDMESSAGE('"s_stereo" is set to "0"'); OPT_STEREO :=false; end;
        if strpar(s,1) = '' then begin
                if OPT_STEREO = true then ADDMESSAGE('"s_stereo" is "1". Default "1". Possible range 0-1.') else
                ADDMESSAGE('"s_stereo" is "0". Default "1". Possible range 0-1.'); end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'hitsound' then begin
        if strpar(s,1) = '1' then begin ADDMESSAGE('"hitsound" is set to "1"'); OPT_HITSND := true; end;
        if strpar(s,1) = '0' then begin ADDMESSAGE('"hitsound" is set to "0"'); OPT_HITSND :=false; end;
        if strpar(s,1) = '' then begin
                if OPT_HITSND = true then ADDMESSAGE('"hitsound" is "1". Default "1". Possible range 0-1.') else
                ADDMESSAGE('"hitsound" is "0". Default "1". Possible range 0-1.'); end;
end;
// ------------------------------------------------------------
{if strpar(s,0) = 'gibvelocity' then begin
        if strpar(s,1) = '1' then begin ADDMESSAGE('"gibvelocity" is set to "1"'); OPT_GIBVELOCITY := true; end;
        if strpar(s,1) = '0' then begin ADDMESSAGE('"gibvelocity" is set to "0"'); OPT_GIBVELOCITY :=false; end;
        if strpar(s,1) = '' then begin
                if OPT_GIBVELOCITY = true then ADDMESSAGE('"gibvelocity" is "1". Default "0". Possible range 0-1.') else
                ADDMESSAGE('"gibvelocity" is "0". Default "0". Possible range 0-1.'); end;
end;}
// ------------------------------------------------------------
if strpar(s,0) = 'gibblood' then begin
        if strpar(s,1) = '1' then begin ADDMESSAGE('"gibblood" is set to "1"'); OPT_GIBBLOOD := true; end;
        if strpar(s,1) = '0' then begin ADDMESSAGE('"gibblood" is set to "0"'); OPT_GIBBLOOD :=false; end;
        if strpar(s,1) = '' then begin
                if OPT_GIBBLOOD = true then ADDMESSAGE('"gibblood" is "1". Default "0". Possible range 0-1.') else
                ADDMESSAGE('"gibblood" is "0". Default "0". Possible range 0-1.'); end;
end;
// ------------------------------------------------------------

if strpar(s,0) = 'drawbackground' then begin
        if strpar(s,1) = '1' then begin ADDMESSAGE('"drawbackground" is set to "1"'); DRAW_BACKGROUND := true; end;
        if strpar(s,1) = '0' then begin ADDMESSAGE('"drawbackground" is set to "0"'); DRAW_BACKGROUND :=false; end;
        if strpar(s,1) = '' then begin
                if DRAW_BACKGROUND = true then ADDMESSAGE('"drawbackground" is "1". Default "0". Possible range 0-1.') else
                ADDMESSAGE('"drawbackground" is "0". Default "0". Possible range 0-1.'); end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'drawfps' then begin
        if strpar(s,1) = '1' then begin ADDMESSAGE('"drawfps" is set to "1"'); DRAW_FPS := true; end;
        if strpar(s,1) = '0' then begin ADDMESSAGE('"drawfps" is set to "0"'); DRAW_FPS :=false; end;
        if strpar(s,1) = '' then begin
                if DRAW_FPS = true then ADDMESSAGE('"drawfps" is "1". Default "0". Possible range 0-1.') else
                ADDMESSAGE('"drawfps" is "0". Default "0". Possible range 0-1.'); end;
end;
// ------------------------------------------------------------
if strpar(s,0) = 'drawnumobjects' then begin
        if strpar(s,1) = '1' then begin ADDMESSAGE('"drawnumobjects" is set to "1"'); DRAW_OBJECTS := true; end;
        if strpar(s,1) = '0' then begin ADDMESSAGE('"drawnumobjects" is set to "0"'); DRAW_OBJECTS :=false; end;
        if strpar(s,1) = '' then begin
                if DRAW_OBJECTS = true then ADDMESSAGE('"drawnumobjects" is "1". Default "0". Possible range 0-1.') else
                ADDMESSAGE('"drawnumobjects" is "0". Default "0". Possible range 0-1.'); end;
end;
// ------------------------------------------------------------
if (strpar(s,0) = 'smoke') then begin
        if (strpar(s,1) = '') then begin if OPT_SMOKE = true then addmessage('"smoke" is "1". Default is "0". Possible range is 0-1.') else addmessage('"smoke" is "0". Default is "0". Possible range is 0-1.') end;
        if (strpar(s,1) = '1') then begin addmessage('"smoke" is set to "1"'); OPT_SMOKE := true; end;
        if (strpar(s,1) = '0') then begin addmessage('"smoke" is set to "0"'); OPT_SMOKE := false; end;
        end;
// ------------------------------------------------------------
{if (strpar(s,0) = 'simplephysics') then begin
        if (strpar(s,1) = '') then begin if CON_SIMPLEPHYSICS = true then addmessage('"simplephysics" is "1". Default is "0". Possible range is 0-1.') else addmessage('"simplephysics" is "0". Default is "0". Possible range is 0-1.') end;
        if (strpar(s,1) = '1') then begin addmessage('"simplephysics" is set to "1"'); CON_SIMPLEPHYSICS := true; end;
        if (strpar(s,1) = '0') then begin addmessage('"simplephysics" is set to "0"'); CON_SIMPLEPHYSICS := false; end;
        end;}
// ------------------------------------------------------------
if (strpar(s,0) = 'menuanimation') then begin
        if (strpar(s,1) = '') then begin if OPT_MENUANIM = true then addmessage('"menuanimation" is "1". Default is "0". Possible range is 0-1.') else addmessage('"menuanimation" is "0". Default is "0". Possible range is 0-1.') end;
        if (strpar(s,1) = '1') then begin addmessage('"menuanimation" is set to "1"'); OPT_MENUANIM := true; end;
        if (strpar(s,1) = '0') then begin addmessage('"menuanimation" is set to "0"'); OPT_MENUANIM := false; end;
        end;
// ------------------------------------------------------------
{if (strpar(s,0) = 'damage_rail') then begin
        if strpar(s,1) = '' then addmessage('"damage_rail" is "'+inttostr(DAMAGE_RAIL)+'". Default is "100". Possible range is 0-65535.')
        else begin
                try DAMAGE_RAIL := strtoint(strpar(s,1)); except addmessage('"'+strpar(s,1) +'" is invalid value.'); DAMAGE_RAIL := 100; end;
                DAMAGE_RAIL := formatnumber(DAMAGE_RAIL);
                addmessage('"damage_rail" is set to "'+inttostr(DAMAGE_RAIL)+'"');
        end;end;
        }
// ------------------------------------------------------------
if (strpar(s,0) = 'barposition') then begin
        if strpar(s,1) = '' then addmessage('"barposition" is "'+inttostr(P1BARORIENT)+'". Default is "427". Possible range is 0-427.')
        else begin
                try P1BARORIENT := strtoint(strpar(s,1)); except addmessage('"'+strpar(s,1) +'" is invalid value.'); P1BARORIENT := 427; end;
                P1BARORIENT := formatnumber(P1BARORIENT);
                if P1BARORIENT > 427 then P1BARORIENT := 427;
                addmessage('"barposition" is set to "'+inttostr(P1BARORIENT)+'"');
        end;end;
// ------------------------------------------------------------
if (strpar(s,0) = 'fraglimit') then begin
        if strpar(s,1) = '' then addmessage('"fraglimit" is "'+inttostr(MATCH_FRAGLIMIT)+'". Default is "0". Possible range is 0-999.')

        else begin
                if ismultip=2 then begin addmessage('server side command.'); exit; end;
                if (ismultip=1) and (OPT_SV_LOCK) then begin addmessage('server commands locked!'); exit; end;
                try MATCH_FRAGLIMIT := strtoint(strpar(s,1)); except addmessage('"'+strpar(s,1) +'" is invalid value.'); MATCH_FRAGLIMIT := 25; end;
                MATCH_FRAGLIMIT := formatnumber(MATCH_FRAGLIMIT);
                if MATCH_FRAGLIMIT > 999 then MATCH_FRAGLIMIT := 999;
                addmessage('"fraglimit" is set to "'+inttostr(MATCH_FRAGLIMIT)+'"');
                if ismultip=1 then SV_TransmitCMD;
        end;end;
// ------------------------------------------------------------
if (strpar(s,0) = 'timelimit') then begin
        if strpar(s,1) = '' then addmessage('"timelimit" is "'+inttostr(MATCH_TIMELIMIT)+'". Default is "0". Possible range is 0-999.')
        else begin
                if ismultip=2 then begin addmessage('server side command.'); exit; end;
                if (ismultip=1) and (OPT_SV_LOCK) then begin addmessage('server commands locked!'); exit; end;
                try MATCH_TIMELIMIT := strtoint(strpar(s,1)); except addmessage('"'+strpar(s,1) +'" is invalid value.'); MATCH_TIMELIMIT := 0; end;
                MATCH_TIMELIMIT := formatnumber(MATCH_TIMELIMIT);
                if MATCH_TIMELIMIT > 999 then MATCH_TIMELIMIT := 999;
                addmessage('"timelimit" is set to "'+inttostr(MATCH_TIMELIMIT)+'"');
                if ismultip=1 then SV_TransmitCMD;
        end;end;
// ------------------------------------------------------------
if (strpar(s,0) = 'capturelimit') then begin
        if strpar(s,1) = '' then addmessage('"capturelimit" is "'+inttostr(MATCH_CAPTURELIMIT)+'". Default is "5". Possible range is 0-250.')
        else begin
                if ismultip=2 then begin addmessage('server side command.'); exit; end;
                if (ismultip=1) and (OPT_SV_LOCK) then begin addmessage('server commands locked!'); exit; end;
                try MATCH_CAPTURELIMIT := strtoint(strpar(s,1)); except addmessage('"'+strpar(s,1) +'" is invalid value.'); MATCH_CAPTURELIMIT := 0; end;
                MATCH_CAPTURELIMIT := formatnumber(MATCH_CAPTURELIMIT);
                if MATCH_CAPTURELIMIT > 250 then MATCH_CAPTURELIMIT := 250;
                addmessage('"capturelimit" is set to "'+inttostr(MATCH_CAPTURELIMIT)+'"');
                if ismultip=1 then SV_TransmitCMD;
        end;end;
// ------------------------------------------------------------
if (strpar(s,0) = 'domlimit') then begin
        if strpar(s,1) = '' then addmessage('"domlimit" is "'+inttostr(MATCH_DOMLIMIT)+'". Default is "300". Possible range is 0-10000.')
        else begin
                if ismultip=2 then begin addmessage('server side command.'); exit; end;
                if (ismultip=1) and (OPT_SV_LOCK) then begin addmessage('server commands locked!'); exit; end;
                try MATCH_DOMLIMIT := strtoint(strpar(s,1)); except addmessage('"'+strpar(s,1) +'" is invalid value.'); MATCH_DOMLIMIT := 0; end;
                MATCH_DOMLIMIT := formatnumber(MATCH_DOMLIMIT);
                if MATCH_DOMLIMIT > 10000 then MATCH_DOMLIMIT := 10000;
                addmessage('"domlimit" is set to "'+inttostr(MATCH_DOMLIMIT)+'"');
                if ismultip=1 then SV_TransmitCMD;
        end;end;
// ------------------------------------------------------------
if (strpar(s,0) = 'warmup') then begin
        if strpar(s,1) = '' then addmessage('"warmup" is "'+inttostr(MATCH_WARMUP)+'". Default is "10". Possible range is 3-999.')
        else begin
                if ismultip=2 then begin addmessage('server side command.'); exit; end;
                try MATCH_WARMUP := strtoint(strpar(s,1)); except addmessage('"'+strpar(s,1) +'" is invalid value.'); MATCH_WARMUP := 10; end;
                MATCH_WARMUP := formatnumber(MATCH_WARMUP);
                if MATCH_WARMUP > 999 then MATCH_WARMUP := 999;
                if MATCH_WARMUP < 3 then MATCH_WARMUP := 3;
                addmessage('"warmup" is set to "'+inttostr(MATCH_WARMUP)+'"');
                if ismultip=1 then SV_TransmitCMD;
        end;end;
// ------------------------------------------------------------
if (strpar(s,0) = 'weapbartime') then begin
        if strpar(s,1) = '' then addmessage('"weapbartime" is "'+inttostr(OPT_P1BARTIME)+'". Default is "100". Possible range is 0-250.')
        else begin
                try e := strtoint(strpar(s,1)); except addmessage('"'+strpar(s,1) +'" is invalid value.'); exit; end;

                if e > 250 then e := 250;
                if e < 0 then e := 0;
                OPT_P1BARTIME := e;
                addmessage('"weapbartime" is set to "'+inttostr(OPT_P1BARTIME)+'"');
        end;
end;
// ------------------------------------------------------------
if (strpar(s,0) = 'p2weapbartime') then begin
        if strpar(s,1) = '' then addmessage('"p2weapbartime" is "'+inttostr(OPT_P2BARTIME)+'". Default is "100". Possible range is 0-250.')
        else begin
                try e := strtoint(strpar(s,1)); except addmessage('"'+strpar(s,1) +'" is invalid value.'); exit; end;
                if e > 250 then e := 250;
                if e < 0 then e := 0;
                OPT_P2BARTIME := e;
                addmessage('"p2weapbartime" is set to "'+inttostr(OPT_P2BARTIME)+'"');
        end;
end;
// ------------------------------------------------------------
if (strpar(s,0) = 'map') then begin
        if MATCH_DDEMOPLAY then begin addmessage('Not able in demo.'); exit; end;
        if strpar(s,1) = '' then addmessage('usage: map mapname <gametype>') else
        begin
{                if players[0] = nil then begin
                        addmessage('cannot execute command. no server.');
                        exit;
                        end;
}

                if ismultip=2 then begin addmessage('server side command.'); exit; end;

                loadmapsearch_lastfile := ROOTDIR+'\maps\'+strpar(s,1)+'.mapa';

                if not fileexists(loadmapsearch_lastfile) then begin
                        if LoadMapSearchSimple(lowercase(extractfilename(loadmapsearch_lastfile)))<>LMS_OK then begin
                                addmessage('Could not find map '+strpar(s,1)+'.mapa');
                                exit;
                        end;
                end;

                if lowercase(extractfilename(map_filename))= lowercase(extractfilename(loadmapsearch_lastfile)) then begin
                        addmessage('This map is already loaded.');
                        exit;
                end;

                if MATCH_DRECORD then DemoEnd(END_JUSTEND);


{  GAMETYPE_FFA = 0;
  GAMETYPE_TEAM = 2;
  GAMETYPE_CTF = 3;
  GAMETYPE_RAILARENA = 4;
  GAMETYPE_TRIXARENA = 5;
  GAMETYPE_PRACTICE = 6;
  GAMETYPE_DOMINATION = 7;
 }

                kk := MATCH_GAMETYPE; // old gametype,
                // Gametype Change;
                st := strpar(s,2);
                //dm
                if st = 'ffa' then MATCH_GAMETYPE := GAMETYPE_FFA else
                if st = 'dm' then MATCH_GAMETYPE := GAMETYPE_FFA else
                if st = 'deathmatch' then MATCH_GAMETYPE := GAMETYPE_FFA else
                if st = '1v1' then MATCH_GAMETYPE := GAMETYPE_FFA else
                if st = '1' then MATCH_GAMETYPE := GAMETYPE_FFA else
                //tdm
                if st = 'team' then MATCH_GAMETYPE := GAMETYPE_TEAM else
                if st = 'tdm' then MATCH_GAMETYPE := GAMETYPE_TEAM else
                if st = 'teamplay' then MATCH_GAMETYPE := GAMETYPE_TEAM else
                if st = '2' then MATCH_GAMETYPE := GAMETYPE_TEAM else
                //ctf
                if st = 'ctf' then MATCH_GAMETYPE := GAMETYPE_CTF else
                if st = 'capturetheflag' then MATCH_GAMETYPE := GAMETYPE_CTF else
                if st = 'flag' then MATCH_GAMETYPE := GAMETYPE_CTF else
                if st = '3' then MATCH_GAMETYPE := GAMETYPE_CTF else
                //dom
                if st = 'dom' then MATCH_GAMETYPE := GAMETYPE_DOMINATION else
                if st = 'domination' then MATCH_GAMETYPE := GAMETYPE_DOMINATION else
                if st = '4' then MATCH_GAMETYPE := GAMETYPE_DOMINATION else
                //rail
                if st = 'rail' then MATCH_GAMETYPE := GAMETYPE_RAILARENA else
                if st = 'railarena' then MATCH_GAMETYPE := GAMETYPE_RAILARENA else
                if st = 'insta' then MATCH_GAMETYPE := GAMETYPE_RAILARENA else
                if st = 'instagib' then MATCH_GAMETYPE := GAMETYPE_RAILARENA else
                if st = '5' then MATCH_GAMETYPE := GAMETYPE_RAILARENA else
                //prac
                if st = 'prac' then MATCH_GAMETYPE := GAMETYPE_PRACTICE else
                if st = 'practice' then MATCH_GAMETYPE := GAMETYPE_PRACTICE else
                if st = 'training' then MATCH_GAMETYPE := GAMETYPE_PRACTICE else
                if st = 'train' then MATCH_GAMETYPE := GAMETYPE_PRACTICE else
                if st = '6' then MATCH_GAMETYPE := GAMETYPE_PRACTICE else
                if st <> '' then
                begin
                        addmessage('^5Changing gametype usage:');
                        addmessage('^2Command "^7map dm2 ^3deathmatch^2" will load map dm2 with DeathMatch gametype.');
                        addmessage('^5Other gametype commands:');
                        addmessage('^2DeathMatch: ^3ffa, dm, deathmatch, 1v1, 1');
                        if ismultip>0 then addmessage('^2TeamPlay: ^3team, tdm, teamplay, 2');
                        if ismultip>0 then addmessage('^2Capture The Flag: ^3ctf, capturetheflag, flag, 3');
                        if ismultip>0 then addmessage('^2Domination: ^3dom, domination, 4');
                        addmessage('^2Rail Arena: ^3rail, railarena, insta, instagib, 5');
                        addmessage('^2Practice: ^3prac, practice, training, train, 6');
                        addmessage('^2Trix Arena: ^3Trix arena gametype will enable automatically at trix maps (hotseat)');
                        if ismultip=0 then addmessage('^5TeamPlay, Capture The Flag, Domination gametypes available only in multiplayer');
                end;

{                if ismultip=0 then begin
                        if (MATCH_GAMETYPE=GAMETYPE_TEAM) or (MATCH_GAMETYPE=GAMETYPE_CTF) or (MATCH_GAMETYPE=GAMETYPE_DOMINATION) then begin
                                addmessage('^5TeamPlay, Capture The Flag, Domination gametypes available only in multiplayer');
                                MATCH_GAMETYPE:=GAMETYPE_FFA;
                        end;
                end;
}
                if ismultip=1 then begin
                        MsgSize := SizeOf(TMP_ChangeLevel);
                        Msg5.DATA := MMP_CHANGELEVEL;
                        Msg5.Filename := extractfilename(loadmapsearch_lastfile);
                        Msg5.CRC32 := LoadMapCRC32(loadmapsearch_lastfile);
                        Msg5.NewGameType := MATCH_GAMETYPE;
//                                addmessage('^1CRC32: '+inttostr(Msg5.CRC32));
                        mainform.BNETSendData2All (Msg5, MsgSize, 1);
                end;

                NFKPLANET_UpdateMapName ( copy(extractfilename(loadmapsearch_lastfile),0,length(extractfilename(loadmapsearch_lastfile))-5) );
                NFKPLANET_UpdateGameType(MATCH_GAMETYPE);

//                addmessage('^1DEBUG: '+extractfilename(loadmapsearch_lastfile));

                if ismultip=1 then begin
                        MsgSize := SizeOf(TMP_SV_MapRestart);
                        Msg4.DATA := MMP_MAPRESTART;
                        Msg4.reason := 1; // respawn all itemz;
                        mainform.BNETSendData2All (Msg4, MsgSize, 1);
                end;

                loadmap(loadmapsearch_lastfile, true);

                ass := inmenu;
                if inmenu then begin
                        MP_WAITSNAPSHOT := FALSE;
                        BNET_ISMULTIP := 1;
                        SpawnServer;
                end;

                for i := 0 to NUM_OBJECTS do if (ddd[i].active = true) and (ddd[i].objtype = 7) then
                if ISMULTIP=1 then begin
                        ShowCriticalError('Can''t change map','Can''t use trick arena maps for multiplayer','');
                        ApplyHcommand('disconnect');
                        exit;
                end;

                if MATCH_GAMETYPE = GAMETYPE_CTF then
                if not CTF_VALIDMAP then begin
                        ShowCriticalError('Can''t change map ('+extractfilename(strpar(s,1)) +')','This is not correct ','Capture The Flag map');
                        Applyhcommand('disconnect');
                        exit;
                end;

                if MATCH_GAMETYPE = GAMETYPE_DOMINATION then
                if not DOM_VALIDMAP then begin
                        ShowCriticalError('Can''t change map ('+extractfilename(strpar(s,1)) +')','This is not correct ','Domination map');
                        Applyhcommand('disconnect');
                        exit;
                end;

                if not ass then playsound(SND_prepare,0,0);
                MATCH_STARTSIN := MATCH_WARMUP*50;

                if kk<>MATCH_GAMETYPE then
                begin
                        SpawnServer_PreInit;
                        SpawnServer_PostInit;
                end;

                DLL_EVENT_MapChanged;

                MAP_RESTART;
                ApplyModels();
        end;
end;
// ------------------------------------------------------------
if par0='rcon' then begin
        if par1 = '' then begin
                addmessage('Usage: rcon <command>');
                exit;
                end;
        RCON_Send (strpar_next(s,1));
end;
// ------------------------------------------------------------
if (lowercase(par0) = 'rconpassword') then begin
        if par1 = '' then begin
                if OPT_RCON_PASSWORD = '' then
                addmessage('"rconpassword" is undefined. rcon currently disabled.') else
                addmessage('"rconpassword" is "'+OPT_RCON_PASSWORD+'". To disable rcon type "rconpassword unset"');
        end else
        begin
                OPT_RCON_PASSWORD := strpar_next(ss,1);
                if length(OPT_RCON_PASSWORD) > 50 then OPT_RCON_PASSWORD := copy(OPT_RCON_PASSWORD,1,50);
                if lowercase(trim(OPT_RCON_PASSWORD)) = 'unset' then begin
                        addmessage('"rconpassword" is now undefined. Remote control is disabled.');
                        OPT_RCON_PASSWORD := '';
                end else
                addmessage('"rconpassword" is changed to "'+OPT_RCON_PASSWORD+'". Remote control is ^5enabled^7.');
        end;
end;
// ------------------------------------------------------------
if (lowercase(strpar(ss,0)) = 'sv_hostname') then begin
        if strpar(s,1) = '' then addmessage('"sv_hostname" is "'+OPT_SV_HOSTNAME+'"') else
        begin
                OPT_SV_HOSTNAME := strpar_next(ss,1);
                if length(OPT_SV_HOSTNAME) > 30 then OPT_SV_HOSTNAME:=copy(OPT_SV_HOSTNAME,1,30);
                addmessage('"sv_hostname" is changed to "'+OPT_SV_HOSTNAME+'"');
                if inmenu=false then NFKPLANET_UpdateHostName(OPT_SV_HOSTNAME);
        end;
end;
// ------------------------------------------------------------
if (lowercase(strpar(ss,0)) = 'name') then begin
        if MATCH_DDEMOPLAY then begin addmessage('Not able in demo.'); exit; end;
        if strpar(s,1) = '' then addmessage('"name" is "'+p1name+'^7^n"') else
        begin

                par := P1NAME;
                if length(strpar(ss,1)) > 30 then P1NAME := copy(strpar_next(ss,1),1,30) else
                P1NAME := strpar_next(ss,1);
                addmessage(par+'^7^n renamed to '+P1NAME);

                for i := 0 to 7 do if players[i] <> nil then if players[i].idd = 0 then
                        players[i].netname := P1NAME;

                for i:=0 to 7 do if players[i] <> nil then if (players[i].netobject=false) and (players[i].idd=0) then
                begin

                        if MATCH_DRECORD then begin
                                DData.type0 := DDEMO_PLAYERRENAME;
                                DData.gametic := gametic;
                                DData.gametime := gametime;
                                DemoStream.Write( DData, Sizeof(DData));
                                DNETNameModelChange.DXID := players[i].DXID;
                                DNETNameModelChange.newstr := players[i].netname;
                                DemoStream.Write( DNETNameModelChange, Sizeof(DNETNameModelChange));
                        end;

                        if ismultip>0 then begin
                                MsgSize := SizeOf(TMP_NameModelChange);
                                Msg7.DATA := MMP_NAMECHANGE;
                                Msg7.DXID := players[i].DXID;
                                Msg7.newstr := players[i].netname;
                                if ismultip=2 then
                                mainform.BNETSendData2HOST (Msg7, MsgSize, 1) else
                                mainform.BNETSendData2All (Msg7, MsgSize, 1);
                        end;

                        break;
                end;


        end;
end;

// ------------------------------------------------------------
{if (lowercase(strpar(ss,0)) = 'playersounds') then begin
        exit;
        if strpar(s,1) = '' then addmessage('"playersounds" is "'+OPT_SOUNDMODEL1+'"') else
        begin
                addmessage('"playersounds" is set to '+strpar(ss,1));
                OPT_SOUNDMODEL1 := strpar(ss,1);
                if players[0] <> nil then players[0].soundmodel := OPT_SOUNDMODEL1;
        end;
end;}
// ------------------------------------------------------------
//if strpar(s,0) = 'unload' then SC_UnLoadUnusefulModels;

if strpar(s,0) = 'enemymodel' then begin
        if strpar(s,1) = '' then begin
                if OPT_ENEMYMODEL = '' then addmessage('"enemymodel" is undefined.') else
                addmessage('"enemymodel" is "'+OPT_ENEMYMODEL+'"');
                exit;
                end;

//        if ISMULTIP=0 then begin addmessage('This command for multiplayer only.'); exit; end;

        ass := true;
        par := lowercase(strpar(s,1));
        if extractmodelskinname(par)='' then par:=par+'+default';

        for i := 0 to NUM_MODELS-1 do if (eee[i].classname+'+'+eee[i].skinname) = par then ass := false;
        if ass = true then begin
                addmessage('Invalid enemy model. "enemymodel" now undefined.');
                OPT_ENEMYMODEL:='';
                exit;
        end;

        OPT_ENEMYMODEL := par;
        addmessage('"enemymodel" changed to "'+OPT_ENEMYMODEL+'"');


        if ISMULTIP=0 then exit;

        for i := 0 to 7 do if players[i] <> nil then if players[i].netobject = true then
                AssignModel(players[i]);
end;
// ------------------------------------------------------------
if strpar(s,0) = 'teammodel' then begin
        if strpar(s,1) = '' then begin
                if OPT_TEAMMODEL = '' then addmessage('"teammodel" is undefined.') else
                addmessage('"teammodel" is "'+OPT_TEAMMODEL+'"');
                exit;
                end;

//        if ISMULTIP=0 then begin addmessage('This command for multiplayer only.'); exit; end;

        ass := true;

        par := lowercase(strpar(s,1));
        if extractmodelskinname(par)='' then par:=par+'+default';

        for i := 0 to NUM_MODELS-1 do if (eee[i].classname+'+'+eee[i].skinname) = par then ass := false;
        if ass = true then begin
                addmessage('Invalid enemy model. "teammodel" now undefined.');
                OPT_TEAMMODEL:='';
                exit;
        end;

        OPT_TEAMMODEL := par;
        addmessage('"teammodel" changed to "'+OPT_TEAMMODEL+'"');

        if ISMULTIP=0 then exit;

        for i := 0 to 7 do if players[i] <> nil then if players[i].netobject = true then
                AssignModel(players[i]);
end;
// ------------------------------------------------------------

if strpar(s,0) = 'model' then begin
        if MATCH_DDEMOPLAY then begin addmessage('Not able in demo.'); exit; end;
        if strpar(s,1) = '' then addmessage('"model" is "'+OPT_NFKMODEL1+'"') else
        begin
                OPT_NFKMODEL1 := strpar(s,1);

                if extractmodelskinname(OPT_NFKMODEL1)='' then OPT_NFKMODEL1:=OPT_NFKMODEL1+'+default';

                if (inmenu) and (GAME_FULLLOAD) then begin
                        ass := true;
                        for i := 0 to NUM_MODELS-1 do if (eee[i].classname+'+'+eee[i].skinname) = OPT_NFKMODEL1 then ass := false;
                        if ass = true then begin
                                addmessage('invalid model+skin name.');
                                OPT_NFKMODEL1 := 'sarge+default';
                        end;
                end;

                addmessage('"model" is set to '+OPT_NFKMODEL1);

                if inmenu then exit;

                for i := 0 to 7 do if players[i] <> nil then if players[i].idd = 0 then begin
                        players[i].nfkmodel := OPT_NFKMODEL1;
                        if not ASSIGNMODEL(players[i]) then OPT_NFKMODEL1 := 'sarge+default' else begin


                                if MATCH_DRECORD then begin
                                        DData.type0 := DDEMO_PLAYERMODELCHANGE;
                                        DData.gametic := gametic;
                                        DData.gametime := gametime;
                                        DemoStream.Write( DData, Sizeof(DData));
                                        DNETNameModelChange.DXID := players[i].DXID;
                                        DNETNameModelChange.newstr := players[i].nfkmodel;
                                        DemoStream.Write( DNETNameModelChange, Sizeof(DNETNameModelChange));
                                end;

                                MsgSize := SizeOf(TMP_NameModelChange);
                                Msg7.DATA := MMP_MODELCHANGE;
                                Msg7.DXID := players[i].DXID;
                                Msg7.newstr := players[i].nfkmodel;

                                if ismultip=2 then
                                mainform.BNETSendData2HOST (Msg7, MsgSize, 1) else
                                mainform.BNETSendData2All (Msg7, MsgSize, 1);

                                end;
                        break;
                        end;
        end;
end;
if strpar(s,0) = 'p2model' then begin
        if MATCH_DDEMOPLAY then begin addmessage('Not able in demo.'); exit; end;
        if strpar(s,1) = '' then addmessage('"p2model" is "'+OPT_NFKMODEL2+'"') else
        begin
                OPT_NFKMODEL2 := strpar(s,1);

                if extractmodelskinname(OPT_NFKMODEL2)='' then OPT_NFKMODEL2:=OPT_NFKMODEL2+'+default';

                if (inmenu) and (GAME_FULLLOAD) then begin
                        ass := true;
                        for i := 0 to NUM_MODELS-1 do if (eee[i].classname+'+'+eee[i].skinname) = OPT_NFKMODEL2 then ass := false;
                        if ass = true then begin
                                addmessage('invalid model+skin name.');
                                OPT_NFKMODEL2 := 'sarge+default';
                        end;
                end;

                addmessage('"p2model" is set to '+OPT_NFKMODEL2);
                if inmenu then exit;

                for i := 0 to 7 do if players[i] <> nil then if players[i].idd = 1 then begin
                        players[i].nfkmodel := OPT_NFKMODEL2;
                        if not ASSIGNMODEL(players[i]) then OPT_NFKMODEL2 := 'sarge+default' else begin

                                end;
                        break;
                        end;
        end;
end;
// ------------------------------------------------------------
{if (lowercase(strpar(ss,0)) = 'p2playersounds') then begin
        exit;
        if strpar(s,1) = '' then addmessage('"p2playersounds" is "'+OPT_SOUNDMODEL2+'"') else
        begin
                addmessage('"p2playersounds" is set to '+strpar(ss,1));
                OPT_SOUNDMODEL2 := strpar(ss,1);
                if players[1] <> nil then players[1].soundmodel := OPT_SOUNDMODEL2;
        end;
end;}
// ------------------------------------------------------------
if (lowercase(strpar(ss,0)) = 'p2name') then begin
        if MATCH_DDEMOPLAY then begin addmessage('Not able in demo.'); exit; end;
        if strpar(ss,1) = '' then addmessage('"p2name" is "'+p2name+'^7^n"') else
        begin
                par := P2NAME;
                if length(strpar_next(ss,1)) > 30 then P2NAME := copy(strpar_next(ss,1),1,30) else
                P2NAME := strpar_next(ss,1);
                addmessage(par+'^7^n renamed to '+P2NAME);
                for i := 0 to 7 do if players[i] <> nil then if players[i].idd = 1 then
                        players[i].netname := P2NAME;
        end;
end;
// ------------------------------------------------------------
if (strpar(s,0) = 'savelog') then begin
        if strpar(s,1) = '' then addmessage('usage: savelog filename.ext') else
        begin
                chdir(ROOTDIR);
                log.SaveToFile(strpar(s,1));
                addmessage('log saved to '+strpar(s,1));
        end;
end;
// ------------------------------------------------------------
{if (strpar(s, 0) = 'gamma') then begin
                addmessage('no gamma control in this version :(');
                {
                if strpar(s,1) = '' then addmessage('"gamma" is "'+inttostr(GAMMA)+'". Default is "0". Possible range is 0-255.')
        else begin
                tmp := FilterString(strpar(s,1));
                try GAMMA:= strtoint(tmp); except addmessage('"'+strpar(s,1)+'" is invalid value.'); GAMMA := 0; end;
                GAMMA := formatbyte(GAMMA);
                addmessage('"gamma" is set to "'+inttostr(GAMMA)+'"');
                Gamma_set(Gamma);
       end;}
//end;
// ------------------------------------------------------------
if (strpar(s, 0) = 'railcolor') then begin
                if strpar(s,1) = '' then addmessage('"railcolor" is "'+inttostr(OPT_RAILCOLOR1)+'". Default is "1". Possible range is 1-8.')
        else begin
                tmp := FilterString(strpar(s,1));
                try OPT_RAILCOLOR1:= strtoint(tmp); except addmessage('"'+strpar(s,1)+'" is invalid value.'); OPT_RAILCOLOR1 := 1; end;
                OPT_RAILCOLOR1 := formatbyte(OPT_RAILCOLOR1);
                if OPT_RAILCOLOR1 > 8 then  OPT_RAILCOLOR1 := 8;
                if OPT_RAILCOLOR1 = 0 then  OPT_RAILCOLOR1 := 1;
                addmessage('"railcolor" is set to "'+inttostr(OPT_RAILCOLOR1)+'"');
        end;end;
// ------------------------------------------------------------
if (strpar(s, 0) = 'p2railcolor') then begin
                if strpar(s,1) = '' then addmessage('"p2railcolor" is "'+inttostr(OPT_RAILCOLOR2)+'". Default is "1". Possible range is 1-8.')
        else begin
                tmp := FilterString(strpar(s,1));
                try OPT_RAILCOLOR2:= strtoint(tmp); except addmessage('"'+strpar(s,1)+'" is invalid value.'); OPT_RAILCOLOR2 := 1; end;
                OPT_RAILCOLOR2 := formatbyte(OPT_RAILCOLOR2);
                if OPT_RAILCOLOR2 > 8 then  OPT_RAILCOLOR2 := 8;
                if OPT_RAILCOLOR2 = 0 then  OPT_RAILCOLOR2 := 1;
                addmessage('"p2railcolor" is set to "'+inttostr(OPT_RAILCOLOR2)+'"');
        end;end;
// ------------------------------------------------------------
if (strpar(s, 0) = 'sensitivity') then begin
                if strpar(s,1) = '' then addmessage('"sensitivity" is "'+inttostr(OPT_SENS)+'". Default is "4". Possible range is 1-9.')
        else begin
                tmp := FilterString(strpar(s,1));
                try OPT_SENS:= strtoint(tmp); except addmessage('"'+strpar(s,1)+'" is invalid value.'); OPT_SENS := 4; end;
                OPT_SENS := formatbyte(OPT_SENS);
                if OPT_SENS > 9 then  OPT_SENS := 9;
                if OPT_SENS = 0 then  OPT_SENS := 1;
                addmessage('"sensitivity" is set to "'+inttostr(OPT_SENS)+'"');
        end;end;
// ------------------------------------------------------------
if (strpar(s, 0) = 'm_accelerate') then begin
                if strpar(s,1) = '' then addmessage('"m_accelerate" is "'+inttostr(OPT_MOUSEACCELDELIM)+'". Default is "0". Possible range is 0-15.')
        else begin
                tmp := FilterString(strpar(s,1));
                try OPT_MOUSEACCELDELIM:= strtoint(tmp); except addmessage('"'+strpar(s,1)+'" is invalid value.'); OPT_MOUSEACCELDELIM := 0; end;
                OPT_MOUSEACCELDELIM := formatbyte(OPT_MOUSEACCELDELIM);
                if OPT_MOUSEACCELDELIM > 15 then  OPT_MOUSEACCELDELIM := 15;
                addmessage('"m_accelerate" is set to "'+inttostr(OPT_MOUSEACCELDELIM)+'"');
        end;end;

// ------------------------------------------------------------

if (strpar(s, 0) = 'p2keybaccelerate') then begin
                if strpar(s,1) = '' then addmessage('"p2keybaccelerate" is "'+inttostr(OPT_KEYBACCELDELIM)+'". Default is "0". Possible range is 0-9.')
        else begin
                tmp := FilterString(strpar(s,1));
                try OPT_KEYBACCELDELIM:= strtoint(tmp); except addmessage('"'+strpar(s,1)+'" is invalid value.'); OPT_KEYBACCELDELIM := 0; end;
                OPT_KEYBACCELDELIM := formatbyte(OPT_KEYBACCELDELIM);
                if OPT_KEYBACCELDELIM > 9 then  OPT_KEYBACCELDELIM := 9;
                addmessage('"p2keybaccelerate" is set to "'+inttostr(OPT_KEYBACCELDELIM)+'"');
        end;end;

// ------------------------------------------------------------
if (strpar(s, 0) = 'keybaccelerate') then begin
                if strpar(s,1) = '' then addmessage('"keybaccelerate" is "'+inttostr(OPT_P1KEYBACCELDELIM)+'". Default is "0". Possible range is 0-9.')
        else begin
                tmp := FilterString(strpar(s,1));
                try OPT_P1KEYBACCELDELIM:= strtoint(tmp); except addmessage('"'+strpar(s,1)+'" is invalid value.'); OPT_P1KEYBACCELDELIM := 0; end;
                OPT_P1KEYBACCELDELIM := formatbyte(OPT_P1KEYBACCELDELIM);
                if OPT_P1KEYBACCELDELIM > 9 then  OPT_P1KEYBACCELDELIM := 9;
                addmessage('"keybaccelerate" is set to "'+inttostr(OPT_P1KEYBACCELDELIM)+'"');
        end;end;

// ------------------------------------------------------------
if (strpar(s, 0) = 'meatlevel') then begin
                if strpar(s,1) = '' then addmessage('"meatlevel" is "'+inttostr(OPT_MEATLEVEL)+'". Default is "1". Possible range is 0-3.')
        else begin
                tmp := FilterString(strpar(s,1));
                try OPT_MEATLEVEL:= strtoint(tmp); except addmessage('"'+strpar(s,1)+'" is invalid value.'); OPT_MEATLEVEL := 1; end;
                OPT_MEATLEVEL := formatbyte(OPT_MEATLEVEL);
                if OPT_MEATLEVEL > 3 then  OPT_MEATLEVEL := 3;
                addmessage('"meatlevel" is set to "'+inttostr(OPT_MEATLEVEL)+'"');
        end;end;
// ------------------------------------------------------------
if (strpar(s, 0) = 'keybsensitivity') then begin
                if strpar(s,1) = '' then addmessage('"keybsensitivity" is "'+inttostr(OPT_KSENS)+'". Default is "3". Possible range is 1-9.')
        else begin
                tmp := FilterString(strpar(s,1));
                try OPT_KSENS:= strtoint(tmp); except addmessage('"'+strpar(s,1)+'" is invalid value.'); OPT_KSENS := 3; end;
                OPT_KSENS := formatbyte(OPT_KSENS);
                if OPT_KSENS > 9 then  OPT_KSENS := 9;
                if OPT_KSENS = 0 then  OPT_KSENS := 1;
                addmessage('"keybsensitivity" is set to "'+inttostr(OPT_KSENS)+'"');
        end;end;
// ------------------------------------------------------------
if (strpar(s, 0) = 'crosscolor') then begin
                if strpar(s,1) = '' then addmessage('"crosscolor" is "'+inttostr(OPT_P1CROSH)+'". Default is "7". Possible range is 1-8.')
        else begin
                tmp := FilterString(strpar(s,1));
                try OPT_P1CROSH:= strtoint(tmp); except addmessage('"'+strpar(s,1)+'" is invalid value.'); OPT_P1CROSH := 7; end;
                OPT_P1CROSH := formatbyte(OPT_P1CROSH);
                if OPT_P1CROSH > 8 then  OPT_P1CROSH := 8;
                if OPT_P1CROSH = 0 then  OPT_P1CROSH := 1;
                addmessage('"crosscolor" is set to "'+inttostr(OPT_P1CROSH)+'"');
        end;end;
// ------------------------------------------------------------
if (strpar(s, 0) = 'crosstype') then begin
                if strpar(s,1) = '' then addmessage('"crosstype" is "'+inttostr(OPT_P1CROSHT)+'". Default is "1". Possible range is 0-9.')
        else begin
                tmp := FilterString(strpar(s,1));
                try OPT_P1CROSHT:= strtoint(tmp); except addmessage('"'+strpar(s,1)+'" is invalid value.'); OPT_P1CROSHT := 1; end;
                OPT_P1CROSHT := formatbyte(OPT_P1CROSHT);
                if OPT_P1CROSHT > 9 then  OPT_P1CROSHT := 9;
                addmessage('"crosstype" is set to "'+inttostr(OPT_P1CROSHT)+'"');
        end;end;
// ------------------------------------------------------------
if (strpar(s, 0) = 'p2crosstype') then begin
                if strpar(s,1) = '' then addmessage('"p2crosstype" is "'+inttostr(OPT_P2CROSHT)+'". Default is "1". Possible range is 0-9.')
        else begin
                tmp := FilterString(strpar(s,1));
                try OPT_P2CROSHT:= strtoint(tmp); except addmessage('"'+strpar(s,1)+'" is invalid value.'); OPT_P2CROSHT := 1; end;
                OPT_P2CROSHT := formatbyte(OPT_P2CROSHT);
                if OPT_P2CROSHT > 9 then  OPT_P2CROSHT := 9;
                addmessage('"p2crosstype" is set to "'+inttostr(OPT_P2CROSHT)+'"');
        end;end;
// ------------------------------------------------------------
if (strpar(s, 0) = 'p2crosscolor') then begin
                if strpar(s,1) = '' then addmessage('"p2crosscolor" is "'+inttostr(OPT_P2CROSH)+'". Default is "7". Possible range is 1-8.')
        else begin
                tmp := FilterString(strpar(s,1));
                try OPT_P2CROSH:= strtoint(tmp); except addmessage('"'+strpar(s,1)+'" is invalid value.'); OPT_P2CROSH := 7; end;
                OPT_P2CROSH := formatbyte(OPT_P2CROSH);
                if OPT_P2CROSH = 0 then  OPT_P2CROSH := 1;
                if OPT_P2CROSH > 8 then  OPT_P2CROSH := 8;
                addmessage('"p2crosscolor" is set to "'+inttostr(OPT_P2CROSH)+'"');
        end;end;
// ------------------------------------------------------------
{if s = 'give armor' then begin
        players[0].armor := 200;
        if players[1] <> nil then players[1].armor := 200;
end;}
{if (strpar(s,0) = 'ppos')then begin
        try strtoint(strpar(s,1)) except exit; end;
        try strtoint(strpar(s,2)) except exit; end;
        if strtoint (strpar(s,1)) > BRICK_X-1 then begin addmessage('x > max_x'); exit; end;
        if strtoint (strpar(s,2)) > BRICK_Y-1 then begin addmessage('y > max_y'); exit; end;
        if strtoint (strpar(s,2)) < 2 then begin addmessage('y < 2'); exit; end;
        if bbb[strtoint (strpar(s,1)),strtoint (strpar(s,2))].block = false then
        if bbb[strtoint (strpar(s,1)),strtoint (strpar(s,2))-1].block = false then
        if bbb[strtoint (strpar(s,1)),strtoint (strpar(s,2))-2].block = false then
        if players[i] <> nil then begin
                        players[i].x :=strtoint (strpar(s,1))*32+16;
                        players[i].y :=strtoint (strpar(s,2))*16;
                        playsound('respawn.wav',players[i].x,players[i].y);
                end;
end;
 }

if ismultip=0 then
if (strpar(s,0) = 'give')then begin
        if MATCH_DDEMOPLAY then begin addmessage('Not able in demo.'); exit; end;

        if (strpar(s,1)='battle') then
        for i := 0 to 7 do if players[i] <> nil then begin
                players[i].item_battle := 30;
                p1flashbar := 1;
                p2flashbar := 1;
                end;

        if (strpar(s,1)='haste') then
        for i := 0 to 7 do if players[i] <> nil then begin
                players[i].item_haste := 30;
                p1flashbar := 1;
                p2flashbar := 1;
                end;

        if (strpar(s,1)='quad') then
        for i := 0 to 7 do if players[i] <> nil then begin
                players[i].item_quad := 30;
                p1flashbar := 1;
                p2flashbar := 1;
                end;

        if (strpar(s,1)='regen') then
        for i := 0 to 7 do if players[i] <> nil then begin
                players[i].item_regen := 30;
                p1flashbar := 1;
                p2flashbar := 1;
                end;

        if (strpar(s,1)='fly') then
        for i := 0 to 7 do if players[i] <> nil then begin
                players[i].item_flight := 30;
                p1flashbar := 1;
                p2flashbar := 1;
                end;

        if (strpar(s,1)='invis') then
        for i := 0 to 7 do if players[i] <> nil then begin
                players[i].item_invis := 30;
                p1flashbar := 1;
                p2flashbar := 1;
                end;

        if (strpar(s,1)='all') then
        for i := 0 to 7 do if players[i] <> nil then begin
                players[i].have_sg := true;
                players[i].have_gl := true;
                players[i].have_rl := true;
                players[i].have_sh := true;
                players[i].have_rg := true;
                players[i].have_pl := true;
                players[i].have_bfg := true;
                players[i].armor := 200;
                players[i].health := 200;
                players[i].ammo_mg := 200;
                players[i].ammo_sg := 100;
                players[i].ammo_gl := 100;
                players[i].ammo_rl := 100;
                players[i].ammo_sh := 200;
                players[i].ammo_rg := 100;
                players[i].ammo_pl := 200;
                players[i].ammo_bfg := 100;
                p1flashbar := 1;
                p2flashbar := 1;
        end;
end;
{}
if ismultip=0 then
IF (INMENU=FALSE) and (MATCH_DDEMOPLAY=false) THEN BEGIN
        if strpar(s,0) = 'kill' then if players[0] <> nil then begin
                players[0].health := 0;
                if MATCH_STARTSIN=0 then dec(players[0].frags);
                end;

        if strpar(s,0) = 'p2kill' then if players[1] <> nil then begin
                players[1].health := 0;
                if MATCH_STARTSIN=0 then dec(players[1].frags);
                end;
END;
//if s = 'kill_' then players[0].health := GIB_DEATH;
//if s = 'kill2_' then if players[1] <> nil then players[1].health := GIB_DEATH;
// ------------------------------------------------------------
end;

// -----------------------------------------------------------------------------
procedure ApplyHCommand(s : string);
begin
MSG_DISABLE := TRUE; HIST_DISABLE := TRUE;
ApplyCommand(s);
MSG_DISABLE := false; HIST_DISABLE := false;
end;

{function VK_CONTROLDOWN : boolean;
begin
 result:=(Word(GetKeyState(VK_SHIFT)) and $8000)<>0;
end;
}
function CtrlKeyDown : boolean;
begin
 result:=(Word(GetKeyState(VK_CONTROL)) and $8000)<>0;
end;

// -----------------------------------------------------------------------------
procedure Tmainform.FormKeyPress(Sender: TObject; var Key: Char);
begin
if (INMENU) and (MENUEDITMODE > 0) and (mapcansel=0) then begin
        if (key >= #32) and (key <= #122) and (length(MENUEDITSTR) < MENUEDITMAX) then MENUEDITSTR := MENUEDITSTR + key;
        if key = #8 then MENUEDITSTR := copy(MENUEDITSTR,0,length(MENUEDITSTR)-1);
        end;

//                addmessage('^1'+ copy (constr, SYS_CONSOLE_POS+1, length(constr)-SYS_CONSOLE_POS));


if INCONSOLE then begin
        if constr = '`' then constr := '';
        // add new letter
        if (key >= #32) and (key <= #122) then begin
                if SYS_CONSOLE_POS < length(constr) then
                constr := copy (constr, 1, SYS_CONSOLE_POS) + key + copy (constr, SYS_CONSOLE_POS+1, length(constr)-SYS_CONSOLE_POS) else
                constr := constr + key;
                inc(SYS_CONSOLE_POS);
//                if SYS_CONSOLE_POS > GetColorTextCount(constr)+1 then SYS_CONSOLE_POS := GetColorTextCount(constr);
                end;
        // delete letter
        if constr<>'' then
        if key = #8 then begin
                constr := copy(constr,1, SYS_CONSOLE_POS-1) + copy(constr,SYS_CONSOLE_POS+1, length(constr)-SYS_CONSOLE_POS);
                if SYS_CONSOLE_POS > 0 then dec(SYS_CONSOLE_POS);
        end;
        if key =#13 then if constr<>'' then BEGIN SYS_CONSOLE_POS:=0; ApplyCommand(constr); constr := ''; conmsg_index := 0; END;
        end;

// combo1.  sorry..
if mapcansel=0 then if inmenu then if not inconsole then
        if (BNET_LOBBY_STATUS = 4) and (combo1.Opened = false) then begin
                if ((key >= #46) and (key <= #58)) or ((key >= #65) and (key <= #90))  or ((key >= #97) and (key <= #122)) then if length(combo1.text) < 15 then combo1.text := combo1.text + key;
                if key = #8 then combo1.text := copy(combo1.text,0,length(combo1.text)-1);
        end;

end;
// -----------------------------------------------------------------------------
procedure Tmainform.DXDrawInitializeSurface(Sender: TObject);
begin
//if not GAME_FULLLOAD then DXDraw.Primary.GammaControl.GetGammaRamp (0, FDefaultGammaRamp);
end;
// -----------------------------------------------------------------------------
procedure Tmainform.MediaPlayer1Notify(Sender: TObject);
begin
//addmessage('change track');
if mediaplayer1.Enabled = false then exit;
if muslist.count = 0 then STARTMUSIC(0) else STARTMUSIC(1);
end;
// -----------------------------------------------------------------------------
procedure Tmainform.FormDestroy(Sender: TObject);
begin
 FinalizeAll();
 PowerGraph.Finalize();
end;
// -----------------------------------------------------------------------------
procedure Tmainform.FinalizeAll();
Var I: Integer;
begin
 if (Assigned(Font1)) then Font1.Finalize();
 if (Assigned(Font2)) then Font2.Finalize();
 if (Assigned(Font3)) then Font3.Finalize();
 if (Assigned(Font4)) then Font4.Finalize();
 if (Assigned(Font2ss)) then Font2ss.Finalize();
 if (Assigned(Font6)) then Font6.Finalize();
 if (Assigned(Font2b)) then Font2b.Finalize();
 if (Assigned(Font2s)) then Font2s.Finalize();

 for I:= 0 to High(Images) do
  if (Assigned(Images[I])) then Images[I].Finalize();
end;
// -----------------------------------------------------------------------------
procedure Tmainform.PowerGraphDeviceLost(Sender: TObject);
begin
        if MainForm.Focused then PowerGraph.Reset();
end;
// -----------------------------------------------------------------------------
procedure Tmainform.DXPlaySessionLost(Sender: TObject);
begin
        ShowCriticalError('Connection lost','Connection lost','');
        Applyhcommand('disconnect');
end;
// -----------------------------------------------------------------------------
procedure Tmainform.FormKeyDown(Sender: TObject; var Key: Word;
  Shift: TShiftState);
begin

if (ssAlt in Shift) and (Key=VK_F4) then begin key:=0; exit; end; // NO ALT+F4

// console messages scrolling.
if inconsole then begin
        if key=33 then if conmsg_index < conmsg.count+1-SYS_CONSOLE_MAXY div 15 then inc(conmsg_index);
        if key=34 then if conmsg_index > 0  then dec(conmsg_index);
        if key=35 then conmsg_index := 0;
        if (key=37) then if SYS_CONSOLE_POS > 0 then dec(SYS_CONSOLE_POS); // LEFT KEY, Shift left
        if (key=39) then if SYS_CONSOLE_POS < length(constr) then inc(SYS_CONSOLE_POS); // Right key, shift right`
        if (key=46) then begin // delete
                constr := copy(constr,1, SYS_CONSOLE_POS) + copy(constr,SYS_CONSOLE_POS+2, length(constr)-SYS_CONSOLE_POS);
                if SYS_CONSOLE_POS > length(constr) then SYS_CONSOLE_POS := length(constr); end;
        if (key=35) then SYS_CONSOLE_POS := length(constr);     // end
        if (key=36) then SYS_CONSOLE_POS := 0;                  // home

        // paste text to console
        if Length(Clipboard.AsText) > 0 then
        if ((key=45) and ( ssShift in Shift ) ) or ((key=86) and ( ssCtrl in Shift ) ) then begin
                        constr := copy(constr, 1, SYS_CONSOLE_POS) + Clipboard.AsText + copy(constr,SYS_CONSOLE_POS+1, length(constr)-SYS_CONSOLE_POS);
                        SYS_CONSOLE_POS := SYS_CONSOLE_POS + length(Clipboard.AsText);
        end;
end;

        // Paste text to Connect Combobox
        if Length(Clipboard.AsText) > 0 then
        if ((key=45) and ( ssShift in Shift ) ) or ((key=86) and ( ssCtrl in Shift ) ) then
        if mapcansel = 0 then if inmenu then if not inconsole then
        if (BNET_LOBBY_STATUS = 4) and (combo1.Opened = false) then begin
                combo1.Text := combo1.Text + trim(Clipboard.AsText);
                if length(combo1.Text) >= 15 then combo1.Text := copy(combo1.Text, 1, 15);
        end;



//addmessage('^2'+inttostr(key));

        // send chat tipa.
        if (CtrlKeyDown) and (key=VK_RETURN) and (length(constr)>=1) then begin // chat command.
                if constr[1]<>'\' then constr := '\'+constr;
                        applycommand(constr);
                        constr := '';
                        conmsg_index :=0;
                        SYS_CONSOLE_POS :=0;
                end;
end;
// -----------------------------------------------------------------------------
//NFK PLANET PROCESS
procedure Tmainform.LOBBYConnecting(Sender: TObject;
  Socket: TCustomWinSocket);
begin
        BNET_LOBBY_STATUS := 1; // CONNECTING...
end;
// -----------------------------------------------------------------------------
procedure Tmainform.LOBBYDisconnect(Sender: TObject;
  Socket: TCustomWinSocket);
begin
//        addmessage('NFKPLANET: Disconnected....DEBUG');
//        errorsound;

        if BNET_LOBBY_STATUS=1 then begin
                BNET_LOBBY_STATUS:=3; // we are cant connect.. show err...
                end else

        if BNET_LOBBY_STATUS=2 then if inmenu then begin
                if MENUORDER = MENU_PAGE_MULTIPLAYER then begin
                        MENUORDER := MENU_PAGE_MAIN;
                        ShowCriticalError('Disconnected','Disconnected from NFK PLANET','');
                end;
        end;

        BNET_LOBBY_STATUS := 0;
end;
// -----------------------------------------------------------------------------
procedure Tmainform.LOBBYConnect(Sender: TObject;
  Socket: TCustomWinSocket);
begin

{        if BNET_AU_CanPlayWithThisVersion = false then begin
                ShowCriticalError('Latest version is required for playing at NFK PLANET','Your NFK version is outdated. Please','visit official website for latest update.');
                applyHcommand('disconnect');
                exit;
                end;
}
        BNET_LOBBY_STATUS := 2; // CONNECTING...
        MP_STEP := 1;
        BREFRESHEnabled := true;

//        AddMessage(Lobby.Host);

        if not NFKPLANET_AutoUpdate() then
                NFKPLANET_UpdateServerList;


end;
// -----------------------------------------------------------------------------
procedure Tmainform.LOBBYError(Sender: TObject; Socket: TCustomWinSocket;
  ErrorEvent: TErrorEvent; var ErrorCode: Integer);
begin
//        addmessage('NFKPLANET: AN ERROR OCCURED!');
end;
// -----------------------------------------------------------------------------
procedure Tmainform.LOBBYRead(Sender: TObject; Socket: TCustomWinSocket);
var RES : dword;
var Answer : TLOBBY_STAT_BACK;
     cmdd : TNFKPLANET_CMD;
     str : string;
     zz : byte;
begin

        res := socket.ReceiveBuf(Answer,sizeof(answer));

        // ---------------------------------------------------------------------
        // List Of Servers Has Arrived.
        if res = 16 then begin
                move(answer, cmdd, 16);
                str := '';
                for zz := 0 to 3 do begin
                        str :=str+inttostr( ord(cmdd._data[zz]));
                        if zz<3 then str:=str+'.';
                end;

                if cmdd._cmd <> #$FF then begin
                      Addmessage('IP:'+str);
                        if (ismultip=1) and (OPT_SV_MAXPLAYERS > GetNumberOfPlayers) then
                                BNET_IPINVITE(str);
                end;
        end;
        // ---------------------------------------------------------------------
        if res = 4 then begin // players playing. does not work
//              if Answer._sequencenr < $FFFF then
  //            BNET_LOBBY_PLAYERSPLAYING := Answer._sequencenr
    //          else BNET_LOBBY_PLAYERSPLAYING := 1;
      //        addmessage(inttostr(Answer._sequencenr));
                exit;
        end;
        // ---------------------------------------------------------------------
        if answer._port > 9 then answer._port := 0; // wrong gametype.

        if (Answer.name='NO SERVERS') and (Answer.mapname = 'UNAVAILABLE') then begin
                BRefreshEnabled := true;
//                NFKPLANET_UpdatePlayersCount;
                exit;
                end;

        if Answer.mapname <> '' then begin
                MP_Sessions.Add ( Answer.name+#0+ Answer.mapname+#0+ inttostr(answer._port)+#0+
                inttostr(answer._users )+#0+
                inttostr(answer._max_users)+#0+
                answer.peer_ip);

                NFKPLANET_PingLastServer;
        end;

        // END of serverlist
        if Answer._sequencenr = $FFFFFFFF then begin
                BRefreshEnabled := true;
//                NFKPLANET_UpdatePlayersCount;
//                NFKPLANET_PingAllServers;
                if MP_Sessions.Count < MP_SessionIndex-1 then
                        MP_SessionIndex := MP_Sessions.Count-1;
                end;

end;

procedure Tmainform.nfkplanet_idleTimer(Sender: TObject);
begin
        if NFKPLANET_KeepAlive_var > 0 then dec(NFKPLANET_KeepAlive_var) else begin
                NFKPLANET_KeepAlive;
                NFKPLANET_KeepAlive_var := 5;
        end;

//      PROXY SUPPORT.
      NFKPLANET_CheckProxies;
end;

procedure Tmainform.FormMouseUp(Sender: TObject; Button: TMouseButton;
  Shift: TShiftState; X, Y: Integer);
begin
if button = mbleft then keyup_ := true;

end;


function BD_GetSystemVariable(s : shortstring):shortstring;
begin
        s := lowercase(s);
        if s = 'rootdir' then result:=ROOTDIR;
        if s = 'mapname' then result:=copy(extractfilename(map_filename_fullpath),0,length(extractfilename(map_filename_fullpath))-5);
        if s = 'mapfilename' then result:=map_filename_fullpath;
        if s = 'mapinternalname' then result:=map_name;
        if s = 'mapauthor' then result:=map_author;
        if s = 'mapcrc32' then result:=inttostr(map_crc32);
        if s = 'playerscount' then result:=inttostr(GetNumberOfPlayers);
        if s = 'playerscount_red' then result:=inttostr(GetRedPlayers);
        if s = 'playerscount_blue' then result:=inttostr(GetBluePlayers);
        if s = 'locationscount' then result:=inttostr(GetLocationsCount);
        if s = 'teamscore_red' then result:=inttostr(GetRedTeamScore);
        if s = 'teamscore_blue' then result:=inttostr(GetBlueTeamScore);
        if s = 'gamesudden' then result:=inttostr(gamesudden);
        if s = 'timelimit' then result:=inttostr(MATCH_TIMELIMIT);
        if s = 'fraglimit' then result:=inttostr(MATCH_FRAGLIMIT);
        if s = 'capturelimit' then result:=inttostr(MATCH_CAPTURELIMIT);
        if s = 'domlimit' then result:=inttostr(MATCH_DOMLIMIT);
        if s = 'overtime' then result:=inttostr(MATCH_OVERTIME);
        if s = 'ctfflagstatus_red' then result:=inttostr(CTF_REDFLAGSTATUS);
        if s = 'ctfflagstatus_blue' then result:=inttostr(CTF_BLUEFLAGSTATUS);
        if s = 'clientid' then result:=inttostr(CLIENTID);
        if s = 'time_min' then result:=inttostr(trunc(gametime/60));
        if s = 'time_sec' then result:=inttostr(gametime - trunc(gametime / 60)*60);
        if s = 'warmupleft' then result:=inttostr(match_startsin div 50);
        if s = 'gametype' then result:=GAMETYPE_STR_NP[MATCH_GAMETYPE];
        if s = 'bricks_x' then result:=inttostr(BRICK_X);
        if s = 'bricks_y' then result:=inttostr(BRICK_Y);
        if s = 'warmuparmor' then result:=inttostr(OPT_WARMUPARMOR);
        if s = 'forcerespawn' then result:=inttostr(OPT_FORCERESPAWN);
        if s = 'sv_maxplayers' then result:=inttostr(OPT_SV_MAXPLAYERS);
        if s = 'nfkversion' then result:=VERSION;
        if s = 'sv_teamdamage' then begin if OPT_TEAMDAMAGE then result := '1' else result := '0'; end;
        if s = 'railarenainstagib' then begin if OPT_RAILARENA_INSTAGIB then result := '1' else result := '0'; end;


end;


end.



